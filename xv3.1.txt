// ==UserScript==
// @name         xv3.1
// @match        *://*.moomoo.io/*
// @version      v3.1
// @author       Zylex[],OMGY
// @devs         Oleh,Enderking
// @match        *://moomoo.io/*
// @match        *://sandbox.moomoo.io/*
// @match        *://dev.moomoo.io/*
// @grant        none
// @require https://update.greasyfork.org/scripts/474034/1271161/MooMooio%20Anti-Kick.js
// ==/UserScript==

//OMGY LAST GAME

const $ = window.$;

let lastBoostRefresh = 0;
let nigthMode = false;
let invisProjectile = false;
let changeWeapon1 = false;
let changeWeapon = false;
let WealthyMode = false;
let privCmdInfoAfterCmd = false;
let aimleft = false;
let buggyArrow = false;
let autoBreak = false;
let objRotate = true;
let autoSpin = false;
let slowTick = false;
let autoplaceSand = false;
let buggyBoost = false;
let counterInsta = false;
let optionboostTick = false;
let bushHat = false;
let autoinsta = false;
let autoSync = false;
let aSheal = false;
let autoHealing = true;
let autoBuying = false;
let antiBoostSpike = false;
let zpyklerTick = false;
let autoPlace = false;
let safeAutoPlaceLegits = false;
let safeAutoPlace = false;
let autoReplace = false;
let smothGhostyObjects = false;
let turretEmp = 0;
getEl("wideAdCard")
    .remove();
getEl("linksContainer2")
    .remove();

getEl('gameName')
    .innerHTML = `MOOMOO.io`;

let userPayload;

function handleStateChange(event) {
    var state;
    if (((state = event == null ? undefined : event.detail) == null ? undefined : state.state) === "verified") {
        userPayload = event.detail.payload;
        document.getElementById("altcha")
            .remove();
        enterGameButton.innerText = "Start Game";
        enterGameButton.classList.remove("disabled");
    }
}

let enterGameButton = getEl("enterGame");
window.addEventListener("load", () => {
    document.getElementById("altcha_checkbox")
        .click();
    enterGameButton.innerText = "Start Game";
    const altchaElement = document.getElementById("altcha");
    if (!(altchaElement == null)) {
        altchaElement.addEventListener("statechange", handleStateChange);
    }
});

function cdf(e, t) {
    try {
        return Math.hypot((t.y2 || t.y) - (e.y2 || e.y), (t.x2 || t.x) - (e.x2 || e.x));
    } catch (e) {
        return Infinity;
    }
}

function getEl(id) {
    return document.getElementById(id);
}

! function() {
    'use strict';

    document.title = "x";

    const scriptSrc = "index-6b10514b.js";
    const scriptTags = document.querySelectorAll(`script[src*="${scriptSrc}"]`);
    if (scriptTags.length > 0) {
        scriptTags[0].remove();
    }

    function loadScript(url, callback) {
        let script = document.createElement("script");
        script.src = url;
        script.onload = () => {
            if (callback) callback();
        };

        document.body.appendChild(script);
    }

    const msgpackUrl = "https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js";
    const customScriptUrl = null;

    loadScript(msgpackUrl, () => {
        loadScript(customScriptUrl);
    });

    window.oncontextmenu = function() {
        return false;
    };

    let config = window.config;
    let recording;

    config.clientSendRate = 9;
    config.serverUpdateRate = 9;

    config.deathFadeout = 0;

    config.playerCapacity = 50;
    window.config.maxPlayers = 50;

    config.isSandbox = window.location.hostname == "sandbox.moomoo.io";

    config.skinColors = ["#bf8f54", "#cbb091", "#896c4b",
                         "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3",
                         "#8bc373", "#91b2db"
                        ];
    config.weaponVariants = [{
        id: 0,
        src: "",
        xp: 0,
        val: 1,
    }, {
        id: 1,
        src: "_g",
        xp: 3000,
        val: 1.1,
    }, {
        id: 2,
        src: "_d",
        xp: 7000,
        val: 1.18,
    }, {
        id: 3,
        src: "_r",
        poison: true,
        xp: 12000,
        val: 1.18,
    }, {
        id: 4,
        src: "_e",
        poison: true,
        heal: true,
        xp: 24000,
        val: 1.18,
    }];

    config.anotherVisual = true;
    config.useWebGl = false;
    config.resetRender = true;

    function waitTime(timeout) {
        return new Promise((done) => {
            setTimeout(() => {
                done();
            }, timeout);
        });
    }

    let canStore;
    if (typeof(Storage) !== "undefined") {
        canStore = true;
    }

    function saveVal(name, val) {
        if (canStore) localStorage.setItem(name, val);
    }

    function deleteVal(name) {
        if (canStore) localStorage.removeItem(name);
    }

    function getSavedVal(name) {
        if (canStore) return localStorage.getItem(name);
        return null;
    }

    let gC = function(a, b) {
        try {
            let res = JSON.parse(getSavedVal(a));
            if (typeof res === "object") {
                return b;
            } else {
                return res;
            }
        } catch (e) {
            return b;
        }
    };

    let configs = {
        predictTick: true,
        antiBullInsta: true,
        antiTrap: true,
        autoRespawn: false,
        healingBeta: true,
    };

    window.removeConfigs = function() {
        for (let cF in configs) {
            deleteVal(cF, configs[cF]);
        }
    };

    for (let cF in configs) {
        configs[cF] = gC(cF, configs[cF]);
    }

    window.debug = function() {};

    document.addEventListener("keydown", (e) => {
        if (e.keyCode == 27) {
            toggleModMenu();
        }
    });

    let modMenus = document.createElement("div");
    modMenus.id = "modMenus";
    document.body.append(modMenus);

    modMenus.style.display = "block";
    modMenus.style.padding = "10px";
    modMenus.style.borderRadius = "4px";
    modMenus.style.position = "absolute";
    modMenus.style.left = "10px";
    modMenus.style.top = "10px";
    modMenus.style.width = "300px";
    modMenus.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    modMenus.style.color = "white";
    modMenus.style.transition = "transform 0.5s ease-in-out, opacity 0.5s ease-in-out";
    modMenus.style.transform = "translateY(-100%)";
    modMenus.style.opacity = "0";
    modMenus.style.zIndex = "1000";

    const mapDisplay = getEl("mapDisplay");
    const scoreDisplay = getEl("scoreDisplay");

    let isMenuOpen = false;

    function toggleModMenu() {
        isMenuOpen = !isMenuOpen;
        if (isMenuOpen) {
            modMenus.style.transform = "translateY(0)";
            modMenus.style.opacity = "1";

            if (mapDisplay) mapDisplay.style.transform = "translateY(100vh)";
            if (scoreDisplay) scoreDisplay.style.transform = "translateY(100vh)";

        } else {
            modMenus.style.transform = "translateY(-100%)";
            modMenus.style.opacity = "0";

            if (mapDisplay) mapDisplay.style.transform = "translateY(0)";
            if (scoreDisplay) scoreDisplay.style.transform = "translateY(0)";
        }
    }

    setTimeout(() => {
        toggleModMenu();
        toggleModMenu();
    }, 100);

    function updateInnerHTML() {
        modMenus.innerHTML = `
    <style>
    #mapDisplay, #scoreDisplay {
        transition: transform 0.5s ease-in-out;
    }
    </style>

    <div id="headline" style="
        font-size: 20px;
        color: #99ee99;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        margin-bottom: 10px;
    ">
        Credits:
    </div>
    <div style="
        color: white;
        font-size: 14px;
        line-height: 1.4;
        padding: 10px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 5px;
    ">
        Author: Zylex<br>
        Devs: Omgy, oleh
        <br><br>
        <span style="font-weight: bold; color: #ddd;">Commands:</span>
        <br>
        <span style="color: #ffcc80;">.t &lt;command&gt;:</span> Execute a command.
        <br>
        <ul style="list-style-type: none; padding-left: 10px;">
            <li><span style="color: #a7d9ed;">-visual</span>: Visuals Mode.</li>
            <li><span style="color: #a7d9ed;">-cw</span>: Weapon Switch.</li>
            <li><span style="color: #a7d9ed;">-nh</span>: Night Mode.</li>
            <li><span style="color: #a7d9ed;">-bref</span>: Ghosty Objects.</li>
            <li><span style="color: #a7d9ed;">-sv</span>:  Object Rotate.</li>
            <li><span style="color: #a7d9ed;">-hat</span>: Hat Loop.</li>
            <li><span style="color: #a7d9ed;">-heal</span>: Auto Heal.</li>
            <li><span style="color: #a7d9ed;">-mill</span>: AutoTripleMill.</li>
            <li><span style="color: #a7d9ed;">-hb</span>: Auto Buy.</li>
            <li><span style="color: #a7d9ed;">-spin</span>: AutoPlayerSpin.</li>
            <li><span style="color: #a7d9ed;">-ag</span>:  InvisGear Heal.</li>
            <li><span style="color: #a7d9ed;">-ab</span>: Auto Break.</li>
            <li><span style="color: #a7d9ed;">-abs</span>: Antiboost Spike.</li>
            <li><span style="color: #a7d9ed;">-spike</span>: Spike Tick.</li>
            <li><span style="color: #a7d9ed;">-placer</span>: Placer.</li>
            <li><span style="color: #a7d9ed;">-le</span>: Legits Place.</li>
            <li><span style="color: #a7d9ed;">-Safe</span>: Safe Place.</li>
            <li><span style="color: #a7d9ed;">-rep</span>: Replace.</li>
            <li><span style="color: #a7d9ed;">-bsp</span>: Auto Boost Spike Tick.</li>
            <li><span style="color: #a7d9ed;">-st</span>: Slowtick.</li>
        </ul>
        <br>
        <span style="font-weight: bold; color: #ddd;">Macros:</span>
        <br>
        <ul style="list-style-type: none; padding-left: 10px;">
            <li><span style="color: #ffcc80;">b</span>: Double Spike Tick.</li>
            <li><span style="color: #ffcc80;">x</span>: Spike Tick.</li>
        </ul>
    </div>`;
    }

    updateInnerHTML();

    let WS = undefined;
    let socketID = undefined;

    let secPacket = 0;
    let secMax = 120;
    let secTime = 1000;
    let firstSend = {
        sec: false
    };
    let game = {
        tick: 0,
        tickQueue: [],
        tickBase: function(set, tick) {
            if (this.tickQueue[this.tick + tick]) {
                this.tickQueue[this.tick + tick].push(set);
            } else {
                this.tickQueue[this.tick + tick] = [set];
            }
        },
        tickRate: (1000 / config.serverUpdateRate),
        tickSpeed: 0,
        lastTick: performance.now()
    };

    let dontSend = false;
    let fpsTimer = {
        last: 0,
        time: 0,
        ltime: 0
    }
    let lastMoveDir = undefined;
    let lastsp = ["cc", 1, "__proto__"];
    let packets = [];
    WebSocket.prototype.nsend = WebSocket.prototype.send;
    WebSocket.prototype.send = function(message) {
        if (!WS) {
            WS = this;
            WS.addEventListener("message", function(msg) {
                getMessage(msg);
            });
            WS.addEventListener("close", (event) => {
                if (event.code == 4001) {
                    window.location.reload();
                }
            });
        }
        if (WS == this) {
            dontSend = false;

            let data = new Uint8Array(message);
            let parsed = window.msgpack.decode(data);
            let type = parsed[0];
            data = parsed[1];

            if (type == "6") {

                if (data[0]) {
                    let profanity = ["cunt", "whore", "fuck", "shit", "faggot", "nigger", "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex", "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune", "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard", ];
                    let tmpString;
                    profanity.forEach((profany) => {
                        if (data[0].indexOf(profany) > -1) {
                            tmpString = "";
                            for (let i = 0; i < profany.length; ++i) {
                                if (i == 1) {
                                    tmpString += String.fromCharCode(0);
                                }
                                tmpString += profany[i];
                            }
                            let re = new RegExp(profany, "g");
                            data[0] = data[0].replace(re, tmpString);
                        }
                    });

                    data[0] = data[0].slice(0, 30);
                }

            } else if (type == "L") {
                data[0] = data[0] + (String.fromCharCode(0)
                    .repeat(7));
                data[0] = data[0].slice(0, 7);
            } else if (type == "M") {
                let indexMark = "x-";
                data[0].name = indexMark + data[0].name == "x-" ? "x-" : "x-" + data[0].name;
                data[0].moofoll = true;
                data[0].skin = data[0].skin == 10 ? "__proto__" : data[0].skin;
                lastsp = [data[0].name, data[0].moofoll, data[0].skin];
            } else if (type == "D") {
                if ((my.lastDir == data[0]) || [null, undefined].includes(data[0])) {
                    dontSend = true;
                } else {
                    my.lastDir = data[0];
                }
            } else if (type == "d") {
                if (!data[2]) {
                    dontSend = true;
                } else {
                    if (![null, undefined].includes(data[1])) {
                        my.lastDir = data[1];
                    }
                }
            } else if (type == "K") {
                if (!data[1]) {
                    dontSend = true;
                }
            } else if (type == "f") {
                if (data[1]) {
                    if (player.moveDir == data[0]) {
                        dontSend = true;
                    }
                    player.moveDir = data[0];
                    player.moveTime = Date.now();
                } else {
                    dontSend = true;
                }
            }

            if (!dontSend) {
                let binary = window.msgpack.encode([type, data]);
                this.nsend(binary);

                if (!firstSend.sec) {
                    firstSend.sec = true;
                    setTimeout(() => {
                        firstSend.sec = false;
                        secPacket = 0;
                    }, secTime);
                }

                secPacket++;
            }
        } else {
            this.nsend(message);
        }
    }

    function packet(type) {
        let data = Array.prototype.slice.call(arguments, 1);
        let binary = window.msgpack.encode([type, data]);
        WS.send(binary);
    }

    let io = {
        send: packet
    };

    function getMessage(message) {
        let data = new Uint8Array(message.data);
        let parsed = window.msgpack.decode(data);
        let type = parsed[0];
        data = parsed[1];
        let events = {
            A: setInitData,
            C: setupGame,
            D: addPlayer,
            E: removePlayer,
            a: updatePlayers,
            G: updateLeaderboard,
            H: loadGameObject,
            I: loadAI,
            J: animateAI,
            K: gatherAnimation,
            L: wiggleGameObject,
            M: shootTurret,
            N: updatePlayerValue,
            O: updateHealth,
            O: updateHealth2,
            O: updateHealth3,
            P: killPlayer,
            Q: killObject,
            R: killObjects,
            S: updateItemCounts,
            T: updateAge,
            U: updateUpgrades,
            V: updateItems,
            3: setPlayerTeam,
            4: setAlliancePlayers,
            5: updateStoreItems,
            6: receiveChat,
            7: updateMinimap,
            8: showText,
            9: pingMap,
            X: addProjectile,
            Y: remProjectile,
        };
        if (type == "io-init") {
            socketID = data[0];
        } else {
            if (events[type]) {
                events[type].apply(undefined, data);
            }
        }
    }

    Math.lerpAngle = function(value1, value2, amount) {
        let difference = Math.abs(value2 - value1);
        if (difference > Math.PI) {
            if (value1 > value2) {
                value2 += Math.PI * 2;
            } else {
                value1 += Math.PI * 2;
            }
        }
        let value = value2 + ((value1 - value2) * amount);
        if (value >= 0 && value <= Math.PI * 2) return value;
        return value % (Math.PI * 2);
    };

    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        if (r < 0) r = 0;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    };

    let ais = [];
    let players = [];
    let alliances = [];
    let alliancePlayers = [];
    let gameObjects = [];
    let liztobj = [];
    let closeObjects = [];
    let projectiles = [];
    let deadPlayers = [];

    let breakObjects = [];

    let player;
    let playerSID;
    let tmpObj;

    let enemy = [];
    let nears = [];
    let near = [];
    let noTail = false;
    let hatLoop = false;
    let loopIndex = 0;
    let loopHats = [51, 50, 28, 29, 30, 36, 37, 38, 44, 35, 42, 43, 49,];
    let trapClear = false;
    let my = {
        reloaded: false,
        waitHit: 0,
        autoAim: false,
        revAim: false,
        ageInsta: true,
        reSync: false,
        bullTick: 0,
        anti0Tick: 0,
        antiSync: false,
        safePrimary: function(tmpObj) {
            return [0, 8].includes(tmpObj.primaryIndex);
        },
        safeSecondary: function(tmpObj) {
            return [10, 11, 14].includes(tmpObj.secondaryIndex);
        },
        lastDir: 0,
    }

    function findID(tmpObj, tmp) {
        return tmpObj.find((THIS) => THIS.id == tmp);
    }

    function findSID(tmpObj, tmp) {
        return tmpObj.find((THIS) => THIS.sid == tmp);
    }

    function findPlayerByID(id) {
        return findID(players, id);
    }

    function findPlayerBySID(sid) {
        return findSID(players, sid);
    }

    function findAIBySID(sid) {
        return findSID(ais, sid);
    }

    function findObjectBySid(sid) {
        return findSID(gameObjects, sid);
    }

    function findProjectileBySid(sid) {
        return findSID(gameObjects, sid);
    }

    let adCard = getEl("adCard");
    adCard.remove();
    let promoImageHolder = getEl("promoImgHolder");
    promoImageHolder.remove();

    let chatButton = getEl("chatButton");
    let gameCanvas = getEl("gameCanvas");
    let mainContext = gameCanvas.getContext("2d");
    let mapContext = mapDisplay.getContext("2d");
    let storeMenu = getEl("storeMenu");
    let storeHolder = getEl("storeHolder");
    let upgradeHolder = getEl("upgradeHolder");
    let upgradeCounter = getEl("upgradeCounter");
    let chatHolder = getEl("chatHolder");
    let actionBar = getEl("actionBar");
    let leaderboardData = getEl("leaderboardData");
    let itemInfoHolder = getEl("itemInfoHolder");
    let menuCardHolder = getEl("menuCardHolder");
    let mainMenu = getEl("mainMenu");
    let diedText = getEl("diedText");
    let screenWidth;
    let screenHeight;
    let maxScreenWidth = config.maxScreenWidth;
    let maxScreenHeight = config.maxScreenHeight;
    let pixelDensity = 1;
    let delta;
    let now;
    let lastUpdate = performance.now();
    let camX;
    let camY;
    let tmpDir;
    let mouseX = 0;
    let mouseY = 0;
    let allianceMenu = getEl("allianceMenu");
    let waterMult = 1;
    let waterPlus = 0;
    let outlineColor = "#525252";
    let darkOutlineColor = "#3d3f42";
    let outlineWidth = 5.5;

    let firstSetup = true;
    let keys = {};
    let moveKeys = {
        87: [0, -1],
        38: [0, -1],
        83: [0, 1],
        40: [0, 1],
        65: [-1, 0],
        37: [-1, 0],
        68: [1, 0],
        39: [1, 0],
    };

    let attackState = 0;
    let inGame = false;

    let macro = {};
    let mills = {
        place: 0,
        placeSpawnPads: 0
    };
    let lastDir;

    let lastLeaderboardData = [];

    let inWindow = true;
    window.onblur = function() {
        inWindow = false;
    };
    window.onfocus = function() {
        inWindow = true;
    };

    let placeVisible = [];

    class Utils {
        constructor() {

            let mathABS = Math.abs,
                mathCOS = Math.cos,
                mathSIN = Math.sin,
                mathPOW = Math.pow,
                mathSQRT = Math.sqrt,
                mathATAN2 = Math.atan2,
                mathPI = Math.PI;

            let _this = this;

            this.round = function(n, v) {
                return Math.round(n * v) / v;
            };
            this.toRad = function(angle) {
                return angle * (mathPI / 180);
            };
            this.toAng = function(radian) {
                return radian / (mathPI / 180);
            };
            this.randInt = function(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            };
            this.randFloat = function(min, max) {
                return Math.random() * (max - min + 1) + min;
            };
            this.lerp = function(value1, value2, amount) {
                return value1 + (value2 - value1) * amount;
            };
            this.decel = function(val, cel) {
                if (val > 0) val = Math.max(0, val - cel);
                else if (val < 0) val = Math.min(0, val + cel);
                return val;
            };
            this.getDistance = function(x1, y1, x2, y2) {
                return mathSQRT((x2 -= x1) * x2 + (y2 -= y1) * y2);
            };
            this.getDist = function(tmp1, tmp2, type1, type2) {
                let tmpXY1 = {
                    x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                    y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
                };
                let tmpXY2 = {
                    x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                    y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
                };
                return mathSQRT((tmpXY2.x -= tmpXY1.x) * tmpXY2.x + (tmpXY2.y -= tmpXY1.y) * tmpXY2.y);
            };
            this.getDirection = function(x1, y1, x2, y2) {
                return mathATAN2(y1 - y2, x1 - x2);
            };
            this.getDirect = function(tmp1, tmp2, type1, type2) {
                let tmpXY1 = {
                    x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                    y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
                };
                let tmpXY2 = {
                    x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                    y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
                };
                return mathATAN2(tmpXY1.y - tmpXY2.y, tmpXY1.x - tmpXY2.x);
            };
            this.getAngleDist = function(a, b) {
                let p = mathABS(b - a) % (mathPI * 2);
                return (p > mathPI ? (mathPI * 2) - p : p);
            };
            this.isNumber = function(n) {
                return (typeof n == "number" && !isNaN(n) && isFinite(n));
            };
            this.isString = function(s) {
                return (s && typeof s == "string");
            };
            this.kFormat = function(num) {
                return num > 999 ? (num / 1000)
                    .toFixed(1) + "k" : num;
            };
            this.sFormat = function(num) {
                let fixs = [{
                        num: 1e3,
                        string: "k"
                },
                    {
                        num: 1e6,
                        string: "m"
                            },
                    {
                        num: 1e9,
                        string: "b"
                            },
                    {
                        num: 1e12,
                        string: "q"
                            }
                           ].reverse();
                let sp = fixs.find(v => num >= v.num);
                if (!sp) return num;
                return (num / sp.num)
                    .toFixed(1) + sp.string;
            };
            this.capitalizeFirst = function(string) {
                return string.charAt(0)
                    .toUpperCase() + string.slice(1);
            };
            this.fixTo = function(n, v) {
                return parseFloat(n.toFixed(v));
            };
            this.sortByPoints = function(a, b) {
                return parseFloat(b.points) - parseFloat(a.points);
            };
            this.lineInRect = function(recX, recY, recX2, recY2, x1, y1, x2, y2) {
                let minX = x1;
                let maxX = x2;
                if (x1 > x2) {
                    minX = x2;
                    maxX = x1;
                }
                if (maxX > recX2)
                    maxX = recX2;
                if (minX < recX)
                    minX = recX;
                if (minX > maxX)
                    return false;
                let minY = y1;
                let maxY = y2;
                let dx = x2 - x1;
                if (Math.abs(dx) > 0.0000001) {
                    let a = (y2 - y1) / dx;
                    let b = y1 - a * x1;
                    minY = a * minX + b;
                    maxY = a * maxX + b;
                }
                if (minY > maxY) {
                    let tmp = maxY;
                    maxY = minY;
                    minY = tmp;
                }
                if (maxY > recY2) maxY = recY2;
                if (minY < recY) minY = recY;
                if (minY > maxY) return false;
                return true;
            };
            this.containsPoint = function(element, x, y) {
                let bounds = element.getBoundingClientRect();
                let left = bounds.left + window.scrollX;
                let top = bounds.top + window.scrollY;
                let width = bounds.width;
                let height = bounds.height;

                let insideHorizontal = x > left && x < left + width;
                let insideVertical = y > top && y < top + height;
                return insideHorizontal && insideVertical;
            };
            this.mousifyTouchEvent = function(event) {
                let touch = event.changedTouches[0];
                event.screenX = touch.screenX;
                event.screenY = touch.screenY;
                event.clientX = touch.clientX;
                event.clientY = touch.clientY;
                event.pageX = touch.pageX;
                event.pageY = touch.pageY;
            };
            this.hookTouchEvents = function(element, skipPrevent) {
                let preventDefault = !skipPrevent;
                let isHovering = false;
                let passive = false;
                element.addEventListener("touchstart", this.checkTrusted(touchStart), passive);
                element.addEventListener("touchmove", this.checkTrusted(touchMove), passive);
                element.addEventListener("touchend", this.checkTrusted(touchEnd), passive);
                element.addEventListener("touchcancel", this.checkTrusted(touchEnd), passive);
                element.addEventListener("touchleave", this.checkTrusted(touchEnd), passive);

                function touchStart(e) {
                    _this.mousifyTouchEvent(e);
                    window.setUsingTouch(true);
                    if (preventDefault) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    if (element.onmouseover) element.onmouseover(e);
                    isHovering = true;
                }

                function touchMove(e) {
                    _this.mousifyTouchEvent(e);
                    window.setUsingTouch(true);
                    if (preventDefault) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    if (_this.containsPoint(element, e.pageX, e.pageY)) {
                        if (!isHovering) {
                            if (element.onmouseover) element.onmouseover(e);
                            isHovering = true;
                        }
                    } else {
                        if (isHovering) {
                            if (element.onmouseout) element.onmouseout(e);
                            isHovering = false;
                        }
                    }
                }

                function touchEnd(e) {
                    _this.mousifyTouchEvent(e);
                    window.setUsingTouch(true);
                    if (preventDefault) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    if (isHovering) {
                        if (element.onclick) element.onclick(e);
                        if (element.onmouseout) element.onmouseout(e);
                        isHovering = false;
                    }
                }
            };
            this.removeAllChildren = function(element) {
                while (element.hasChildNodes()) {
                    element.removeChild(element.lastChild);
                }
            };
            this.generateElement = function(config) {
                let element = document.createElement(config.tag || "div");

                function bind(configValue, elementValue) {
                    if (config[configValue]) element[elementValue] = config[configValue];
                }
                bind("text", "textContent");
                bind("html", "innerHTML");
                bind("class", "className");
                for (let key in config) {
                    switch (key) {
                        case "tag":
                        case "text":
                        case "html":
                        case "class":
                        case "style":
                        case "hookTouch":
                        case "parent":
                        case "children":
                            continue;
                        default:
                            break;
                    }
                    element[key] = config[key];
                }
                if (element.onclick) element.onclick = this.checkTrusted(element.onclick);
                if (element.onmouseover) element.onmouseover = this.checkTrusted(element.onmouseover);
                if (element.onmouseout) element.onmouseout = this.checkTrusted(element.onmouseout);
                if (config.style) {
                    element.style.cssText = config.style;
                }
                if (config.hookTouch) {
                    this.hookTouchEvents(element);
                }
                if (config.parent) {
                    config.parent.appendChild(element);
                }
                if (config.children) {
                    for (let i = 0; i < config.children.length; i++) {
                        element.appendChild(config.children[i]);
                    }
                }
                return element;
            };
            this.checkTrusted = function(callback) {
                return function(ev) {
                    if (ev && ev instanceof Event && (ev && typeof ev.isTrusted == "boolean" ? ev.isTrusted : true)) {
                        callback(ev);
                    }
                };
            };
            this.randomString = function(length) {
                let text = "";
                let possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                for (let i = 0; i < length; i++) {
                    text += possible.charAt(Math.floor(Math.random() * possible.length));
                }
                return text;
            };
            this.countInArray = function(array, val) {
                let count = 0;
                for (let i = 0; i < array.length; i++) {
                    if (array[i] === val) count++;
                }
                return count;
            };
            this.hexToRgb = function(hex) {
                return hex.slice(1)
                    .match(/.{1,2}/g)
                    .map(g => parseInt(g, 16));
            };
            this.getRgb = function(r, g, b) {
                return [r / 255, g / 255, b / 255].join(", ");
            };
        }
    };
    class Animtext {
        constructor() {
            this.init = function(x, y, scale, speed, life, text, color) {
                if (WealthyMode) {
                    this.x = x;
                    this.y = y;
                    this.color = color;
                    this.scale = scale;
                    this.weight = 50;
                    this.startScale = this.scale * .8;
                    this.maxScale = 1.5 * scale;
                    this.scaleSpeed = 0.7;
                    this.speed = speed;
                    this.speedMax = speed;
                    this.life = life;
                    this.maxLife = life;
                    this.text = text;
                    this.movSpeed = Math.random() * 1 + 1;
                    this.movAngle = Math.random() * 1 < .5;
                } else {
                    this.x = x;
                    this.y = y;
                    this.color = color;
                    this.scale = scale;
                    this.startScale = this.scale;
                    this.maxScale = scale * 1.5;
                    this.scaleSpeed = 0.7;
                    this.speed = speed;
                    this.life = life;
                    this.text = text;
                    this.acc = 1;
                    this.alpha = 0;
                    this.maxLife = life;
                    this.ranX = UTILS.randFloat(-1, 1);
                }
            };

            this.update = function(delta) {
                if (WealthyMode) {
                    if (this.life) {
                        this.life -= delta;
                        if (this.scaleSpeed != -0.35) {
                            this.y -= this.speed * delta;
                            this.movAngle ? (this.x -= this.speed * delta * (this.movSpeed)) : (this.x += this.speed * delta * (this.movSpeed));
                        } else {
                            this.y += this.speed * delta;
                        }
                        this.scale += this.scaleSpeed * (delta / 4.5);
                        this.scale = Math.max(this.scale, this.startScale);
                        this.speed < this.speedMax && (this.speed += this.speedMax * .01);
                        if (this.scale >= this.maxScale) {
                            this.scale = this.maxScale;
                            this.scaleSpeed *= -.5;
                            this.speed = this.speed * .5;
                        };
                        this.life <= 0 && (this.life = 0)
                    };
                } else {
                    if (this.life > 0) {
                        this.life -= delta;
                        this.y -= this.speed * delta;
                        if (this.life <= 0) {
                            this.life = 0;
                        }
                    }
                }
            };

            this.render = function(ctxt, xOff, yOff, value) {
                if (WealthyMode) {
                    ctxt.lineWidth = 10;
                    ctxt.strokeStyle = "#3d3f42";
                    ctxt.fillStyle = this.color;
                    ctxt.globalAlpha = this.life / this.maxLife * 2
                    ctxt.font = this.scale + "px Hammersmith One";
                    ctxt.strokeText(this.text, this.x - xOff, this.y - yOff);
                    ctxt.fillText(this.text, this.x - xOff, this.y - yOff);
                    ctxt.globalAlpha = 1;
                } else {
                    ctxt.lineWidth = 10;
                    ctxt.fillStyle = this.color;
                    ctxt.font = this.scale + "px Hammersmith One";
                    ctxt.fillText(this.text, this.x - xOff, this.y - yOff);
                    ctxt.globalAlpha = 1;
                }
            };
        }
    }
    class Textmanager {
        constructor() {
            this.texts = [];
            this.stack = [];

            this.update = function(delta, ctxt, xOff, yOff) {
                ctxt.textBaseline = "middle";
                ctxt.textAlign = "center";
                for (let i = 0; i < this.texts.length; ++i) {
                    if (this.texts[i].life) {
                        this.texts[i].update(delta);
                        this.texts[i].render(ctxt, xOff, yOff);
                    }
                }
            };

            this.showText = function(x, y, scale, speed, life, text, color) {
                let tmpText;
                for (let i = 0; i < this.texts.length; ++i) {
                    if (!this.texts[i].life) {
                        tmpText = this.texts[i];
                        break;
                    }
                }
                if (!tmpText) {
                    tmpText = new Animtext();
                    this.texts.push(tmpText);
                }
                tmpText.init(x, y, scale, speed, life, text, color);
            };
        }
    }

    class GameObject {
        constructor(sid) {
            this.sid = sid;

            this.init = function(x, y, dir, scale, type, data, owner) {
                data = data || {};
                this.sentTo = {};
                this.gridLocations = [];
                this.active = true;
                this.render = true;
                this.doUpdate = data.doUpdate;
                this.x = x;
                this.y = y;
                this.dir = dir;
                this.lastDir = dir;
                this.xWiggle = 0;
                this.yWiggle = 0;
                this.visScale = scale;
                this.scale = scale;
                this.type = type;
                this.id = data.id;
                this.owner = owner;
                this.name = data.name;
                this.isItem = (this.id != undefined);
                this.group = data.group;
                this.maxHealth = data.health;
                this.health = this.maxHealth;
                this.layer = 2;
                if (this.group != undefined) {
                    this.layer = this.group.layer;
                } else if (this.type == 0) {
                    this.layer = 3;
                } else if (this.type == 2) {
                    this.layer = 0;
                } else if (this.type == 4) {
                    this.layer = -1;
                }
                this.colDiv = data.colDiv || 1;
                this.blocker = data.blocker;
                this.ignoreCollision = data.ignoreCollision;
                this.dontGather = data.dontGather;
                this.hideFromEnemy = data.hideFromEnemy;
                this.friction = data.friction;
                this.projDmg = data.projDmg;
                this.dmg = data.dmg;
                this.pDmg = data.pDmg;
                this.pps = data.pps;
                this.zIndex = data.zIndex || 0;
                this.turnSpeed = data.turnSpeed;
                this.req = data.req;
                this.trap = data.trap;
                this.healCol = data.healCol;
                this.teleport = data.teleport;
                this.boostSpeed = data.boostSpeed;
                this.projectile = data.projectile;
                this.shootRange = data.shootRange;
                this.shootRate = data.shootRate;
                this.shootCount = this.shootRate;
                this.spawnPoint = data.spawnPoint;
                this.onNear = 0;
                this.breakObj = false;
                this.alpha = data.alpha || 1;
                this.maxAlpha = data.alpha || 1;

                this.targetAlpha = data.alpha || 1;
                this.currentAlpha = data.alpha || 1;

                this.damaged = 0;
            };

            this.changeHealth = function(amount, doer) {
                this.health += amount;
                return (this.health <= 0);
            };

            this.getScale = function(sM, ig) {
                sM = sM || 1;
                return this.scale * ((this.isItem || this.type == 2 || this.type == 3 || this.type == 4) ?
                    1 : (0.6 * sM)) * (ig ? 1 : this.colDiv);
            };

            this.visibleToPlayer = function(player) {
                return !(this.hideFromEnemy) || (this.owner && (this.owner == player ||
                    (this.owner.team && player.team == this.owner.team)));
            };

            this.update = function(delta) {
                if (this.active) {
                    if (this.xWiggle) {
                        this.xWiggle *= Math.pow(0.99, delta);
                    }
                    if (this.yWiggle) {
                        this.yWiggle *= Math.pow(0.99, delta);
                    }

                    if (objRotate) {
                        if (this.turnSpeed) {
                            this.dir += this.turnSpeed * delta;
                        }
                    } else {
                        let d2 = UTILS.getAngleDist(this.lastDir, this.dir);
                        if (d2 > 0.01) {
                            this.dir += d2 / 5;
                        } else {
                            this.dir = this.lastDir;
                        }
                    }
                } else {
                    if (this.alive) {
                        this.alpha -= delta / (200 / this.maxAlpha);
                        this.visScale += delta / (this.scale / 2.5);
                        if (this.alpha <= 0) {
                            this.alpha = 0;
                            this.alive = false;
                        }
                    }
                }
            };

            this.isTeamObject = function(tmpObj) {
                return this.owner == null ? true : (this.owner && tmpObj.sid == this.owner.sid || tmpObj.findAllianceBySid(this.owner.sid));
            };
        }
    }
    class Items {
        constructor() {
            this.groups = [{
                id: 0,
                name: "food",
                layer: 0
            }, {
                id: 1,
                name: "walls",
                place: true,
                limit: 30,
                layer: 0
            }, {
                id: 2,
                name: "spikes",
                place: true,
                limit: 15,
                layer: 0
            }, {
                id: 3,
                name: "mill",
                place: true,
                limit: 7,
                sandboxLimit: 299,
                layer: 1
            }, {
                id: 4,
                name: "mine",
                place: true,
                limit: 1,
                layer: 0
            }, {
                id: 5,
                name: "trap",
                place: true,
                limit: 6,
                layer: -1
            }, {
                id: 6,
                name: "booster",
                place: true,
                limit: 12,
                sandboxLimit: 299,
                layer: -1
            }, {
                id: 7,
                name: "turret",
                place: true,
                limit: 2,
                layer: 1
            }, {
                id: 8,
                name: "watchtower",
                place: true,
                limit: 12,
                layer: 1
            }, {
                id: 9,
                name: "buff",
                place: true,
                limit: 4,
                layer: -1
            }, {
                id: 10,
                name: "spawn",
                place: true,
                limit: 1,
                layer: -1
            }, {
                id: 11,
                name: "sapling",
                place: true,
                limit: 2,
                layer: 0
            }, {
                id: 12,
                name: "blocker",
                place: true,
                limit: 3,
                layer: -1
            }, {
                id: 13,
                name: "teleporter",
                place: true,
                limit: 2,
                sandboxLimit: 299,
                layer: -1
            }];

            this.projectiles = [{
                indx: 0,
                layer: 0,
                src: "arrow_1",
                dmg: 25,
                speed: 1.6,
                scale: 103,
                range: 1000
            }, {
                indx: 1,
                layer: 1,
                dmg: 25,
                scale: 20
            }, {
                indx: 0,
                layer: 0,
                src: "arrow_1",
                dmg: 35,
                speed: 2.5,
                scale: 103,
                range: 1200
            }, {
                indx: 0,
                layer: 0,
                src: "arrow_1",
                dmg: 30,
                speed: 2,
                scale: 103,
                range: 1200
            }, {
                indx: 1,
                layer: 1,
                dmg: 16,
                scale: 20
            }, {
                indx: 0,
                layer: 0,
                src: "bullet_1",
                dmg: 50,
                speed: 3.6,
                scale: 160,
                range: 1400
            }];

            this.weapons = [{
                id: 0,
                type: 0,
                name: "tool hammer",
                desc: "tool for gathering all resources",
                src: "hammer_1",
                length: 140,
                width: 140,
                xOff: -3,
                yOff: 18,
                dmg: 25,
                range: 65,
                gather: 1,
                speed: 300
            }, {
                id: 1,
                type: 0,
                age: 2,
                name: "hand axe",
                desc: "gathers resources at a higher rate",
                src: "axe_1",
                length: 140,
                width: 140,
                xOff: 3,
                yOff: 24,
                dmg: 30,
                spdMult: 1,
                range: 70,
                gather: 2,
                speed: 400
            }, {
                id: 2,
                type: 0,
                age: 8,
                pre: 1,
                name: "great axe",
                desc: "deal more damage and gather more resources",
                src: "great_axe_1",
                length: 140,
                width: 140,
                xOff: -8,
                yOff: 25,
                dmg: 35,
                spdMult: 1,
                range: 75,
                gather: 4,
                speed: 400
            }, {
                id: 3,
                type: 0,
                age: 2,
                name: "short sword",
                desc: "increased attack power but slower move speed",
                src: "sword_1",
                iPad: 1.3,
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 46,
                dmg: 35,
                spdMult: 0.85,
                range: 110,
                gather: 1,
                speed: 300
            }, {
                id: 4,
                type: 0,
                age: 8,
                pre: 3,
                name: "katana",
                desc: "greater range and damage",
                src: "samurai_1",
                iPad: 1.3,
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 59,
                dmg: 40,
                spdMult: 0.8,
                range: 118,
                gather: 1,
                speed: 300
            }, {
                id: 5,
                type: 0,
                age: 2,
                name: "polearm",
                desc: "long range melee weapon",
                src: "spear_1",
                iPad: 1.3,
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 53,
                dmg: 45,
                knock: 0.2,
                spdMult: 0.82,
                range: 142,
                gather: 1,
                speed: 700
            }, {
                id: 6,
                type: 0,
                age: 2,
                name: "bat",
                desc: "fast long range melee weapon",
                src: "bat_1",
                iPad: 1.3,
                length: 110,
                width: 180,
                xOff: -8,
                yOff: 53,
                dmg: 20,
                knock: 0.7,
                range: 110,
                gather: 1,
                speed: 300
            }, {
                id: 7,
                type: 0,
                age: 2,
                name: "daggers",
                desc: "really fast short range weapon",
                src: "dagger_1",
                iPad: 0.8,
                length: 110,
                width: 110,
                xOff: 18,
                yOff: 0,
                dmg: 20,
                knock: 0.1,
                range: 65,
                gather: 1,
                hitSlow: 0.1,
                spdMult: 1.13,
                speed: 100
            }, {
                id: 8,
                type: 0,
                age: 2,
                name: "stick",
                desc: "great for gathering but very weak",
                src: "stick_1",
                length: 140,
                width: 140,
                xOff: 3,
                yOff: 24,
                dmg: 1,
                spdMult: 1,
                range: 70,
                gather: 7,
                speed: 400
            }, {
                id: 9,
                type: 1,
                age: 6,
                name: "hunting bow",
                desc: "bow used for ranged combat and hunting",
                src: "bow_1",
                req: ["wood", 4],
                length: 120,
                width: 120,
                xOff: -6,
                yOff: 0,
                Pdmg: 25,
                projectile: 0,
                spdMult: 0.75,
                speed: 600
            }, {
                id: 10,
                type: 1,
                age: 6,
                name: "great hammer",
                desc: "hammer used for destroying structures",
                src: "great_hammer_1",
                length: 140,
                width: 140,
                xOff: -9,
                yOff: 25,
                dmg: 10,
                Pdmg: 10,
                spdMult: 0.88,
                range: 75,
                sDmg: 7.5,
                gather: 1,
                speed: 400
            }, {
                id: 11,
                type: 1,
                age: 6,
                name: "wooden shield",
                desc: "blocks projectiles and reduces melee damage",
                src: "shield_1",
                length: 120,
                width: 120,
                shield: 0.2,
                xOff: 6,
                yOff: 0,
                Pdmg: 0,
                spdMult: 0.7
            }, {
                id: 12,
                type: 1,
                age: 8,
                pre: 9,
                name: "crossbow",
                desc: "deals more damage and has greater range",
                src: "crossbow_1",
                req: ["wood", 5],
                aboveHand: true,
                armS: 0.75,
                length: 120,
                width: 120,
                xOff: -4,
                yOff: 0,
                Pdmg: 35,
                projectile: 2,
                spdMult: 0.7,
                speed: 700
            }, {
                id: 13,
                type: 1,
                age: 9,
                pre: 12,
                name: "repeater crossbow",
                desc: "high firerate crossbow with reduced damage",
                src: "crossbow_2",
                req: ["wood", 10],
                aboveHand: true,
                armS: 0.75,
                length: 120,
                width: 120,
                xOff: -4,
                yOff: 0,
                Pdmg: 30,
                projectile: 3,
                spdMult: 0.7,
                speed: 230
            }, {
                id: 14,
                type: 1,
                age: 6,
                name: "mc grabby",
                desc: "steals resources from enemies",
                src: "grab_1",
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 53,
                dmg: 0,
                Pdmg: 0,
                steal: 250,
                knock: 0.2,
                spdMult: 1.05,
                range: 125,
                gather: 0,
                speed: 700
            }, {
                id: 15,
                type: 1,
                age: 9,
                pre: 12,
                name: "musket",
                desc: "slow firerate but high damage and range",
                src: "musket_1",
                req: ["stone", 10],
                aboveHand: true,
                rec: 0.35,
                armS: 0.6,
                hndS: 0.3,
                hndD: 1.6,
                length: 205,
                width: 205,
                xOff: 25,
                yOff: 0,
                Pdmg: 50,
                projectile: 5,
                hideProjectile: true,
                spdMult: 0.6,
                speed: 1500
            }];

            this.list = [{
                group: this.groups[0],
                name: "apple",
                desc: "restores 20 health when consumed",
                req: ["food", 10],
                consume: function(doer) {
                    return doer.changeHealth(20, doer);
                },
                scale: 22,
                holdOffset: 15,
                healing: 20,
                itemID: 0,
                itemAID: 16,
            }, {
                age: 3,
                group: this.groups[0],
                name: "cookie",
                desc: "restores 40 health when consumed",
                req: ["food", 15],
                consume: function(doer) {
                    return doer.changeHealth(40, doer);
                },
                scale: 27,
                holdOffset: 15,
                healing: 40,
                itemID: 1,
                itemAID: 17,
            }, {
                age: 7,
                group: this.groups[0],
                name: "cheese",
                desc: "restores 30 health and another 50 over 5 seconds",
                req: ["food", 25],
                consume: function(doer) {
                    if (doer.changeHealth(30, doer) || doer.health < 100) {
                        doer.dmgOverTime.dmg = -10;
                        doer.dmgOverTime.doer = doer;
                        doer.dmgOverTime.time = 5;
                        return true;
                    }
                    return false;
                },
                scale: 27,
                holdOffset: 15,
                healing: 30,
                itemID: 2,
                itemAID: 18,
            }, {
                group: this.groups[1],
                name: "wood wall",
                desc: "provides protection for your village",
                req: ["wood", 10],
                projDmg: true,
                health: 380,
                scale: 50,
                holdOffset: 20,
                placeOffset: -5,
                itemID: 3,
                itemAID: 19,
            }, {
                age: 3,
                group: this.groups[1],
                name: "stone wall",
                desc: "provides improved protection for your village",
                req: ["stone", 25],
                health: 900,
                scale: 50,
                holdOffset: 20,
                placeOffset: -5,
                itemID: 4,
                itemAID: 20,
            }, {
                age: 7,
                group: this.groups[1],
                name: "castle wall",
                desc: "provides powerful protection for your village",
                req: ["stone", 35],
                health: 1500,
                scale: 52,
                holdOffset: 20,
                placeOffset: -5,
                itemID: 5,
                itemAID: 21,
            }, {
                group: this.groups[2],
                name: "spikes",
                desc: "damages enemies when they touch them",
                req: ["wood", 20, "stone", 5],
                health: 400,
                dmg: 20,
                scale: 49,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5,
                itemID: 6,
                itemAID: 22,
                shadow: {
                    offsetX: 5,
                    offsetY: 5,
                    color: "rgba()"
                }

            }, {
                age: 5,
                group: this.groups[2],
                name: "greater spikes",
                desc: "damages enemies when they touch them",
                req: ["wood", 30, "stone", 10],
                health: 500,
                dmg: 35,
                scale: 52,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5,
                itemID: 7,
                itemAID: 23,
            }, {
                age: 9,
                group: this.groups[2],
                name: "poison spikes",
                desc: "poisons enemies when they touch them",
                req: ["wood", 35, "stone", 15],
                health: 600,
                dmg: 30,
                pDmg: 5,
                scale: 52,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5,
                itemID: 8,
                itemAID: 24,
            }, {
                age: 9,
                group: this.groups[2],
                name: "spinning spikes",
                desc: "damages enemies when they touch them",
                req: ["wood", 30, "stone", 20],
                health: 500,
                dmg: 45,
                turnSpeed: 0.003,
                scale: 52,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5,
                itemID: 9,
                itemAID: 25,
            }, {
                group: this.groups[3],
                name: "windmill",
                desc: "generates gold over time",
                req: ["wood", 50, "stone", 10],
                health: 400,
                pps: 1,
                turnSpeed: 0.0016,
                spritePadding: 25,
                iconLineMult: 12,
                scale: 45,
                holdOffset: 20,
                placeOffset: 5,
                itemID: 10,
                itemAID: 26,
            }, {
                age: 5,
                group: this.groups[3],
                name: "faster windmill",
                desc: "generates more gold over time",
                req: ["wood", 60, "stone", 20],
                health: 500,
                pps: 1.5,
                turnSpeed: 0.0025,
                spritePadding: 25,
                iconLineMult: 12,
                scale: 47,
                holdOffset: 20,
                placeOffset: 5,
                itemID: 11,
                itemAID: 27,
            }, {
                age: 8,
                group: this.groups[3],
                name: "power mill",
                desc: "generates more gold over time",
                req: ["wood", 100, "stone", 50],
                health: 800,
                pps: 2,
                turnSpeed: 0.005,
                spritePadding: 25,
                iconLineMult: 12,
                scale: 47,
                holdOffset: 20,
                placeOffset: 5,
                itemID: 12,
                itemAID: 28,
            }, {
                age: 5,
                group: this.groups[4],
                type: 2,
                name: "mine",
                desc: "allows you to mine stone",
                req: ["wood", 20, "stone", 100],
                iconLineMult: 12,
                scale: 65,
                holdOffset: 20,
                placeOffset: 0,
                itemID: 13,
                itemAID: 29,
            }, {
                age: 5,
                group: this.groups[11],
                type: 0,
                name: "sapling",
                desc: "allows you to farm wood",
                req: ["wood", 150],
                iconLineMult: 12,
                colDiv: 0.5,
                scale: 110,
                holdOffset: 50,
                placeOffset: -15,
                itemID: 14,
                itemAID: 30,
            }, {
                age: 4,
                group: this.groups[5],
                name: "pit trap",
                desc: "pit that traps enemies if they walk over it",
                req: ["wood", 30, "stone", 30],
                trap: true,
                ignoreCollision: true,
                hideFromEnemy: true,
                health: 500,
                colDiv: 0.2,
                scale: 50,
                holdOffset: 20,
                placeOffset: -5,
                alpha: 0.6,
                itemID: 15,
                itemAID: 31,
            }, {
                age: 4,
                group: this.groups[6],
                name: "boost pad",
                desc: "provides boost when stepped on",
                req: ["stone", 20, "wood", 5],
                ignoreCollision: true,
                boostSpeed: 1.5,
                health: 150,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5,
                itemID: 16,
                itemAID: 32,
            }, {
                age: 7,
                group: this.groups[7],
                doUpdate: true,
                name: "turret",
                desc: "defensive structure that shoots at enemies",
                req: ["wood", 200, "stone", 150],
                health: 800,
                projectile: 1,
                shootRange: 700,
                shootRate: 2200,
                scale: 43,
                holdOffset: 20,
                placeOffset: -5,
                itemID: 17,
                itemAID: 33,
            }, {
                age: 7,
                group: this.groups[8],
                name: "platform",
                desc: "platform to shoot over walls and cross over water",
                req: ["wood", 20],
                ignoreCollision: true,
                zIndex: 1,
                health: 300,
                scale: 43,
                holdOffset: 20,
                placeOffset: -5,
                itemID: 18,
                itemAID: 34,
            }, {
                age: 7,
                group: this.groups[9],
                name: "healing pad",
                desc: "standing on it will slowly heal you",
                req: ["wood", 30, "food", 10],
                ignoreCollision: true,
                healCol: 15,
                health: 400,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5,
                itemID: 19,
                itemAID: 35,
            }, {
                age: 9,
                group: this.groups[10],
                name: "spawn pad",
                desc: "you will spawn here when you die but it will dissapear",
                req: ["wood", 100, "stone", 100],
                health: 400,
                ignoreCollision: true,
                spawnPoint: true,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5,
                itemID: 20,
                itemAID: 36,
            }, {
                age: 7,
                group: this.groups[12],
                name: "blocker",
                desc: "blocks building in radius",
                req: ["wood", 30, "stone", 25],
                ignoreCollision: true,
                blocker: 300,
                health: 400,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5,
                itemID: 21,
                itemAID: 37,
            }, {
                age: 7,
                group: this.groups[13],
                name: "teleporter",
                desc: "teleports you to a random point on the map",
                req: ["wood", 60, "stone", 60],
                ignoreCollision: true,
                teleport: true,
                health: 200,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5,
                itemID: 22,
                itemAID: 38
            }];
            this.katanaActive = false;
            this.katanaChanged = false;

            // Grsel deiimi kontrol et
            this.checkVisual = () => {
                // Temel kontroller
                if (!player?.alive || !inGame) {
                    if (this.katanaActive) {
                        this.resetVisual();
                        // ldnde katanaChanged'i sfrla
                        this.katanaChanged = false;
                    }
                    return;
                }

                // Short sword + Musket kontrol
                const hasCombo = player.weapons[0] === 3 && player.weapons[1] === 15;

                // Kombo varsa ve henz deitirilmemise
                if (hasCombo && !this.katanaActive && !this.katanaChanged) {
                    try {
                        // Katana grnm uygula
                        const katana = this.weapons[4];
                        const sword = this.weapons[3];

                        sword.src = katana.src;
                        sword.length = katana.length;
                        sword.width = katana.width;
                        sword.xOff = katana.xOff;
                        sword.yOff = katana.yOff;

                        this.katanaActive = true;
                        this.katanaChanged = true;

                    } catch (e) {
                        console.error("Katana grnm uygulanrken hata:", e);
                    }
                }

                // Kombinasyon bozulunca sfrla
                if (!hasCombo && this.katanaActive) {
                    this.resetVisual();
                    // Kombo bozulduunda da katanaChanged'i sfrla
                    this.katanaChanged = false;
                }
            }

            // Orijinal grnme dndr
            this.resetVisual = () => {
                try {
                    const sword = this.weapons[3];
                    sword.src = "sword_1";
                    sword.length = 130;
                    sword.width = 210;
                    sword.xOff = -8;
                    sword.yOff = 46;

                    this.katanaActive = false;
                } catch (e) {
                    console.error("Grnm sfrlanrken hata:", e);
                }
            }

            this.checkItem = {
                index: function(id, myItems) {
                    return [0, 1, 2].includes(id) ? 0 : [3, 4, 5].includes(id) ? 1 : [6, 7, 8, 9].includes(id) ? 2 : [10, 11, 12].includes(id) ? 3 : [13, 14].includes(id) ? 5 : [15, 16].includes(id) ? 4 : [17, 18, 19, 21, 22].includes(id) ? [13, 14].includes(myItems) ? 6 :
                        5 :
                        id == 20 ? [13, 14].includes(myItems) ? 7 :
                        6 :
                        undefined;
                }
            }

            for (let i = 0; i < this.list.length; ++i) {
                this.list[i].id = i;
                if (this.list[i].pre) this.list[i].pre = i - this.list[i].pre;
            }

            if (typeof window !== "undefined") {
                function shuffle(a) {
                    for (let i = a.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [a[i], a[j]] = [a[j], a[i]];
                    }
                    return a;
                }
            }
        }
    }
    class Objectmanager {
        constructor(GameObject, closeObjects, UTILS, config, players, server) {
            let mathFloor = Math.floor,
                mathABS = Math.abs,
                mathCOS = Math.cos,
                mathSIN = Math.sin,
                mathPOW = Math.pow,
                mathSQRT = Math.sqrt;

            this.ignoreAdd = false;
            this.hitObj = [];

            this.disableObj = function(obj) {
                obj.active = false;
            };

            let tmpObj;
            this.add = function(sid, x, y, dir, s, type, data, setSID, owner) {
                tmpObj = findObjectBySid(sid);
                if (!tmpObj) {
                    tmpObj = gameObjects.find((tmp) => !tmp.active);
                    if (!tmpObj) {
                        tmpObj = new GameObject(sid);
                        gameObjects.push(tmpObj);
                    }
                }
                if (setSID) {
                    tmpObj.sid = sid;
                }
                tmpObj.init(x, y, dir, s, type, data, owner);
            };

            this.disableBySid = function(sid) {
                let find = findObjectBySid(sid);
                if (find) {
                    this.disableObj(find);
                }
            };

            this.removeAllItems = function(sid, server) {
                gameObjects.filter((tmp) => tmp.active && tmp.owner && tmp.owner.sid == sid)
                    .forEach((tmp) => this.disableObj(tmp));
            };

            this.checkItemLocation = function(x, y, s, sM, indx, ignoreWater, placer) {
                let cantPlace = closeObjects.find((tmp) => tmp.active && UTILS.getDistance(x, y, tmp.x, tmp.y) < s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem)));
                if (cantPlace) return false;
                if (!ignoreWater && indx != 18 && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2) return false;
                return true;
            };

        }
    }
    class Projectile {
        constructor(players, ais, objectManager, items, config, UTILS, server) {

            this.init = function(indx, x, y, dir, spd, dmg, rng, scl, owner) {
                this.active = true;
                this.tickActive = true;
                this.indx = indx;
                this.x = x;
                this.y = y;
                this.x2 = x;
                this.y2 = y;
                this.dir = dir;
                this.skipMov = true;
                this.speed = spd;
                this.dmg = dmg;
                this.scale = scl;
                this.range = rng;
                this.r2 = rng;
                this.owner = owner;
            };

            this.update = function(delta) {
                if (this.active) {
                    let tmpSpeed = this.speed * delta;
                    if (!this.skipMov) {
                        this.x += tmpSpeed * Math.cos(this.dir);
                        this.y += tmpSpeed * Math.sin(this.dir);
                        this.range -= tmpSpeed;
                        if (this.range <= 0) {
                            this.x += this.range * Math.cos(this.dir);
                            this.y += this.range * Math.sin(this.dir);
                            tmpSpeed = 1;
                            this.range = 0;
                            this.active = false;
                        }
                    } else {
                        this.skipMov = false;
                    }
                }
            };
            this.tickUpdate = function(delta) {
                if (this.tickActive) {
                    let tmpSpeed = this.speed * delta;
                    if (!this.skipMov) {
                        this.x2 += tmpSpeed * Math.cos(this.dir);
                        this.y2 += tmpSpeed * Math.sin(this.dir);
                        this.r2 -= tmpSpeed;
                        if (this.r2 <= 0) {
                            this.x2 += this.r2 * Math.cos(this.dir);
                            this.y2 += this.r2 * Math.sin(this.dir);
                            tmpSpeed = 1;
                            this.r2 = 0;
                            this.tickActive = false;
                        }
                    } else {
                        this.skipMov = false;
                    }
                }
            };
        }
    };
    class Store {
        constructor() {
            this.hats = [{
                id: 45,
                name: "Shame!",
                dontSell: true,
                price: 0,
                scale: 120,
                desc: "hacks are for winners"
            }, {
                id: 51,
                name: "Moo Cap",
                price: 0,
                scale: 120,
                desc: "coolest mooer around"
            }, {
                id: 50,
                name: "Apple Cap",
                price: 0,
                scale: 120,
                desc: "apple farms remembers"
            }, {
                id: 28,
                name: "Moo Head",
                price: 0,
                scale: 120,
                desc: "no effect"
            }, {
                id: 29,
                name: "Pig Head",
                price: 0,
                scale: 120,
                desc: "no effect"
            }, {
                id: 30,
                name: "Fluff Head",
                price: 0,
                scale: 120,
                desc: "no effect"
            }, {
                id: 36,
                name: "Pandou Head",
                price: 0,
                scale: 120,
                desc: "no effect"
            }, {
                id: 37,
                name: "Bear Head",
                price: 0,
                scale: 120,
                desc: "no effect"
            }, {
                id: 38,
                name: "Monkey Head",
                price: 0,
                scale: 120,
                desc: "no effect"
            }, {
                id: 44,
                name: "Polar Head",
                price: 0,
                scale: 120,
                desc: "no effect"
            }, {
                id: 35,
                name: "Fez Hat",
                price: 0,
                scale: 120,
                desc: "no effect"
            }, {
                id: 42,
                name: "Enigma Hat",
                price: 0,
                scale: 120,
                desc: "join the enigma army"
            }, {
                id: 43,
                name: "Blitz Hat",
                price: 0,
                scale: 120,
                desc: "hey everybody i'm blitz"
            }, {
                id: 49,
                name: "Bob XIII Hat",
                price: 0,
                scale: 120,
                desc: "like and subscribe"
            }, {
                id: 57,
                name: "Pumpkin",
                price: 50,
                scale: 120,
                desc: "Spooooky"
            }, {
                id: 8,
                name: "Bummle Hat",
                price: 100,
                scale: 120,
                desc: "no effect"
            }, {
                id: 2,
                name: "Straw Hat",
                price: 500,
                scale: 120,
                desc: "no effect"
            }, {
                id: 15,
                name: "Winter Cap",
                price: 600,
                scale: 120,
                desc: "allows you to move at normal speed in snow",
                coldM: 1
            }, {
                id: 5,
                name: "Cowboy Hat",
                price: 1000,
                scale: 120,
                desc: "no effect"
            }, {
                id: 4,
                name: "Ranger Hat",
                price: 2000,
                scale: 120,
                desc: "no effect"
            }, {
                id: 18,
                name: "Explorer Hat",
                price: 2000,
                scale: 120,
                desc: "no effect"
            }, {
                id: 31,
                name: "Flipper Hat",
                price: 2500,
                scale: 120,
                desc: "have more control while in water",
                watrImm: true
            }, {
                id: 1,
                name: "Marksman Cap",
                price: 3000,
                scale: 120,
                desc: "increases arrow speed and range",
                aMlt: 1.3
            }, {
                id: 10,
                name: "Bush Gear",
                price: 3000,
                scale: 160,
                desc: "allows you to disguise yourself as a bush"
            }, {
                id: 48,
                name: "Halo",
                price: 3000,
                scale: 120,
                desc: "no effect"
            }, {
                id: 6,
                name: "Soldier Helmet",
                price: 4000,
                scale: 120,
                desc: "reduces damage taken but slows movement",
                spdMult: 0.94,
                dmgMult: 0.75
            }, {
                id: 23,
                name: "Anti Venom Gear",
                price: 4000,
                scale: 120,
                desc: "makes you immune to poison",
                poisonRes: 1
            }, {
                id: 13,
                name: "Medic Gear",
                price: 5000,
                scale: 110,
                desc: "slowly regenerates health over time",
                healthRegen: 3
            }, {
                id: 9,
                name: "Miners Helmet",
                price: 5000,
                scale: 120,
                desc: "earn 1 extra gold per resource",
                extraGold: 1
            }, {
                id: 32,
                name: "Musketeer Hat",
                price: 5000,
                scale: 120,
                desc: "reduces cost of projectiles",
                projCost: 0.5
            }, {
                id: 7,
                name: "Bull Helmet",
                price: 6000,
                scale: 120,
                desc: "increases damage done but drains health",
                healthRegen: -5,
                dmgMultO: 1.5,
                spdMult: 0.96
            }, {
                id: 22,
                name: "Emp Helmet",
                price: 6000,
                scale: 120,
                desc: "turrets won't attack but you move slower",
                antiTurret: 1,
                spdMult: 0.7
            }, {
                id: 12,
                name: "Booster Hat",
                price: 6000,
                scale: 120,
                desc: "increases your movement speed",
                spdMult: 1.16
            }, {
                id: 26,
                name: "Barbarian Armor",
                price: 8000,
                scale: 120,
                desc: "knocks back enemies that attack you",
                dmgK: 0.6
            }, {
                id: 21,
                name: "Plague Mask",
                price: 10000,
                scale: 120,
                desc: "melee attacks deal poison damage",
                poisonDmg: 5,
                poisonTime: 6
            }, {
                id: 46,
                name: "Bull Mask",
                price: 10000,
                scale: 120,
                desc: "bulls won't target you unless you attack them",
                bullRepel: 1
            }, {
                id: 14,
                name: "Windmill Hat",
                topSprite: true,
                price: 10000,
                scale: 120,
                desc: "generates points while worn",
                pps: 1.5
            }, {
                id: 11,
                name: "Spike Gear",
                topSprite: true,
                price: 10000,
                scale: 120,
                desc: "deal damage to players that damage you",
                dmg: 0.45
            }, {
                id: 53,
                name: "Turret Gear",
                topSprite: true,
                price: 10000,
                scale: 120,
                desc: "you become a walking turret",
                turret: {
                    proj: 1,
                    range: 700,
                    rate: 2500
                },
                spdMult: 0.7
            }, {
                id: 20,
                name: "Samurai Armor",
                price: 12000,
                scale: 120,
                desc: "increased attack speed and fire rate",
                atkSpd: 0.78
            }, {
                id: 58,
                name: "Dark Knight",
                price: 12000,
                scale: 120,
                desc: "restores health when you deal damage",
                healD: 0.4
            }, {
                id: 27,
                name: "Scavenger Gear",
                price: 15000,
                scale: 120,
                desc: "earn double points for each kill",
                kScrM: 2
            }, {
                id: 40,
                name: "Tank Gear",
                price: 15000,
                scale: 120,
                desc: "increased damage to buildings but slower movement",
                spdMult: 0.3,
                bDmg: 3.3
            }, {
                id: 52,
                name: "Thief Gear",
                price: 15000,
                scale: 120,
                desc: "steal half of a players gold when you kill them",
                goldSteal: 0.5
            }, {
                id: 55,
                name: "Bloodthirster",
                price: 20000,
                scale: 120,
                desc: "Restore Health when dealing damage. And increased damage",
                healD: 0.25,
                dmgMultO: 1.2,
            }, {
                id: 56,
                name: "Assassin Gear",
                price: 20000,
                scale: 120,
                desc: "Go invisible when not moving. Can't eat. Increased speed",
                noEat: true,
                spdMult: 1.1,
                invisTimer: 1000
            }];

            this.accessories = [{
                id: 12,
                name: "Snowball",
                price: 1000,
                scale: 105,
                xOff: 18,
                desc: "no effect"
            }, {
                id: 9,
                name: "Tree Cape",
                price: 1000,
                scale: 90,
                desc: "no effect"
            }, {
                id: 10,
                name: "Stone Cape",
                price: 1000,
                scale: 90,
                desc: "no effect"
            }, {
                id: 3,
                name: "Cookie Cape",
                price: 1500,
                scale: 90,
                desc: "no effect"
            }, {
                id: 8,
                name: "Cow Cape",
                price: 2000,
                scale: 90,
                desc: "no effect"
            }, {
                id: 11,
                name: "Monkey Tail",
                price: 2000,
                scale: 97,
                xOff: 25,
                desc: "Super speed but reduced damage",
                spdMult: 1.35,
                dmgMultO: 0.2
            }, {
                id: 17,
                name: "Apple Basket",
                price: 3000,
                scale: 80,
                xOff: 12,
                desc: "slowly regenerates health over time",
                healthRegen: 1
            }, {
                id: 6,
                name: "Winter Cape",
                price: 3000,
                scale: 90,
                desc: "no effect"
            }, {
                id: 4,
                name: "Skull Cape",
                price: 4000,
                scale: 90,
                desc: "no effect"
            }, {
                id: 5,
                name: "Dash Cape",
                price: 5000,
                scale: 90,
                desc: "no effect"
            }, {
                id: 2,
                name: "Dragon Cape",
                price: 6000,
                scale: 90,
                desc: "no effect"
            }, {
                id: 1,
                name: "Super Cape",
                price: 8000,
                scale: 90,
                desc: "no effect"
            }, {
                id: 7,
                name: "Troll Cape",
                price: 8000,
                scale: 90,
                desc: "no effect"
            }, {
                id: 14,
                name: "Thorns",
                price: 10000,
                scale: 115,
                xOff: 20,
                desc: "no effect"
            }, {
                id: 15,
                name: "Blockades",
                price: 10000,
                scale: 95,
                xOff: 15,
                desc: "no effect"
            }, {
                id: 20,
                name: "Devils Tail",
                price: 10000,
                scale: 95,
                xOff: 20,
                desc: "no effect"
            }, {
                id: 16,
                name: "Sawblade",
                price: 12000,
                scale: 90,
                spin: true,
                xOff: 0,
                desc: "deal damage to players that damage you",
                dmg: 0.15
            }, {
                id: 13,
                name: "Angel Wings",
                price: 15000,
                scale: 138,
                xOff: 22,
                desc: "slowly regenerates health over time",
                healthRegen: 3
            }, {
                id: 19,
                name: "Shadow Wings",
                price: 15000,
                scale: 138,
                xOff: 22,
                desc: "increased movement speed",
                spdMult: 1.1
            }, {
                id: 18,
                name: "Blood Wings",
                price: 20000,
                scale: 178,
                xOff: 26,
                desc: "restores health when you deal damage",
                healD: 0.2
            }, {
                id: 21,
                name: "Corrupt X Wings",
                price: 20000,
                scale: 178,
                xOff: 26,
                desc: "deal damage to players that damage you",
                dmg: 0.25
            }];
        }
    };
    class ProjectileManager {
        constructor(Projectile, projectiles, players, ais, objectManager, items, config, UTILS, server) {
            this.addProjectile = function(x, y, dir, range, speed, indx, owner, ignoreObj, layer, inWindow) {
                let tmpData = items.projectiles[indx];
                let tmpProj;
                for (let i = 0; i < projectiles.length; ++i) {
                    if (!projectiles[i].active) {
                        tmpProj = projectiles[i];
                        break;
                    }
                }
                if (!tmpProj) {
                    tmpProj = new Projectile(players, ais, objectManager, items, config, UTILS, server);
                    tmpProj.sid = projectiles.length;
                    projectiles.push(tmpProj);
                }
                tmpProj.init(indx, x, y, dir, speed, tmpData.dmg, range, tmpData.scale, owner);
                tmpProj.ignoreObj = ignoreObj;
                tmpProj.layer = layer || tmpData.layer;
                tmpProj.inWindow = inWindow;
                tmpProj.src = tmpData.src;
                return tmpProj;
            };
        }
    };
    class AiManager {

        constructor(ais, AI, players, items, objectManager, config, UTILS, scoreCallback, server) {

            this.aiTypes = [{
                id: 0,
                src: "cow_1",
                killScore: 150,
                health: 500,
                weightM: 0.8,
                speed: 0.00095,
                turnSpeed: 0.001,
                scale: 72,
                drop: ["food", 50]
            }, {
                id: 1,
                src: "pig_1",
                killScore: 200,
                health: 800,
                weightM: 0.6,
                speed: 0.00085,
                turnSpeed: 0.001,
                scale: 72,
                drop: ["food", 80]
            }, {
                id: 2,
                name: "Bull",
                src: "bull_2",
                hostile: true,
                dmg: 20,
                killScore: 1000,
                health: 1800,
                weightM: 0.5,
                speed: 0.00094,
                turnSpeed: 0.00074,
                scale: 78,
                viewRange: 800,
                chargePlayer: true,
                drop: ["food", 100]
            }, {
                id: 3,
                name: "Bully",
                src: "bull_1",
                hostile: true,
                dmg: 20,
                killScore: 2000,
                health: 2800,
                weightM: 0.45,
                speed: 0.001,
                turnSpeed: 0.0008,
                scale: 90,
                viewRange: 900,
                chargePlayer: true,
                drop: ["food", 400]
            }, {
                id: 4,
                name: "Wolf",
                src: "wolf_1",
                hostile: true,
                dmg: 8,
                killScore: 500,
                health: 300,
                weightM: 0.45,
                speed: 0.001,
                turnSpeed: 0.002,
                scale: 84,
                viewRange: 800,
                chargePlayer: true,
                drop: ["food", 200]
            }, {
                id: 5,
                name: "Quack",
                src: "chicken_1",
                dmg: 8,
                killScore: 2000,
                noTrap: true,
                health: 300,
                weightM: 0.2,
                speed: 0.0018,
                turnSpeed: 0.006,
                scale: 70,
                drop: ["food", 100]
            }, {
                id: 6,
                name: "MOOSTAFA",
                nameScale: 50,
                src: "enemy",
                hostile: true,
                dontRun: true,
                fixedSpawn: true,
                spawnDelay: 60000,
                noTrap: true,
                colDmg: 100,
                dmg: 40,
                killScore: 8000,
                health: 18000,
                weightM: 0.4,
                speed: 0.0007,
                turnSpeed: 0.01,
                scale: 80,
                spriteMlt: 1.8,
                leapForce: 0.9,
                viewRange: 1000,
                hitRange: 210,
                hitDelay: 1000,
                chargePlayer: true,
                drop: ["food", 100]
            }, {
                id: 7,
                name: "Treasure",
                hostile: true,
                nameScale: 35,
                src: "crate_1",
                fixedSpawn: true,
                spawnDelay: 120000,
                colDmg: 200,
                killScore: 5000,
                health: 20000,
                weightM: 0.1,
                speed: 0.0,
                turnSpeed: 0.0,
                scale: 70,
                spriteMlt: 1.0
            }, {
                id: 8,
                name: "MOOFIE",
                src: "wolf_2",
                hostile: true,
                fixedSpawn: true,
                dontRun: true,
                hitScare: 4,
                spawnDelay: 30000,
                noTrap: true,
                nameScale: 35,
                dmg: 10,
                colDmg: 100,
                killScore: 3000,
                health: 7000,
                weightM: 0.45,
                speed: 0.0015,
                turnSpeed: 0.002,
                scale: 90,
                viewRange: 800,
                chargePlayer: true,
                drop: ["food", 1000]
            }, {
                id: 9,
                name: "MOOFIE",
                src: "wolf_2",
                hostile: !0,
                fixedSpawn: !0,
                dontRun: !0,
                hitScare: 50,
                spawnDelay: 6e4,
                noTrap: !0,
                nameScale: 35,
                dmg: 12,
                colDmg: 100,
                killScore: 3e3,
                health: 9e3,
                weightM: .45,
                speed: .0015,
                turnSpeed: .0025,
                scale: 94,
                viewRange: 1440,
                chargePlayer: !0,
                drop: ["food", 3e3],
                minSpawnRange: .85,
                maxSpawnRange: .9
            }, {
                id: 10,
                name: "Wolf",
                src: "wolf_1",
                hostile: !0,
                fixedSpawn: !0,
                dontRun: !0,
                hitScare: 50,
                spawnDelay: 3e4,
                dmg: 10,
                killScore: 700,
                health: 500,
                weightM: .45,
                speed: .00115,
                turnSpeed: .0025,
                scale: 88,
                viewRange: 1440,
                chargePlayer: !0,
                drop: ["food", 400],
                minSpawnRange: .85,
                maxSpawnRange: .9
            }, {
                id: 11,
                name: "Bully",
                src: "bull_1",
                hostile: !0,
                fixedSpawn: !0,
                dontRun: !0,
                hitScare: 50,
                dmg: 20,
                killScore: 5e3,
                health: 5e3,
                spawnDelay: 1e5,
                weightM: .45,
                speed: .00115,
                turnSpeed: .0025,
                scale: 94,
                viewRange: 1440,
                chargePlayer: !0,
                drop: ["food", 800],
                minSpawnRange: .85,
                maxSpawnRange: .9
            }];

            this.spawn = function(x, y, dir, index) {
                let tmpObj = ais.find((tmp) => !tmp.active);
                if (!tmpObj) {
                    tmpObj = new AI(ais.length, objectManager, players, items, UTILS, config, scoreCallback, server);
                    ais.push(tmpObj);
                }
                tmpObj.init(x, y, dir, index, this.aiTypes[index]);
                return tmpObj;
            };
        }

    };

    class AI {
        constructor(sid, objectManager, players, items, UTILS, config, scoreCallback, server) {
            this.sid = sid;
            this.isAI = true;
            this.nameIndex = UTILS.randInt(0, config.cowNames.length - 1);

            this.init = function(x, y, dir, index, data) {
                this.x = x;
                this.y = y;
                this.startX = data.fixedSpawn ? x : null;
                this.startY = data.fixedSpawn ? y : null;
                this.xVel = 0;
                this.yVel = 0;
                this.zIndex = 0;
                this.dir = dir;
                this.dirPlus = 0;
                this.showName = 'aaa';
                this.index = index;
                this.src = data.src;
                if (data.name) this.name = data.name;
                this.weightM = data.weightM;
                this.speed = data.speed;
                this.killScore = data.killScore;
                this.turnSpeed = data.turnSpeed;
                this.scale = data.scale;
                this.maxHealth = data.health;
                this.leapForce = data.leapForce;
                this.health = this.maxHealth;
                this.chargePlayer = data.chargePlayer;
                this.viewRange = data.viewRange;
                this.drop = data.drop;
                this.dmg = data.dmg;
                this.hostile = data.hostile;
                this.dontRun = data.dontRun;
                this.hitRange = data.hitRange;
                this.hitDelay = data.hitDelay;
                this.hitScare = data.hitScare;
                this.spriteMlt = data.spriteMlt;
                this.nameScale = data.nameScale;
                this.colDmg = data.colDmg;
                this.noTrap = data.noTrap;
                this.spawnDelay = data.spawnDelay;
                this.hitWait = 0;
                this.waitCount = 1000;
                this.moveCount = 0;
                this.targetDir = 0;
                this.active = true;
                this.alive = true;
                this.runFrom = null;
                this.chargeTarget = null;
                this.dmgOverTime = {};
            };

            let tmpRatio = 0;
            let animIndex = 0;
            this.animate = function(delta) {
                if (this.animTime > 0) {
                    this.animTime -= delta;
                    if (this.animTime <= 0) {
                        this.animTime = 0;
                        this.dirPlus = 0;
                        tmpRatio = 0;
                        animIndex = 0;
                    } else {
                        if (animIndex == 0) {
                            tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                            this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                            if (tmpRatio >= 1) {
                                tmpRatio = 1;
                                animIndex = 1;
                            }
                        } else {
                            tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                            this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                        }
                    }
                }
            };

            this.startAnim = function() {
                this.animTime = this.animSpeed = 600;
                this.targetAngle = Math.PI * 0.8;
                tmpRatio = 0;
                animIndex = 0;
            };

        };

    };

    class Player {
        constructor(id, sid, config, UTILS, projectileManager, objectManager, players, ais, items, hats, accessories, server, scoreCallback, iconCallback) {
            this.id = id;
            this.sid = sid;
            this.tmpScore = 0;
            this.team = null;
            this.latestSkin = 0;
            this.oldSkinIndex = 0;
            this.skinIndex = 0;
            this.latestTail = 0;
            this.oldTailIndex = 0;
            this.tailIndex = 0;
            this.hitTime = 0;
            this.lastHit = 0;
            this.showName = 'NOOO';
            this.tails = {};

            for (let i = 0; i < accessories.length; ++i) {
                if (accessories[i].price <= 0) this.tails[accessories[i].id] = 1;
            }
            this.skins = {};
            for (let i = 0; i < hats.length; ++i) {
                if (hats[i].price <= 0) this.skins[hats[i].id] = 1;
            }

            this.points = 0;
            this.dt = 0;
            this.hidden = false;
            this.itemCounts = {};
            this.isPlayer = true;
            this.pps = 0;
            this.moveDir = undefined;
            this.moveTime = 0;
            this.skinRot = 0;
            this.lastPing = 0;
            this.iconIndex = 0;
            this.trapClear = false;
            this.skinColor = 0;
            this.dist2 = 0;
            this.aim2 = 0;
            this.maxSpeed = 1;
            this.backupNobull = true;
            this.spawn = function(moofoll) {
                this.attacked = false;
                this.timeDamaged = 0;
                this.timeHealed = 0;
                this.pinge = 0;
                this.millPlace = 'NOOO';
                this.lastshamecount = 0;
                this.death = false;
                this.spinDir = 0;
                this.sync = false;
                this.antiBull = 0;
                this.bullTimer = 0;
                this.poisonTimer = 0;
                this.active = true;
                this.alive = true;
                this.lockMove = false;
                this.lockDir = false;
                this.minimapCounter = 0;
                this.chatCountdown = 0;
                this.shameCount = 0;
                this.shameTimer = 0;
                this.sentTo = {};
                this.gathering = 0;
                this.gatherIndex = 0;
                this.lastGather = 0;
                this.shooting = {};
                this.shootIndex = 9;
                this.autoGather = 0;
                this.animTime = 0;
                this.animSpeed = 0;
                this.mouseState = 0;
                this.buildIndex = -1;
                this.weaponIndex = 0;
                this.weaponCode = 0;
                this.weaponVariant = 0;
                this.weaponIndex = 0;
                this.primaryIndex = undefined;
                this.secondaryIndex = undefined;
                this.dmgOverTime = {};
                this.noMovTimer = 0;
                this.maxXP = 300;
                this.XP = 0;
                this.age = 1;
                this.kills = 0;
                this.upgrAge = 2;
                this.upgradePoints = 0;
                this.x = 0;
                this.y = 0;
                this.oldXY = {
                    x: 0,
                    y: 0
                };
                this.zIndex = 0;
                this.xVel = 0;
                this.yVel = 0;
                this.slowMult = 1;
                this.dir = 0;
                this.dirPlus = 0;
                this.targetDir = 0;
                this.targetAngle = 0;
                this.maxHealth = 100;
                this.health = this.maxHealth;
                this.oldHealth = this.maxHealth;
                this.damaged = 0;
                this.scale = config.playerScale;
                this.speed = config.playerSpeed;
                this.resetMoveDir();
                this.resetResources(moofoll);
                this.items = [0, 3, 6, 10];
                this.weapons = [0];
                this.shootCount = 0;
                this.weaponXP = [];
                this.reloads = {
                    0: 0,
                    1: 0,
                    2: 0,
                    3: 0,
                    4: 0,
                    5: 0,
                    6: 0,
                    7: 0,
                    8: 0,
                    9: 0,
                    10: 0,
                    11: 0,
                    12: 0,
                    13: 0,
                    14: 0,
                    15: 0,
                    53: 0,
                };
                this.bowThreat = {
                    9: 0,
                    12: 0,
                    13: 0,
                    15: 0,
                };
                this.damageThreat = 0;
                this.inTrap = false;
                this.canEmpAnti = false;
                this.empAnti = false;
                this.soldierAnti = false;
                this.poisonTick = 0;
                this.bullTick = 0;
                this.setPoisonTick = false;
                this.setBullTick = false;
                this.antiTimer = 2;
            };

            this.resetMoveDir = function() {
                this.moveDir = undefined;
            };

            this.resetResources = function(moofoll) {
                for (let i = 0; i < config.resourceTypes.length; ++i) {
                    this[config.resourceTypes[i]] = moofoll ? 100 : 0;
                }
            };

            this.getItemType = function(id) {
                let findindx = this.items.findIndex((ids) => ids == id);
                if (findindx != -1) {
                    return findindx;
                } else {
                    return items.checkItem.index(id, this.items);
                }
            };

            this.setData = function(data) {
                this.id = data[0];
                this.sid = data[1];
                this.name = data[2];
                this.x = data[3];
                this.y = data[4];
                this.dir = data[5];
                this.health = data[6];
                this.maxHealth = data[7];
                this.scale = data[8];
                this.skinColor = data[9];
            };

            this.updateTimer = function() {

                this.bullTimer -= 1;
                if (this.bullTimer <= 0) {
                    this.setBullTick = false;
                    this.bullTick = game.tick - 1;
                    this.bullTimer = config.serverUpdateRate;
                }
                this.poisonTimer -= 1;
                if (this.poisonTimer <= 0) {
                    this.setPoisonTick = false;
                    this.poisonTick = game.tick - 1;
                    this.poisonTimer = config.serverUpdateRate;
                }

            };
            this.update = function(delta) {
                if (this.active) {

                    let gear = {
                        skin: findID(hats, this.skinIndex),
                        tail: findID(accessories, this.tailIndex)
                    }
                    let spdMult = ((this.buildIndex >= 0) ? 0.5 : 1) * (items.weapons[this.weaponIndex].spdMult || 1) * (gear.skin ? (gear.skin.spdMult || 1) : 1) * (gear.tail ? (gear.tail.spdMult || 1) : 1) * (this.y <= config.snowBiomeTop ? ((gear.skin && gear.skin.coldM) ? 1 : config.snowSpeed) : 1) * this.slowMult;
                    this.maxSpeed = spdMult;

                }
            };

            let tmpRatio = 0;
            let animIndex = 0;
            let crazyFactor = 4;
            let waveAmplitude = Math.PI / -7;

            this.animate = function(delta) {
                if (this.animTime > 0) {
                    this.animTime -= delta * 1.8; // 1.7'den 1.8'e kardm - daha hzl animasyon
                    if (this.animTime <= 0) {
                        this.animTime = 0;
                        this.dirPlus = 0;
                        tmpRatio = 0;
                        animIndex = 0;
                    } else {
                        if (animIndex == 0) {
                            // lk yar animasyon
                            tmpRatio += delta / (this.animSpeed * (config.hitReturnRatio * 0.55)); // 0.6'dan 0.55'e drdm
                            this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                            if (tmpRatio >= 1) {
                                tmpRatio = 1;
                                animIndex = 1;
                            }
                        } else {
                            // kinci yar animasyon - geri dn
                            tmpRatio -= delta / (this.animSpeed * ((1 - config.hitReturnRatio) * 0.55)); // 0.6'dan 0.55'e drdm
                            this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                        }
                    }
                }
            };

            this.startAnim = function(didHit, index) {
                this.animTime = this.animSpeed = items.weapons[index].speed * 1.8;
                this.targetAngle = (didHit ? -config.hitAngle : -Math.PI);
                tmpRatio = 0;
                animIndex = 0;
            };

            this.canSee = function(other) {
                if (!other) return false;
                let dx = Math.abs(other.x - this.x) - other.scale;
                let dy = Math.abs(other.y - this.y) - other.scale;
                return dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3;
            };

            this.judgeShame = function() {
                this.lastshamecount = this.shameCount;
                if (this.oldHealth < this.health) {
                    if (this.hitTime) {
                        let timeSinceHit = Date.now() - this.hitTime;
                        this.hitTime = 0;
                        if (timeSinceHit < 120) {
                            this.shameCount++;
                        } else {
                            this.shameCount = Math.max(0, this.shameCount - 2);
                        }
                    }
                } else if (this.oldHealth > this.health) {
                    this.hitTime = Date.now();
                    this.lastHit = Date.now();
                }
            };
            this.addShameTimer = function() {
                this.shameCount = 0;
                this.shameTimer = 30;
                let interval = setInterval(() => {
                    this.shameTimer--;
                    if (this.shameTimer <= 0) {
                        clearInterval(interval);
                    }
                }, 1000);
            };

            this.isTeam = function(tmpObj) {
                return (this == tmpObj || (this.team && this.team == tmpObj.team));
            };

            this.findAllianceBySid = function(sid) {
                return this.team ? alliancePlayers.find((THIS) => THIS === sid) : null;
            };
            this.checkCanInsta = function(nobull) {
                let totally = 0;
                if (this.alive && inGame) {
                    let primary = {
                        weapon: this.weapons[0],
                        variant: this.primaryVariant,
                        dmg: this.weapons[0] == undefined ? 0 : items.weapons[this.weapons[0]].dmg,
                    };
                    let secondary = {
                        weapon: this.weapons[1],
                        variant: this.secondaryVariant,
                        dmg: this.weapons[1] == undefined ? 0 : items.weapons[this.weapons[1]].Pdmg,
                    };
                    let bull = this.skins[7] && !nobull ? 1.5 : 1;
                    let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1;
                    if (primary.weapon != undefined && this.reloads[primary.weapon] == 0) {
                        totally += primary.dmg * pV * bull;
                    }
                    if (secondary.weapon != undefined && this.reloads[secondary.weapon] == 0) {
                        totally += secondary.dmg;
                    }
                    if (this.skins[53] && this.reloads[53] <= (player.weapons[1] == 10 ? 0 : game.tickRate) && near.skinIndex != 22) {
                        totally += 25;
                    }
                    totally *= near.skinIndex == 6 ? 0.75 : 1;
                    return totally;
                }
                return 0;
            };

            this.manageReload = function() {
                if (this.shooting[53]) {
                    this.shooting[53] = 0;
                    this.reloads[53] = (2500 - game.tickRate);
                } else {
                    if (this.reloads[53] > 0) {
                        this.reloads[53] = Math.max(0, this.reloads[53] - game.tickRate);
                    }
                }

                if (this.reloads[this.weaponIndex] <= 1000 / 9) {
                    let index = this.weaponIndex;
                    let nearObja = closeObjects.filter((e) => (e.active || e.alive) && e.health < e.maxHealth && e.group !== undefined && UTILS.getDist(e, player, 0, 2) <= (items.weapons[player.weaponIndex].range + e.scale));
                    for (let i = 0; i < nearObja.length; i++) {
                        let aaa = nearObja[i];

                        let val = items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1) * 3.3;
                        let valaa = items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1);
                        if (aaa.health - (valaa) <= 0 && near.length) {
                            place(near.dist2 < ((near.scale * 1.8) + 50) ? 4 : 2, caf(aaa, player) + Math.PI);
                        }
                    }
                }

                if (this.gathering || this.shooting[1]) {
                    if (this.gathering) {
                        this.gathering = 0;
                        this.reloads[this.gatherIndex] = (items.weapons[this.gatherIndex].speed * (this.skinIndex == 20 ? 0.78 : 1));
                        this.attacked = true;
                    }
                    if (this.shooting[1]) {
                        this.shooting[1] = 0;
                        this.reloads[this.shootIndex] = (items.weapons[this.shootIndex].speed * (this.skinIndex == 20 ? 0.78 : 1));
                        this.attacked = true;
                    }
                } else {
                    this.attacked = false;
                    if (this.buildIndex < 0) {
                        if (this.reloads[this.weaponIndex] > 0) {
                            this.reloads[this.weaponIndex] = Math.max(0, this.reloads[this.weaponIndex] - 110);
                            if (this.reloads[this.primaryIndex] == 0 && this.reloads[this.weaponIndex] == 0) {
                                this.antiBull++;
                                game.tickBase(() => {
                                    this.antiBull = 0;
                                }, 1);
                            }
                        }
                    }
                }
            };
            this.addDamageThreat = function(tmpObj) {
                const defaultPrimaryDmg = 45;
                const defaultSecondaryDmg = 35;
                const bullMultiplier = 1.5;
                const defaultVariantVal = 1.18;
                const skinIndexPenalty = 0.75;
                const closeRangeThreshold = 300;
                const additionalThreatReloadTickRate = game.tickRate;
                const additionalThreatValue = 25;

                let {
                    primaryIndex,
                    primaryVariant,
                    secondaryIndex,
                    secondaryVariant,
                    reloads,
                    dist2
                } = this;
                let {
                    weapons
                } = items;
                let {
                    weaponVariants
                } = config;

                let primary = {
                    weapon: primaryIndex,
                    variant: primaryVariant,
                    dmg: primaryIndex === undefined ? defaultPrimaryDmg : weapons[primaryIndex].dmg
                };

                let secondary = {
                    weapon: secondaryIndex,
                    variant: secondaryVariant,
                    dmg: secondaryIndex === undefined ? defaultSecondaryDmg : weapons[secondaryIndex].Pdmg
                };

                let primaryVariantValue = primary.variant !== undefined ? weaponVariants[primary.variant].val : defaultVariantVal;
                let secondaryVariantValue = secondary.variant !== undefined && ![9, 12, 17, 15].includes(secondary.weapon) ? weaponVariants[secondary.variant].val : defaultVariantVal;

                let damageThreat = 0;

                if (primary.weapon === undefined || reloads[primary.weapon] === 0) {
                    damageThreat += primary.dmg * primaryVariantValue * bullMultiplier;
                }

                if (secondary.weapon === undefined || reloads[secondary.weapon] === 0) {
                    damageThreat += secondary.dmg * secondaryVariantValue;
                }

                if (reloads[53] <= additionalThreatReloadTickRate) {
                    damageThreat += additionalThreatValue;
                }

                damageThreat *= tmpObj.skinIndex === 6 ? skinIndexPenalty : 1;

                if (!this.isTeam(tmpObj) && dist2 <= closeRangeThreshold) {
                    tmpObj.damageThreat += damageThreat;
                }
            };
            this.addDamageProbability = function(tmpObj) {
                let primary = {
                    weapon: this.primaryIndex,
                    variant: this.primaryVariant
                };
                primary.dmg = primary.weapon == undefined ? 45 : items.weapons[primary.weapon].dmg;
                let secondary = {
                    weapon: this.secondaryIndex,
                    variant: this.secondaryVariant
                };
                secondary.dmg = secondary.weapon == undefined ? 50 : items.weapons[secondary.weapon].Pdmg;
                let bull = 1.5;
                let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1.18;
                let sV = secondary.variant != undefined ? [9, 12, 17, 15].includes(secondary.weapon) ? 1 : config.weaponVariants[secondary.variant].val : 1.18;
                if (primary.weapon == undefined ? true : this.reloads[primary.weapon] == 0) {
                    this.damageProbably += primary.dmg * pV * bull * 0.75;
                }
                if (secondary.weapon == undefined ? true : this.reloads[secondary.weapon] == 0) {
                    this.damageProbably += secondary.dmg * sV;
                }
                this.damageProbably *= 0.75;
                if (!this.isTeam(tmpObj)) {
                    if (this.dist2 <= 300) {
                        tmpObj.damageProbably += this.damageProbably;
                    }
                }
            };
        }
    };


    function easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    }

    function sendUpgrade(index) {
        player.reloads[index] = 0;
        packet("H", index);
    }

    function storeEquip(id, index) {
        packet("c", 0, id, index);
    }

    function storeBuy(id, index) {
        packet("c", 1, id, index);
    }

    function buyEquip(id, index) {
        let nID = player.skins[6] ? 6 : 0;
        if (player.alive && inGame) {
            if (index == 0) {
                if (player.skins[id]) {
                    if (player.latestSkin != id) {
                        packet("c", 0, id, 0);
                    }
                } else {
                    if (autoBuying) {
                        let find = findID(hats, id);
                        if (find) {
                            if (player.points >= find.price) {
                                packet("c", 1, id, 0);
                                packet("c", 0, id, 0);
                            } else {
                                if (player.latestSkin != nID) {
                                    packet("c", 0, nID, 0);
                                }
                            }
                        } else {
                            if (player.latestSkin != nID) {
                                packet("c", 0, nID, 0);
                            }
                        }
                    } else {
                        if (player.latestSkin != nID) {
                            packet("c", 0, nID, 0);
                        }
                    }
                }
            } else if (index == 1) {
                if (player.tails[id]) {
                    if (player.latestTail != id) {
                        packet("c", 0, id, 1);
                    }
                } else {
                    if (autoBuying) {
                        let find = findID(accessories, id);
                        if (find) {
                            if (player.points >= find.price) {
                                packet("c", 1, id, 1);
                                packet("c", 0, id, 1);
                            } else {
                                if (player.latestTail != 0) {
                                    packet("c", 0, 0, 1);
                                }
                            }
                        } else {
                            if (player.latestTail != 0) {
                                packet("c", 0, 0, 1);
                            }
                        }
                    } else {
                        if (player.latestTail != 0) {
                            packet("c", 0, 0, 1);
                        }
                    }
                }
            }
        }
    }

    function selectToBuild(index, wpn) {
        packet("z", index, wpn);
    }

    function selectWeapon(index, isPlace) {
        if (!isPlace) {
            player.weaponCode = index;
        }
        packet("z", index, 1);
    }

    function sendAutoGather() {
        packet("K", 1, 1);
    }

    function sendAtck(id, angle) {
        packet("F", id, angle, 1);
    }

    function getLimited(item) {
        let group = item.group;
        let limit = config.isSandbox ? (group.sandboxLimit || 99) : group.limit;

        return player.itemCounts[group.id] == undefined ? true : player.itemCounts[group.id] < limit;
    }

    let evil = true;

    function place(id, rad, rmd) {
        if (!my.noAim || id == 0) {
            try {
                let wall = id == 2 && !evil ? 1 : id;
                if (wall == undefined) return;
                let item = items.list[player.items[wall]];
                let tmpS = 35 + item.scale + (item.placeOffset || 0);
                let tmpX = player.x2 + tmpS * Math.cos(rad);
                let tmpY = player.y2 + tmpS * Math.sin(rad);

                let limited = getLimited(item);
                if (player.alive && inGame && (wall == 0 || limited)) {
                    selectToBuild(player.items[wall]);
                    sendAtck(1, rad);
                    selectWeapon(player.weaponCode, 1);
                }
            } catch (e) {
                console.error(e);
            }
        }
    }

    function checkPlace(id, rad) {
        try {
            let wall = id == 2 && !evil ? 1 : id;
            if (wall == undefined) return;
            let item = items.list[player.items[wall]];
            let tmpS = 35 + item.scale + (item.placeOffset || 0);
            let tmpX = player.x2 + tmpS * Math.cos(rad);
            let tmpY = player.y2 + tmpS * Math.sin(rad);
            if (
                objectManager.checkItemLocation(
                    tmpX,
                    tmpY,
                    item.scale,
                    0.6,
                    item.id,
                    false,
                    player
                )
            ) {
                place(wall, rad, 1);
            }
        } catch (e) {}
    }

    function checkCanPlace(id, rad) {
        try {
            let wall = id == 2 && !evil ? 1 : id;
            if (wall == undefined) return false;
            let item = items.list[player.items[wall]];
            let tmpS = 35 + item.scale + (item.placeOffset || 0);
            let tmpX = player.x2 + tmpS * Math.cos(rad);
            let tmpY = player.y2 + tmpS * Math.sin(rad);
            if (
                objectManager.checkItemLocation(
                    tmpX,
                    tmpY,
                    item.scale,
                    0.6,
                    item.id,
                    false,
                    player
                )
            ) {
                return true;
            } else {
                return false;
            }
        } catch (e) {}
    }

    function checkBlockingItem(id, rad) {
        try {
            let wall = id == 2 && !evil ? 1 : id;
            if (wall == undefined) return false;
            let item = items.list[player.items[wall]];
            let tmpS = 35 + item.scale + (item.placeOffset || 0);
            let tmpX = player.x2 + tmpS * Math.cos(rad);
            let tmpY = player.y2 + tmpS * Math.sin(rad);
            return objectManager.checkBlockingItem(
                tmpX,
                tmpY,
                item.scale,
                0.6,
                item.id,
                false,
                player
            );
        } catch (e) {}
    }

    function checkCanPrePlace(id, rad, obj) {
        try {
            let wall = id == 2 && !evil ? 1 : id;
            if (wall == undefined) return false;
            let item = items.list[player.items[wall]];
            let tmpS = 35 + item.scale + (item.placeOffset || 0);
            let tmpX = player.x2 + tmpS * Math.cos(rad);
            let tmpY = player.y2 + tmpS * Math.sin(rad);
            if (
                objectManager.checkItemLocationPrePlace(
                    tmpX,
                    tmpY,
                    item.scale,
                    0.6,
                    item.id,
                    false,
                    player,
                    obj
                )
            ) {
                return true;
            } else {
                return false;
            }
        } catch (e) {}
    }
    let ticks = {
        tick: 0,
        delay: 0,
        time: [],
        manage: [],
    };

    function isTeam(tmpObj) {
        return (tmpObj == player || (tmpObj.team && tmpObj.team == player.team));
    }

    function getDamageThreat(tmpObj) {
        tmpObj.instaThreat = 0;
        if (isTeam(tmpObj)) {
            let primary = {
                weapon: tmpObj.primaryIndex,
                variant: tmpObj.primaryVariant,
                dmg: tmpObj.primaryIndex == undefined ? 45 : items.weapons[tmpObj.primaryIndex].dmg,
            };
            let secondary = {
                weapon: tmpObj.secondaryIndex,
                variant: tmpObj.secondaryVariant,
                dmg: tmpObj.secondaryIndex == undefined ? 50 : items.weapons[tmpObj.secondaryIndex].Pdmg,
            };
            let bull = tmpObj.skinIndex == 7 ? 1.5 : 1;
            let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1.18;
            if (primary.weapon != undefined && tmpObj.reloads[primary.weapon] == 0) {
                tmpObj.instaThreat += primary.dmg * pV * bull;
            }
            if (secondary.weapon != undefined && tmpObj.reloads[secondary.weapon] == 0) {
                tmpObj.instaThreat += secondary.dmg;
            }
            if (tmpObj.reloads[53] === 0) {
                tmpObj.instaThreat += 25;
            }
            tmpObj.instaThreat *= player.skinIndex == 6 ? 0.75 : 1;
        }
    }
    let bestMonkeys = 0;

    function updateHealth(sid, value) {
        let tmpObj = findPlayerBySID(sid);
        if (!tmpObj) return;

        tmpObj.oldHealth = tmpObj.health;
        tmpObj.health = value;
        tmpObj.judgeShame();

        if (tmpObj.oldHealth > value) { // Hasar alndnda
            tmpObj.timeDamaged = Date.now();

            if (tmpObj === player) {
                const damageTaken = tmpObj.oldHealth - value;
                const healthPercent = player.health;
                const pingDelay = Math.max(0, 120 - window.pingTime);

                // Temel heal fonksiyonu
                const doHeal = (times, delay) => {
                    setTimeout(() => {
                        for (let i = 0; i < times; i++) {
                            place(0, getAttackDir());
                        }
                    }, delay);
                };

                // Hasar miktar bazl heal
                if (damageTaken >= 45) { // Kritik hasar
                    if (tmpObj.shameCount < 3) {
                        // Instant oklu heal
                        for (let i = 0; i < 4; i++) {
                            place(0, getAttackDir());
                        }
                        // Ping bazl gecikmeli heal
                        doHeal(3, pingDelay);
                    } else {
                        // Shame yksekse daha kontroll heal
                        doHeal(3, pingDelay);
                        doHeal(2, pingDelay * 2);
                    }
                } else if (damageTaken >= 25) { // Orta hasar
                    if (tmpObj.shameCount < 4) {
                        // Instant double heal
                        place(0, getAttackDir());
                        place(0, getAttackDir());
                        // Gecikmeli heal
                        doHeal(2, pingDelay);
                    } else {
                        doHeal(2, pingDelay);
                    }
                }

                // Can yzdesi bazl ek kontroller
                if (healthPercent < 35) { // ok dk can
                    if (tmpObj.shameCount < 5) {
                        doHeal(3, 0); // Instant l heal
                        doHeal(2, pingDelay); // Gecikmeli double
                    }
                } else if (healthPercent < 50) { // Dk can
                    if (tmpObj.shameCount < 4) {
                        doHeal(2, 0);
                        doHeal(1, pingDelay);
                    }
                }

                // Enemy yaknlk kontrol
                if (near && near.dist2 <= 300) {
                    if (near.primaryIndex == 4 || near.primaryIndex == 5) { // Tehlikeli silahlar
                        doHeal(2, pingDelay / 2); // Daha hzl heal
                    }
                }

                // Extra gvenlik healleri
                if (healthPercent < 25 && tmpObj.shameCount < 3) {
                    setTimeout(() => {
                        place(0, getAttackDir());
                        place(0, getAttackDir());
                    }, pingDelay / 2);
                }
                var isAlly = function(id) {
                    for (let i = 0; i < alliancePlayers.length; i += 2) {
                        if (id == alliancePlayers[i]) {
                            return true;
                        }
                    }
                }

                function GetangleSpike(a, b) {
                    if (a == player) {
                        return Math.sqrt(Math.pow((b.y - a.y2), 2) + Math.pow((b.x - a.x2), 2));
                    } else if (b == player) {
                        return Math.sqrt(Math.pow((b.y2 - a.y), 2) + Math.pow((b.x2 - a.x), 2));
                    } else {
                        return Math.sqrt(Math.pow((b.y - a.y), 2) + Math.pow((b.x - a.x), 2));
                    }
                }
                let spikes = gameObjects.filter(obj => (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "spinning spikes" || obj.name == "poison spikes") && GetangleSpike(player, obj) < player.scale + obj.scale + 50 && !isAlly(obj.owner.sid) && obj.active)
                let direction = Math.atan2(player.y2 - near.y2, player.x2 - near.x2)
                let newPos = {
                    x: player.x + Math.cos(direction) * 35,
                    y: player.y2 + Math.sin(direction) * 35,
                }
                if (GetangleSpike(spikes, player) <= 200 && near.dist2 <= 250) {
                    if (near.reloads[near.primaryIndex] || near.reloads[near.secondaryIndex] && near.reloads[53] == 0 && items.weapons[near.secondaryIndex == 10 || near.secondaryIndex]) {
                        for (let i = 0; i < spikes.length; i++) {
                            if (GetangleSpike(spikes[i], newPos) < player.scale + spikes[i].scale && (!my.inTrap || my.inTrap)) {
                                buyEquip(6, 0);
                                player.soldierAnti = true;
                            }
                        }
                    } else {
                        if (player.health <= 25 >= 90 && player.shameCount <= 5) {
                            setTimeout(healer(), 111)
                            buyEquip(6, 0);
                        } else {
                            setTimeout(healer(), 111)
                        }
                    }
                }
            }
        }
    }

    function heal() {
        // Eksik can miktarn %20 artrarak daha fazla heal sinyali gnderiyoruz
        const enhancedHeals = Math.ceil(((100 - player.health) * 1.31) / items.list[player.items[0]].healing);
        for (let i = 0; i < enhancedHeals; i++) {
            place(0, getAttackDir());
        }
    }

    function healer1() {
        place(0, getAttackDir());
        return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
    }

    function updateHealthImportants(sid, value) {
        let _ = findPlayerBySID(sid);
        if (!_) return;

        if (_) {
            _.oldHealth = _.health;
            _.health = value;
            _.judgeShame();
            if (_.oldHealth > _.health) {
                _.timeDamaged = Date.now();
                _.damaged = _.oldHealth - _.health;
                let damaged = _.damaged;
                _ = findPlayerBySID(sid);
                let bullTicked = false;
                if (_.health <= 0) {
                    if (!_.death) {
                        _.death = true;
                    }
                }
                if (_ == player) {
                    if (_.skinIndex == 7 && (damaged == 5 || (_.latestTail == 13 && damaged == 2))) {
                        if (my.reSync) {
                            my.reSync = false;
                            _.setBullTick = true;
                        }
                        bullTicked = true;
                    }
                    let antiinsta = true;
                    let antiinsta1 = false;


                    let EmpAnti = (player.empAnti);
                    let antiinsta3 = true;
                    let autoheal = false;
                    let antiinsta4 = true;
                    let healTimeout = 85;
                    let attackers = getAttacker(damaged);
                    let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg);
                    let includeSpikeDmgs = near.length ? !bullTicked && (gearDmgs.includes(damaged) && near[0].skinIndex == 11 && near[0].tailIndex == 21) : false;

                    function AutoHealBetaTest(timeout) {
                        if (EmpAnti) {
                            setTimeout(() => {
                                healer();
                            }, timeout);
                        };
                    };
                    if (attackers.length) {
                        let by = attackers.filter(tmp => {
                            if (tmp.dist2 <= (tmp.weaponIndex < 9 ? 300 : 700)) {
                                tmpDir = UTILS.getDirect(player, tmp, 2, 2);
                                if (UTILS.getAngleDist(tmpDir, tmp.d2) <= Math.PI) {
                                    return tmp;
                                }
                            }
                        });
                        if (healTimeout && player.dmg) {
                            if (healTimeout) {
                                healTimeout = (65 || 80);
                                if (by.length) {
                                    let maxDamage = includeSpikeDmgs ? 10 : 10;
                                    if (damaged > maxDamage && game.tick - _.antiTimer > 1) {
                                        _.canEmpAnti = true;
                                        _.antiTimer = game.tick;
                                        let shame = 4;
                                        if (_.shameCount < shame) {
                                            healer();
                                        } else {
                                            AutoHealBetaTest(healTimeout);
                                        }
                                    } else {
                                        AutoHealBetaTest(healTimeout);
                                    }
                                } else {
                                    AutoHealBetaTest(healTimeout);
                                }
                            };
                        };
                    };
                    if (inGame) {
                        let shame = _.weapons[0] == 4 ? 2 : 5;
                        let damageThreatCondition = damaged >= (includeSpikeDmgs ? 8 : 20) && _.damageThreat >= 20;
                        if (damageThreatCondition && antiinsta4 && (game.tick - _.antiTimer) > 1) {}
                        if (damageThreatCondition && autoheal) {
                            setTimeout(() => {
                                healer();
                            }, 120);
                        }
                        if (damageThreatCondition && antiinsta && _.primaryIndex !== "4" && (game.tick - _.antiTimer) > 1);
                        if (damaged >= 20 && player.skinIndex == 11 && player.shameCount <= 3) {
                            instaC.canCounter = true;
                        }
                        if (damaged >= 0 && damaged <= 66 && player.shameCount === 4 && _.primaryIndex !== "4") {
                            autoheal = true;
                            antiinsta = false;
                            antiinsta1 = false;
                            antiinsta4 = false;
                        } else if (player.shameCount !== 4) {
                            autoheal = false;
                            antiinsta = true;
                            antiinsta4 = true;
                        }
                        if (damaged <= 66 && player.shameCount === 3 && _.primaryIndex !== "4") {
                            antiinsta = false;
                        } else if (player.shameCount !== 3) {
                            antiinsta = true;
                        }
                        if (damaged <= 66 && player.shameCount === 4 && _.primaryIndex !== "4") {
                            antiinsta1 = true;
                        } else if (player.shameCount !== 4) {
                            antiinsta1 = false;
                        }
                        if (damaged <= 66 && player.skinIndex != 6 && enemy.weaponIndex === 4) {
                            game.tickBase(() => {
                                healer1();
                            }, 2);
                        }
                    };
                    let dmg = 100 - player.health;
                    if (damaged >= (includeSpikeDmgs ? 8 : 20) && _.damageThreat >= 20 && antiinsta4 && (game.tick - _.antiTimer) > 1) {
                        if (_.reloads[53] == 0 && _.reloads[_.weapons[1]] == 0) {
                            _.canEmpAnti = true;
                        } else {
                            player.soldierAnti = true;
                        }
                        _.antiTimer = game.tick;
                        let shame = _.weapons[0] == 4 ? 2 : 5;
                        if (_.shameCount < shame) {
                            healer();
                        } else {
                            game.tickBase(() => {
                                healer();
                            }, 2);
                        }
                        if (damaged >= (includeSpikeDmgs ? 8 : 20) && _.damageThreat >= 20 && autoheal) {
                            setTimeout(() => {
                                healer();
                            }, 120);
                        }
                        let dmg = 100 - player.health;
                        if (damaged >= (includeSpikeDmgs ? 8 : 20) && _.damageThreat >= 20 && antiinsta && _.primaryIndex !== "4" && (game.tick - _.antiTimer) > 1) {
                            if (_.reloads[53] == 0 && _.reloads[_.weapons[1]] == 0) {
                                _.canEmpAnti = true;
                            } else {
                                player.soldierAnti = true;
                            }
                            _.antiTimer = game.tick;
                            let shame = _.weapons[0] == 4 ? 2 : 5;
                            if (_.shameCount < shame) {
                                healer();
                            } else {
                                game.tickBase(() => {
                                    healer();
                                }, 2);
                            }
                        }
                        if (damaged >= 20 && player.skinIndex == 11 && player.shameCount <= 3) instaC.canCounter = true;
                    } else {
                        game.tickBase(() => {
                            healer();
                        }, 2);
                    }
                } else {
                    _.maxShameCount = Math.max(_.maxShameCount, _.shameCount);
                }
            } else if (!_.setPoisonTick && (_.damaged == 5 || (_.latestTail == 13 && _.damaged == 2))) {
                _.setPoisonTick = true;
            }
        }
    }

    function updateHealth2(sid, value) {
        let tmpObj = findPlayerBySID(sid);
        if (tmpObj) {
            tmpObj.oldHealth = tmpObj.health;
            tmpObj.health = value;
            tmpObj.judgeShame();

            if (tmpObj.oldHealth > tmpObj.health) {
                tmpObj.timeDamaged = Date.now();
                tmpObj.damaged = tmpObj.oldHealth - tmpObj.health;
                let damaged = tmpObj.damaged;

                if (tmpObj.health <= 0 && !tmpObj.death) {
                    tmpObj.death = true;
                }

                if (tmpObj === player && autoHealing) {
                    handlePlayerDamage(tmpObj, damaged);
                } else {
                    handleNonPlayerDamage(tmpObj);
                }
            }
        }
    }

    function updateHealth3(sid, value) {
        let tmpObj = findPlayerBySID(sid);
        let secondary = {
            weapon: tmpObj.primaryIndex,
            variant: tmpObj.primaryVariant,
        };
        if (!tmpObj) return;

        let oldHealth = tmpObj.health;
        tmpObj.oldHealth = oldHealth;
        tmpObj.health = value;
        tmpObj.judgeShame();
        if (oldHealth > value) {
            tmpObj.timeDamaged = Date.now();
            if (tmpObj === near) {
                let damage = oldHealth - value;
                let shame = tmpObj.shameCount
                if (tmpObj.skinIndex === 7 && (damage === 5 || (tmpObj.latestTail === 13 && damage === 2))) {
                    tmpObj.bullTick = game.tick;
                }
            }
            tmpObj.damaged = oldHealth - value;
            advHeal.push([sid, value, tmpObj.damaged]);
        } else if (tmpObj !== player) {
            tmpObj.maxShameCount = Math.max(tmpObj.maxShameCount, tmpObj.shameCount);
        }
        if (nears.length && tmpObj.shameCount <= 5 && nears.some(items => [9, 12, 13, 15].includes(secondary.weapon))) {
            if (near.reloads[near.secondaryIndex] == 0) {}
        }
    }

    function handlePlayerDamage(player, damaged) {
        let bullTicked = false;
        let autoheal = false;
        let antiinsta = true,
            antiinsta1 = true,
            antiinsta4 = true;

        if (inGame) {
            let attackers = getAttacker(damaged);
            let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg);
            let includeSpikeDmgs = near.length ? !bullTicked && (gearDmgs.includes(damaged) && near[0].skinIndex == 11 && near[0].tailIndex == 21) : false;
            let healTimeout = 140 - window.ping;

            if (damaged >= 0 && damaged <= 66 && player.shameCount === 4 && player.primaryIndex !== "4") {
                autoheal = true;
                antiinsta = false;
                antiinsta1 = false;
                antiinsta4 = false;
            } else {
                if (player.shameCount !== 4) {
                    autoheal = false;
                    antiinsta = true;
                    antiinsta4 = true;
                }
            }

            if (damaged <= 66 && player.shameCount === 3 && player.primaryIndex !== "4") {
                antiinsta = false;
            } else {
                if (player.shameCount !== 3) {
                    antiinsta = true;
                }
            }

            if (damaged <= 66 && player.shameCount === 4 && player.primaryIndex !== "4") {
                antiinsta1 = true;
            } else {
                if (player.shameCount !== 4) {
                    antiinsta1 = false;
                }
            }

            if (damaged >= 0 && damaged <= 90 && player.shameCount === 2) {
                antiinsta4 = false;
            } else {
                if (player.shameCount !== 3) {
                    antiinsta4 = true;
                }
            }

            if (damaged >= 0 && damaged <= 90 && !antiinsta) {
                if (player.shameCount === 3) {
                    antiinsta1 = true;
                } else {
                    antiinsta1 = false;
                }
            }

            if (damaged <= 66 && player.skinIndex != 6 && enemy.weaponIndex === 4) {
                game.tickBase(() => {
                    healer1();
                }, 2);
            }

            if (damaged >= (includeSpikeDmgs ? 8 : 20) && player.damageThreat >= 20 && antiinsta4 && (game.tick - player.antiTimer) > 1) {
                if (player.reloads[53] == 0 && player.reloads[player.weapons[1]] == 0) {
                    player.canEmpAnti = true;
                } else {
                    player.soldierAnti = true;
                }
                player.antiTimer = game.tick;
                let shame = player.weapons[0] == 4 ? 2 : 5;
                if (player.shameCount < shame) {
                    healer();
                } else {
                    game.tickBase(() => {
                        healer();
                    }, 2);
                }
                if (damaged >= (includeSpikeDmgs ? 8 : 20) && player.damageThreat >= 20 && autoheal) {
                    setTimeout(() => {
                        healer();
                    }, 120);
                }
            } else {
                game.tickBase(() => {
                    healer();
                }, 2);
            }

            if (damaged >= 20 && player.skinIndex == 11 && player.shameCount <= 3) {
                instaC.canCounter = true;
            }
        }
    }

    function handleNonPlayerDamage(tmpObj) {
        if (!tmpObj.setPoisonTick && (tmpObj.damaged == 5 || (tmpObj.latestTail == 13 && tmpObj.damaged == 2))) {
            tmpObj.setPoisonTick = true;
        }
    }

    function setTickout(doo, timeout) {
        if (!ticks.manage[ticks.tick + timeout]) {
            ticks.manage[ticks.tick + timeout] = [doo];
        } else {
            ticks.manage[ticks.tick + timeout].push(doo);
        }
    }
    let doEmpAntiInsta = false;
    let judgeAtNextTick = false;

    function soldierMult() {
        return player.latestSkin == 6 ? 0.75 : 1;
    }

    function getAttacker(damaged) {
        let attackers = enemy.filter(tmp => {
            let damages = new Damages(items);
            let dmg = damages.weapons[tmp.weaponIndex];
            let by = tmp.weaponIndex < 9 ? [dmg[0], dmg[1], dmg[2], dmg[3]] : [dmg[0], dmg[1]];
            let rule = {
                one: tmp.dist2 <= 300,
                two: by.includes(damaged),
                three: tmp.attacked
            }
            return rule.one && rule.two && rule.three;
        });
        return attackers;
    }

    function healer(extra = 0) {
        if (extra == 0) {
            for (let i = 0; i < healthBased(); i++) {
                place(0, getAttackDir());
            }
        } else {
            for (let i = 0; i < healthBased() + extra; i++) {
                place(0, getAttackDir());
            }
        }
    }

    function applCxC(value) {
        if (player.skinIndex != 45 && player.skinIndex != 56) {
            if (0 == player.items[0]) {
                if (value < -80) {
                    return 5;
                } else if (value < -60) {
                    return 4;
                } else if (value < -40) {
                    return 3;
                } else if (value < -20) {
                    return 2;
                } else {
                    return 1;
                }
            } else if (1 == player.items[0]) {
                if (value < -80) {
                    return 3;
                } else if (value < -40) {
                    return 2;
                } else {
                    return 1;
                }
            } else if (2 == player.items[0]) {
                if (value < -90) {
                    return 4;
                } else if (value < -60) {
                    return 3;
                } else if (value < -30) {
                    return 2;
                } else {
                    return 1;
                }
            } else {
                return 4;
            }
        } else {
            return 0;
        }
    }

    function healthBased() {
        if (player.health == 100) return 0;
        if (player.skinIndex != 45 && player.skinIndex != 56) {
            return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
        }
        return 0;
    }

    function calcDmg(value) {
        return value * player.skinIndex == 6 ? 0.75 : 1;
    }
    let predictDamage = 0;

    let stopHealing = false;

    function healIntrap(tmpObj, value) {
        var heal = function(amount, after) {
            setTickout(() => {
                for (let i = 0; i < applCxC(amount); i++) {
                    place(0, getAttackDir());
                }
            }, after);
        };
        if (enemy.length) {
            heal(value, 2);
        } else {
            heal(value, 3);
        }
    }
    let backupAnti = [];
    let hittedTime = Date.now();

    function autoHealer(tmpObj, value) {
        let pingHeal = function() {
            return Math.max(0, 175 - window.pingTime);
        };
        let antiInsta = false;
        let findAttacker = undefined;
        if (true) {
            if (near.dist2 <= 300) {
                if (value >= 20 && (Date.now() - hittedTime >= 180 || Date.now() - hittedTime <= 60)) {
                    if (tmpObj.shameCount < tmpObj.dangerShame) {
                        for (let i = 0; i < applCxC(value); i++) {
                            place(0, getAttackDir());
                            if (Date.now() - hittedTime >= 260) {
                                place(0, getAttackDir());
                            }
                        }
                        if (value >= 70) {
                            const heal = () => {
                                let times = player.items[0] === 1 ? 3 : 4;
                                for (let i = 0; i < times; i++) place(0, getAttackDir());
                            }
                            const slowHeal = () => {
                                setTimeout(() => {
                                    heal();
                                }, pingHeal())
                            }
                            slowHeal();
                        }
                    } else {
                        setTickout(() => {
                            for (let i = 0; i < applCxC(value); i++) {
                                place(0, getAttackDir());
                            }
                        }, 2);
                    }
                } else {
                    if (traps.inTrap) {
                        healIntrap(tmpObj, value);
                    } else {
                        setTickout(() => {
                            for (let i = 0; i < applCxC(value); i++) {
                                place(0, getAttackDir());
                            }
                        }, 2);
                    }
                }
                if (player.skinIndex == 11) {
                    if (value >= 30) {
                        instaC.isCounter = true;
                    }
                }
                if (value >= 20) {
                    hittedTime = Date.now();
                    judgeAtNextTick = true;
                }
            } else {
                if (traps.inTrap) {
                    healIntrap(tmpObj, value);
                } else {
                    setTickout(() => {
                        for (let i = 0; i < applCxC(value); i++) {
                            place(0, getAttackDir());
                        }
                    }, 2);
                }
            }
        }
    }
    const Healing = () => new class {
        constructor() {
            this.enemy = near.dist2 <= items.weapons[near.weapons[0]].range;
            this.windowTickHeal = Math.max(10, (9 * 0.25) + window.pingTime);
            this.getHealDir = getAttackDir();
            this.shame = player.shameCount;
            this.msHeal = function() {
                if (window.pingTime >= 100) {
                    let healAnti = setInterval(() => {
                        if (this.shame < 5) {
                            place(0, this.getHealDir);
                        }
                    }, 20 * this.windowTickHeal);
                    setInterval(() => {
                        clearInterval(healAnti);
                        setInterval(() => {}, config.tickRate);
                    }, config.tickRate);
                } else {
                    if (window.pingTime >= 20) {
                        let healAnti = setInterval(() => {
                            if (this.shame < 5) {
                                place(0, this.getHealDir);
                            }
                        }, 75 * this.windowTickHeal);
                        setInterval(() => {
                            clearInterval(healAnti);
                            setInterval(() => {}, config.tickRate);
                        }, config.tickRate);
                    } else {
                        if (window.pingTime >= 40) {
                            let healAnti = setInterval(() => {
                                if (this.shame < 5) {
                                    place(0, this.getHealDir);
                                }
                            }, 65 * this.windowTickHeal);
                            setInterval(() => {
                                clearInterval(healAnti);
                                setInterval(() => {}, config.tickRate);
                            }, config.tickRate);
                        } else {
                            if (window.pingTime >= 60) {
                                let healAnti = setInterval(() => {
                                    if (this.shame < 5) {
                                        place(0, this.getHealDir);
                                    }
                                }, 50 * this.windowTickHeal);
                                setInterval(() => {
                                    clearInterval(healAnti);
                                    setInterval(() => {}, config.tickRate);
                                }, config.tickRate);
                            } else {
                                if (window.pingTime >= 80) {
                                    let healAnti = setInterval(() => {
                                        if (this.shame < 5) {
                                            place(0, this.getHealDir);
                                        }
                                    }, 35 * this.windowTickHeal);
                                    setInterval(() => {
                                        clearInterval(healAnti);
                                        setInterval(() => {}, config.tickRate);
                                    }, config.tickRate);
                                }
                            }
                        }
                    }
                }
            };
            this.inTrapHeal = function() {
                if (traps.inTrap && near.primaryIndex == 5 && near.secondaryIndex == 10 && near.primaryIndex == 4) {
                    if (this.enemy && traps.health <= 250) {
                        healer();
                        buyEquip(6, 0);
                        sendChat("x-anti");
                    } else if (traps.inTrap) {
                        if (traps.health <= 120 && player.syncThreat >= 2 && near.primaryIndex == 5 && near.primaryIndex == 4 && near.primaryIndex == 3 && near.secondaryIndex == 10 && near.secondaryIndex == 15 && near.secondaryIndex == 9 && near.secondaryIndex == 13 && near.secondaryIndex == 12) {
                            setInterval(() => {
                                if (this.shame <= 5) {
                                    place(0, this.getHealDir);
                                    buyEquip(6, 0);
                                }
                            }, 10 * this.windowTickHeal);
                        }
                    }
                }
            };
            this.Antisync = function() {
                let bullMultiPlier = 1.5;
                this.damage.threat = dmgpotwowwowow <= near.skin[7] * bullMultiPlier;
                if (this.damage.threat === 100 && player.syncThreat >= 2) {
                    setInterval(() => {
                        if (this.shame <= 5) {
                            place(0, this.getHealDir);
                            buyEquip(6, 0);
                        }
                    }, 5 * this.windowTickHeal);
                } else if (player.syncThreat >= 2 && near.reloads[near.primaryIndex] == 0) {
                    setInterval(() => {
                        if (this.shame <= 5) {
                            place(0, this.getHealDir);
                            buyEquip(6, 0);
                        }
                    }, 5 * this.windowTickHeal);
                }
            }
        };
    }

    function antiSyncHealing(timearg) {
        // Temel heal hzn artr (9 -> 10)
        let windowTickHeal = Math.max(10, (10 * 0.25) + window.pingTime);
        my.antiSync = true;
        Healing.AntiSync = true;

        // lk heal burst'
        for (let i = 0; i < 2; i++) {
            place(0, getAttackDir());
        }

        // Ana heal dngs
        let healAnti = setInterval(() => {
            if (player.shameCount < 5) {
                // Her tick'te 2 heal gnder
                place(0, getAttackDir());
                setTimeout(() => {
                    place(0, getAttackDir());
                }, 15); // 15ms gecikme ile ikinci heal
            }
        }, Healing.msHeal * windowTickHeal * 0.9); // Interval sresini %10 azalt

        // Temizleme ve sonlandrma
        setTimeout(() => {
            clearInterval(healAnti);
            // Son bir heal burst'
            for (let i = 0; i < 2; i++) {
                place(0, getAttackDir());
            }

            setTimeout(() => {
                my.antiSync = false;
                Healing.AntiSync = false;
            }, config.tickRate * 0.9); // Biraz daha hzl sonlandr
        }, config.tickRate * timearg);
    }
    function biomeGear(mover, returns) {
        if (
            player.y2 >= config.mapScale / 2 - config.riverWidth / 2 &&
            player.y2 <= config.mapScale / 2 + config.riverWidth / 2
        ) {
            if (returns) return 31;
            buyEquip(31, 0);
        } else if (bushHat) {
            if (returns) {
                return 10;
            }
            buyEquip(10, 0);
        } else {
            if (player.y2 <= config.snowBiomeTop) {
                if (returns) return enemy && near.primaryIndex == 5 && near.dist2 <= 400 ? hatLoop : 0;
                buyEquip(hatLoop ? loopHats[loopIndex++] : 15, 0);
            } else {
                if (returns) return enemy && near.primaryIndex == 5 && near.dist2 <= 400 ? hatLoop : 0;
                buyEquip(hatLoop ? loopHats[loopIndex++] : 12, 0);
            }
        }
        if (returns) return 0;
    }
    let advHeal = [];

    function sortWeaponVariant(id) {
        switch (id) {
            case 0:
                return 1;
                break;
            case 1:
                return 1.1;
                break;
            case 2:
                return 1.18;
                break;
            case 3:
                return 1.18;
                break;
            default:
                return 1;
                break;
        }
    }

    function sortSecondaryAmmoDamage(weapon) {
        switch (weapon) {
            case 10:
                return 10;
                break;
            case 15:
                return 50;
                break;
            case 9:
                return 25;
                break;
            case 12:
                return 35;
                break;
            case 13:
                return 30;
                break;
            default:
                return 0;
        }
    }

    function potdmg(tmpObj, t) {
        let d = t - tmpObj.health;
        if (d >= 100) {} else {
            if (player == tmpObj) {
                if (tmpObj.skinIndex == 7 && (Math.abs(d) == 5 || (tmpObj.latestTail == 13 && Math.abs(d) == 2))) {
                    tmpObj.bullTick = game.tick
                    if (my.reSync) {
                        my.reSync = false;
                    }
                }
                dmgpotwowwowow();
            }
        }
    }

    function dmgpotwowwowow() {
        let potential = DmgPotWorkfrfrfr();
        if (nears.length) {
            if (Math.round(player.health - potential <= 0)) {
                if ((player.health - (potential * player.skinIndex == 6 ? 0.75 : 1) >= 0)) {
                    game.tickBase(() => {
                        heal();
                    }, 2);
                } else {
                    if (player.shameCount < 5) {
                        heal();
                    } else {
                        game.tickBase(() => {
                            heal();
                        }, 2);
                    }
                }
            } else {
                game.tickBase(() => {
                    heal();
                }, 2);
            }
        } else {
            game.tickBase(() => {
                heal();
            }, 2);
        }
    }

    function DmgPotWorkfrfrfr() {
        let predictedDamage = 0;
        let weapon1Dmg, weapon2Dmg;
        let weapon1Reload, weapon2Reload;
        for (let i = 0; i < nears.length; i++) {
            let singleIndividual = nears[i];
            weapon1Dmg = items.weapons[singleIndividual.weapons[0]].dmg * sortWeaponVariant(singleIndividual.weaponVariant);
            weapon2Dmg = singleIndividual.weapons[1] == 10 ? items.weapons[singleIndividual.weapons[1]].dmg : items.weapons[singleIndividual.weapons[1]].Pdmg;
            weapon1Reload = singleIndividual.reloads[singleIndividual.weapons[0]] == 0;
            weapon2Reload = singleIndividual.reloads[singleIndividual.weapons[1]] == 0;
            if (singleIndividual.primaryIndex !== undefined) {
                predictedDamage += weapon1Reload ? weapon1Dmg * 1.5 : 0;
            } else {
                predictedDamage += 45;
            }
            if (singleIndividual.secondaryIndex !== undefined) {
                predictedDamage += weapon2Reload ? weapon2Dmg : 0;
            } else {
                predictedDamage += 50;
            }
            predictedDamage += singleIndividual.reloads[53] == 0 ? 25 : 0;
        }
    }
    let placedSpikePositions = new Set();
    let placedTrapPositions = new Set();

    const isPositionValid = (position) => {
        const playerX = player.x2;
        const playerY = player.y2;
        const distToPosition = Math.hypot(position[0] - playerX, position[1] - playerY);
        return distToPosition > 35;
    }

    const calculatePossibleTrapPositions = (x, y, radius) => {
        const trapPositions = [];
        const numPositions = 8;
        for (let i = 0; i < numPositions; i++) {
            const angle = (2 * Math.PI * i) / numPositions;
            const offsetX = x + radius * Math.cos(angle);
            const offsetY = y + radius * Math.sin(angle);
            const position = [offsetX, offsetY];
            if (!trapPositions.some((pos) => isPositionTooClose(position, pos))) {
                trapPositions.push(position);
            }
        }
        return trapPositions;
    }

    const isPositionTooClose = (position1, position2, minDistance = 50) => {
        const dist = Math.hypot(position1[0] - position2[0], position1[1] - position2[1]);
        return dist < minDistance;
    }

    class Traps {
        constructor(UTILS, items) {
            this.dist = 0;
            this.aim = 0;
            this.inTrap = false;
            this.replaced = false;
            this.antiTrapped = false;
            this.info = {};

            this.notFast = function() {
                return player.weapons[1] == 10 && ((this.info.health > items.weapons[player.weapons[0]].dmg) || player.weapons[0] == 5);
            };

            this.testCanPlace = function(
                id,
                first = -(Math.PI / 2),
                repeat = Math.PI / 2,
                plus = Math.PI / 18,
                radian,
                replacer
            ) {
                try {
                    let item = items.list[player.items[id]];
                    let tmpS = 35 + item.scale + (item.placeOffset || 0);
                    let tmpObjects = liztobj;
                    let placed = [];
                    let counts = {
                        attempts: 0,
                        placed: 0
                    };
                    let trapped = false;
                    for (let i = first; i < repeat; i += plus) {
                        let relAim = radian + i;
                        let tmpX = player.x + tmpS * Math.cos(relAim);
                        let tmpY = player.y + tmpS * Math.sin(relAim);
                        let cantPlace = tmpObjects.find(
                            (tmp) =>
                            tmp.active &&
                            UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) <
                            item.scale +
                            (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem))
                        );
                        if (cantPlace) continue;
                        if (
                            item.id != 18 &&
                            tmpY >= config.mapScale / 2 - config.riverWidth / 2 &&
                            tmpY <= config.mapScale / 2 + config.riverWidth / 2
                        ) continue;
                        if (!replacer) {
                            if (player.inTrap) {
                                if (trapped && near.dist2 >= 300) {
                                    checkPlace(2, relAim);
                                } else if (player.items[4] == 15) {
                                    checkPlace(4, relAim);
                                    trapped = true;
                                }
                            } else {
                                if (UTILS.getAngleDist(near.aim2, relAim) <= config.gatherAngle) {
                                    checkPlace(2, relAim);
                                } else {
                                    player.items[4] == 15 && checkPlace(4, relAim);
                                }
                            }
                        } else {
                            place(id, relAim);
                        }
                        tmpObjects.push({
                            x: tmpX,
                            y: tmpY,
                            active: true,
                            blocker: item.blocker,
                            scale: item.scale,
                            isItem: true,
                            type: null,
                            colDiv: item.colDiv,
                            getScale: function() {
                                return this.scale;
                            },
                        });
                        placed.push({
                            x: tmpX,
                            y: tmpY,
                            dmg: item.dmg,
                            active: true,
                            blocker: item.blocker,
                            scale: item.scale,
                            isItem: true,
                            type: null,
                            colDiv: item.colDiv,
                            getScale: function() {
                                return this.scale;
                            },
                        });
                    }
                    if (counts.placed > 0 && replacer && item.dmg) {
                        if (near.dist2 <= items.weapons[player.weapons[0]].range + (player.scale * 1.8) && zpyklerTick) {
                            instaC.canStackSpiketick = true;
                        }
                    }
                } catch (err) {}
            };
            this.checkZpyklerTick = function(anti = false) {
                try {
                    if (
                        (![3, 4, 5].includes(near.primaryIndex) &&
                            ![3, 4, 5].includes(near.primaryIndex)) ||
                        !near.trapClear
                    ) return false;
                    if (
                        my.autoPush ?
                        false :
                        near.primaryIndex == undefined ?
                        false :
                        near.reloads[near.primaryIndex] > game.tickRate
                    ) return false;
                    if (near.dist2 <= items.weapons[near.primaryIndex ?? 5].range + 63) {
                        let item = items.list[9];
                        let tmpS = 35 + item.scale + (item.placeOffset ?? 0);
                        let danger = 0;
                        let counts = {
                            attempts: 0,
                            block: `unblocked`,
                        };
                        for (let i = -1; i <= 1; i += 1 / 10) {
                            counts.attempts++;
                            let relAim = UTILS.getDirect(player, near, 2, 2) + i;
                            let tmpX = near.y + tmpS * Math.cos(relAim);
                            let tmpY = near.y + tmpS * Math.sin(relAim);
                            let spikeContact =
                                UTILS.getDistance(tmpX, tmpY, player.x2, player.y2) <=
                                item.scale + 40;
                            if (!spikeContact) continue;
                            let cantPlace = liztobj.find(
                                (tmp) =>
                                tmp.active &&
                                UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) <
                                item.scale +
                                (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem))
                            );
                            if (cantPlace) continue;
                            if (
                                tmpY >= config.mapScale / 2 - config.riverWidth / 2 &&
                                tmpY <= config.mapScale / 2 + config.riverWidth / 2
                            ) continue;
                            danger++;
                            counts.block = `blocked`;
                            break;
                        }
                        if (danger && anti) {
                            buyEquip(6, 0);
                            my.anti0Tick = 1;
                            player.chat.message = "Anti " + near.sid;
                            player.chat.count = 2000;
                            return true;
                        } else if (danger) {
                            return true;
                        }
                    }
                } catch (err) {
                    return null;
                }
                return false;
            };
            this.protect = function(aim) {
                if (player.items[2]) {
                    checkPlace(aim + (Math.PI * 1.25))
                    checkPlace(aim + (Math.PI * 0.75))
                }
                this.testCanPlace(
                    2,
                    -(Math.PI / 2),
                    Math.PI / 2,
                    Math.PI / 18,
                    aim + Math.PI
                );
                this.antiTrapped = true;
            };

            let perfSpikeAngle;
            let perfSpike;
            let placedOnPerfectAngle = false;
            this.autoPlace = function() {
                if (optionboostTick && !traps.inTrap && !near.inTrap) {
                    if (near.dist2 <= 115) {
                        checkPlace(2, near.aim2 + toRad(45));
                        checkPlace(2, near.aim2 - toRad(45));
                        instaC.canStackSpiketick = true;
                    }
                } else {
                    if (!boostspike && autoPlace && near && near.dist2) {
                        if (near.inTrap) {
                            near.trapDist = UTILS.getDist(near.inTrap, near, 0, 2);
                            near.trapAngle = UTILS.getDirect(near, near.inTrap, 2, 0);
                            if (near.trapDist >= 13) {
                                let item = items.list[player.items[evil ? 2 : 1]];
                                let s = 35 + item.scale + (item.placeOffset ?? 0);
                                if (near.dist2 <= 70 + item.scale * 2) {
                                    let angle = UTILS.getDirect(near, near.inTrap, 2, 0);
                                    let perfectPlace = {
                                        x: near.inTrap.x + Math.cos(angle) * (near.inTrap.getScale(0.6, false) / 2 + items.list[player.items[2]].scale),
                                        y: near.inTrap.y + Math.sin(angle) * (near.inTrap.getScale(0.6, false) / 2 + items.list[player.items[2]].scale)
                                    };
                                    perfSpikeAngle = UTILS.getDirect(perfectPlace, player, 0, 0);
                                    perfSpike = perfectPlace;
                                    let item2 = items.list[player.items[2]];
                                    let tmpS = 35 + item2.scale + (item2.placeOffset ?? 0);
                                    let tmpX = player.x2 + tmpS * Math.cos(perfSpikeAngle);
                                    let tmpY = player.y2 + tmpS * Math.sin(perfSpikeAngle);
                                    if (
                                        checkCanPlace(evil ? 2 : 1, perfSpikeAngle) &&
                                        UTILS.getDistance(tmpX, tmpY, near.x2, near.y2) < item2.scale + near.scale &&
                                        !placedOnPerfectAngle
                                    ) {
                                        checkPlace(evil ? 2 : 1, perfSpikeAngle);
                                        placedOnPerfectAngle = true;
                                    }
                                    for (
                                        let ayochilltfoutyo = -45; ayochilltfoutyo < 45; ayochilltfoutyo += Math.abs(ayochilltfoutyo) >= 35 ? 1 : 0.5
                                    ) {
                                        let randomAngle = perfSpikeAngle + UTILS.toRad(ayochilltfoutyo);
                                        if (
                                            checkCanPlace(evil ? 2 : 1, randomAngle) &&
                                            UTILS.getDistance(
                                                player.x2 + tmpS * Math.cos(randomAngle),
                                                player.y2 + tmpS * Math.sin(randomAngle),
                                                near.x2,
                                                near.y2
                                            ) < item2.scale + near.scale
                                        ) {
                                            checkPlace(evil ? 2 : 1, randomAngle);
                                            break;
                                        }
                                    }
                                } else {
                                    placedOnPerfectAngle = false;
                                    perfSpikeAngle = undefined;
                                }
                            } else {
                                placedOnPerfectAngle = false;
                                perfSpikeAngle = undefined;
                            }
                            // EKLEME 1: Eer trap iindeysek, 3 rastgele spike yerletir (bizim lokalimizde grnmez)
                            if (traps.inTrap) {
                                for (let i = 0; i < 3; i++) {
                                    let randomOffset = toRad(UTILS.randInt(-45, 45));
                                    checkPlace(2, near.aim2 + randomOffset);
                                }
                            }
                            if (!placedOnPerfectAngle) {
                                if (near.dist2 <= 270) {
                                    checkPlace(evil ? 2 : 1, UTILS.getDirect(near.inTrap, player, 0, 2) + Math.PI);
                                    if (
                                        !checkCanPlace(evil ? 2 : 1, UTILS.getDirect(near.inTrap, player, 0, 2) + Math.PI)
                                    ) {
                                        checkPlace(
                                            evil ? 2 : 1,
                                            UTILS.getDirect(near.inTrap, player, 0, 2) +
                                            Math.PI -
                                            ((Math.random() * Math.PI) / 8 + Math.PI / 8)
                                        );
                                        checkPlace(
                                            evil ? 2 : 1,
                                            UTILS.getDirect(near.inTrap, player, 0, 2) +
                                            Math.PI +
                                            ((Math.random() * Math.PI) / 8 + Math.PI / 8)
                                        );
                                    }
                                }
                            }
                        } else {
                            // near mesafesi <=80 iin bo brakyoruz
                            if (near.dist2 <= 80) {
                                // Handle closer distance
                            } else if (near.dist2 <= 150 && near.dist2 >= 80) {
                                checkPlace(2, near.aim2);
                            }

                            //new
                            perfSpikeAngle = undefined;
                            if (near.dist2 <= 100) {
                                for (let offset = -30; offset <= 30; offset += 30) {
                                    checkPlace(4, near.aim2 + toRad(offset));
                                }
                            } else if (near.dist2 <= 150 && near.dist2 >= 80) {
                                checkPlace(2, near.aim2);
                            }

                            // spike in trap: tuzak iindeyken 120 CPS checkPlace
                            if (enemy.length && enemy[0].inTrap) {
                                if (checkCanPlace(2, near.aim2 + Math.PI - toRad(45))) { // sol arka
                                    for (let i = 0; i < 120; i++) {
                                        checkPlace(2, near.aim2 + Math.PI - toRad(45));
                                    }
                                }
                                if (checkCanPlace(2, near.aim2 + Math.PI)) { // merkez arka
                                    for (let i = 0; i < 120; i++) {
                                        checkPlace(2, near.aim2 + Math.PI);
                                    }
                                }
                                if (checkCanPlace(2, near.aim2 + Math.PI + toRad(45))) { // sa arka
                                    for (let i = 0; i < 120; i++) {
                                        checkPlace(2, near.aim2 + Math.PI + toRad(45));
                                    }
                                }
                            }

                            // spiketick no insta: tuzak iindeyken 120 CPS checkPlace
                            if (traps.inTrap && enemy.length && enemy[0].inTrap && near.dist2 < 80) {
                                if (checkCanPlace(2, near.aim2)) {
                                    for (let i = 0; i < 120; i++) {
                                        checkPlace(2, near.aim2);
                                    }
                                }
                            }
                            // Mevcut kodun devam:
                            if (near.dist2 <= ((player.items[4] && player.items[4] == 16) ? 120 : 90) ||
                                near.dist3 <= ((player.items[4] && player.items[4] == 16) ? 110 : 85)
                            ) {
                                checkPlace(2, near.aim2 + Math.PI + Math.random * 0.2);
                                checkPlace(2, near.aim2 + Math.PI + Math.PI / 1.5 + Math.random * 0.2);
                                checkPlace(2, near.aim2 + Math.PI - Math.PI / 1.5);
                            } else if (near.dist2 <= 150 || near.dist3 <= 130) {
                                checkPlace(
                                    evil ? 2 : 1,
                                    near.aim2 + Math.PI / 1.5 + Math.random() - 0.5
                                );
                                checkPlace(
                                    evil ? 2 : 1,
                                    near.aim2 - Math.PI / 1.5 + Math.random() - 0.5
                                );
                            } else if (
                                near.dist2 <= 190 &&
                                player.items[4] &&
                                player.items[4] == 15
                            ) {
                                checkPlace(4, near.aim2 + Math.random() - 0.5);
                                checkPlace(4, near.aim2 + Math.PI / 1.5 + Math.random() - 0.5);
                                checkPlace(4, near.aim2 - Math.PI / 1.5 + Math.random() - 0.5);
                            } else if (
                                near.dist2 <= 250 &&
                                player.items[4] &&
                                player.items[4] == 15
                            ) {
                                checkPlace(4, near.aim2);
                            }
                        }
                    } else if (safeAutoPlace && !boostspike) {
                        if (
                            (safeAutoPlaceLegits ? near : near) &&
                            player.items[4] == 15
                        ) {
                            let tmpPlayer = safeAutoPlaceLegits ? near : near;
                            let item = items.list[15];
                            let tmp = {
                                x: undefined,
                                y: undefined
                            };
                            tmp.x = player.x2 + 40 * Math.cos(tmpPlayer.aim2);
                            tmp.y = player.y2 + 40 * Math.sin(tmpPlayer.aim2);
                            let trapScale = 10;
                            if (UTILS.getDist(tmp, tmpPlayer, 0, 2) <= 75) {
                                if (checkCanPlace(4, tmpPlayer.aim2)) {
                                    checkPlace(4, tmpPlayer.aim2);
                                } else {
                                    for (
                                        let ayochilltfoutyo = -30; ayochilltfoutyo < 30; ayochilltfoutyo += 2
                                    ) {
                                        let randomAngle = perfSpikeAngle + UTILS.toRad(ayochilltfoutyo);
                                        if (
                                            checkCanPlace(4, randomAngle) &&
                                            Math.hypot(
                                                tmpPlayer.x - (player.x2 + 40 * Math.cos(randomAngle)),
                                                tmpPlayer.y - (player.y2 + 40 * Math.sin(randomAngle))
                                            ) < item.scale + 35
                                        ) {
                                            checkPlace(4, randomAngle);
                                            break;
                                        }
                                    }
                                }
                            }
                        } else if (near.dist2 && near.dist2 <= 90) {
                            if (
                                checkCanPlace(2, near.aim2 + Math.PI) &&
                                checkCanPlace(2, near.aim2 + Math.PI + Math.PI / 1.5) &&
                                checkCanPlace(2, near.aim2 + Math.PI + Math.PI / 1.5)
                            ) {
                                checkPlace(2, near.aim2 + Math.PI);
                                checkPlace(2, near.aim2 + Math.PI + Math.PI / 1.5);
                                checkPlace(2, near.aim2 + Math.PI - Math.PI / 1.5);
                            } else {
                                checkPlace(2, near.aim2);
                                checkPlace(2, near.aim2 + Math.PI / 1.5);
                                checkPlace(2, near.aim2 - Math.PI / 1.5);
                            }
                        }
                    }
                };

                function calculatePerfectAngle(x1, y1, x2, y2) {
                    return Math.atan2(y2 - y1, x2 - x1);
                }
                this.checkPerfAngle = function(findObj, returnDir) {
                    let objAim = UTILS.getDirect(findObj, player, 0, 2);
                    let objDst = UTILS.getDist(findObj, player, 0, 2);
                    let item = items.list[player.items[evil ? 2 : 1]];
                    let angle = UTILS.getDirect(near, near.inTrap, 2, 0);
                    let perfectPlace = {
                        x: near.inTrap.x + Math.cos(angle) * (35 + item.scale),
                        y: near.inTrap.y + Math.sin(angle) * (35 + item.scale),
                    };
                    let bestSpikeAngle = UTILS.getDirect(perfectPlace, player, 0, 2);
                    let tmpS = 35 + item.scale + (item.placeOffset ?? 0);
                    let tmpX = player.x2 + tmpS * Math.cos(bestSpikeAngle);
                    let tmpY = player.y2 + tmpS * Math.sin(bestSpikeAngle);
                    if (
                        checkCanPrePlace(2, bestSpikeAngle, findObj) &&
                        UTILS.getDistance(tmpX, tmpY, near.x2, near.y2) <
                        item.scale + near.scale
                    ) {
                        if (!returnDir) {
                            checkPlace(2, bestSpikeAngle);
                            let touchDist = item.scale + 35;
                            let get = (e) =>
                                UTILS.getDistance(
                                    player.x2 + tmpS * Math.cos(bestSpikeAngle),
                                    player.y2 + tmpS * Math.sin(bestSpikeAngle),
                                    near["x" + e.toString()],
                                    near["y" + e.toString()]
                                );
                            if (get(3) <= touchDist || get(2) <= touchDist) instaC.wantZpyklerTick = true;
                            return;
                        } else {
                            return bestSpikeAngle;
                        }
                    } else {
                        for (
                            let ayochilltfoutyo = -45; ayochilltfoutyo < 45; ayochilltfoutyo += Math.abs(ayochilltfoutyo) >= 35 ? 1 : 0.5
                        ) {
                            let randomAngle = bestSpikeAngle + UTILS.toRad(ayochilltfoutyo);
                            if (
                                checkCanPrePlace(2, randomAngle, findObj) &&
                                UTILS.getDistance(
                                    player.x2 + tmpS * Math.cos(randomAngle),
                                    player.y2 + tmpS * Math.sin(randomAngle),
                                    near.x2,
                                    near.y2
                                ) <
                                item.scale + near.scale
                            ) {
                                let touchDist = item.scale + 35;
                                let get = (e) =>
                                    UTILS.getDistance(
                                        player.x2 + tmpS * Math.cos(randomAngle),
                                        player.y2 + tmpS * Math.sin(randomAngle),
                                        near["x" + e.toString()],
                                        near["y" + e.toString()]
                                    );
                                if (get(3) <= touchDist || get(2) <= touchDist) instaC.wantZpyklerTick = true;
                                if (!returnDir) {
                                    checkPlace(2, randomAngle);
                                    return;
                                } else {
                                    return randomAngle;
                                }
                            }
                        }
                    }
                    return false;
                };
                this.replacer = function(obj) {
                    const weaponRange = items.weapons[player.weaponIndex].range + 70;
                    const {
                        x2: playerX,
                        y2: playerY
                    } = player;
                    if (near.dist2 <= 300 && autoReplace) {
                        let objAim = UTILS.getDirect(obj, player, 0, 2);
                        let itemTarp = items.list[15];
                        if (
                            near.dist2 > 300 &&
                            (!player.items[4] || player.items[4] == 16)
                        ) return;
                        let itemZpyke = items.list[player.items[2]];
                        let bestAngle = undefined;
                        let tmpSTarp = 35 + itemTarp.scale + (itemTarp.placeOffset ?? 0);
                        let tmpXTarp = player.x2 + tmpSTarp * Math.cos(near.aim2);
                        let tmpYTarp = player.y2 + tmpSTarp * Math.sin(near.aim2);
                        let tmpDirTarp = Math.atan2(
                            near.y2 - tmpYTarp,
                            near.x2 - tmpXTarp
                        );
                        let tmpDir2Tarp = Math.atan2(
                            near.y2 - (player.y2 + tmpSTarp * Math.sin(objAim)),
                            near.x2 - (player.x2 + tmpSTarp * Math.cos(objAim))
                        );
                        let tmpSZpyke = 35 + itemZpyke.scale + (itemZpyke.placeOffset ?? 0);
                        let tmpXZpyke = player.x2 + tmpSZpyke * Math.cos(near.aim2);
                        let tmpYZpyke = player.y2 + tmpSZpyke * Math.sin(near.aim2);
                        let tmpDirZpyke = Math.atan2(
                            near.y2 - tmpYZpyke,
                            near.x2 - tmpXZpyke
                        );
                        let tmpDir2Zpyke = Math.atan2(
                            near.y2 - (player.y2 + tmpSZpyke * Math.sin(objAim)),
                            near.x2 - (player.x2 + tmpSZpyke * Math.cos(objAim))
                        );
                        let kbPos = {
                            x: near.x2 + Math.cos(tmpDirZpyke) * 150,
                            y: near.x2 + Math.cos(tmpDirZpyke) * 150,
                        };
                        let highScore = 0;
                        if (!near.trapClear) {
                            if (obj.sid == near.trapInfo2.sid) {
                                if (
                                    UTILS.getDist({
                                            x: player.x2 + tmpSZpyke * Math.cos(objAim),
                                            y: player.y2 + tmpSZpyke * Math.sin(objAim),
                                        },
                                        near,
                                        0,
                                        3
                                    ) <
                                    itemZpyke.scale + 35
                                ) {
                                    if (
                                        checkCanPrePlace(2, objAim + Math.PI / 4, obj) &&
                                        checkCanPrePlace(2, objAim - Math.PI / 4, obj)
                                    ) {
                                        place(2, objAim + Math.PI / 4);
                                        place(2, objAim - Math.PI / 4);
                                        instaC.canZpykeTick = true;
                                        return;
                                    } else if (
                                        checkCanPrePlace(2, near.aim2 + Math.PI / 4, obj) &&
                                        checkCanPrePlace(2, near.aim2 - Math.PI / 4, obj)
                                    ) {
                                        place(2, near.aim2 + Math.PI / 4);
                                        place(2, near.aim2 - Math.PI / 4);
                                        instaC.canZpykeTick = true;
                                        return;
                                    } else if (checkCanPrePlace(2, objAim, obj)) {
                                        place(2, objAim);
                                        instaC.wantZpyklerTick = true;
                                        return;
                                    } else if (checkCanPrePlace(2, near.aim2, obj)) {
                                        place(2, near.aim2);
                                        instaC.wantZpyklerTick = true;
                                        return;
                                    }
                                }
                            }
                            if (
                                obj.sid == near.trapInfo2.sid &&
                                45 +
                                items.weapons[player.weapons[0]].dmg *
                                (player.skins[7] ? 1.5 : 1) >=
                                100
                            ) {
                                if (checkCanPrePlace(2, near.aim2, obj)) {
                                    place(2, near.aim2);
                                    instaC.wantZpyklerTick = true;
                                    return;
                                } else if (checkCanPrePlace(2, objAim, obj)) {
                                    place(2, objAim);
                                    instaC.wantZpyklerTick = true;
                                    return;
                                }
                            }
                            if (
                                near.trapped &&
                                obj.sid != near.trapInfo2.sid &&
                                this.checkPerfAngle(obj, 1)
                            ) {
                                this.checkPerfAngle(obj);
                                return;
                            } else {
                                if (obj.sid == near.trapInfo2.sid) {
                                    let bestPos = undefined;
                                    let bestDiff = 0;
                                    let spikes = liztobj.filter(
                                        (e) =>
                                        e.active && e.owner && !e.isTeamObject(near) && e.dmg
                                    );
                                    for (let i = 0; i < spikes.length; i++) {
                                        let e = spikes[i];
                                        let nearSpikes = spikes.filter(
                                            (a) => UTILS.getDist(e, a) <= 140
                                        );
                                        if (nearSpikes > highScore) {
                                            highScore = spikes.filter((a) => UTILS.getDist(e, a) <= 140);
                                            bestPos = e;
                                        }
                                    }
                                    if (
                                        checkCanPrePlace(2, objAim, obj) &&
                                        UTILS.getAngleDist(
                                            Math.atan2(
                                                bestPos.y - near.y2,
                                                bestPos.x - near.x2
                                            ),
                                            tmpDir2Zpyke
                                        ) <= 0.3 &&
                                        UTILS.getDistance(
                                            player.x2 + tmpSZpyke * Math.cos(objAim),
                                            player.y2 + tmpSZpyke * Math.sin(objAim),
                                            near.x3,
                                            near.y3
                                        ) <
                                        itemZpyke.scale + 35
                                    ) {
                                        place(2, objAim);
                                        instaC.wantZpyklerTick = true;
                                        obj.prePlaced = true;
                                        return;
                                    } else {
                                        for (
                                            let ayochilltfoutyo = -45; ayochilltfoutyo < 45; ayochilltfoutyo += Math.abs(ayochilltfoutyo) >= 35 ? 1 : 0.5
                                        ) {
                                            let randomAngle = objAim + UTILS.toRad(ayochilltfoutyo);
                                            let zpykeAngle = Math.atan2(
                                                near.y2 -
                                                (player.y2 + tmpSZpyke * Math.sin(randomAngle)),
                                                near.x2 -
                                                (player.x2 + tmpSZpyke * Math.cos(randomAngle))
                                            );
                                            if (
                                                checkCanPrePlace(2, randomAngle, obj) &&
                                                UTILS.getAngleDist(
                                                    Math.atan2(
                                                        near.y2 - bestPos.y,
                                                        near.x2 - bestPos.x
                                                    ),
                                                    zpykeAngle
                                                ) <= (bestDiff ?? 0.3) &&
                                                UTILS.getDistance(
                                                    player.x2 + tmpSZpyke * Math.cos(randomAngle),
                                                    player.y2 + tmpSZpyke * Math.sin(randomAngle),
                                                    near.x3,
                                                    near.y3
                                                ) <
                                                itemZpyke.scale + 35
                                            ) {
                                                bestAngle = randomAngle;
                                                bestDiff = UTILS.getAngleDist(
                                                    Math.atan2(
                                                        near.y2 - bestPos.y,
                                                        near.x2 - bestPos.x
                                                    ),
                                                    zpykeAngle
                                                );
                                                return;
                                            }
                                        }
                                        if (bestAngle != undefined) {
                                            place(2, bestAngle);
                                            instaC.wantZpyklerTick = true;
                                            obj.prePlaced = true;
                                            return;
                                        }
                                    }
                                }
                            }
                        }
                        if (
                            player.items[4] &&
                            !macro.v &&
                            (macro.f ||
                                (player.items[4] == 15 &&
                                    (Math.hypot(tmpXTarp - near.x3, tmpYTarp - near.y3) <=
                                        45 ||
                                        near.dist2 >= 250)))
                        ) {
                            if (checkCanPrePlace(4, near.aim2, obj)) {
                                place(4, near.aim2);
                                obj.prePlaced = true;
                            } else if (
                                checkCanPrePlace(4, objAim, obj) &&
                                Math.hypot(
                                    player.x2 + tmpSTarp * Math.cos(objAim) - near.x3,
                                    player.y2 + tmpSTarp * Math.sin(objAim) - near.y3
                                ) <= 45
                            ) {
                                place(4, objAim);
                                obj.prePlaced = true;
                            } else if (
                                Math.hypot(tmpXTarp - near.x3, tmpYTarp - near.y3) <= 45
                            ) {
                                for (
                                    let ayochilltfoutyo = -45; ayochilltfoutyo < 45; ayochilltfoutyo += Math.abs(ayochilltfoutyo) >= 35 ? 1 : 0.5
                                ) {
                                    let randomAngle = near.aim2 + UTILS.toRad(ayochilltfoutyo);
                                    if (
                                        checkCanPrePlace(4, randomAngle, obj) &&
                                        UTILS.getDistance(
                                            player.x2 + tmpSTarp * Math.cos(randomAngle),
                                            player.y2 + tmpSTarp * Math.sin(randomAngle),
                                            near.x3,
                                            near.y3
                                        ) <= 45
                                    ) {
                                        place(4, randomAngle);
                                        obj.prePlaced = true;
                                        break;
                                    }
                                }
                            }
                        } else {
                            if (checkCanPrePlace(2, objAim, obj)) {
                                let placedSpikePos = {
                                    x: player.x2 + tmpSZpyke * Math.cos(objAim),
                                    y: player.y2 + tmpSZpyke * Math.sin(objAim),
                                };
                                if (
                                    UTILS.getDist(placedSpikePos, near, 0, 3) <=
                                    itemZpyke.scale + 35 ||
                                    UTILS.getDist(placedSpikePos, near, 0, 2) <=
                                    itemZpyke.scale + 35
                                ) instaC.wantZpykeTick = true;
                                place(2, objAim);
                                obj.prePlaced = true;
                                return;
                            } else {
                                for (
                                    let ayochilltfoutyo = -45; ayochilltfoutyo < 45; ayochilltfoutyo += Math.abs(ayochilltfoutyo) >= 35 ? 1 : 0.5
                                ) {
                                    let randomAngle = objAim + UTILS.toRad(ayochilltfoutyo);
                                    if (
                                        checkCanPrePlace(2, randomAngle, obj) &&
                                        UTILS.getDistance(
                                            player.x2 + tmpSZpyke * Math.cos(randomAngle),
                                            player.y2 + tmpSZpyke * Math.sin(randomAngle),
                                            near.x3,
                                            near.y3
                                        ) <
                                        itemZpyke.scale + 35
                                    ) {
                                        place(2, randomAngle);
                                        let placedSpikePos = {
                                            x: player.x2 + tmpSZpyke * Math.cos(objAim),
                                            y: player.y2 + tmpSZpyke * Math.sin(objAim),
                                        };
                                        if (
                                            UTILS.getDist(placedSpikePos, near, 0, 3) <=
                                            itemZpyke.scale + 35 ||
                                            UTILS.getDist(placedSpikePos, near, 0, 2) <=
                                            itemZpyke.scale + 35
                                        ) instaC.wantZpykeTick = true;
                                        obj.prePlaced = true;
                                        return;
                                    }
                                }
                            }
                        }
                    }
                };
                this.preplacer = function(obj) {
                    const weaponRange = items.weapons[player.weaponIndex].range + 70;
                    const {
                        x2: playerX,
                        y2: playerY
                    } = player;
                    if (near.dist2 <= 300 && autoReplace) {
                        let objAim = UTILS.getDirect(obj, player, 0, 2);
                        let itemTarp = items.list[15];
                        if (
                            near.dist2 > 300 &&
                            (!player.items[4] || player.items[4] == 16)
                        ) return;
                        let itemZpyke = items.list[player.items[2]];
                        let bestAngle = undefined;
                        let tmpSTarp = 35 + itemTarp.scale + (itemTarp.placeOffset ?? 0);
                        let tmpXTarp = player.x2 + tmpSTarp * Math.cos(near.aim2);
                        let tmpYTarp = player.y2 + tmpSTarp * Math.sin(near.aim2);
                        let tmpDirTarp = Math.atan2(
                            near.y2 - tmpYTarp,
                            near.x2 - tmpXTarp
                        );
                        let tmpDir2Tarp = Math.atan2(
                            near.y2 - (player.y2 + tmpSTarp * Math.sin(objAim)),
                            near.x2 - (player.x2 + tmpSTarp * Math.cos(objAim))
                        );
                        let tmpSZpyke = 35 + itemZpyke.scale + (itemZpyke.placeOffset ?? 0);
                        let tmpXZpyke = player.x2 + tmpSZpyke * Math.cos(near.aim2);
                        let tmpYZpyke = player.y2 + tmpSZpyke * Math.sin(near.aim2);
                        let tmpDirZpyke = Math.atan2(
                            near.y2 - tmpYZpyke,
                            near.x2 - tmpXZpyke
                        );
                        let tmpDir2Zpyke = Math.atan2(
                            near.y2 - (player.y2 + tmpSZpyke * Math.sin(objAim)),
                            near.x2 - (player.x2 + tmpSZpyke * Math.cos(objAim))
                        );
                        let kbPos = {
                            x: near.x2 + Math.cos(tmpDirZpyke) * 150,
                            y: near.x2 + Math.cos(tmpDirZpyke) * 150,
                        };
                        let highScore = 0;
                        if (!near.trapClear) {
                            if (obj.sid == near.trapInfo2.sid) {
                                if (
                                    UTILS.getDist({
                                            x: player.x2 + tmpSZpyke * Math.cos(objAim),
                                            y: player.y2 + tmpSZpyke * Math.sin(objAim),
                                        },
                                        near,
                                        0,
                                        3
                                    ) <
                                    itemZpyke.scale + 35
                                ) {
                                    if (
                                        checkCanPrePlace(2, objAim + Math.PI / 4, obj) &&
                                        checkCanPrePlace(2, objAim - Math.PI / 4, obj)
                                    ) {
                                        place(2, objAim + Math.PI / 4);
                                        place(2, objAim - Math.PI / 4);
                                        instaC.canZpykeTick = true;
                                        return;
                                    } else if (
                                        checkCanPrePlace(2, near.aim2 + Math.PI / 4, obj) &&
                                        checkCanPrePlace(2, near.aim2 - Math.PI / 4, obj)
                                    ) {
                                        place(2, near.aim2 + Math.PI / 4);
                                        place(2, near.aim2 - Math.PI / 4);
                                        instaC.canZpykeTick = true;
                                        return;
                                    } else if (checkCanPrePlace(2, objAim, obj)) {
                                        place(2, objAim);
                                        instaC.wantZpyklerTick = true;
                                        return;
                                    } else if (checkCanPrePlace(2, near.aim2, obj)) {
                                        place(2, near.aim2);
                                        instaC.wantZpyklerTick = true;
                                        return;
                                    }
                                }
                            }
                            if (
                                obj.sid == near.trapInfo2.sid &&
                                45 +
                                items.weapons[player.weapons[0]].dmg *
                                (player.skins[7] ? 1.5 : 1) >=
                                100
                            ) {
                                if (checkCanPrePlace(2, near.aim2, obj)) {
                                    place(2, near.aim2);
                                    instaC.wantZpyklerTick = true;
                                    return;
                                } else if (checkCanPrePlace(2, objAim, obj)) {
                                    place(2, objAim);
                                    instaC.wantZpyklerTick = true;
                                    return;
                                }
                            }
                            if (
                                near.trapped &&
                                obj.sid != near.trapInfo2.sid &&
                                this.checkPerfAngle(obj, 1)
                            ) {
                                this.checkPerfAngle(obj);
                                return;
                            } else {
                                if (obj.sid == near.trapInfo2.sid) {
                                    let bestPos = undefined;
                                    let bestDiff = 0;
                                    let spikes = liztobj.filter(
                                        (e) =>
                                        e.active && e.owner && !e.isTeamObject(near) && e.dmg
                                    );
                                    for (let i = 0; i < spikes.length; i++) {
                                        let e = spikes[i];
                                        let nearSpikes = spikes.filter(
                                            (a) => UTILS.getDist(e, a) <= 140
                                        );
                                        if (nearSpikes > highScore) {
                                            highScore = spikes.filter((a) => UTILS.getDist(e, a) <= 140);
                                            bestPos = e;
                                        }
                                    }
                                    if (
                                        checkCanPrePlace(2, objAim, obj) &&
                                        UTILS.getAngleDist(
                                            Math.atan2(
                                                bestPos.y - near.y2,
                                                bestPos.x - near.x2
                                            ),
                                            tmpDir2Zpyke
                                        ) <= 0.3 &&
                                        UTILS.getDistance(
                                            player.x2 + tmpSZpyke * Math.cos(objAim),
                                            player.y2 + tmpSZpyke * Math.sin(objAim),
                                            near.x3,
                                            near.y3
                                        ) <
                                        itemZpyke.scale + 35
                                    ) {
                                        place(2, objAim);
                                        instaC.wantZpyklerTick = true;
                                        obj.prePlaced = true;
                                        return;
                                    } else {
                                        for (
                                            let ayochilltfoutyo = -45; ayochilltfoutyo < 45; ayochilltfoutyo += Math.abs(ayochilltfoutyo) >= 35 ? 1 : 0.5
                                        ) {
                                            let randomAngle = objAim + UTILS.toRad(ayochilltfoutyo);
                                            let zpykeAngle = Math.atan2(
                                                near.y2 -
                                                (player.y2 + tmpSZpyke * Math.sin(randomAngle)),
                                                near.x2 -
                                                (player.x2 + tmpSZpyke * Math.cos(randomAngle))
                                            );
                                            if (
                                                checkCanPrePlace(2, randomAngle, obj) &&
                                                UTILS.getAngleDist(
                                                    Math.atan2(
                                                        near.y2 - bestPos.y,
                                                        near.x2 - bestPos.x
                                                    ),
                                                    zpykeAngle
                                                ) <= (bestDiff ?? 0.3) &&
                                                UTILS.getDistance(
                                                    player.x2 + tmpSZpyke * Math.cos(randomAngle),
                                                    player.y2 + tmpSZpyke * Math.sin(randomAngle),
                                                    near.x3,
                                                    near.y3
                                                ) <
                                                itemZpyke.scale + 35
                                            ) {
                                                bestAngle = randomAngle;
                                                bestDiff = UTILS.getAngleDist(
                                                    Math.atan2(
                                                        near.y2 - bestPos.y,
                                                        near.x2 - bestPos.x
                                                    ),
                                                    zpykeAngle
                                                );
                                                return;
                                            }
                                        }
                                        if (bestAngle != undefined) {
                                            place(2, bestAngle);
                                            instaC.wantZpyklerTick = true;
                                            obj.prePlaced = true;
                                            return;
                                        }
                                    }
                                }
                            }
                        }
                        if (
                            player.items[4] &&
                            !macro.v &&
                            (macro.f ||
                                (player.items[4] == 15 &&
                                    (Math.hypot(tmpXTarp - near.x3, tmpYTarp - near.y3) <=
                                        45 ||
                                        near.dist2 >= 250)))
                        ) {
                            if (checkCanPrePlace(4, near.aim2, obj)) {
                                place(4, near.aim2);
                                obj.prePlaced = true;
                            } else if (
                                checkCanPrePlace(4, objAim, obj) &&
                                Math.hypot(
                                    player.x2 + tmpSTarp * Math.cos(objAim) - near.x3,
                                    player.y2 + tmpSTarp * Math.sin(objAim) - near.y3
                                ) <= 45
                            ) {
                                place(4, objAim);
                                obj.prePlaced = true;
                            } else if (
                                Math.hypot(tmpXTarp - near.x3, tmpYTarp - near.y3) <= 45
                            ) {
                                for (
                                    let ayochilltfoutyo = -45; ayochilltfoutyo < 45; ayochilltfoutyo += Math.abs(ayochilltfoutyo) >= 35 ? 1 : 0.5
                                ) {
                                    let randomAngle = near.aim2 + UTILS.toRad(ayochilltfoutyo);
                                    if (
                                        checkCanPrePlace(4, randomAngle, obj) &&
                                        UTILS.getDistance(
                                            player.x2 + tmpSTarp * Math.cos(randomAngle),
                                            player.y2 + tmpSTarp * Math.sin(randomAngle),
                                            near.x3,
                                            near.y3
                                        ) <= 45
                                    ) {
                                        place(4, randomAngle);
                                        obj.prePlaced = true;
                                        break;
                                    }
                                }
                            }
                        } else {
                            if (checkCanPrePlace(2, objAim, obj)) {
                                let placedSpikePos = {
                                    x: player.x2 + tmpSZpyke * Math.cos(objAim),
                                    y: player.y2 + tmpSZpyke * Math.sin(objAim),
                                };
                                if (
                                    UTILS.getDist(placedSpikePos, near, 0, 3) <=
                                    itemZpyke.scale + 35 ||
                                    UTILS.getDist(placedSpikePos, near, 0, 2) <=
                                    itemZpyke.scale + 35
                                ) instaC.wantZpykeTick = true;
                                place(2, objAim);
                                obj.prePlaced = true;
                                return;
                            } else {
                                for (
                                    let ayochilltfoutyo = -45; ayochilltfoutyo < 45; ayochilltfoutyo += Math.abs(ayochilltfoutyo) >= 35 ? 1 : 0.5
                                ) {
                                    let randomAngle = objAim + UTILS.toRad(ayochilltfoutyo);
                                    if (
                                        checkCanPrePlace(2, randomAngle, obj) &&
                                        UTILS.getDistance(
                                            player.x2 + tmpSZpyke * Math.cos(randomAngle),
                                            player.y2 + tmpSZpyke * Math.sin(randomAngle),
                                            near.x3,
                                            near.y3
                                        ) <
                                        itemZpyke.scale + 35
                                    ) {
                                        place(2, randomAngle);
                                        let placedSpikePos = {
                                            x: player.x2 + tmpSZpyke * Math.cos(objAim),
                                            y: player.y2 + tmpSZpyke * Math.sin(objAim),
                                        };
                                        if (
                                            UTILS.getDist(placedSpikePos, near, 0, 3) <=
                                            itemZpyke.scale + 35 ||
                                            UTILS.getDist(placedSpikePos, near, 0, 2) <=
                                            itemZpyke.scale + 35
                                        )
                                            instaC.wantZpykeTick = true;
                                        obj.prePlaced = true;
                                        return;
                                    }
                                }
                            }
                        }
                    }
                };
            }
        }
    }

    class Instakill {
        constructor() {
            this.wait = false;
            this.can = false;
            this.isTrue = false;
            this.nobull = false;
            this.ticking = false;
            this.canSpikeTick = false;
            this.startTick = false;
            this.readyTick = false;
            this.canCounter = false;
            this.revTick = false;
            this.syncHit = false;

            this.changeType = function(type) {
                this.wait = false;
                this.isTrue = true;
                my.autoAim = true;

                if (type == "rev") {
                    selectWeapon(player.weapons[1]);
                    buyEquip(53, 0);
                    buyEquip(21, 1);
                    sendAutoGather();
                    game.tickBase(() => {
                        selectWeapon(player.weapons[0]);
                        buyEquip(7, 0);
                        game.tickBase(() => {
                            sendAutoGather();
                            this.isTrue = false;
                            my.autoAim = false;
                        }, 1);
                    }, 1);
                } else if (type == "normal") {
                    selectWeapon(player.weapons[0]);
                    buyEquip(7, 0);
                    buyEquip(7, 0);
                    sendAutoGather();
                    game.tickBase(() => {
                        buyEquip(53, 0);
                        selectWeapon(player.weapons[1]);
                        buyEquip(53, 0);
                        buyEquip(18, 1);
                        game.tickBase(() => {
                            sendAutoGather();
                            this.isTrue = false;
                            my.autoAim = false;
                        }, 1);
                    }, 1);
                } else {
                    setTimeout(() => {
                        this.isTrue = false;
                        my.autoAim = false;
                    }, 50);
                }
            };
            this.zpyklerTickType = function() {
                if (trapClear) {
                    let antiBullTrue = configs.antiBull;
                    this.isTrue = true;
                    my.autoAim = true;
                    selectWeapon(player.weapons[0]);
                    buyEquip(7, 0);
                    sendAutoGather(1);
                    game.tickBase(() => {
                        buyEquip(53, 0);
                        selectWeapon(player.weapons[0]);
                        buyEquip(53, 0);
                        game.tickBase(() => {
                            this.isTrue = false;
                            my.autoAim = false;
                            buyEquip(0, 0);
                            buyEquip(antiBullTrue ? 21 : 19, 1);
                        }, 1);
                    }, 1);
                } else {
                    return;
                }
            };
            this.OneTickType = function() {
                this.isTrue = true;
                my.autoAim = true;
                biomeGear();
                buyEquip(19, 1);
                packet("9", near.aim2, 1);
                game.tickBase(() => {
                    if (player.weapons[1] == 15) {
                        my.revAim = true;
                    }
                    selectWeapon(player.weapons[[9, 12, 13, 15].includes(player.weapons[1]) ? 1 : 0]);
                    buyEquip(53, 0);
                    buyEquip(19, 1);
                    if ([9, 12, 13, 15].includes(player.weapons[1])) {
                        sendAutoGather();
                    }
                    packet("9", near.aim2, 1);
                    game.tickBase(() => {
                        my.revAim = false;
                        selectWeapon(player.weapons[0]);
                        buyEquip(7, 0);
                        buyEquip(19, 1);
                        if (![9, 12, 13, 15].includes(player.weapons[1])) {
                            sendAutoGather();
                        }
                        packet("9", near.aim2, 1);
                        game.tickBase(() => {
                            sendAutoGather();
                            this.isTrue = false;
                            my.autoAim = false;
                            packet("9", undefined, 1);
                        }, 2);
                    }, 1);
                }, 1);
            };
            this.BoostOneTICKERS = function() {
                this.isTrue = true;
                my.autoAim = true;
                biomeGear();
                buyEquip(19, 1);
                packet("9", near.aim2, 1);
                game.tickBase(() => {
                    selectWeapon(player.weapons[0]);
                    buyEquip(53, 0);
                    buyEquip(19, 1);
                    packet("9", near.aim2, 1);
                    place(4, near.aim2);
                    game.tickBase(() => {
                        my.revAim = false;
                        selectWeapon(player.weapons[0]);
                        buyEquip(7, 0);
                        buyEquip(19, 1);
                        sendAutoGather();
                        packet("9", near.aim2, 1);
                        game.tickBase(() => {
                            sendAutoGather();
                            this.isTrue = false;
                            my.autoAim = false;
                            packet("9", undefined, 1);
                        }, 5);
                    }, 1);
                }, 1);
            };
            this.threeOneTickType = function() {
                io.send("");
                this.isTrue = true;
                my.autoAim = true;
                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                biomeGear();
                buyEquip(0, 1);
                packet("9", near.aim2, 1);
                game.tickBase(() => {
                    selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                    buyEquip(53, 0);
                    buyEquip(0, 1);
                    packet("9", near.aim2, 1);
                    game.tickBase(() => {
                        selectWeapon(player.weapons[0]);
                        buyEquip(7, 0);
                        buyEquip(0, 1);
                        sendAutoGather();
                        packet("9", near.aim2, 1);
                        game.tickBase(() => {
                            sendAutoGather();
                            this.isTrue = false;
                            my.autoAim = false;
                            packet("9", undefined, 1);
                        }, 1);
                    }, 1);
                }, 1);
            };
            this.kmTickType = function() {
                this.isTrue = true;
                my.autoAim = true;
                my.revAim = true;
                selectWeapon(player.weapons[1]);
                buyEquip(53, 0);
                buyEquip(0, 1);
                sendAutoGather();
                packet("9", near.aim2, 1);
                game.tickBase(() => {
                    my.revAim = false;
                    selectWeapon(player.weapons[0]);
                    buyEquip(7, 0);
                    buyEquip(0, 1);
                    packet("9", near.aim2, 1);
                    game.tickBase(() => {
                        sendAutoGather();
                        this.isTrue = false;
                        my.autoAim = false;
                        packet("9", undefined, 1);
                    }, 1);
                }, 1);
            };
            this.spiketickOption = function() {
                selectWeapon(player.weapons[0]);
                buyEquip(7, 0);
                buyEquip(18, 1);
                sendAutoGather();
                game.tickBase(() => {
                    selectWeapon(player.weapons[0]);
                    buyEquip(53, 0);
                    game.tickBase(() => {
                        sendAutoGather();
                        my.autoAim = false;
                    }, 1);
                }, 1);
            };
            this.boostTickType = function() {
                this.isTrue = true;
                my.autoAim = true;
                buyEquip(40, 0);
                buyEquip(0, 1);
                packet("9", near.aim2, 1);
                game.tickBase(() => {
                    if (player.weapons[1] == 15) {
                        my.revAim = true;
                    }
                    selectWeapon(player.weapons[[9, 12, 13, 15].includes(player.weapons[1]) ? 1 : 0]);
                    buyEquip(53, 0);
                    buyEquip(19, 1);
                    if ([9, 12, 13, 15].includes(player.weapons[1])) {
                        sendAutoGather();
                    }
                    packet("9", near.aim2, 1);
                    place(4, near.aim2);
                    game.tickBase(() => {
                        my.revAim = false;
                        selectWeapon(player.weapons[0]);
                        buyEquip(7, 0);
                        if (![9, 12, 13, 15].includes(player.weapons[1])) {
                            sendAutoGather();
                        }
                        packet("9", near.aim2, 1);
                        game.tickBase(() => {
                            sendAutoGather();
                            this.isTrue = false;
                            my.autoAim = false;
                            packet("9", undefined, 1);
                        }, 1);
                    }, 1);
                }, 1);
            };
            this.rangeType = function(type) {
                this.isTrue = true;
                my.autoAim = true;
                if (type == "ageInsta") {
                    my.ageInsta = false;
                    if (player.items[5] == 18) {
                        place(5, near.aim2);
                    }
                    packet("f", undefined, 1);
                    buyEquip(22, 0);
                    buyEquip(21, 1);
                    game.tickBase(() => {
                        selectWeapon(player.weapons[1]);
                        buyEquip(53, 0);
                        buyEquip(21, 1);
                        sendAutoGather();
                        game.tickBase(() => {
                            sendUpgrade(12);
                            selectWeapon(player.weapons[1]);
                            buyEquip(53, 0);
                            buyEquip(21, 1);
                            game.tickBase(() => {
                                sendUpgrade(15);
                                selectWeapon(player.weapons[1]);
                                buyEquip(53, 0);
                                buyEquip(21, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 1);
                            }, 1);
                        }, 1);
                    }, 1);
                } else {
                    selectWeapon(player.weapons[1]);
                    if (player.reloads[53] == 0 && near.dist2 <= 700 && near.skinIndex != 22) {
                        buyEquip(53, 0);
                    } else {
                        buyEquip(20, 0);
                    }
                    buyEquip(11, 1);
                    sendAutoGather();
                    game.tickBase(() => {
                        sendAutoGather();
                        this.isTrue = false;
                        my.autoAim = false;
                    }, 1);
                }
            };
            this.gotoGoal = function(goto, OT) {
                let slowDists = (weeeee) => weeeee * config.playerScale;
                let goal = {
                    a: goto - OT,
                    b: goto + OT,
                    c: goto - slowDists(1),
                    d: goto + slowDists(1),
                    e: goto - slowDists(2),
                    f: goto + slowDists(2),
                    g: goto - slowDists(4),
                    h: goto + slowDists(4)
                };
                let bQ = function(wwww, awwww) {
                    if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2 && awwww == 0) {
                        buyEquip(31, 0);
                    } else {
                        buyEquip(wwww, awwww);
                    }
                }
                if (enemy.length) {
                    let dst = near.dist2;
                    this.ticking = true;
                    if (dst >= goal.a && dst <= goal.b) {
                        bQ(12, 0);
                        bQ(11, 1);
                        if (player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0] || player.buildIndex > -1) {
                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                        }
                        return {
                            dir: undefined,
                            action: 1
                        };
                    } else {
                        if (dst < goal.a) {
                            if (dst >= goal.g) {
                                if (dst >= goal.e) {
                                    if (dst >= goal.c) {
                                        bQ(40, 0);
                                        bQ(0, 1);
                                        if (slowTick) {
                                            player.buildIndex != player.items[1] && selectToBuild(player.items[1]);
                                        } else {
                                            if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                            }
                                        }
                                    } else {
                                        bQ(40, 0);
                                        bQ(0, 1);
                                        if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                        }
                                    }
                                } else {
                                    bQ(hatLoop ? loopHats[loopIndex++] || aSheal : 0, 0);
                                    bQ(0, 1);
                                    if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                    }
                                }
                            } else {
                                biomeGear();
                                bQ(0, 1);
                                if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                    selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                }
                            }
                            return {
                                dir: near.aim2 + Math.PI,
                                action: 0
                            };
                        } else if (dst > goal.b) {
                            if (dst <= goal.h) {
                                if (dst <= goal.f) {
                                    if (dst <= goal.d) {
                                        bQ(40, 0);
                                        bQ(0, 1);
                                        if (slowTick) {
                                            player.buildIndex != player.items[1] && selectToBuild(player.items[1]);
                                        } else {
                                            if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                            }
                                        }
                                    } else {
                                        bQ(40, 0);
                                        bQ(0, 1);
                                        if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                        }
                                    }
                                } else {
                                    bQ(hatLoop ? loopHats[loopIndex++] || aSheal : 0, 0);
                                    bQ(0, 1);
                                    if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                    }
                                }
                            } else {
                                biomeGear();
                                bQ(0, 1);
                                if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                    selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                }
                            }
                            return {
                                dir: near.aim2,
                                action: 0
                            };
                        }
                        return {
                            dir: undefined,
                            action: 0
                        };
                    }
                } else {
                    this.ticking = false;
                    return {
                        dir: undefined,
                        action: 0
                    };
                }
            }

            this.tickMovement = function() {
                let dist = player.weapons[1] == 9 ? 245 : 245;
                let actionDist = player.weapons[1] == 9 ? 2 : player.weapons[1] == 12 ? 1.5 : player.weapons[1] == 13 ? 1 : player.weapons[1] == 15 ? 2 : 3;
                let moveMent = this.gotoGoal(245, 3);
                if (moveMent.action) {
                    if (player.reloads[53] == 0 && !this.isTrue) {
                        this.OneTickType();
                    } else {
                        packet("9", moveMent.dir, 1);
                    }
                } else {
                    packet("9", moveMent.dir, 1);
                }
            }
            this.BoostOneTick = function() {
                let dist = player.weapons[1] == 9 ? 365 : player.weapons[1] == 12 ? 380 : player.weapons[1] == 13 ? 365 : player.weapons[1] == 15 ? 365 : 370;
                let actionDist = player.weapons[1] == 9 ? 2 : player.weapons[1] == 12 ? 1.5 : player.weapons[1] == 13 ? 1 : player.weapons[1] == 15 ? 2 : 3;
                let moveMent = this.gotoGoal(372, 3);
                if (moveMent.action) {
                    if (player.reloads[53] == 0 && !this.isTrue) {
                        this.BoostOneTICKERS();
                    } else {
                        packet("9", moveMent.dir, 1);
                    }
                } else {
                    packet("9", moveMent.dir, 1);
                }
            }
            this.kmTickMovement = function() {
                let moveMent = this.gotoGoal(240, 3);
                if (moveMent.action) {
                    if (near.skinIndex != 22 && player.reloads[53] == 0 && !this.isTrue && ((game.tick - near.poisonTick) % config.serverUpdateRate == 8)) {
                        this.kmTickType();
                    } else {
                        packet("9", moveMent.dir, 1);
                    }
                } else {
                    packet("9", moveMent.dir, 1);
                }
            }
            this.boostTickMovement = function() {
                let dist = player.weapons[1] == 9 ? 345 : player.weapons[1] == 12 ? 375 : player.weapons[1] == 13 ? 363 : player.weapons[1] == 15 ? 365 : 370;
                let actionDist = player.weapons[1] == 9 ? 2 : player.weapons[1] == 12 ? 1.5 : player.weapons[1] == 13 ? 1 : player.weapons[1] == 15 ? 2 : 3;
                let moveMent = this.gotoGoal(372, 3);
                if (moveMent.action) {
                    if (player.reloads[53] == 0 && !this.isTrue) {
                        this.boostTickType();
                    } else {
                        packet("9", moveMent.dir, 1);
                    }
                } else {
                    packet("9", moveMent.dir, 1);
                }
            }
            this.perfCheck = function(pl, nr) {
                if (nr.weaponIndex == 11 && UTILS.getAngleDist(nr.aim2 + Math.PI, nr.d2) <= config.shieldAngle) return false;
                if (![9, 12, 13, 15].includes(player.weapons[1])) return true;
                let pjs = {
                    x: nr.x2 + (65 * Math.cos(nr.aim2 + Math.PI)),
                    y: nr.y2 + (65 * Math.sin(nr.aim2 + Math.PI))
                };
                if (UTILS.lineInRect(pl.x2 - pl.scale, pl.y2 - pl.scale, pl.x2 + pl.scale, pl.y2 + pl.scale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                    return true;
                }
                let finds = ais.filter(tmp => tmp.visible)
                    .find((tmp) => {
                        if (UTILS.lineInRect(tmp.x2 - tmp.scale, tmp.y2 - tmp.scale, tmp.x2 + tmp.scale, tmp.y2 + tmp.scale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                            return true;
                        }
                    });
                if (finds) return false;
                finds = closeObjects.filter(tmp => tmp.active)
                    .find((tmp) => {
                        let tmpScale = tmp.getScale();
                        if (!tmp.ignoreCollision && UTILS.lineInRect(tmp.x - tmpScale, tmp.y - tmpScale, tmp.x + tmpScale, tmp.y + tmpScale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                            return true;
                        }
                    });
                if (finds) return false;
                return true;
            };
        }
    }

    class Autobuy {
        constructor(buyHat, buyAcc) {
            this.hat = function() {
                buyHat.forEach((id) => {
                    let find = findID(hats, id);
                    if (find && !player.skins[id] && player.points >= find.price) packet("c", 1, id, 0);
                });
            };
            this.acc = function() {
                buyAcc.forEach((id) => {
                    let find = findID(accessories, id);
                    if (find && !player.tails[id] && player.points >= find.price) packet("c", 1, id, 1);
                });
            };
        }
    };

    class Damages {
        constructor(items) {
            this.calcDmg = function(dmg, val) {
                return dmg * val;
            };
            this.getAllDamage = function(dmg) {
                return [this.calcDmg(dmg, 0.75), dmg, this.calcDmg(dmg, 1.125), this.calcDmg(dmg, 1.5)];
            };
            this.weapons = [];
            for (let i = 0; i < items.weapons.length; i++) {
                let wp = items.weapons[i];
                let name = wp.name.split(" ")
                    .length <= 1 ? wp.name : (wp.name.split(" ")[0] + "_" + wp.name.split(" ")[1]);
                this.weapons.push(this.getAllDamage(i > 8 ? wp.Pdmg : wp.dmg));
                this[name] = this.weapons[i];
            }
        }
    }

    let tmpList = [];
    let UTILS = new Utils();
    let items = new Items();
    let objectManager = new Objectmanager(GameObject, gameObjects, UTILS, config);
    let store = new Store();
    let hats = store.hats;
    let accessories = store.accessories;
    let projectileManager = new ProjectileManager(Projectile, projectiles, players, ais, objectManager, items, config, UTILS);
    let aiManager = new AiManager(ais, AI, players, items, null, config, UTILS);
    let textManager = new Textmanager();

    let traps = new Traps(UTILS, items);
    let instaC = new Instakill();
    let autoBuy = new Autobuy([40, 7, 22, 53, 15, 31, 11, 26, 10], [11, 21, 18]);

    let lastDeath;
    let minimapData;
    let mapMarker = {};
    let mapPings = [];
    let tmpPing;

    let antiinsta = true;
    let antiinsta1 = false;

    function sendChat(message, priv, privMesObject = player) {
        if (priv) {
            privMesObject.chatMessage = message;
            privMesObject.chatCountdown = config.chatCountdown;
        } else {
            packet("6", message.slice(0, 30));
        }
    }

    let runAtNextTick = [];

    function checkProjectileHolder(x, y, dir, range, speed, indx, layer, sid) {
        let weaponIndx = indx == 0 ? 9 : indx == 2 ? 12 : indx == 3 ? 13 : indx == 5 && 15;
        let projOffset = config.playerScale * 2;
        let projXY = {
            x: indx == 1 ? x : x - projOffset * Math.cos(dir),
            y: indx == 1 ? y : y - projOffset * Math.sin(dir),
        };
        let nearPlayer = players.filter((e) => e.visible && UTILS.getDist(projXY, e, 0, 2) <= e.scale)
            .sort(function(a, b) {
                return UTILS.getDist(projXY, a, 0, 2) - UTILS.getDist(projXY, b, 0, 2);
            })[0];
        if (nearPlayer) {
            if (indx == 1) {
                nearPlayer.shooting[53] = 1;
            } else {
                nearPlayer.shootIndex = weaponIndx;
                nearPlayer.shooting[1] = 1;
                antiProj(nearPlayer, dir, range, speed, indx, weaponIndx);
            }
        }
    }
    let projectileCount = 0;

    function getVolcanoDist() {
        return UTILS.getDist(player, {
            x: 13960,
            y: 13960
        }, 2, 0);
    }

    function predictHeal(times) {
        for (let i = 0; i < times; i++) {
            place(0, getAttackDir());
        }
    }
    let noWep = false;
    let noHat = false;

    function antiProj(tmpObj, dir, range, speed, index, weaponIndex, indx, y, x) {
        let weaponIndx = indx == 0 ? 9 : indx == 2 ? 12 : indx == 3 ? 13 : indx == 5 && 15;
        let projOffset = config.playerScale * 2;
        let projXY = {
            x: indx == 1 ? x : x - projOffset * Math.cos(dir),
            y: indx == 1 ? y : y - projOffset * Math.sin(dir),
        };
        let fixXY = function(tmpObj) {
            return {
                x2: UTILS.fixTo(tmpObj.x2, 2),
                y2: UTILS.fixTo(tmpObj.y2, 2),
            };
        };
        let nearPlayer = players.filter((e) => e.visible && UTILS.getDist(projXY, e, 0, 2) <= e.scale)
            .sort(function(a, b) {
                return (UTILS.getDist(projXY, a, 0, 2) - UTILS.getDist(projXY, b, 0, 2));
            })[0];
        if (!tmpObj.isTeam(player)) {
            tmpDir = UTILS.getDirect(player, tmpObj, 2, 2);
            if (UTILS.getAngleDist(tmpDir, dir) <= 0.2) {
                tmpObj.bowThreat[weaponIndex]++;
                if (index == 5) {
                    projectileCount++;
                }
                if (enemy) {
                    let enemyIndex = enemy.index;
                    if (index == 1 || index == 2 || index == 3 || index == 5 || index == 13 || index == 14 || index == 15) {
                        player.shooting[53] = 1;
                        setTimeout(() => {
                            player.shooting[53] = 0;
                        }, range / speed);
                    }

                    player.bowThreat[index]++;
                    setTimeout(() => {
                        player.bowThreat[index]--;
                    }, range / speed);
                }
                if (tmpObj.bowThreat[9] >= 1 && (tmpObj.bowThreat[12] >= 1 || tmpObj.bowThreat[15] >= 1)) {
                    place(3, tmpObj.aim2);
                    buyEquip(6, 0);
                    my.anti0Tick = 4;
                    if (!my.antiSync) {
                        antiSyncHealing(4);
                        packet("9", tmpObj.aim2 + 3.1415926535897932 / 2, 1)
                        game.tickBase(() => {
                            packet("9", undefined, 1)
                        }, 2)
                    }
                }
            } else {
                if (near.dist2 < 550) {
                    if (projectileCount >= 2) {
                        place(3, tmpObj.aim2);
                        packet("9", tmpObj.aim2 + 3.1415926535897932 / 2, 1)
                        my.anti0Tick = 4;
                        predictHeal(2)
                        game.tickBase(() => {
                            packet("9", undefined, 1)
                        }, 4)
                        if (!my.antiSync) {
                            antiSyncHealing(4);
                        }
                    } else {
                        if (projectileCount === 1 && near.reloads[near.weapons[0]] == 0 && near.dist2 < items.weapons[near.weapons[0]].range + player.scale * 1.8) {
                            buyEquip(6, 0);
                            buyEquip(21, 1);
                            let shotWeapon = false;
                            let shootingAlly = false;
                            if (player.team) {
                                let nearAllies = enemy.filter((e) => e.team == player.team);
                                for (let i = 0; i < nearAllies.length; i++) {
                                    let tmp = nearAllies[i];
                                    if (tmp.sid == player.sid) return;
                                    if (
                                        UTILS.getAngleDist(UTILS.getDirect(tmp, tmpObj, 2, 2), dir) <=
                                        Math.PI / 2
                                    ) {
                                        shootingAlly = true;
                                        tmp.shootingAlly = true;
                                    }
                                }
                            }
                            if (
                                UTILS.getAngleDist(UTILS.getDirect(player, tmpObj, 2, 2), dir) <=
                                Math.PI / 2
                            ) {
                                if (weaponIndex == 9) {
                                    tmpObj.bowThreat++;
                                    game.tickBase(() => {
                                        tmpObj.bowThreat--;
                                    }, 5);
                                } else if (weaponIndex == 12 && tmpObj.bowThreat > 0) {
                                    tmpObj.bowThreat = 0;
                                    if (player.weapons[1] == 11) {
                                        selectWeapon(11);
                                        noWep = true;
                                        packet("D", tmpObj.aim2, "shield");
                                        my.noAim = true;
                                        game.tickBase(() => {
                                            noWep = false;
                                            selectWeapon(player.weapons[0]);
                                            my.noAim = false;
                                        }, 6);
                                    } else {
                                        checkPlace(3, tmpObj.aim2);
                                        my.anti0Tick = 4;
                                    }
                                } else if (weaponIndex == 15 && tmpObj.bowThreat > 0) {
                                    tmpObj.bowThreat = 0;
                                    if (player.weapons[1] == 11) {
                                        selectWeapon(11);
                                        noWep = true;
                                        packet("D", tmpObj.aim2, "shield");
                                        my.noAim = true;
                                        game.tickBase(() => {
                                            noWep = false;
                                            selectWeapon(player.weapons[0]);
                                            my.noAim = false;
                                        }, 6);
                                    } else {
                                        checkPlace(3, tmpObj.aim2);
                                        my.anti0Tick = 4;
                                    }
                                }
                                if ([9, 15, 13, 12].includes[weaponIndex]) {
                                    shotWeapon = true;
                                    projectileCount++;
                                    game.tickBase(() => {
                                        projectileCount--;
                                    }, 5)
                                }
                                if (projectileCount >= 2) {
                                    if (player.weapons[1] == 11) {
                                        selectWeapon(11);
                                        noWep = true;
                                        packet("D", tmpObj.aim2, "shield");
                                        my.noAim = true;
                                        game.tickBase(() => {
                                            noWep = false;
                                            selectWeapon(player.weapons[0]);
                                            my.noAim = false;
                                        }, 6);
                                    } else {
                                        checkPlace(3, tmpObj.aim2);
                                        my.anti0Tick = 4;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    function showItemInfo(item, isWeapon, isStoreItem) {
        if (player && item) {
            UTILS.removeAllChildren(itemInfoHolder);
            itemInfoHolder.classList.add("visible");
            UTILS.generateElement({
                id: "itemInfoName",
                text: UTILS.capitalizeFirst(item.name),
                parent: itemInfoHolder
            });
            UTILS.generateElement({
                id: "itemInfoDesc",
                text: item.desc,
                parent: itemInfoHolder
            });
            if (isStoreItem) {

            } else if (isWeapon) {
                UTILS.generateElement({
                    class: "itemInfoReq",
                    text: !item.type ? "primary" : "secondary",
                    parent: itemInfoHolder
                });
            } else {
                for (let i = 0; i < item.req.length; i += 2) {
                    UTILS.generateElement({
                        class: "itemInfoReq",
                        html: item.req[i] + "<span class='itemInfoReqVal'> x" + item.req[i + 1] + "</span>",
                        parent: itemInfoHolder
                    });
                }
                if (item.group.limit) {
                    UTILS.generateElement({
                        class: "itemInfoLmt",
                        text: (player.itemCounts[item.group.id] || 0) + "/" + (config.isSandbox ? 99 : item.group.limit),
                        parent: itemInfoHolder
                    });
                }
            }
        } else {
            itemInfoHolder.classList.remove("visible");
        }
    }

    window.addEventListener("resize", UTILS.checkTrusted(resize));

    function resize() {
        screenWidth = window.innerWidth;
        screenHeight = window.innerHeight;
        let scaleFillNative = Math.max(screenWidth / maxScreenWidth, screenHeight / maxScreenHeight) * pixelDensity;
        gameCanvas.width = screenWidth * pixelDensity;
        gameCanvas.height = screenHeight * pixelDensity;
        gameCanvas.style.width = screenWidth + "px";
        gameCanvas.style.height = screenHeight + "px";
        mainContext.setTransform(
            scaleFillNative, 0,
            0, scaleFillNative,
            (screenWidth * pixelDensity - (maxScreenWidth * scaleFillNative)) / 2,
            (screenHeight * pixelDensity - (maxScreenHeight * scaleFillNative)) / 2
        );
    }
    resize();

    var usingTouch;
    const mals = document.getElementById('touch-controls-fullscreen');
    mals.style.display = 'block';
    mals.addEventListener("mousemove", gameInput, false);

    function gameInput(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    }
    let clicks = {
        left: false,
        middle: false,
        right: false,
    };
    mals.addEventListener("mousedown", mouseDown, false);

    function mouseDown(e) {
        if (attackState != 1) {
            attackState = 1;
            if (e.button == 0) {
                clicks.left = true;
            } else if (e.button == 1) {
                clicks.middle = true;
            } else if (e.button == 2) {
                clicks.right = true;
            }
        }
    }
    mals.addEventListener("mouseup", UTILS.checkTrusted(mouseUp));

    function mouseUp(e) {
        if (attackState != 0) {
            attackState = 0;
            if (e.button == 0) {
                clicks.left = false;
            } else if (e.button == 1) {
                clicks.middle = false;
            } else if (e.button == 2) {
                clicks.right = false;
            }
        }
    }
    mals.addEventListener("wheel", wheel, false);

    function wheel(e) {
        if (player.shameCount > 1) {
            buyEquip(7, 0);
        } else {
            buyEquip(0, 0);
        }
    }


    function getMoveDir() {
        let dx = 0;
        let dy = 0;
        for (let key in moveKeys) {
            let tmpDir = moveKeys[key];
            dx += !!keys[key] * tmpDir[0];
            dy += !!keys[key] * tmpDir[1];
        }
        return dx == 0 && dy == 0 ? undefined : Math.atan2(dy, dx);
    }

    function getSafeDir() {
        if (!player) return 0;
        if (!player.lockDir) {
            lastDir = Math.atan2(mouseY - (screenHeight / 2), mouseX - (screenWidth / 2));
        }
        return lastDir || 0;
    }

    let plusDir = 0;
    let lastSpin = Date.now();
    let spinDir = 0;

    function getAttackDir() {
        if (!player) return 0;

        const primaryWeapon = player.weapons[0];
        const secondaryWeapon = player.weapons[1];
        const primaryReload = player.reloads[primaryWeapon];
        const secondaryReload = player.reloads[secondaryWeapon];

        function getBestTargetDirection() {
            return enemy.length ? near.aim2 : getSafeDir();
        }

        if ((my.autoAim || (clicks.left && aimleft)) && primaryReload === 0) {
            lastDir = getBestTargetDirection();
        } else if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0) {
            lastDir = getSafeDir();
        } else if (traps.inTrap) {
            lastDir = traps.aim;
        } else {
            if (autoSpin) {
                // Hesaplanan hzl spin as, 5 kat hzlandrlm (ayarlayabilirsiniz)
                let fastSpin = (game.tick * (9 * Math.PI / config.serverUpdateRate) * 9) % (9 * Math.PI);
                // Server'a hzl spin asn gnderiyoruz:
                packet("", 1, fastSpin);
                // Yerel grnm iin normal (sabit) yn:
                lastDir = getSafeDir();
            } else if (!player.lockDir) {
                lastDir = getSafeDir();
            }
        }

        lastDir = smoothTransition(lastDir);
        return lastDir;
    }

    function smoothTransition(targetDir) {
        const smoothingFactor = 0.1;
        return (1 - smoothingFactor) * lastDir + smoothingFactor * targetDir;
    }

    function getVisualDir() {
        if (!player) {
            return 0;
        }
        lastDir = getSafeDir();
        return lastDir || 0;
    }

    function keysActive() {
        return (allianceMenu.style.display != "block" &&
            chatHolder.style.display != "block");
    }
    let follow = (ang) => {
        packet("9", ang)
    }
    let nerpl = () => {
        let dist = 10000;
        let ind = 0;
        for (let i = 0; i < players.length; i++) {
            let ds = Math.sqrt(Math.pow(players[i].x - player.x, 2) + Math.pow(players[i].y - player.y, 2));
            if (ds < dist) {
                ind = i;
                dist = ds;
            };
        }
        return [dist, players[ind]];
    }
    let myplayer = {
        x: null,
        y: null,
        id: null,
        weapon: 0,
        fs: 0,
        ms: 10,
        ss: 6,
        ts: 15,
        sec: 0,
        go: null,
        tur: 0,
        name: null,
        timepol: 885
    };
    let angle = 0;
    let boostspike = false;
    let spk = (ang) => {
        packet('z', myplayer.ss, null);
        place(ang);
        packet('z', myplayer.d, true);
    }
    let trap = (ang) => {
        packet('z', myplayer.ts, null);
        place(ang);
        packet('z', myplayer.d, true);
    }
    let throttleBoostSpike = 123; // PlaceThreadCount
    setInterval(() => {
        if (boostspike) {
            let nerplayer = nerpl();
            let dist = Math.sqrt(Math.pow(nerplayer[1].y - myplayer.y, 2) + Math.pow(nerplayer[1].x - myplayer.x, 2));

            follow(near.aim2);

            if (near.dist2 > 222) {
                place(4, near.aim2);
            }
            if (near.dist2 < 100) {
                place(2, near.aim2 - Math.PI / 2);
                place(2, near.aim2 + Math.PI / 2);
            }
            if (near.dist2 < 90) {
                place(2, near.aim2);
            }
            if (near.dist2 < 220) {
                place(2, near.aim2 - Math.PI / 2);
                place(2, near.aim2 + Math.PI / 2);
                place(2, near.aim2 + Math.PI);
            }
        }
    }, throttleBoostSpike);

    function toRad(a) {
        return a * (Math.PI / 180);
    }

    function insta() {
        my.autoAim = true;
        selectWeapon(player.weapons[0]);
        buyEquip(7, 0);
        buyEquip(18, 1);
        packet("F", 1, near.aim2);
        setTimeout(() => {
            buyEquip(53, 0);
            selectWeapon(player.weapons[1]);
        }, 93); // nceki 90 ms -> 95 ms
        setTimeout(() => {
            my.autoAim = false;
            buyEquip(0, 0);
            packet("F", 0, null);
        }, 202); // nceki 200 ms -> 205 ms
    }
    let faw = 0;
    const rw = ["Omgy Recording.", "Sub To Omgy", "Omgy Recording..", "Sub To Omgy", "Omgy Recording"];
    const gfdsd = [5000, 5000, 5000, 5000, 5000];

    function gfds() {
        const wqe = rw[faw];
        const tre = gfdsd[faw];
        sendChat(wqe);
        faw = (faw + 1) % rw.length;
        setTimeout(gfds, tre);
    }

    const rdas = () => {
        faw = 0;
        setTimeout(() => {
            gfds();
        }, 1);
    }

    function keyDown(event) {
        let keyNum = event.which || event.keyCode || 0;
        if (player && player.alive && keysActive()) {
            if (!keys[keyNum]) {
                keys[keyNum] = 1;
                macro[event.key] = 1;
                if (event.key === "j") {
                    rdas = !rdas;
                } else if (keyNum == 69) {
                    sendAutoGather();
                } else if (keyNum == 67) {
                    updateMapMarker();
                } else if (event.key === ".") {
                    boostspike = true;
                } else if (event.key == "b") {
                    if (player.items[4] == 16 && player.reloads[player.weapons[1]] == 0 || player.reloads[player.weapons[0]] == 0) {
                        selectWeapon(player.weapons[1] == 10 ? 10 : player.weapons[0]);
                        place(4, buyEquip(40, 0));
                        buyEquip(11, 1);
                        packet("F", 1);
                        sendAutoGather();
                        game.tickBase(() => {
                            buyEquip(6, 0);
                            sendAutoGather();
                            packet("F", 0, null);
                        }, 1);
                    }
                } else if (event.key == "g") {
                    place(2, near.aim2 + toRad(45));
                    place(2, near.aim2 - toRad(45));
                    selectWeapon(player.weapons[0]);
                    buyEquip(7, 0);
                    buyEquip(18, 1);
                    sendAutoGather();
                    game.tickBase(() => {
                        selectWeapon(player.weapons[0]);
                        buyEquip(53, 0);
                        game.tickBase(() => {
                            sendAutoGather();
                            my.autoAim = false;
                        }, 1);
                    }, 1);
                } else if (event.key == "x") {
                    place(2, near.aim2);
                    selectWeapon(player.weapons[0]);
                    buyEquip(7, 0);
                    buyEquip(18, 1);
                    sendAutoGather();
                    game.tickBase(() => {
                        selectWeapon(player.weapons[0]);
                        buyEquip(53, 0);
                        game.tickBase(() => {
                            sendAutoGather();
                            my.autoAim = false;
                        }, 1);
                    }, 1);
                } else if (player.weapons[keyNum - 49] != undefined) {
                    player.weaponCode = player.weapons[keyNum - 49];
                } else if (moveKeys[keyNum]) {
                    sendMoveDir();
                } else if (event.key == "r") {
                    insta();
                } else if (event.key == "Z") {
                    typeof window.debug == "function" && window.debug();
                } else if (keyNum == 32) {
                    packet("F", 1, getSafeDir(), 1);
                    packet("F", 0, getSafeDir(), 1);
                }
            }
        }
    }

    addEventListener("keydown", UTILS.checkTrusted(keyDown));

    function keyUp(event) {
        if (player && player.alive) {
            let keyNum = event.which || event.keyCode || 0;
            if (keysActive()) {
                if (keys[keyNum]) {
                    keys[keyNum] = 0;
                    macro[event.key] = 0;
                    if (moveKeys[keyNum]) {
                        sendMoveDir();
                    } else if (event.key == ".") {
                        boostspike = false;
                    } else if (event.key == ",") {
                        player.sync = false;
                    }
                }
            }
        }
    }


    window.addEventListener("keyup", UTILS.checkTrusted(keyUp));

    function sendMoveDir() {
        let newMoveDir = getMoveDir();
        if (lastMoveDir == undefined || newMoveDir == undefined || Math.abs(newMoveDir - lastMoveDir) > 0.3) {
            packet("9", newMoveDir, 1);
            lastMoveDir = newMoveDir;
        }
    }

    function setInitData(data) {
        alliances = data.teams;
    }

    function setupGame(yourSID) {
        keys = {};
        macro = {};
        playerSID = yourSID;
        attackState = 0;
        inGame = true;
        packet("F", 0, getAttackDir(), 1);
        my.ageInsta = true;
        if (firstSetup) {
            firstSetup = false;
            gameObjects.length = 0;
            closeObjects.length = 0;
        }
    }

    let originalName = null;

    function addPlayer(data, isYou) {
        let tmpPlayer = findPlayerByID(data[0]);
        if (!tmpPlayer) {
            tmpPlayer = new Player(data[0], data[1], config, UTILS, projectileManager,
                objectManager, players, ais, items, hats, accessories);
            players.push(tmpPlayer);
        }
        tmpPlayer.spawn(isYou ? true : null);
        tmpPlayer.visible = false;
        tmpPlayer.oldPos = {
            x2: undefined,
            y2: undefined
        };
        tmpPlayer.x2 = undefined;
        tmpPlayer.y2 = undefined;
        tmpPlayer.x3 = undefined;
        tmpPlayer.y3 = undefined;
        tmpPlayer.setData(data);
        if (isYou) {
            player = tmpPlayer;
            camX = player.x;
            camY = player.y;
            originalName = player.name;
            my.lastDir = 0;
            updateItems();
            updateAge();
            if (player.skins[7]) {
                my.reSync = true;
            }
        }
    }

    function removePlayer(id) {
        for (let i = 0; i < players.length; i++) {
            if (players[i].id == id) {
                players.splice(i, 1);
                break;
            }
        }
    }

    function killPlayer(sid) {
        inGame = false;
        lastDeath = {
            x: player.x,
            y: player.y,
        };
    }

    function updateItemCounts(index, value) {
        if (player) {
            player.itemCounts[index] = value;
        }
    }

    function updateAge(xp, mxp, age) {
        if (xp != undefined) {
            player.XP = xp;
        }
        if (mxp != undefined) {
            player.maxXP = mxp;
        }
        if (age != undefined) {
            player.age = age;
        }
    }

    function updateUpgrades(points, age) {
        player.upgradePoints = points;
        player.upgrAge = age;
        if (points > 0) {
            tmpList.length = 0;
            UTILS.removeAllChildren(upgradeHolder);
            for (let i = 0; i < items.weapons.length; ++i) {
                if (items.weapons[i].age == age && (items.weapons[i].pre == undefined || player.weapons.indexOf(items.weapons[i].pre) >= 0)) {
                    let e = UTILS.generateElement({
                        id: "upgradeItem" + i,
                        class: "actionBarItem",
                        onmouseout: function() {
                            showItemInfo();
                        },
                        parent: upgradeHolder
                    });
                    e.style.backgroundImage = getEl("actionBarItem" + i)
                        .style.backgroundImage;
                    tmpList.push(i);
                }
            }
            for (let i = 0; i < items.list.length; ++i) {
                if (items.list[i].age == age && (items.list[i].pre == undefined || player.items.indexOf(items.list[i].pre) >= 0)) {
                    let tmpI = (items.weapons.length + i);
                    let e = UTILS.generateElement({
                        id: "upgradeItem" + tmpI,
                        class: "actionBarItem",
                        onmouseout: function() {
                            showItemInfo();
                        },
                        parent: upgradeHolder
                    });
                    e.style.backgroundImage = getEl("actionBarItem" + tmpI)
                        .style.backgroundImage;
                    tmpList.push(tmpI);
                }
            }
            for (let i = 0; i < tmpList.length; i++) {
                (function(i) {
                    let tmpItem = getEl('upgradeItem' + i);
                    tmpItem.onmouseover = function() {
                        if (items.weapons[i]) {
                            showItemInfo(items.weapons[i], true);
                        } else {
                            showItemInfo(items.list[i - items.weapons.length]);
                        }
                    };
                    tmpItem.onclick = UTILS.checkTrusted(function() {
                        packet("H", i);
                    });
                    UTILS.hookTouchEvents(tmpItem);
                })(tmpList[i]);
            }
            if (tmpList.length) {
                upgradeHolder.style.display = "block";
                upgradeCounter.style.display = "block";
                upgradeCounter.innerHTML = "SELECT ITEMS (" + points + ")";
            } else {
                upgradeHolder.style.display = "none";
                upgradeCounter.style.display = "none";
                showItemInfo();
            }
        } else {
            upgradeHolder.style.display = "none";
            upgradeCounter.style.display = "none";
            showItemInfo();
        }
    }

    const killObject = (sid) => {
        const findObj = findObjectBySid(sid);
        objectManager.disableBySid(sid);

        if (!player) return;

        const index = breakObjects.findIndex(obj => obj.sid === sid);
        if (index !== -1) {
            breakObjects.splice(index, 1);
        }

        if (near.dist2 <= 300) traps.replacer(findObj);
    };

    function killObjects(sid) {
        if (player) objectManager.removeAllItems(sid);
    }

    function caf(e, t) {
        try {
            return Math.atan2((t.y2 || t.y) - (e.y2 || e.y), (t.x2 || t.x) - (e.x2 || e.x));
        } catch (e) {
            return 0;
        }
    }

    let found = false;
    let autoQ = false;

    let autos = {
        insta: {
            todo: false,
            wait: false,
            count: 4,
            shame: 5
        },
        bull: false,
        antibull: 0,
        reloaded: false,
        stopspin: true
    }

    function isInTrap(plyr) {
        return liztobj
            .filter(
                (e) =>
                e.trap &&
                e.active &&
                UTILS.getDist(e, plyr, 0, 2) <= 35 + e.getScale() + 5 &&
                !e.isTeamObject(plyr)
            )
            .sort(function(a, b) {
                return UTILS.getDist(a, plyr, 0, 2) - UTILS.getDist(b, plyr, 0, 2);
            })[0];
    }

    function move(dir) {
        packet("9", dir, 1);
    }

    function setMove(dir) {
        move(dir);
        game.tickBase(() => {
            move(lastMoveDir || undefined);
        }, 1);
    }

    function updatePlayers(data, x, y, value) {
        game.tick++;
        enemy = [];
        nears = [];
        near = [];
        game.tickSpeed = performance.now() - game.lastTick;
        game.lastTick = performance.now();
        players.forEach((tmp) => {
            tmp.forcePos = !tmp.visible;
            tmp.visible = false;
            if ((tmp.timeHealed - tmp.timeDamaged) > 0 && tmp.lastshamecount < tmp.shameCount) {
                tmp.pinge = (tmp.timeHealed - tmp.timeDamaged);
            }
        });
        for (let i = 0; i < data.length;) {
            tmpObj = findPlayerBySID(data[i]);
            if (tmpObj) {
                tmpObj.t1 = (tmpObj.t2 === undefined) ? game.lastTick : tmpObj.t2;
                tmpObj.t2 = game.lastTick;
                tmpObj.oldPos.x2 = tmpObj.x2;
                tmpObj.oldPos.y2 = tmpObj.y2;
                tmpObj.x1 = tmpObj.x;
                tmpObj.y1 = tmpObj.y;
                tmpObj.x2 = data[i + 1];
                tmpObj.y2 = data[i + 2];
                tmpObj.x3 = tmpObj.x2 + (tmpObj.x2 - tmpObj.oldPos.x2);
                tmpObj.y3 = tmpObj.y2 + (tmpObj.y2 - tmpObj.oldPos.y2);
                tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 3] : tmpObj.d2;
                tmpObj.d2 = data[i + 3];
                tmpObj.dt = 0;
                tmpObj.buildIndex = data[i + 4];
                tmpObj.weaponIndex = data[i + 5];
                tmpObj.weaponVariant = data[i + 6];
                tmpObj.team = data[i + 7];
                tmpObj.isLeader = data[i + 8];
                tmpObj.oldSkinIndex = tmpObj.skinIndex;
                tmpObj.oldTailIndex = tmpObj.tailIndex;
                tmpObj.skinIndex = data[i + 9];
                tmpObj.tailIndex = data[i + 10];
                tmpObj.iconIndex = data[i + 11];
                tmpObj.zIndex = data[i + 12];
                tmpObj.visible = true;
                tmpObj.update(game.tickSpeed);
                tmpObj.dist2 = UTILS.getDist(tmpObj, player, 2, 2);
                tmpObj.aim2 = UTILS.getDirect(tmpObj, player, 2, 2);
                tmpObj.dist3 = UTILS.getDist(tmpObj, player, 3, 3);
                tmpObj.aim3 = UTILS.getDirect(tmpObj, player, 3, 3);

                tmpObj.damageThreat = 0;

                if (tmpObj.skinIndex == 45 && tmpObj.shameTimer <= 0) {
                    tmpObj.addShameTimer();
                }
                if (tmpObj.oldSkinIndex == 45 && tmpObj.skinIndex != 45) {
                    tmpObj.shameTimer = 0;
                    tmpObj.shameCount = 0;
                    if (tmpObj == player) {
                        healer();
                    }
                }

                if (player.shameCount < 4 && near.dist3 <= 300 && near.reloads[near.primaryIndex] <= game.tickRate * (window.pingTime >= 130 ? 2 : 1)) {
                    autoQ = true;
                    healer();
                } else {
                    if (autoQ) {
                        healer();
                    }
                    autoQ = false;
                }
                let nearTrap = isInTrap(tmpObj);
                if (nearTrap) {
                    tmpObj.trapped = true;
                    tmpObj.inTrap = nearTrap;
                    tmpObj.trapInfo2 = nearTrap;
                    tmpObj.trapAim = UTILS.getDirect(nearTrap, tmpObj, 0, 2);
                    tmpObj.trapClear = false;
                } else {
                    tmpObj.trapped = false;
                    tmpObj.inTrap = undefined;
                    tmpObj.trapAim = undefined;
                    if (!tmpObj.trapClear) {
                        game.tickBase(() => {
                            tmpObj.trapInfo2 = undefined;
                            tmpObj.trapClear = true;
                        }, 1);
                    }
                }
                if (tmpObj == player) {
                    if (closeObjects.length) {
                        let nearTrap = closeObjects.filter(e => e.trap && e.active && UTILS.getDist(e, tmpObj, 0, 2) <= (tmpObj.scale + e.getScale() + 5) && !e.isTeamObject(tmpObj))
                            .sort(function(a, b) {
                                return UTILS.getDist(a, tmpObj, 0, 2) - UTILS.getDist(b, tmpObj, 0, 2);
                            })[0];
                        let trapSpike;

                        if (nearTrap) {
                            trapSpike = gameObjects.find(
                                (obj) => obj.dmg && cdf(tmpObj, obj) <= tmpObj.scale + obj.scale
                            );
                            let spike = gameObjects.filter(
                                (obj) =>
                                obj.dmg &&
                                cdf(tmpObj, obj) <= tmpObj.scale + nearTrap.scale / 2 &&
                                !obj.isTeamObject(tmpObj) &&
                                obj.active
                            )[0];

                            traps.dist = UTILS.getDist(nearTrap, tmpObj, 0, 2);
                            traps.aim = UTILS.getDirect(spike ? spike : nearTrap, tmpObj, 0, 2);

                            traps.protect(traps.aim);

                            traps.inTrap = true;
                            traps.info = nearTrap;
                        } else {
                            if (traps.inTrap && near.dist2 < 200) {
                                healer();
                            } else {
                                if (!trapClear) {
                                    game.tickBase(() => {
                                        trapClear = true;
                                    }, 1);
                                }
                                traps.inTrap = false;
                                traps.info = {};
                            }
                        }
                    } else {
                        if (!trapClear) {
                            game.tickBase(() => {
                                trapClear = true;
                            }, 1);
                        }
                        traps.inTrap = false;
                        traps.info = {};
                    }
                }


                if (tmpObj.weaponIndex < 9) {
                    tmpObj.primaryIndex = tmpObj.weaponIndex;
                    tmpObj.primaryVariant = tmpObj.weaponVariant;
                } else if (tmpObj.weaponIndex > 8) {
                    tmpObj.secondaryIndex = tmpObj.weaponIndex;
                    tmpObj.secondaryVariant = tmpObj.weaponVariant;
                }
            }
            i += 13;
        }

        if (runAtNextTick.length) {
            runAtNextTick.forEach((tmp) => {
                checkProjectileHolder(...tmp);
            });
            runAtNextTick = [];
        }
        for (let i = 0; i < data.length;) {
            tmpObj = findPlayerBySID(data[i]);
            if (tmpObj) {
                if (!tmpObj.isTeam(player)) {
                    enemy.push(tmpObj);
                    if (tmpObj.dist2 <= items.weapons[tmpObj.primaryIndex == undefined ? 5 : tmpObj.primaryIndex].range + (player.scale * 2)) {
                        nears.push(tmpObj);
                    }
                }
                tmpObj.manageReload();
                if (tmpObj != player) {
                    tmpObj.addDamageThreat(player);
                }
            }
            i += 13;
        }
        turretEmp = 0;
        gameObjects.filter((e) => e.active && e.doUpdate)
            .forEach((tmp) => {
                if (tmp.shootted) {
                    tmp.shootted = 0;
                    tmp.shootReload = 2200 - config.tickRate;
                } else {
                    if (tmp.shootReload > 0) {
                        tmp.shootReload = Math.max(0, tmp.shootReload - config.tickRate);
                        if (tmp.shootReload <= 0) {
                            tmp.shootReload = 2200;
                        }
                    }
                    if (!tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 2) <= 735) {
                        turretEmp++;
                    }
                }
            });
        if (player && player.alive) {
            if (enemy.length) {
                near = enemy.sort(function(tmp1, tmp2) {
                    return tmp1.dist2 - tmp2.dist2;
                })[0];
            }
            if (game.tickQueue[game.tick]) {
                game.tickQueue[game.tick].forEach((action) => {
                    action();
                });
                game.tickQueue[game.tick] = null;
            }
            var antispiketicked = false
            if (advHeal.length) {
                advHeal.forEach((updHealth) => {
                    if (window.pingTime < 150) {
                        let sid = updHealth[0];
                        let value = updHealth[1];
                        let totalDamage = 100 - value
                        let damaged = updHealth[2];
                        tmpObj = findPlayerBySID(sid);
                        let bullTicked = false;
                        if (tmpObj && tmpObj.health <= 0) {
                            if (!tmpObj.death) {
                                tmpObj.death = true;
                                if (tmpObj != player) {}
                            }
                        }
                        if (tmpObj == player) {
                            if (tmpObj.skinIndex == 7 && (damaged == 5 || (tmpObj.latestTail == 13 && damaged == 2))) {
                                if (my.reSync) {
                                    my.reSync = false;
                                    tmpObj.setBullTick = true;
                                }
                                bullTicked = true;
                            }
                            if (inGame) {
                                let attackers = getAttacker(damaged);
                                let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg * soldierMult());
                                let includeSpikeDmgs = enemy.length ? !bullTicked && (gearDmgs.includes(damaged) && near.skinIndex == 11) : false;
                                let healTimeout = 140 - window.pingTime;
                                let dmg = 100 - player.health;
                                let safewalking = false
                                let slowHeal = function(timer, tickBase) {
                                    if (!tickBase) {
                                        setTimeout(() => {
                                            healer();
                                        }, timer);
                                    } else {
                                        game.tickBase(() => {
                                            healer()
                                        }, 2)
                                    }
                                }
                                if (configs.healingBeta) {
                                    if (enemy.length) {
                                        if ([0, 7, 8].includes(near.primaryIndex)) {
                                            if (damaged < 75) {
                                                slowHeal(healTimeout)
                                            } else {
                                                healer()
                                            }
                                        }
                                        let NearHasOneFrame = near.primaryVariant >= 1 && near.weapons[0] == 5
                                        let PolOrKat = player.weapons[0] === 4 || player.weapons[0] === 5
                                        let canSafeHitback = PolOrKat && !traps.inTrap && player.shameCount <= 4 && !NearHasOneFrame && !antispiketicked && !safewalking // && near.reloads[player.weapons[0]] == 0
                                        if (canSafeHitback && damaged >= 20 && near.dist2 <= 150 && (player.weapons[0] == 4 || player.weapons[0] == 3 || player.weapons[0] == 5) && player.skinIndex == 11 && player.reloads[player.weapons[1]] == 0 && player.reloads[player.weapons[0]] == 0) { //hitback
                                            healer();
                                        }
                                        if (player.weapons[1] == 11) {
                                            if ([15, 9, 12, 13].includes(near.secondaryIndex) && near.reloads[near.secondaryIndex] == 1) {
                                                if (damaged < 75) {
                                                    my.autoAim = true;
                                                    selectWeapon(player.weapons[1]);
                                                    slowHeal(healTimeout)
                                                    setTimeout(() => {
                                                        selectWeapon(player.weapons[0]);
                                                        my.autoAim = false;
                                                    }, 250);
                                                }
                                            }
                                        } else if (player.weapons[1] == 11) {
                                            if (near.skinIndex == 53) {
                                                my.autoAim = true;
                                                selectWeapon(player.weapons[1]);
                                                slowHeal(healTimeout)
                                                setTimeout(() => {
                                                    selectWeapon(player.weapons[0]);
                                                    my.autoAim = false;
                                                }, 250);
                                            }
                                        }
                                        if ([1, 2, 6].includes(near.primaryIndex)) {
                                            if (damaged >= 25 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5) {
                                                healer()
                                            } else {
                                                slowHeal(healTimeout)
                                            }
                                        }
                                        if (near.primaryIndex == 5 && near.secondaryIndex == 10 && traps.inTrap && dmg >= 10 && near.reloads[near.primaryIndex] == 0) {
                                            healer()
                                        }
                                        if (near.primaryIndex == 3) {
                                            if (near.secondaryIndex == 15) {
                                                if (near.primaryVariant < 2) {
                                                    if (damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 6) {
                                                        tmpObj.canEmpAnti = true
                                                        healer()
                                                    } else {
                                                        slowHeal(healTimeout)
                                                    }
                                                } else {
                                                    if (damaged > 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 6 && game.tick - player.antiTimer > 1) {
                                                        tmpObj.canEmpAnti = true
                                                        tmpObj.antiTimer = game.tick
                                                        healer()
                                                    } else {
                                                        slowHeal(healTimeout)
                                                    }
                                                }
                                            } else {
                                                if (damaged >= 25 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 4) {
                                                    healer()
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            }
                                        }
                                        if (near.primaryIndex == 4) {
                                            if (near.primaryVariant >= 1) {
                                                if (damaged >= 10 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 4) {
                                                    healer()
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            } else {
                                                if (damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 3) {
                                                    healer()
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            }
                                        }
                                        if ([undefined, 5].includes(near.primaryIndex)) {
                                            if (near.secondaryIndex == 10) {
                                                if (dmg >= (includeSpikeDmgs ? 10 : 20) && tmpObj.damageThreat + dmg >= 80 && tmpObj.shameCount < 6) {
                                                    healer()
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            } else
                                            if (near.primaryVariant >= 2 || near.primaryVariant == undefined) {
                                                if (dmg >= (includeSpikeDmgs ? 15 : 20) && tmpObj.damageThreat + dmg >= 50 && tmpObj.shameCount < 6) {
                                                    healer()
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            } else
                                            if ([undefined || 15].includes(near.secondaryIndex)) {
                                                if (damaged > (includeSpikeDmgs ? 8 : 20) && player.damageThreat >= 25 && (game.tick - player.antiTimer) > 1) {
                                                    if (tmpObj.shameCount < 5) {
                                                        healer()
                                                    } else {
                                                        slowHeal(healTimeout)
                                                    }
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            } else
                                            if ([9, 12, 13].includes(near.secondaryIndex)) {
                                                if (dmg >= 25 && player.damageThreat + dmg >= 70 && tmpObj.shameCount < 6) {
                                                    healer()
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            } else {
                                                if (damaged > 25 && player.damageThreat + dmg >= 95) {
                                                    healer()
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            }
                                        }
                                        if (near.primaryIndex == 6) {
                                            if (near.secondaryIndex == 15) {
                                                if (damaged >= 25 && tmpObj.damageThreat + dmg >= 95 && tmpObj.shameCount < 4) {
                                                    healer()
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            } else {
                                                if (damaged >= 70 && tmpObj.shameCount < 4) {
                                                    healer()
                                                } else {
                                                    slowHeal(healTimeout)
                                                }
                                            }
                                        }
                                        if (damaged >= 30 && near.reloads[near.secondaryIndex] == 0 && near.dist2 <= 150 && player.skinIndex == 11 && player.tailIndex == 21) instaC.canCounter = true
                                    } else {
                                        if (damaged >= 70) {
                                            healer()
                                        } else {
                                            slowHeal(healTimeout)
                                        }
                                    }
                                } else {
                                    if (damaged >= (includeSpikeDmgs ? 8 : 25) && dmg + player.damageThreat >= 80 && (game.tick - player.antiTimer) > 1) {
                                        if (tmpObj.reloads[53] == 0 && tmpObj.reloads[tmpObj.weapons[1]] == 0) {
                                            tmpObj.canEmpAnti = true;
                                        } else {
                                            player.soldierAnti = true;
                                        }
                                        tmpObj.antiTimer = game.tick;
                                        let shame = [0, 4, 6, 7, 8].includes(near.primaryIndex) ? 2 : 5;
                                        if (tmpObj.shameCount < shame) {
                                            healer();
                                        } else {
                                            if (near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21))) {
                                                slowHeal(healTimeout)
                                            } else {
                                                slowHeal(healTimeout, 1)
                                            }
                                        }
                                    } else {
                                        if (near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21))) {
                                            slowHeal(healTimeout)
                                        } else {
                                            slowHeal(healTimeout, 1)
                                        }
                                    }
                                    if (damaged >= 25 && near.dist2 <= 140 && player.skinIndex == 11 && player.tailIndex == 21) instaC.canCounter = true
                                }
                            } else {
                                if (!tmpObj.setPoisonTick && (tmpObj.damaged == 5 || (tmpObj.latestTail == 13 && tmpObj.damaged == 2))) {
                                    tmpObj.setPoisonTick = true;
                                }
                            }
                        }
                    } else {
                        let [sid, value, damaged] = updHealth;
                        let totalDamage = 100 - value;
                        let tmpObj = findPlayerBySID(sid);
                        let bullTicked = false;

                        if (tmpObj == player) {
                            if (tmpObj.skinIndex == 7 && (damaged == 5 || (tmpObj.latestTail == 13 && damaged == 2))) {
                                if (my.reSync) {
                                    my.reSync = false;
                                    tmpObj.setBullTick = true;
                                    bullTicked = true;
                                }
                            }
                            if (inGame) {
                                let attackers = getAttacker(damaged);
                                let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg * soldierMult());
                                let includeSpikeDmgs = enemy.length ? !bullTicked && (gearDmgs.includes(damaged) && near.skinIndex == 11) : false;
                                let healTimeout = 60;
                                let dmg = 100 - player.health;
                                let shameCountThreshold = [2, 5][[0, 4, 6, 7, 8].includes(near.primaryIndex) ? 0 : 1];

                                let slowHeal = function(timer, tickBase) {
                                    if (!tickBase) setTimeout(() => healer(), timer);
                                    else game.tickBase(() => healer(), 2);
                                };

                                if (configs.healingBeta) {
                                    let canHealFast = [0, 7, 8].includes(near.primaryIndex) ? damaged < 75 : [1, 2, 6].includes(near.primaryIndex) ? damaged >= 25 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5 : [undefined, 5].includes(near.primaryIndex) ? dmg >= (includeSpikeDmgs ? 15 : 20) && tmpObj.damageThreat + dmg >= 50 && tmpObj.shameCount < 6 :
                                        near.primaryIndex == 3 && near.secondaryIndex == 15 ? damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 5 && game.tick - player.antiTimer > 1 :
                                        near.primaryIndex == 4 ? near.primaryVariant >= 1 ? damaged >= 10 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 4 :
                                        damaged >= 35 && player.damageThreat + dmg >= 95 && tmpObj.shameCount < 3 :
                                        near.primaryIndex == 6 && near.secondaryIndex == 15 ? damaged >= 25 && tmpObj.damageThreat + dmg >= 95 && tmpObj.shameCount < 4 :
                                        damaged >= 25 && player.damageThreat + dmg >= 95;

                                    canHealFast ? healer() : slowHeal(healTimeout);
                                } else {
                                    let canHealFast = damaged >= (includeSpikeDmgs ? 8 : 25) && dmg + player.damageThreat >= 80 && (game.tick - player.antiTimer) > 1;

                                    if (canHealFast) {
                                        if (tmpObj.reloads[53] == 0 && tmpObj.reloads[tmpObj.weapons[1]] == 0) tmpObj.canEmpAnti = true;
                                        else player.soldierAnti = true;
                                        tmpObj.antiTimer = game.tick;
                                        if (tmpObj.shameCount < shameCountThreshold) healer();
                                        else slowHeal(healTimeout, near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21)) ? 0 : 1);
                                    } else {
                                        slowHeal(healTimeout, near.primaryIndex == 7 || (player.weapons[0] == 7 && (near.skinIndex == 11 || near.tailIndex == 21)) ? 0 : 1);
                                    }
                                }
                            } else {
                                if (!tmpObj.setPoisonTick && (tmpObj.damaged == 5 || (tmpObj.latestTail == 13 && tmpObj.damaged == 2))) {
                                    tmpObj.setPoisonTick = true;
                                }
                            }
                        }
                    }
                });
                advHeal = [];
            }

            players.forEach((tmp) => {
                if (!tmp.visible && player != tmp) {
                    tmp.reloads = {
                        0: 0,
                        1: 0,
                        2: 0,
                        3: 0,
                        4: 0,
                        5: 0,
                        6: 0,
                        7: 0,
                        8: 0,
                        9: 0,
                        10: 0,
                        11: 0,
                        12: 0,
                        13: 0,
                        14: 0,
                        15: 0,
                        53: 0,
                    };
                }
                if (tmp.setBullTick) {
                    tmp.bullTimer = 0;
                }
                if (tmp.setPoisonTick) {
                    tmp.poisonTimer = 0;
                }
                tmp.updateTimer();
            });
            if (inGame) {
                if (enemy.length) {
                    let prehit = closeObjects.filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 3) <= (tmp.scale + near.scale))
                        .sort(function(a, b) {
                            return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                        })[0];
                    if (prehit) {
                        if (near.dist3 <= items.weapons[player.weapons[0]].range + player.scale * 1.8 && configs.predictTick) {
                            instaC.canSpikeTick = true;
                            instaC.syncHit = true;
                            if (configs.revTick && player.weapons[1] == 15 && player.reloads[53] == 0 && instaC.perfCheck(player, near)) {
                                instaC.revTick = true;
                            }
                        }
                    }

                    let antiSpikeTick = closeObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 3) < (tmp.scale + player.scale))
                        .sort(function(a, b) {
                            return UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2);
                        })[0];
                    if (antiSpikeTick && !traps.inTrap && trapClear) {
                        if (near.dist3 <= items.weapons[5].range + near.scale * 1.8) {
                            my.anti0Tick = 1;
                            Healing.inTrapHeal = true;
                        }
                    }
                }
                // Heal
                macro.q && (function() {
                    place(0, getAttackDir());
                    checkPlace(0, getAttackDir());
                })();

                // Boost pad
                macro.f && (function() {
                    place(4, getSafeDir());
                    checkPlace(4, getSafeDir());
                    game.tickBase(() => {
                        place(4, getSafeDir());
                        checkPlace(4, getSafeDir());
                    }, 1);
                })();

                // Spike
                macro.v && (function() {
                    place(2, getSafeDir());
                    checkPlace(2, getSafeDir());
                    game.tickBase(() => {
                        place(2, getSafeDir());
                        checkPlace(2, getSafeDir());
                    }, 1);
                })();

                // Trap
                macro.h && (function() {
                    place(5, getSafeDir());
                    checkPlace(5, getSafeDir());
                    game.tickBase(() => {
                        place(5, getSafeDir());
                        checkPlace(5, getSafeDir());
                    }, 1);
                })();

                // Windmill
                macro.n && (function() {
                    place(3, getSafeDir());
                    checkPlace(3, getSafeDir());
                    game.tickBase(() => {
                        place(3, getSafeDir());
                        checkPlace(3, getSafeDir());
                    }, 1);
                })();


                if (game.tick % 1 == 0 && lastMoveDir != undefined) {
                    if (mills.place) {
                        let plcAng = 7.7;
                        for (let i = -plcAng; i <= plcAng; i += plcAng) {
                            checkPlace(3, UTILS.getDirect(player.oldPos, player, 2, 2) + i);
                        }
                    } else {
                        if (mills.placeSpawnPads) {
                            for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                checkPlace(player.getItemType(20), UTILS.getDirect(player.oldPos, player, 2, 2) + i);
                            }
                        }
                    }
                }
                if (
                    instaC.wantZpyklerTick &&
                    (!evil ||
                        items.weapons[player.weapons[0]].dmg *
                        (player.skins[7] ? 1.5 : 1) *
                        sortWeaponVariant(player.primaryVariant) +
                        items.list[player.items[2]].dmg +
                        (game.tick % 9 <= 1 ? 5 : 0) <
                        100 ||
                        (!trapClear &&
                            traps.info.health <
                            (player.weapons[1] == 10 ?
                                75 :
                                items.weapons[player.weapons[0]].dmg) *
                            3.3 &&
                            player.reloads[player.weaponIndex] == 0) ||
                        traps.checkZpyklerTick())
                ) {
                    instaC.wantZpyklerTick = false;
                } else if (instaC.wantZpyklerTick) {
                    instaC.canZpykeTick = true;
                    instaC.wantZpyklerTick = false;
                }
                if (instaC.canZpykeTick && evil) {
                    instaC.canZpykeTick = false;
                    if ([1, 2, 3, 4, 5, 6].includes(player.weapons[0]) &&
                        player.reloads[player.weapons[0]] == 0 &&
                        !instaC.isTrue
                    ) {
                        instaC.zpyklerTickType();
                        if (instaC.syncHit) {}
                    }
                }
                if (instaC.canStackSpiketick) {
                    instaC.canStackSpiketick = false;
                    if ([1, 2, 3, 4, 5, 6].includes(player.weapons[0]) &&
                        player.reloads[player.weapons[0]] == 0 &&
                        !instaC.isTrue
                    ) {
                        instaC.spiketickOption();
                        if (instaC.syncHit) {}
                    }
                }
                if (autoinsta) {
                    const primaryWeapon = player.weapons[0];
                    const secondaryWeapon = player.weapons[1];
                    const inRange = near.dist2 <= items.weapons[primaryWeapon].range + player.scale * 1.8;
                    const isFullyReloaded = player.reloads[primaryWeapon] === 0 && player.reloads[secondaryWeapon] === 0 && player.reloads[53] == 0;

                    if (secondaryWeapon === 15 || secondaryWeapon === 9 || secondaryWeapon === 12 || secondaryWeapon === 13) {
                        if (isFullyReloaded && !clicks.right && inRange && secondaryWeapon !== 10 && near.skinIndex != 6) {
                            instaC.changeType((secondaryWeapon === 9 || secondaryWeapon === 12 || secondaryWeapon === 13) ? "rev" : "normal");
                        }
                    } else if (secondaryWeapon === 10 && ((primaryWeapon === 5 || primaryWeapon === 4))) {
                        if (isFullyReloaded && !clicks.right && inRange) {
                            instaC.changeType("normal");
                        }
                    }
                }

                function hitBull(angle, id) {
                    let antiBullTrue = configs.antiBull;
                    instaC.isTrue = true;
                    if (angle == near.aim2) {
                        my.autoAim = true;
                        game.tickBase(() => {
                            my.autoAim = false;
                        }, 2);
                    } else {
                        packet("D", angle, "hitBull");
                    }
                    selectWeapon(player.weapons[id]);
                    if (player.tailIndex == 11) {
                        buyEquip(19, 1);
                    } else {
                        buyEquip(7, 0);
                    }
                    sendAutoGather(2);
                    game.tickBase(() => {
                        packet("D", angle, "hitBull");
                        selectWeapon(player.weapons[id]);
                        instaC.isTrue = false;
                    }, 1);
                }
                let canSyncHit = false;
                if (
                    player.reloads[player.weapons[0]] != 0 ||
                    !near ||
                    near.dist2 > items.weapons[player.weapons[0]].range + 63
                ) {
                    canSyncHit = false;
                } else {
                    let _ = near;
                    let dmg = 0;
                    for (let j = 0; j < enemy.length; j++) {
                        let tmp = enemy[j];
                        if (tmp) {
                            if (tmp.sid == player.sid || tmp.sid == near.sid) continue;
                            if (
                                tmp.primaryIndex &&
                                tmp.canSync &&
                                (UTILS.getDist(tmp, near, 3, 3) <=
                                    items.weapons[tmp.primaryIndex].range + 63 ||
                                    UTILS.getDist(tmp, near, 2, 2) <=
                                    items.weapons[tmp.primaryIndex].range + 63)
                            ) {
                                dmg +=
                                    items.weapons[tmp.primaryIndex].dmg *
                                    sortWeaponVariant(tmp.primaryVariant) *
                                    1.5;
                            }
                        }
                    }
                    dmg +=
                        items.weapons[player.weapons[0]].dmg *
                        1.5 *
                        sortWeaponVariant(player.primaryVariant);
                    if (dmg * (_.skinIndex == 6 ? 0.75 : 1) >= 100) {
                        canSyncHit = true;
                    } else {
                        canSyncHit = false;
                    }
                }
                // autoHit:
                if (
                    autoSync &&
                    canSyncHit &&
                    (UTILS.getDist(player, near, 3, 3) <=
                        items.weapons[player.primaryIndex].range + 63 ||
                        UTILS.getDist(player, near, 2, 2) <=
                        items.weapons[player.primaryIndex].range + 63)
                ) {
                    player.chat.message = "Autosync";
                    player.chat.count = 2000;
                    hitBull(near.aim2, 0);
                }
                if (!instaC.isTrue) {
                    if (!clicks.middle && (clicks.left || clicks.right)) {
                        // Seili silah koru
                        let weapon = player.weaponIndex;

                        if (changeWeapon1) {
                            // CW1 modunda hi silah deiimi olmaz
                            // Mevcut silahta kal

                        } else if (changeWeapon) {
                            // Normal CW modu - sadece sa/sol tkla silah deiimi
                            if (clicks.right) {
                                // Secondary'de great hammer varsa ge
                                if (player.weapons[1] == 10) {
                                    weapon = player.weapons[1];
                                    selectWeapon(weapon);
                                } else {
                                    // Hammer yoksa primary'de kal
                                    weapon = player.weapons[0];
                                    selectWeapon(weapon);
                                }
                            } else if (clicks.left) {
                                weapon = player.weapons[0];
                                selectWeapon(weapon);
                            }
                        }

                        // Vuru ilemleri
                        if (player.reloads[weapon] == 0 && !my.waitHit) {
                            sendAutoGather();
                            my.waitHit = 1;
                            game.tickBase(() => {
                                sendAutoGather();
                                my.waitHit = 0;
                            }, 1);
                        }
                    } else if (traps.inTrap && autoBreak) {
                        let weapon = player.weapons[traps.notFast() ? 1 : 0];

                        if ((player.weaponIndex != weapon) || player.buildIndex > -1) {
                            selectWeapon(weapon);
                        }

                        if (player.reloads[weapon] == 0 && !my.waitHit) {
                            sendAutoGather();
                            my.waitHit = 1;
                            game.tickBase(() => {
                                sendAutoGather();
                                my.waitHit = 0;
                            }, 1);
                        }
                    } else {
                        if (clicks.middle && player.reloads[player.weapons[1]] == 0) {
                            // near dist > 400 for ticked eeeeeee
                            let checkCanTickBow = near.dist2 > 400 && player.reloads[53] == 0 && near.dist2 < 710;
                            if (my.ageInsta && player.weapons[0] != 4 && player.weapons[1] == 9 && player.age >= 9 && checkCanTickBow && enemy.length) {
                                instaC.rangeType("ageInsta");
                                setMove(near.aim2);
                            } else {
                                instaC.rangeType();
                            }
                        } else if (player.reloads[player.weapons[0]] == 0 && ([9, 12, 13, 15].includes(player.weapons[1]) ? (player.reloads[player.weapons[1]] == 0) : true)) {
                            if (macro.c) instaC.BoostOneTick();
                            if (macro[","]) instaC.boostTickMovement();
                        }

                        if (player.weapons[1]) {
                            if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0) {
                                if (!my.reloaded) {
                                    my.reloaded = true;

                                    // changeWeapon1 aktifse hi silah deiimi yapma
                                    if (changeWeapon1) {
                                        // Hibir ey yapma, mevcut silah koru
                                    }
                                    // changeWeapon false ise sadece hammer iin deiim yap
                                    else if (!changeWeapon) {
                                        if (player.weapons[1] == 10 && clicks.right) {
                                            if (player.weaponIndex != player.weapons[1]) {
                                                selectWeapon(player.weapons[1]); // Hammer'a ge
                                            }
                                        }
                                    }
                                    // Normal silah deiimi aktif (changeWeapon true)
                                    else {
                                        let fastSpeed = items.weapons[player.weapons[0]].spdMult < items.weapons[player.weapons[1]].spdMult ? 1 : 0;
                                        if (player.weaponIndex != player.weapons[fastSpeed] || player.buildIndex > -1) {
                                            selectWeapon(player.weapons[fastSpeed]);
                                        }
                                    }
                                }
                            } else {
                                my.reloaded = false;
                                if (player.reloads[player.weapons[0]] > 0) {
                                    if (player.weaponIndex != player.weapons[0] || player.buildIndex > -1) {
                                        selectWeapon(player.weapons[0]);
                                    }
                                } else if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] > 0) {
                                    if (player.weaponIndex != player.weapons[1] || player.buildIndex > -1) {
                                        selectWeapon(player.weapons[1]);
                                    }
                                }
                            }
                        }
                    }
                }
                if (!instaC.isTrue && !traps.inTrap) {
                    traps.autoPlace();
                }

                if (!macro.q && !macro.f && !macro.v && !macro.h && !macro.n) {
                    packet("D", getAttackDir());
                }

                const Hg = (hat, acc) => {
                    buyEquip(hat, 0);
                    buyEquip(acc, 1);
                };
                // hatchanger
                if (storeMenu.style.display != "block" && !instaC.isTrue && !instaC.ticking) {
                    let empAnti = player.empAnti || turretEmp > 0;
                    if (clicks.left || clicks.right) {
                        buyEquip(clicks.left ? 18 : 11, 1);
                    } else {
                        let d = (near.dist2 <= 300 || player.syncThreats >= 2);
                        let b = player.skinIndex == 26;
                        let e = near && d ? 21 : b ? 18 : 11;

                        buyEquip(e, 1);
                    }

                    let pri = player.weapons[0];
                    let sec = player.weapons[1];

                    if (my.anti0Tick > 0) {
                        buyEquip(hatLoop ? loopHats[loopIndex++] || bushHat : 0, 0);
                        buyEquip(21, 1);
                    } else if (aSheal && player.moveDir == undefined && Date.now() - player.moveTime > 1500 && player.health == 100 && Date.now() - player.lastHit > 1500 && Date.now() - player.lastGather > 1500) {
                        buyEquip((near.primaryIndex == 5 && near.reloads[near.weaponIndex] > 0 && near.reloads[near.weaponIndex] <= game.tickRate) ? 6 : 56, 0);
                        buyEquip(21, 1);
                        if (near.dist2 <= 320) {
                            if (near.reloads[53] == 0) {
                                buyEquip(6, 0);
                            }
                            let getAimToYou = UTILS.getDirect(player, near, 0, 2);
                            let isValidAim = getAimToYou && UTILS.getAngleDist(getAimToYou, near.dir) <= config.gatherAngle;
                            if (!my.safePrimary(near) && !my.safeSecondary(near) && near.primaryIndex === 5 && isValidAim) {
                                buyEquip(6, 0);
                            }
                        }
                    } else if (clicks.left || clicks.right) {
                        let anties = (hatLoop ? loopHats[loopIndex++] : 12, 0);
                        if (clicks.left) {
                            let id = player.reloads[pri] == 0 ? 7 : anties;

                            buyEquip(id, 0);
                            buyEquip(18, 1);
                        } else if (clicks.right) {
                            let wowok = player.weapons[sec == 10 ? 1 : 0];
                            let id = player.reloads[wowok] == 0 ? 40 : anties;

                            buyEquip(id, 0);
                        }
                    } else if (traps.inTrap) {
                        let weapon = player.weapons[sec === 10 ? 1 : 0];
                        let checkBreak = traps.info.health <= items.weapons[player.weaponIndex].dmg ? false : player.reloads[weapon] === 0;

                        if (checkBreak) {
                            buyEquip(40, 0);
                        } else if (traps.inTrap) {
                            if ([3, 4, 5].includes(near.primaryIndex) && near.dist2 <= 295) {
                                buyEquip(6, 0);
                            } else {
                                buyEquip((near.dist2 <= 300 && [3, 4, 5, 7].includes(near.primaryIndex) && [10, 9, 12, 13, 15].includes(near.secondaryIndex)) ? 6 : hatLoop ? loopHats[loopIndex++] : 26, 0);
                            }
                        } else {
                            if (((!enemy.length || near.dist2 >= 250) && player.shameCount > 0 && player.skinIndex != 45) || my.reSync) {
                                buyEquip(7, 0);
                                setTimeout(() => {
                                    buyEquip(hatLoop ? loopHats[loopIndex++] || bushHat : sendMoveDir ? 12 : config.snowBiomeTop ? 15 : 6, 0);
                                }, 100);
                            } else {
                                if (((!enemy.length || near.dist2 >= 250) && player.shameCount > 3 && player.skinIndex != 45) || my.reSync) {
                                    buyEquip(7, 0);
                                }
                            }
                        }
                    } else {
                        if (traps.inTrap && near.dist2 <= 285 && near.primaryIndex == 5) {
                            buyEquip(6, 0);
                        } else if (player.syncThreats >= 2) {
                            if ([4, 5, 3].includes(pri)) {
                                buyEquip(6, 0);
                                if (near.reloads[near.primaryIndex] == 0) {
                                    Healing.Antisync(2);
                                }
                            }
                        } else {
                            if ((player.shameCount > 0 && player.skinIndex != 45) || my.reSync) {
                                buyEquip(7, 0);
                                setTimeout(() => {
                                    buyEquip(hatLoop ? loopHats[loopIndex++] || bushHat : sendMoveDir ? 12 : config.snowBiomeTop ? 15 : 6, 0);
                                }, 100);
                            } else {
                                if (((!enemy.length || near.dist2 >= 250) && player.shameCount > 3 && player.skinIndex != 45) || my.reSync) {
                                    buyEquip(7, 0);
                                } else {
                                    if (player.empAnti || turretEmp) {
                                        buyEquip(22, 0);
                                    } else {
                                        if (near.dist2 <= 400) {
                                            let nearPri = near.primaryIndex;
                                            let checkPoleandKatana = [undefined, 5, 4].includes(nearPri);
                                            let findBarber = [6, 7, 8].includes(nearPri) ? 26 : 11;
                                            let id = checkPoleandKatana ? 6 : hatLoop ? loopHats[loopIndex++] : findBarber;
                                            buyEquip(id, 0);
                                        } else {
                                            biomeGear(1);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }


                if (instaC.ticking) {
                    instaC.ticking = false;
                }
                if (instaC.syncHit) {
                    instaC.syncHit = false;
                }
                if (player.empAnti) {
                    player.empAnti = false;
                }
                if (player.soldierAnti) {
                    player.soldierAnti = false;
                }
                if (my.anti0Tick > 0) {
                    my.anti0Tick--;
                }
                if (traps.replaced) {
                    traps.replaced = false;
                }
                if (traps.antiTrapped) {
                    traps.antiTrapped = false;
                }
            }
        }
    }

    const updateLeaderboard = (data) => {
        lastLeaderboardData = data;
        UTILS.removeAllChildren(leaderboardData);

        let tmpC = 1;
        for (let i = 0; i < data.length; i += 3) {
            const SID = data[i];
            const playerName = data[i + 1] || "unknown";
            const playerScore = UTILS.sFormat(data[i + 2]) || "0";

            const displayName = playerName.length > 15 ? "long name man" : playerName;

            const fragment = document.createDocumentFragment();
            const leaderHolder = UTILS.generateElement({
                class: "leaderHolder",
                children: [
                    UTILS.generateElement({
                        class: "leaderboardItem",
                        style: `color: ${playerSID === SID ? "#fff" : "rgba(255,255,255,0.6)"}`,
                        text: `${tmpC}. ${displayName}`
                    }),
                    UTILS.generateElement({
                        class: "leaderScore",
                        text: playerScore
                    })
                ]
            });
            fragment.appendChild(leaderHolder);
            leaderboardData.appendChild(fragment);

            tmpC++;
        }
    }

    function loadGameObject(data) {
        for (let i = 0; i < data.length;) {
            objectManager.add(data[i], data[i + 1], data[i + 2], data[i + 3], data[i + 4],
                data[i + 5], items.list[data[i + 6]], true, (data[i + 7] >= 0 ? {
                    sid: data[i + 7]
                } : null));
            i += 8;
        }
    }

    function loadAI(data) {
        for (let i = 0; i < ais.length; ++i) {
            ais[i].forcePos = !ais[i].visible;
            ais[i].visible = false;
        }
        if (data) {
            let tmpTime = performance.now();
            for (let i = 0; i < data.length;) {
                tmpObj = findAIBySID(data[i]);
                if (tmpObj) {
                    tmpObj.index = data[i + 1];
                    tmpObj.t1 = (tmpObj.t2 === undefined) ? tmpTime : tmpObj.t2;
                    tmpObj.t2 = tmpTime;
                    tmpObj.x1 = tmpObj.x;
                    tmpObj.y1 = tmpObj.y;
                    tmpObj.x2 = data[i + 2];
                    tmpObj.y2 = data[i + 3];
                    tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 4] : tmpObj.d2;
                    tmpObj.d2 = data[i + 4];
                    tmpObj.health = data[i + 5];
                    tmpObj.dt = 0;
                    tmpObj.visible = true;
                } else {
                    tmpObj = aiManager.spawn(data[i + 2], data[i + 3], data[i + 4], data[i + 1]);
                    tmpObj.x2 = tmpObj.x;
                    tmpObj.y2 = tmpObj.y;
                    tmpObj.d2 = tmpObj.dir;
                    tmpObj.health = data[i + 5];
                    if (!aiManager.aiTypes[data[i + 1]].name) tmpObj.name = config.cowNames[data[i + 6]];
                    tmpObj.forcePos = true;
                    tmpObj.sid = data[i];
                    tmpObj.visible = true;
                }
                i += 7;
            }
        }
    }

    function animateAI(sid) {
        tmpObj = findAIBySID(sid);
        if (tmpObj) tmpObj.startAnim();
    }

    function gatherAnimation(sid, didHit, index) {
        tmpObj = findPlayerBySID(sid);

        if (tmpObj) {
            tmpObj.startAnim(didHit, index);
            tmpObj.gatherIndex = index;
            tmpObj.gathering = 1;
            tmpObj.lastGather = Date.now();

            if (nears.filter(near => near.gathering)
                .length > 1) {
                healer();
            }

            if (didHit) {
                let tmpObjects = objectManager.hitObj;
                objectManager.hitObj = [];
                game.tickBase(() => {
                    tmpObj = findPlayerBySID(sid);
                    let val = items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1) * (tmpObj.skinIndex == 40 ? 3.3 : 1);
                    tmpObjects.forEach((healthy) => {
                        healthy.health -= val;
                    });
                }, 1);
            }
        }
    }

    function wiggleGameObject(dir, sid) {
        tmpObj = findObjectBySid(sid);
        if (tmpObj) {
            tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir);
            tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir);
            if (tmpObj.health) {
                objectManager.hitObj.push(tmpObj);
            }
        }
    }

    function shootTurret(sid, dir) {
        tmpObj = findObjectBySid(sid);
        if (tmpObj) {
            if (config.anotherVisual) {
                tmpObj.lastDir = dir;
            } else {
                tmpObj.dir = dir;
            }
            tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir + Math.PI);
            tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir + Math.PI);
        }
    }

    function updatePlayerValue(index, value, updateView) {
        if (player) {
            player[index] = value;
            if (index == "points") {
                if (autoBuying) {
                    autoBuy.hat();
                    autoBuy.acc();
                }
            } else if (index == "kills") {
                if (configs.killChat) {
                    if (!recording) {
                        sendChat("Another Human Player Dead");
                    }
                }
            }
        }
    }

    function updateItems(data, wpn) {
        if (data) {
            if (wpn) {
                player.weapons = data;
                player.primaryIndex = player.weapons[0];
                player.secondaryIndex = player.weapons[1];
                if (!instaC.isTrue) {
                    selectWeapon(player.weapons[0]);
                }
            } else {
                player.items = data;
            }
        }

        for (let i = 0; i < items.list.length; i++) {
            let tmpI = items.weapons.length + i;
            let actionBarItem = getEl("actionBarItem" + tmpI);
            actionBarItem.style.display = player.items.indexOf(items.list[i].id) >= 0 ? "inline-block" : "none";
        }

        for (let i = 0; i < items.weapons.length; i++) {
            let actionBarItem = getEl("actionBarItem" + i);
            actionBarItem.style.display = player.weapons[items.weapons[i].type] == items.weapons[i].id ? "inline-block" : "none";
        }

        let kms = player.weapons[0] == 3 && player.weapons[1] == 15;
        if (kms) {
            getEl("actionBarItem3")
                .style.display = "none";
            getEl("actionBarItem4")
                .style.display = "inline-block";
        }
    }

    function addProjectile(x, y, dir, range, speed, indx, layer, sid) {
        if (invisProjectile) {
            // Don't render if invisProjectile is enabled
            runAtNextTick.push(Array.prototype.slice.call(arguments));
        } else {
            projectileManager.addProjectile(x, y, dir, range, speed, indx, null, null, layer, inWindow)
                .sid = sid;
            runAtNextTick.push(Array.prototype.slice.call(arguments));
        }
    }

    function remProjectile(sid, range) {
        for (let i = 0; i < projectiles.length; ++i) {
            if (projectiles[i].sid == sid) {
                projectiles[i].range = range;
                let tmpObjects = objectManager.hitObj;
                objectManager.hitObj = [];
                game.tickBase(() => {
                    let val = projectiles[i].dmg;
                    tmpObjects.forEach((healthy) => {
                        if (healthy.projDmg) {
                            healthy.health -= val;
                        }
                    });
                }, 1);
            }
        }
    }

    function setPlayerTeam(team, isOwner) {
        if (player) {
            player.team = team;
            player.isOwner = isOwner;
            if (team == null) alliancePlayers = [];
        }
    }

    function setAlliancePlayers(data) {
        alliancePlayers = data;
    }

    function updateStoreItems(type, id, index) {
        if (index) {
            if (!type) player.tails[id] = 1;
            else {
                player.latestTail = id;
            }
        } else {
            if (!type) player.skins[id] = 1, id == 7 && (my.reSync = true);
            else {
                player.latestSkin = id;
            }
        }
    }

    const updateChatCmd = (tmpPlayer, message) => {
        if (player != tmpPlayer) return;

        const checkCmd = (name, real) => {
            let isWorryAbYouuu = real ? "enabled" : "disabled";
            setTimeout(() => {
                sendChat(`${name} ${isWorryAbYouuu}.`, privCmdInfoAfterCmd);
            }, 500);
        }

        let mainPrefix = ".t";
        let cmd = message.replace(mainPrefix, "");

        switch (cmd) {
            case " -cw":
                if (!changeWeapon1) { // Eer cw1 aktif deilse
                    changeWeapon = !changeWeapon;
                    checkCmd("WeaponSwitch[AI]", changeWeapon);
                } else {
                    // cw1 aktifse, cw aktif edilemez
                    sendChat("Cannot enable CW while CW1 is active", privCmdInfoAfterCmd);
                }
                break;

            case " -cw1":
                changeWeapon1 = !changeWeapon1;
                checkCmd("NoWeaponSwitch", changeWeapon1);
                if (changeWeapon1 && changeWeapon) {
                    // Eer cw1 aktif edilirse ve cw aktifse
                    setTimeout(() => {
                        changeWeapon = false; // cw'yi devre d brak
                        sendChat("Change Weapon disabled.", privCmdInfoAfterCmd);
                    }, 2000);
                }
                break;
            case " -hat":
                hatLoop = !hatLoop;
                checkCmd("HatLoop", hatLoop);
                break;
            case " -uah":
            case " -uheal":
                ultraHeal = !ultraHeal;

                if (ultraHeal) {
                    autoHealing = false;
                    aSheal = false;
                }
                checkCmd("UltraHeal", ultraHeal);
                break;
            case " -hl":
                hatLoop = !hatLoop;
                checkCmd("HatLoop", hatLoop);
                break;
            case " -st":
                slowTick = !slowTick;
                checkCmd("SlowTick", slowTick);
                break;
            case " -visual":
                WealthyMode = !WealthyMode;
                checkCmd("WealthyVisual", WealthyMode);
                break;
            case " -n ":
            case " -nh":
                nigthMode = !nigthMode;
                checkCmd("nigthMode", nigthMode);
                break;
            case " -ba":
                buggyArrow = !buggyArrow;
                checkCmd("buggyArrow", buggyArrow);
                break;
            case " -ai":
                autoinsta = !autoinsta;
                checkCmd("Autoinsta", autoinsta);
                break;
            case " -bb":
                buggyBoost = !buggyBoost;
                checkCmd("buggyBoost", buggyBoost);
                break;
            case " -priv":
                privCmdInfoAfterCmd = !privCmdInfoAfterCmd;
                checkCmd("PrivCmd", privCmdInfoAfterCmd);
                break;
            case " -bsp":
                optionboostTick = !optionboostTick;
                checkCmd("boostSpikeTick", optionboostTick);
                break;
            case " -p":
            case " -gp":
                invisProjectile = !invisProjectile;
                checkCmd("GhostProjectiles", invisProjectile);
                break;
            case " -aim":
                aimleft = !aimleft;
                checkCmd("LeftClickAim", aimleft);
                break;
            case " -bref":
                smothGhostyObjects = !smothGhostyObjects;
                checkCmd("Ghost Objects", smothGhostyObjects);
                break;
            case " -heal":
                autoHealing = !autoHealing;
                checkCmd("AutoHeal", autoHealing);
                break;
            case " -ah":
                autoHealing = !autoHealing;
                checkCmd("AutoHeal", autoHealing);
                break;
            case " -abs":
                antiBoostSpike = !antiBoostSpike;
                checkCmd("antiBoostSpike", antiBoostSpike);
                break;
            case " -placer":
                autoPlace = !autoPlace;
                checkCmd("autoPlace", autoPlace);
                break;
            case " -ap":
                autoPlace = !autoPlace;
                checkCmd("autoPlace", autoPlace);
                break;
            case " -le":
                safeAutoPlaceLegits = !safeAutoPlaceLegits;
                checkCmd("AutoPlaceLegit", safeAutoPlaceLegits);
                break;
            case " -sync":
                autoSync = !autoSync;
                checkCmd("autoSync", autoSync);
                break;
            case " -Safe":
                safeAutoPlace = !safeAutoPlace;
                checkCmd("safeAutoPlace", safeAutoPlace);
                break;
            case " -rep":
                autoReplace = !autoReplace;
                checkCmd("Replace", autoReplace);
                break;
            case " -mill":
            case " -am":
                mills.place = !mills.place;
                checkCmd("AutoTripleMill", mills.place);
                break;
            case " -hb":
                autoBuying = !autoBuying;
                checkCmd("AutoBuy", autoBuying);
                break;
            case " -ab":
                autoBreak = !autoBreak;
                checkCmd("AutoBreak", autoBreak);
                break;
            case " -sv":
                objRotate = !objRotate;
                checkCmd("RotateObjects", objRotate);
                break;
            case " -ro":
                objRotate = !objRotate;
                checkCmd("RotateObjects", objRotate);
                break;
            case " -as":
            case " -spin":
                autoSpin = !autoSpin;
                checkCmd("AutoPlayerSpin", autoSpin);
                break;
            case " -ag":
                aSheal = !aSheal;
                checkCmd("AssassinGearHeal", aSheal);
                break;
            case " -bush":
                bushHat = !bushHat;
                checkCmd("BushGear", bushHat);
                break;
            default:
                break;
        }
    };

    function receiveChat(sid, message) {
        let tmpPlayer = findPlayerBySID(sid);

        if (!tmpPlayer) return;

        tmpPlayer.chatMessage = message;
        tmpPlayer.chatCountdown = config.chatCountdown;

        updateChatCmd(tmpPlayer, message);
    }

    throttleBoostSpike

    function updateMinimap(data) {
        minimapData = data;
    }

    function showText(x, y, value, type) {
        let timeLife = WealthyMode ? 750 : 500;
        let size = WealthyMode ? 40 : 50;

        if (type === -1) {
            textManager.showText(x, y, size, 0.18, timeLife, value, "#ee5551");
        } else {
            let wowowiwn = WealthyMode ? "#cc5151" : "#fff";
            textManager.showText(x, y, size, 0.18, timeLife, Math.abs(value), (value >= 0) ? wowowiwn : "#8ecc51");
        }
    }

    // RENDER LEAF:
    function renderLeaf(x, y, l, r, ctxt) {
        let endX = x + (l * Math.cos(r));
        let endY = y + (l * Math.sin(r));
        let width = l * 0.4;
        ctxt.moveTo(x, y);
        ctxt.beginPath();
        ctxt.quadraticCurveTo(((x + endX) / 2) + (width * Math.cos(r + Math.PI / 2)),
            ((y + endY) / 2) + (width * Math.sin(r + Math.PI / 2)), endX, endY);
        ctxt.quadraticCurveTo(((x + endX) / 2) - (width * Math.cos(r + Math.PI / 2)),
            ((y + endY) / 2) - (width * Math.sin(r + Math.PI / 2)), x, y);
        ctxt.closePath();
        ctxt.fill();
        ctxt.stroke();
    }

    // RENDER CIRCLE:
    function renderCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
        tmpContext = tmpContext || mainContext;
        tmpContext.beginPath();
        tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
        if (!dontFill) tmpContext.fill();
        if (!dontStroke) tmpContext.stroke();
    }

    function renderHealthCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
        tmpContext = tmpContext || mainContext;
        tmpContext.beginPath();
        tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
        if (!dontFill) tmpContext.fill();
        if (!dontStroke) tmpContext.stroke();
    }

    // RENDER STAR SHAPE:
    function renderStar(ctxt, spikes, outer, inner) {
        let rot = Math.PI / 2 * 3;
        let x, y;
        let step = Math.PI / spikes;
        ctxt.beginPath();
        ctxt.moveTo(0, -outer);
        for (let i = 0; i < spikes; i++) {
            x = Math.cos(rot) * outer;
            y = Math.sin(rot) * outer;
            ctxt.lineTo(x, y);
            rot += step;
            x = Math.cos(rot) * inner;
            y = Math.sin(rot) * inner;
            ctxt.lineTo(x, y);
            rot += step;
        }
        ctxt.lineTo(0, -outer);
        ctxt.closePath();
    }

    function renderHealthStar(ctxt, spikes, outer, inner) {
        let rot = Math.PI / 2 * 3;
        let x, y;
        let step = Math.PI / spikes;
        ctxt.beginPath();
        ctxt.moveTo(0, -outer);
        for (let i = 0; i < spikes; i++) {
            x = Math.cos(rot) * outer;
            y = Math.sin(rot) * outer;
            ctxt.lineTo(x, y);
            rot += step;
            x = Math.cos(rot) * inner;
            y = Math.sin(rot) * inner;
            ctxt.lineTo(x, y);
            rot += step;
        }
        ctxt.lineTo(0, -outer);
        ctxt.closePath();
    }

    // RENDER RECTANGLE:
    function renderRect(x, y, w, h, ctxt, dontStroke, dontFill) {
        if (!dontFill) ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
        if (!dontStroke) ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
    }

    function renderHealthRect(x, y, w, h, ctxt, dontStroke, dontFill) {
        if (!dontFill) ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
        if (!dontStroke) ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
    }

    // RENDER RECTCIRCLE:
    function renderRectCircle(x, y, s, sw, seg, ctxt, dontStroke, dontFill) {
        ctxt.save();
        ctxt.translate(x, y);
        seg = Math.ceil(seg / 2);
        for (let i = 0; i < seg; i++) {
            renderRect(0, 0, s * 2, sw, ctxt, dontStroke, dontFill);
            ctxt.rotate(Math.PI / seg);
        }
        ctxt.restore();
    }

    // RENDER BLOB:
    function renderBlob(ctxt, spikes, outer, inner) {
        let rot = Math.PI / 2 * 3;
        let x, y;
        let step = Math.PI / spikes;
        let tmpOuter;
        ctxt.beginPath();
        ctxt.moveTo(0, -inner);
        for (let i = 0; i < spikes; i++) {
            tmpOuter = UTILS.randInt(outer + 0.9, outer * 1.2);
            ctxt.quadraticCurveTo(Math.cos(rot + step) * tmpOuter, Math.sin(rot + step) * tmpOuter,
                Math.cos(rot + (step * 2)) * inner, Math.sin(rot + (step * 2)) * inner);
            rot += step * 2;
        }
        ctxt.lineTo(0, -inner);
        ctxt.closePath();
    }

    // RENDER TRIANGLE:
    function renderTriangle(s, ctx) {
        ctx = ctx || mainContext;
        let h = s * (Math.sqrt(3) / 2);
        ctx.beginPath();
        ctx.moveTo(0, -h / 2);
        ctx.lineTo(-s / 2, h / 2);
        ctx.lineTo(s / 2, h / 2);
        ctx.lineTo(0, -h / 2);
        ctx.fill();
        ctx.closePath();
    }

    // PREPARE MENU BACKGROUND:
    function prepareMenuBackground() {
        let tmpMid = config.mapScale / 2;
        objectManager.add(0, tmpMid, tmpMid + 200, 0, config.treeScales[3], 0);
        objectManager.add(1, tmpMid, tmpMid - 480, 0, config.treeScales[3], 0);
        objectManager.add(2, tmpMid + 300, tmpMid + 450, 0, config.treeScales[3], 0);
        objectManager.add(3, tmpMid - 950, tmpMid - 130, 0, config.treeScales[2], 0);
        objectManager.add(4, tmpMid - 750, tmpMid - 400, 0, config.treeScales[3], 0);
        objectManager.add(5, tmpMid - 700, tmpMid + 400, 0, config.treeScales[2], 0);
        objectManager.add(6, tmpMid + 800, tmpMid - 200, 0, config.treeScales[3], 0);
        objectManager.add(7, tmpMid - 260, tmpMid + 340, 0, config.bushScales[3], 1);
        objectManager.add(8, tmpMid + 760, tmpMid + 310, 0, config.bushScales[3], 1);
        objectManager.add(9, tmpMid - 800, tmpMid + 100, 0, config.bushScales[3], 1);
        objectManager.add(10, tmpMid - 800, tmpMid + 300, 0, items.list[4].scale, items.list[4].id, items.list[10]);
        objectManager.add(11, tmpMid + 650, tmpMid - 390, 0, items.list[4].scale, items.list[4].id, items.list[10]);
        objectManager.add(12, tmpMid - 400, tmpMid - 450, 0, config.rockScales[2], 2);
    }

    // RENDER PLAYERS:
    function renderPlayers(xOffset, yOffset, zIndex) {
        mainContext.globalAlpha = 1;
        mainContext.fillStyle = "#91b2db";
        for (let i = 0; i < players.length; ++i) {
            let tmpObj = players[i];
            if (tmpObj.zIndex == zIndex) {
                tmpObj.animate(delta);
                if (tmpObj.visible) {
                    tmpObj.skinRot += 0.001 * delta;
                    tmpDir = !configs.showDir && tmpObj == player ? configs.attackDir ? getVisualDir() :
                        getSafeDir() :
                        tmpObj.dir || 0;
                    mainContext.save();

                    if (tmpObj.skinIndex == 10 && WealthyMode) {
                        mainContext.globalAlpha = .67;
                    } else {
                        mainContext.globalAlpha = 1;
                    }

                    mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                    // RENDER PLAYER:
                    if (autoSpin && (tmpObj == player)) {
                        mainContext.rotate(tmpDir + tmpObj.dt);
                    } else {
                        mainContext.rotate(tmpDir + tmpObj.dirPlus);
                    }
                    renderPlayer(tmpObj, mainContext);
                    mainContext.restore();
                }
            }
        }
    }
    // RENDER DEAD PLAYER:
    function renderDeadPlayer(obj, ctxt) {
        ctxt = ctxt || mainContext;
        ctxt.lineWidth = outlineWidth;
        ctxt.lineJoin = "miter";
        let handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS || 1);
        let oHandAngle = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndS || 1) : 1;
        let oHandDist = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndD || 1) : 1;
        // TAIL/CAPE:
        renderTail2(13, ctxt, obj);
        // WEAPON BELLOW HANDS:
        if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
            renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant || 0].src || "", obj.scale, 0, ctxt);
            if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                renderProjectile(obj.scale, 0,
                    items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
            }
        }
        // HANDS:
        ctxt.fillStyle = "#ececec";
        renderCircle(obj.scale * Math.cos(handAngle), (obj.scale * Math.sin(handAngle)), 14);
        renderCircle((obj.scale * oHandDist) * Math.cos(-handAngle * oHandAngle),
            (obj.scale * oHandDist) * Math.sin(-handAngle * oHandAngle), 14);
        // WEAPON ABOVE HANDS:
        if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
            renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant || 0].src || "", obj.scale, 0, ctxt);
            if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                renderProjectile(obj.scale, 0,
                    items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
            }
        }
        // BUILD ITEM:
        if (obj.buildIndex >= 0) {
            var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
            ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
        }
        // BODY:
        renderCircle(0, 0, obj.scale, ctxt);
        // SKIN:
        ctxt.rotate(Math.PI / 2);
        renderSkin2(48, ctxt, null, obj)
    }

    // RENDER PLAYER:
    function renderPlayer(obj, ctxt) {
        ctxt = ctxt || mainContext;
        ctxt.lineWidth = outlineWidth;
        ctxt.lineJoin = "miter";
        let handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS || 1);
        let oHandAngle = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndS || 1) : 1;
        let oHandDist = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndD || 1) : 1;
        // TAIL/CAPE:
        if (obj.tailIndex > 0) {
            renderTailTextureImage(obj.tailIndex, ctxt, obj);
        }

        // WEAPON BELLOW HANDS:
        if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
            renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
            if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                renderProjectile(obj.scale, 0,
                    items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
            }
        }

        // HANDS:
        ctxt.fillStyle = config.skinColors[obj.skinColor];
        renderCircle(obj.scale * Math.cos(handAngle), (obj.scale * Math.sin(handAngle)), 14);
        renderCircle((obj.scale * oHandDist) * Math.cos(-handAngle * oHandAngle),
            (obj.scale * oHandDist) * Math.sin(-handAngle * oHandAngle), 14);

        // WEAPON ABOVE HANDS:
        if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
            renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
            if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                renderProjectile(obj.scale, 0,
                    items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
            }
        }

        // BUILD ITEM:
        if (obj.buildIndex >= 0) {
            var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
            ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
        }

        // BODY:
        renderCircle(0, 0, obj.scale, ctxt);

        // SKIN:
        if (obj.skinIndex > 0) {
            ctxt.rotate(Math.PI / 2);
            renderTextureSkin(obj.skinIndex, ctxt, null, obj);
        }

    }

    // RENDER NORMAL SKIN
    var skinSprites2 = {};
    var skinPointers2 = {};

    function renderSkin2(index, ctxt, parentSkin, owner) {
        tmpSkin = skinSprites2[index];
        if (!tmpSkin) {
            var tmpImage = new Image();
            tmpImage.onload = function() {
                this.isLoaded = true;
                this.onload = null;
            };
            //tmpImage.src = "https://moomoo.io/img/hats/hat_" + index + ".png";
            tmpImage.src = "https://moomoo.io/img/hats/hat_" + index + ".png";
            skinSprites2[index] = tmpImage;
            tmpSkin = tmpImage;
        }
        var tmpObj = parentSkin || skinPointers2[index];
        if (!tmpObj) {
            for (var i = 0; i < hats.length; ++i) {
                if (hats[i].id == index) {
                    tmpObj = hats[i];
                    break;
                }
            }
            skinPointers2[index] = tmpObj;
        }
        if (tmpSkin.isLoaded)
            ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale);
        if (!parentSkin && tmpObj.topSprite) {
            ctxt.save();
            ctxt.rotate(owner.skinRot);
            renderSkin2(index + "_top", ctxt, tmpObj, owner);
            ctxt.restore();
        }
    }

    // RENDER SKIN:
    function renderTextureSkin(index, ctxt, parentSkin, owner) {
        if (!(tmpSkin = skinSprites[index + (txt ? "lol" : 0)])) {
            var tmpImage = new Image();
            tmpImage.onload = function() {
                    this.isLoaded = true,
                        this.onload = null
                },
                tmpImage.src = setSkinTextureImage(index, "hat", index),
                skinSprites[index + (txt ? "lol" : 0)] = tmpImage,
                tmpSkin = tmpImage
        }
        var tmpObj = parentSkin || skinPointers[index];
        if (!tmpObj) {
            for (var i = 0; i < hats.length; ++i) {
                if (hats[i].id == index) {
                    tmpObj = hats[i];
                    break;
                }
            }
            skinPointers[index] = tmpObj;
        }
        if (tmpSkin.isLoaded)
            ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale);
        if (!parentSkin && tmpObj.topSprite) {
            ctxt.save();
            ctxt.rotate(owner.skinRot);
            renderSkin(index + "_top", ctxt, tmpObj, owner);
            ctxt.restore();
        }
    }

    function setSkinTextureImage(id, type, id2) {
        if (type == "acc") {
            return ".././img/accessories/access_" + id + ".png";
        } else if (type == "hat") {
            return ".././img/hats/hat_" + id + ".png";
        } else {
            return ".././img/weapons/" + id + ".png";
        }
    }
    // RENDER SKINS:
    let skinSprites = {};
    let skinPointers = {};
    let tmpSkin;

    function renderSkin(index, ctxt, parentSkin, owner) {
        tmpSkin = skinSprites[index];
        if (!tmpSkin) {
            let tmpImage = new Image();
            tmpImage.onload = function() {
                this.isLoaded = true;
                this.onload = null;
            };
            tmpImage.src = "https://moomoo.io/img/hats/hat_" + index + ".png";
            skinSprites[index] = tmpImage;
            tmpSkin = tmpImage;
        }
        let tmpObj = parentSkin || skinPointers[index];
        if (!tmpObj) {
            for (let i = 0; i < hats.length; ++i) {
                if (hats[i].id == index) {
                    tmpObj = hats[i];
                    break;
                }
            }
            skinPointers[index] = tmpObj;
        }
        if (tmpSkin.isLoaded)
            ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale);
        if (!parentSkin && tmpObj.topSprite) {
            ctxt.save();
            ctxt.rotate(owner.skinRot);
            renderSkin(index + "_top", ctxt, tmpObj, owner);
            ctxt.restore();
        }
    }

    // RENDER TAIL:
    var newAccImgs = {
        21: "https://i.imgur.com/4ddZert.png",
        19: "https://i.imgur.com/sULkUZT.png",
    };

    function setTailTextureImage(id, type, id2) {
        if (true) {
            if (newAccImgs[id] && type == "acc") {
                return newAccImgs[id];
            } else {
                if (type == "acc") {
                    return ".././img/accessories/access_" + id + ".png";
                } else if (type == "hat") {
                    return ".././img/hats/hat_" + id + ".png";
                } else {
                    return ".././img/weapons/" + id + ".png";
                }
            }
        } else {
            if (type == "acc") {
                return ".././img/accessories/access_" + id + ".png";
            } else if (type == "hat") {
                return ".././img/hats/hat_" + id + ".png";
            } else {
                return ".././img/weapons/" + id + ".png";
            }
        }
    }

    function renderTailTextureImage(index, ctxt, owner) {
        if (!(tmpSkin = accessSprites[index + (txt ? "lol" : 0)])) {
            var tmpImage = new Image();
            tmpImage.onload = function() {
                    this.isLoaded = true,
                        this.onload = null
                },
                tmpImage.src = setTailTextureImage(index, "acc"), //".././img/accessories/access_" + index + ".png";
                accessSprites[index + (txt ? "lol" : 0)] = tmpImage,
                tmpSkin = tmpImage;
        }
        var tmpObj = accessPointers[index];
        if (!tmpObj) {
            for (var i = 0; i < accessories.length; ++i) {
                if (accessories[i].id == index) {
                    tmpObj = accessories[i];
                    break;
                }
            }
            accessPointers[index] = tmpObj;
        }
        if (tmpSkin.isLoaded) {
            ctxt.save();
            ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
            if (tmpObj.spin)
                ctxt.rotate(owner.skinRot);
            ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
            ctxt.restore();
        }
    }

    let accessSprites = {};
    let accessPointers = {};
    var txt = true;

    function renderTail(index, ctxt, owner) {
        tmpSkin = accessSprites[index];
        if (!tmpSkin) {
            let tmpImage = new Image();
            tmpImage.onload = function() {
                this.isLoaded = true;
                this.onload = null;
            };
            tmpImage.src = "https://moomoo.io/img/accessories/access_" + index + ".png";
            accessSprites[index] = tmpImage;
            tmpSkin = tmpImage;
        }
        let tmpObj = accessPointers[index];
        if (!tmpObj) {
            for (let i = 0; i < accessories.length; ++i) {
                if (accessories[i].id == index) {
                    tmpObj = accessories[i];
                    break;
                }
            }
            accessPointers[index] = tmpObj;
        }
        if (tmpSkin.isLoaded) {
            ctxt.save();
            ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
            if (tmpObj.spin)
                ctxt.rotate(owner.skinRot);
            ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
            ctxt.restore();
        }
    }

    var accessSprites2 = {};
    var accessPointers2 = {};

    function renderTail2(index, ctxt, owner) {
        tmpSkin = accessSprites2[index];
        if (!tmpSkin) {
            var tmpImage = new Image();
            tmpImage.onload = function() {
                this.isLoaded = true;
                this.onload = null;
            };
            tmpImage.src = "https://moomoo.io/img/accessories/access_" + index + ".png";
            accessSprites2[index] = tmpImage;
            tmpSkin = tmpImage;
        }
        var tmpObj = accessPointers2[index];
        if (!tmpObj) {
            for (var i = 0; i < accessories.length; ++i) {
                if (accessories[i].id == index) {
                    tmpObj = accessories[i];
                    break;
                }
            }
            accessPointers2[index] = tmpObj;
        }
        if (tmpSkin.isLoaded) {
            ctxt.save();
            ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
            if (tmpObj.spin)
                ctxt.rotate(owner.skinRot);
            ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
            ctxt.restore();
        }
    }

    // RENDER TOOL:
    let toolSprites = {};

    function renderTool(obj, variant, x, y, ctxt) {
        let tmpSrc = obj.src + (variant || "");
        let tmpSprite = toolSprites[tmpSrc];
        if (!tmpSprite) {
            tmpSprite = new Image();
            tmpSprite.onload = function() {
                this.isLoaded = true;
            }
            tmpSprite.src = "https://moomoo.io/img/weapons/" + tmpSrc + ".png";
            toolSprites[tmpSrc] = tmpSprite;
        }
        if (tmpSprite.isLoaded)
            ctxt.drawImage(tmpSprite, x + obj.xOff - (obj.length / 2), y + obj.yOff - (obj.width / 2), obj.length, obj.width);
    }

    // RENDER PROJECTILES:
    function renderProjectiles(layer, f, d) {
        for (let i = 0; i < projectiles.length; i++) {
            tmpObj = projectiles[i];
            if (tmpObj.active && tmpObj.layer == layer && tmpObj.inWindow) {
                tmpObj.update(delta);
                if (tmpObj.active && isOnScreen(tmpObj.x - f, tmpObj.y - d, tmpObj.scale)) {
                    mainContext.save();
                    if (buggyArrow) {
                        mainContext.translate(tmpObj.x - f, tmpObj.y - d);
                        mainContext.rotate(-Math.PI / 4);
                        renderProjectile(0, 0, tmpObj, mainContext, 1);
                        mainContext.restore();
                    } else {
                        mainContext.translate(tmpObj.x - f, tmpObj.y - d);
                        mainContext.rotate(tmpObj.dir);
                        renderProjectile(0, 0, tmpObj, mainContext, 1);
                        mainContext.restore();
                    }
                }
            }
        };
    }
    // RENDER PROJECTILE:
    let projectileSprites = {}; //fz iz zexy

    function renderProjectile(x, y, obj, ctxt, debug) {
        if (obj.src) {
            let tmpSrc = items.projectiles[obj.indx].src;
            let tmpSprite = projectileSprites[tmpSrc];
            if (!tmpSprite) {
                tmpSprite = new Image();
                tmpSprite.onload = function() {
                    this.isLoaded = true;
                }
                tmpSprite.src = "https://moomoo.io/img/weapons/" + tmpSrc + ".png";
                projectileSprites[tmpSrc] = tmpSprite;
            }
            if (tmpSprite.isLoaded)
                ctxt.drawImage(tmpSprite, x - (obj.scale / 2), y - (obj.scale / 2), obj.scale, obj.scale);
        } else if (obj.indx == 1) {
            ctxt.fillStyle = "#939393";
            renderCircle(x, y, obj.scale, ctxt);
        }
    }

    // RENDER AI:
    let aiSprites = {};

    function renderAI(obj, ctxt) {
        let tmpIndx = obj.index;
        let tmpSprite = aiSprites[tmpIndx];
        if (!tmpSprite) {
            let tmpImg = new Image();
            tmpImg.onload = function() {
                this.isLoaded = true;
                this.onload = null;
            };
            tmpImg.src = "https://moomoo.io/img/animals/" + obj.src + ".png";
            tmpSprite = tmpImg;
            aiSprites[tmpIndx] = tmpSprite;
        }
        if (tmpSprite.isLoaded) {
            let tmpScale = obj.scale * 1.2 * (obj.spriteMlt || 1);
            ctxt.drawImage(tmpSprite, -tmpScale, -tmpScale, tmpScale * 2, tmpScale * 2);
        }
    }
    // RENDER WATER BODIES:
    function renderWaterBodies(f, d, ctxt, padding) {

        // MIDDLE RIVER:
        let tmpW = config.riverWidth + padding;
        let tmpY = (config.mapScale / 2) - d - (tmpW / 2);
        if (tmpY < maxScreenHeight && tmpY + tmpW > 0) {
            ctxt.fillRect(0, tmpY, maxScreenWidth, tmpW);
        }
    }

    // RENDER GAME OBJECTS:
    let gameObjectSprites = {};

    function getResSprite(obj) {
        let biomeID = (obj.y >= config.mapScale - config.snowBiomeTop) ? 2 : ((obj.y <= config.snowBiomeTop) ? 1 : 0);
        let tmpIndex = (obj.type + "_" + obj.scale + "_" + biomeID);
        let tmpSprite = gameObjectSprites[tmpIndex];
        if (!tmpSprite) {
            let blurScale = 6;
            let tmpCanvas = document.createElement("canvas");
            tmpCanvas.width = tmpCanvas.height = (obj.scale * 2.1) + outlineWidth;
            let tmpContext = tmpCanvas.getContext('2d');
            tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
            tmpContext.rotate(UTILS.randFloat(0, Math.PI));
            tmpContext.strokeStyle = outlineColor;
            tmpContext.lineWidth = outlineWidth;

            if (obj.type == 0) {
                let tmpScale;
                let tmpCount = UTILS.randInt(5, 7);
                for (let i = 0; i < 2; ++i) {
                    tmpScale = tmpObj.scale * (!i ? 1 : 0.5);
                    renderStar(tmpContext, tmpCount, tmpScale, tmpScale * 0.7);
                    tmpContext.fillStyle = !biomeID ? (!i ? "#9ebf57" : "#b4db62") : (!i ? "#e3f1f4" : "#fff");
                    tmpContext.fill();
                    if (!i) {
                        tmpContext.stroke();
                        tmpContext.shadowBlur = null;
                        tmpContext.shadowColor = null;
                        tmpContext.globalAlpha = 1;
                    }
                }
            } else if (obj.type == 1) {
                if (biomeID == 2) {
                    tmpContext.fillStyle = "#606060";
                    renderStar(tmpContext, 6, obj.scale * 0.3, obj.scale * 0.71);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#89a54c";
                    renderCircle(0, 0, obj.scale * 0.55, tmpContext);
                    tmpContext.fillStyle = "#a5c65b";
                    renderCircle(0, 0, obj.scale * 0.3, tmpContext, true);
                } else {
                    renderBlob(tmpContext, 6, tmpObj.scale, tmpObj.scale * 0.7);
                    tmpContext.fillStyle = biomeID ? "#e3f1f4" : "#89a54c";
                    tmpContext.fill();
                    tmpContext.stroke();

                    tmpContext.shadowBlur = null;
                    tmpContext.shadowColor = null;

                    tmpContext.fillStyle = biomeID ? "#6a64af" : "#c15555";
                    let tmpRange;
                    let berries = 4;
                    let rotVal = (Math.PI * 2) / berries;
                    for (let i = 0; i < berries; ++i) {
                        tmpRange = UTILS.randInt(tmpObj.scale / 3.5, tmpObj.scale / 2.3);
                        renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                            UTILS.randInt(10, 12), tmpContext);
                    }
                }
            } else if (obj.type == 2 || obj.type == 3) {
                tmpContext.fillStyle = (obj.type == 2) ? (biomeID == 2 ? "#938d77" : "#939393") : "#e0c655";
                renderStar(tmpContext, 3, obj.scale, obj.scale);
                tmpContext.fill();
                tmpContext.stroke();

                tmpContext.shadowBlur = null;
                tmpContext.shadowColor = null;

                tmpContext.fillStyle = (obj.type == 2) ? (biomeID == 2 ? "#b2ab90" : "#bcbcbc") : "#ebdca3";
                renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                tmpContext.fill();
            }
            tmpSprite = tmpCanvas;
            gameObjectSprites[tmpIndex] = tmpSprite;
        }
        return tmpSprite;
    }

    // GET ITEM SPRITE:
    let itemSprites = [];

    function getItemSprite(obj, asIcon) {
        let tmpSprite = itemSprites[obj.id];
        if (!tmpSprite || asIcon) {
            let tmpCanvas = document.createElement("canvas");
            let reScale = ((!asIcon && obj.name == "windmill") ? items.list[4].scale : obj.scale);
            tmpCanvas.width = tmpCanvas.height = (reScale * 2.5) + outlineWidth + (items.list[obj.id].spritePadding || 0);
            let tmpContext = tmpCanvas.getContext("2d");
            tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
            tmpContext.rotate(asIcon ? 0 : (Math.PI / 2));
            tmpContext.strokeStyle = outlineColor;
            tmpContext.lineWidth = outlineWidth * (asIcon ? (tmpCanvas.width / 81) : 1);
            if (obj.name == "apple") {
                tmpContext.fillStyle = "#c15555";
                renderCircle(0, 0, obj.scale, tmpContext);
                tmpContext.fillStyle = "#89a54c";
                let leafDir = -(Math.PI / 2);
                renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir),
                    25, leafDir + Math.PI / 2, tmpContext);
            } else if (obj.name == "cookie") {
                tmpContext.fillStyle = "#cca861";
                renderCircle(0, 0, obj.scale, tmpContext);
                tmpContext.fillStyle = "#937c4b";
                let chips = 4;
                let rotVal = (Math.PI * 2) / chips;
                let tmpRange;
                for (let i = 0; i < chips; ++i) {
                    tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                    renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                        UTILS.randInt(4, 5), tmpContext, true);
                }
            } else if (obj.name == "cheese") {
                tmpContext.fillStyle = "#f4f3ac";
                renderCircle(0, 0, obj.scale, tmpContext);
                tmpContext.fillStyle = "#c3c28b";
                let chips = 4;
                let rotVal = (Math.PI * 2) / chips;
                let tmpRange;
                for (let i = 0; i < chips; ++i) {
                    tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                    renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                        UTILS.randInt(4, 5), tmpContext, true);
                }
            } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
                    "#a5974c" : "#939393";
                let sides = (obj.name == "castle wall") ? 4 : 3;
                renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
                    "#c9b758" : "#bcbcbc";
                renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                tmpContext.fill();
            } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
                obj.name == "spinning spikes") {
                tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
                let tmpScale = (obj.scale * 0.6);
                renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.fillStyle = "#a5974c";
                renderCircle(0, 0, tmpScale, tmpContext);
                tmpContext.fillStyle = "#c9b758";
                renderCircle(0, 0, tmpScale / 2, tmpContext, true);
            } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                tmpContext.fillStyle = "#a5974c";
                renderCircle(0, 0, reScale, tmpContext);
                tmpContext.fillStyle = "#c9b758";
                renderRectCircle(0, 0, reScale * 1.5, 29, 4, tmpContext);
                tmpContext.fillStyle = "#a5974c";
                renderCircle(0, 0, reScale * 0.5, tmpContext);
            } else if (obj.name == "mine") {
                tmpContext.fillStyle = "#939393";
                renderStar(tmpContext, 3, obj.scale, obj.scale);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.fillStyle = "#bcbcbc";
                renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                tmpContext.fill();
            } else if (obj.name == "sapling") {
                for (let i = 0; i < 2; ++i) {
                    let tmpScale = obj.scale * (!i ? 1 : 0.5);
                    renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                    tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
                    tmpContext.fill();
                    if (!i) tmpContext.stroke();
                }
            } else if (obj.name == "pit trap") {
                tmpContext.fillStyle = "#a5974c";
                renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.fillStyle = outlineColor;
                renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                tmpContext.fill();
            } else if (obj.name == "boost pad") {
                tmpContext.fillStyle = "#7e7f82";
                if (buggyBoost) {
                    const angleB = 0;
                    tmpContext.rotate(angleB, tmpContext.stroke);
                }
                renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.fillStyle = "#dbd97d";
                renderTriangle(obj.scale * 1, tmpContext);
            } else if (obj.name == "turret") {
                tmpContext.fillStyle = "#a5974c";
                renderCircle(0, 0, obj.scale, tmpContext);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.fillStyle = "#939393";
                let tmpLen = 50;
                renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                tmpContext.fill();
                tmpContext.stroke();
            } else if (obj.name == "platform") {
                tmpContext.fillStyle = "#cebd5f";
                let tmpCount = 4;
                let tmpS = obj.scale * 2;
                let tmpW = tmpS / tmpCount;
                let tmpX = -(obj.scale / 2);
                for (let i = 0; i < tmpCount; ++i) {
                    renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpX += tmpS / tmpCount;
                }
            } else if (obj.name == "healing pad") {
                tmpContext.fillStyle = "#7e7f82";
                renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.fillStyle = "#db6e6e";
                renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
            } else if (obj.name == "spawn pad") {
                tmpContext.fillStyle = "#7e7f82";
                const angleB = Math.random() * 90;
                renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.fillStyle = "#71aad6";
                renderCircle(0, 0, obj.scale * 0.6, tmpContext);
            } else if (obj.name == "blocker") {
                tmpContext.fillStyle = "#7e7f82";
                renderCircle(0, 0, obj.scale, tmpContext);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.rotate(Math.PI / 4);
                tmpContext.fillStyle = "#db6e6e";
                renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
            } else if (obj.name == "teleporter") {
                tmpContext.fillStyle = "#7e7f82";
                renderCircle(0, 0, obj.scale, tmpContext);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.rotate(Math.PI / 4);
                tmpContext.fillStyle = "#d76edb";
                renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
            }
            tmpSprite = tmpCanvas;
            if (!asIcon) itemSprites[obj.id] = tmpSprite;
        }
        return tmpSprite;
    }

    let objSprites = [];

    function getObjSprite(obj) {
        let tmpSprite = objSprites[obj.id];
        if (!tmpSprite) {
            let tmpCanvas = document.createElement("canvas");
            tmpCanvas.width = tmpCanvas.height = obj.scale * 2.5 + outlineWidth + (items.list[obj.id].spritePadding || 0);
            let tmpContext = tmpCanvas.getContext("2d");
            tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
            tmpContext.rotate(Math.PI / 2);
            tmpContext.strokeStyle = outlineColor;
            tmpContext.lineWidth = outlineWidth;
            if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                tmpContext.fillStyle = obj.name == "poison spikes" ? "#7b935d" : "#939393";
                let tmpScale = obj.scale * 0.6;
                renderStar(tmpContext, obj.name == "spikes" ? 5 : 6, obj.scale, tmpScale);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.fillStyle = "#a5974c";
                renderCircle(0, 0, tmpScale, tmpContext);
                tmpContext.fillStyle = "#cc5151";
                renderCircle(0, 0, tmpScale / 2, tmpContext, true);
            } else if (obj.name == "pit trap") {
                tmpContext.fillStyle = "#a5974c";
                renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                tmpContext.fill();
                tmpContext.stroke();
                tmpContext.fillStyle = "#cc5151";
                renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                tmpContext.fill();
            }
            tmpSprite = tmpCanvas;
            objSprites[obj.id] = tmpSprite;
        }
        return tmpSprite;
    }

    // OBJECT ON SCREEN:
    function isOnScreen(x, y, s) {
        return (x + s >= 0 && x - s <= maxScreenWidth && y + s >= 0 && (y,
            s,
            maxScreenHeight));
    }
    const Ye = {
        animationTime: 0,
        land: null,
        lava: null,
        x: 13960,
        y: 13960,
    };

    function Do(e, t, i) {
        const n = e.lineWidth || 0;
        (i /= 2), e.beginPath();
        let s = (Math.PI * 2) / t;
        for (let r = 0; r < t; r++)
            e.lineTo(
                i + (i - n / 2) * Math.cos(s * r),
                i + (i - n / 2) * Math.sin(s * r)
            );
        e.closePath();
    }

    function drawVolcanoSprite() {
        const t = 320 * 2,
            i = document.createElement("canvas");
        (i.width = t), (i.height = t);
        const n = i.getContext("2d");
        (n.strokeStyle = "#3e3e3e"),
        (n.lineWidth = 11),
        (n.fillStyle = "#7f7f7f"),
        Do(n, 10, t),
            n.fill(),
            n.stroke(),
            (Ye.land = i);
        const s = document.createElement("canvas"),
            r = 200;
        (s.width = r), (s.height = r);
        const o = s.getContext("2d");
        (o.strokeStyle = "#525252"),
        (o.lineWidth = 5.5 * 1.6),
        (o.fillStyle = "#f54e16"),
        (o.strokeStyle = "#f56f16"),
        Do(o, 10, r),
            o.fill(),
            o.stroke(),
            (Ye.lava = s);
    }
    drawVolcanoSprite();

    function drawVolcano(context, x, y) {
        const e = player.x - maxScreenWidth / 2,
            t = player.y - maxScreenHeight / 2;
        (Ye.animationTime += delta), (Ye.animationTime %= 3200);
        const i = 1600,
            n = 1.7 + 0.3 * (Math.abs(i - Ye.animationTime) / i),
            s = 100 * n;
        context.drawImage(Ye.land, x - 320, y - 320, 320 * 2, 320 * 2),
            context.drawImage(Ye.lava, x - s, y - s, s * 2, s * 2);
    }
    // RENDER GAMEOBJECTS:
    function renderGameObjects(layer, xOffset, yOffset) {
        let tmpSprite, tmpX, tmpY;

        let renderMainMenuObjects = inGame ? closeObjects : gameObjects;

        renderMainMenuObjects.forEach((tmp) => {
            tmpObj = tmp;

            if (tmpObj.alive || tmpObj.active) {
                tmpX = tmpObj.x + tmpObj.xWiggle - xOffset;
                tmpY = tmpObj.y + tmpObj.yWiggle - yOffset;

                if (layer == 0) {
                    tmpObj.update(delta);
                }

                if (tmpObj.layer == layer && isOnScreen(tmpX, tmpY, tmpObj.scale + (tmpObj.blocker || 0))) {
                    if (tmpObj.isItem) {
                        if ((tmpObj.dmg || tmpObj.trap) && !tmpObj.isTeamObject(player)) {
                            tmpSprite = getObjSprite(tmpObj);
                        } else {
                            tmpSprite = getItemSprite(tmpObj);
                        }

                        mainContext.save();

                        mainContext.translate(tmpX, tmpY);
                        mainContext.rotate(tmpObj.dir);

                        if (smothGhostyObjects) {
                            tmpObj.targetAlpha = Math.pow(tmpObj.health / tmpObj.maxHealth, 0.5) * tmpObj.alpha;
                        } else {
                            tmpObj.targetAlpha = tmpObj.alpha;
                        }

                        tmpObj.currentAlpha += (tmpObj.targetAlpha - tmpObj.currentAlpha) * 0.06;

                        mainContext.globalAlpha = tmpObj.currentAlpha;

                        if (!tmpObj.active) {
                            mainContext.scale(tmpObj.visScale / tmpObj.scale, tmpObj.visScale / tmpObj.scale);
                        }

                        mainContext.drawImage(tmpSprite, -(tmpSprite.width / 2), -(tmpSprite.height / 2));

                        if (tmpObj.blocker) {
                            mainContext.strokeStyle = "#db6e6e";
                            mainContext.globalAlpha = 0.3;
                            mainContext.lineWidth = 6;
                            renderCircle(0, 0, tmpObj.blocker, mainContext, false, true);
                        }

                        mainContext.restore();
                    } else {
                        tmpSprite = getResSprite(tmpObj);
                        if (tmpObj.type === 4) {
                            drawVolcano(mainContext, tmpX, tmpY);
                        } else {
                            mainContext.drawImage(
                                tmpSprite,
                                tmpX - tmpSprite.width / 2,
                                tmpY - tmpSprite.height / 2
                            );
                        }
                    }
                }
            }
        });
    }

    // RENDER MINIMAP:
    class MapPing {
        constructor(color, scale) {
            this.init = function(x, y) {
                this.scale = 0;
                this.x = x;
                this.y = y;
                this.active = true;
            };
            this.update = function(ctxt, delta) {
                if (this.active) {
                    this.scale += 0.05 * delta;
                    if (this.scale >= scale) {
                        this.active = false;
                    } else {
                        ctxt.globalAlpha = (1 - Math.max(0, this.scale / scale));
                        ctxt.beginPath();
                        ctxt.arc((this.x / config.mapScale) * mapDisplay.width, (this.y / config.mapScale) *
                            mapDisplay.width, this.scale, 0, 2 * Math.PI);
                        ctxt.stroke();
                    }
                }
            };
            this.color = color;
        }
    }

    function pingMap(x, y) {
        tmpPing = mapPings.find(pings => !pings.active);
        if (!tmpPing) {
            tmpPing = new MapPing("#fff", config.mapPingScale);
            mapPings.push(tmpPing);
        }
        tmpPing.init(x, y);
    }

    function updateMapMarker() {
        mapMarker.x = player.x;
        mapMarker.y = player.y;
    }

    function renderMinimap(delta) {
        if (player && player.alive) {
            mapContext.clearRect(0, 0, mapDisplay.width, mapDisplay.height);

            // RENDER PINGS:
            mapContext.lineWidth = 4;
            for (let i = 0; i < mapPings.length; ++i) {
                tmpPing = mapPings[i];
                mapContext.strokeStyle = tmpPing.color;
                tmpPing.update(mapContext, delta);
            }
            let breakTracks = [];
            // BREAK TRACKER:
            if (breakTracks.length && getEl("combat")
                .value == "2yl") {
                for (let i = 0; i < breakTracks.length; i++) {
                    tmpObj = breakTracks[i];
                    mapContext.fillStyle = "#fff";
                    mapContext.font = "34px Hammersmith One";
                    mapContext.textBaseline = "middle";
                    mapContext.textAlign = "center";
                    mapContext.fillText("L", (tmpObj.x / config.mapScale) * mapDisplay.width, (tmpObj.y / config.mapScale) * mapDisplay.height);
                }
            }

            // RENDER PLAYERS:
            mapContext.globalAlpha = 1;
            mapContext.fillStyle = "#fff";
            renderCircle((player.x / config.mapScale) * mapDisplay.width,
                (player.y / config.mapScale) * mapDisplay.height, 7, mapContext, true);
            mapContext.fillStyle = "rgba(255,255,255,0.35)";
            if (player.team && minimapData) {
                for (let i = 0; i < minimapData.length;) {
                    renderCircle((minimapData[i] / config.mapScale) * mapDisplay.width,
                        (minimapData[i + 1] / config.mapScale) * mapDisplay.height, 7, mapContext, true);
                    i += 2;
                }
            }

            // DEATH LOCATION:
            if (lastDeath) {
                mapContext.fillStyle = "#fc5553";
                mapContext.font = "34px Hammersmith One";
                mapContext.textBaseline = "middle";
                mapContext.textAlign = "center";
                mapContext.fillText("x", (lastDeath.x / config.mapScale) * mapDisplay.width,
                    (lastDeath.y / config.mapScale) * mapDisplay.height);
            }

            // MAP MARKER:
            if (mapMarker) {
                mapContext.fillStyle = "#fff";
                mapContext.font = "34px Hammersmith One";
                mapContext.textBaseline = "middle";
                mapContext.textAlign = "center";
                mapContext.fillText("x", (mapMarker.x / config.mapScale) * mapDisplay.width,
                    (mapMarker.y / config.mapScale) * mapDisplay.height);
            }
        }
    }

    // ICONS:
    let iconSprites = {};
    let icons = ["crown", "skull"];

    function loadIcons() {
        for (let i = 0; i < icons.length; ++i) {
            let tmpSprite = new Image();
            tmpSprite.onload = function() {
                this.isLoaded = true;
            };
            tmpSprite.src = "./../img/icons/" + icons[i] + ".png";
            iconSprites[icons[i]] = tmpSprite;
        }
    }
    loadIcons();

    // UPDATE GAME:
    let hue = 0,
        hueDirection = 1,
        hueSpeed = 9;
    let hueRandomFactor = 0.5;

    function createMapBoundariesGradient() {
        const gradient = mainContext.createLinearGradient(0, 0, maxScreenWidth, 0);
        gradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
        gradient.addColorStop(1, `hsl(${hue + 120}, 100%, 50%)`);
        return gradient;
    }

    let incr = 0;
    let lastBoostRefresh = 0;

    function updateGame() {
        if (gameObjects.length && inGame) {
            if (loopIndex >= loopHats.length) {
                loopIndex = 0;
            }

            function updateBuggyBoosts() {
                gameObjects.forEach(obj => {
                    if (obj.active && obj.name === "boost pad") {
                        if (buggyBoost) {
                            // Sadece bizim yerletirdiimiz boostlar kontrol et
                            if (obj.owner && obj.owner.sid === player.sid) {
                                // lk kez yerletirilen boost iin random a ata
                                if (obj.initialDir === undefined) {
                                    obj.initialDir = Math.random() * (Math.PI * 2);
                                    obj.dir = obj.initialDir;
                                }

                                // Bizim boost'un asn koru
                                obj.dir = obj.initialDir;
                            }
                        }
                    }
                });
            }
            // UpdateGame iinde
            items.checkVisual(); // Katana grnmn kontrol et

            gameObjects.forEach((tmp) => {
                const distance = UTILS.getDistance(tmp.x, tmp.y, player.x, player.y);
                const inRange = distance <= 1200;

                if (inRange && !closeObjects.includes(tmp)) {
                    closeObjects.push(tmp);
                    tmp.render = true;
                } else if (!inRange && closeObjects.includes(tmp)) {
                    tmp.render = false;
                    closeObjects.splice(closeObjects.indexOf(tmp), 1);
                }
            });

            updateBuggyBoosts(); // Boost padleri gncelle
        }

        mainContext.beginPath();
        mainContext.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

        if (player) {
            // INTERPOLATE PLAYERS AND AI:
            let lastTime = now - (1000 / config.serverUpdateRate);
            let tmpDiff;
            for (let i = 0; i < players.length + ais.length; ++i) {
                tmpObj = players[i] || ais[i - players.length];
                if (tmpObj && tmpObj.visible) {
                    if (tmpObj.forcePos) {
                        tmpObj.x = tmpObj.x2;
                        tmpObj.y = tmpObj.y2;
                        tmpObj.dir = tmpObj.d2;
                    } else {
                        let total = tmpObj.t2 - tmpObj.t1;
                        let fraction = lastTime - tmpObj.t1;
                        let ratio = (fraction / total);
                        let rate = 170;
                        tmpObj.dt += delta;
                        let tmpRate = Math.min(1.7, tmpObj.dt / rate);
                        tmpDiff = (tmpObj.x2 - tmpObj.x1);
                        tmpObj.x = tmpObj.x1 + (tmpDiff * tmpRate);
                        tmpDiff = (tmpObj.y2 - tmpObj.y1);
                        tmpObj.y = tmpObj.y1 + (tmpDiff * tmpRate);
                        tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                    }
                }
            }
            // MOVE CAMERA:
            let damping = 0.13;
            camX += (player.x - camX) * damping;
            camY += (player.y - camY) * damping;
        } else {
            camX = config.mapScale / 2;
            camY = config.mapScale / 2;
        }

        // RENDER CORDS:
        let xOffset = camX - (maxScreenWidth / 2);
        let yOffset = camY - (maxScreenHeight / 2);

        // RENDER BACKGROUND:
        if (config.snowBiomeTop - yOffset <= 0 && config.mapScale - config.snowBiomeTop - yOffset >= maxScreenHeight) {
            mainContext.fillStyle = "#b6db66";
            mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
        } else if (config.mapScale - config.snowBiomeTop - yOffset <= 0) {
            mainContext.fillStyle = "#dbc666";
            mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
        } else if (config.snowBiomeTop - yOffset >= maxScreenHeight) {
            mainContext.fillStyle = "#fff";
            mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
        } else if (config.snowBiomeTop - yOffset >= 0) {
            mainContext.fillStyle = "#fff";
            mainContext.fillRect(0, 0, maxScreenWidth, config.snowBiomeTop - yOffset);
            mainContext.fillStyle = "#b6db66";
            mainContext.fillRect(0, config.snowBiomeTop - yOffset, maxScreenWidth,
                maxScreenHeight - (config.snowBiomeTop - yOffset));
        } else {
            mainContext.fillStyle = "#b6db66";
            mainContext.fillRect(0, 0, maxScreenWidth,
                (config.mapScale - config.snowBiomeTop - yOffset));
            mainContext.fillStyle = "#dbc666";
            mainContext.fillRect(0, (config.mapScale - config.snowBiomeTop - yOffset), maxScreenWidth,
                maxScreenHeight - (config.mapScale - config.snowBiomeTop - yOffset));
        }

        // RENDER WATER AREAS:
        if (!firstSetup) {
            waterMult += waterPlus * config.waveSpeed * delta;
            if (waterMult >= config.waveMax) {
                waterMult = config.waveMax;
                waterPlus = -1;
            } else if (waterMult <= 1) {
                waterMult = waterPlus = 1;
            }
            mainContext.globalAlpha = 1;
            mainContext.fillStyle = "#dbc666";
            renderWaterBodies(xOffset, yOffset, mainContext, config.riverPadding);
            mainContext.fillStyle = "#91b2db";
            renderWaterBodies(xOffset, yOffset, mainContext, (waterMult - 1) * 250);
        }

        // RENDER GRID:
        mainContext.lineWidth = 4;
        mainContext.strokeStyle = "#000";
        mainContext.globalAlpha = 0.06;
        mainContext.beginPath();
        let gridSize = 60;
        for (var x = -xOffset % gridSize; x < maxScreenWidth; x += gridSize) {
            if (x > 0) {
                mainContext.moveTo(x, 0);
                mainContext.lineTo(x, maxScreenHeight);
            }
        }
        for (var y = -yOffset % gridSize; y < maxScreenHeight; y += gridSize) {
            if (y > 0) {
                mainContext.moveTo(0, y);
                mainContext.lineTo(maxScreenWidth, y);
            }
        }
        mainContext.stroke();

        // RENDER DEAD PLAYERS:
        mainContext.globalAlpha = 1;
        mainContext.strokeStyle = outlineColor;

        // RENDER BOTTOM LAYER:
        mainContext.globalAlpha = 1;
        mainContext.strokeStyle = outlineColor;
        renderGameObjects(-1, xOffset, yOffset);

        // RENDER PROJECTILES:
        mainContext.globalAlpha = 1;
        mainContext.lineWidth = outlineWidth;
        renderProjectiles(0, xOffset, yOffset);

        // RENDER PLAYERS:
        renderPlayers(xOffset, yOffset, 0);

        // RENDER AI:
        mainContext.globalAlpha = 1;
        for (let i = 0; i < ais.length; ++i) {
            tmpObj = ais[i];
            if (tmpObj.active && tmpObj.visible) {
                tmpObj.animate(delta);
                mainContext.save();
                mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                mainContext.rotate(tmpObj.dir + tmpObj.dirPlus - (Math.PI / 2));
                renderAI(tmpObj, mainContext);
                mainContext.restore();
            }
        }

        // RENDER GAME OBJECTS (LAYERED):
        renderGameObjects(0, xOffset, yOffset);
        renderProjectiles(1, xOffset, yOffset);
        renderGameObjects(1, xOffset, yOffset);
        renderPlayers(xOffset, yOffset, 1);
        renderGameObjects(2, xOffset, yOffset);
        renderGameObjects(3, xOffset, yOffset);

        // MAP BOUNDARIES:
        mainContext.fillStyle = WealthyMode ? createMapBoundariesGradient() : "#000";
        mainContext.globalAlpha = 0.09;

        const sides = [
            {
                x: 0,
                y: 0,
                w: -xOffset,
                h: maxScreenHeight
            },
            {
                x: config.mapScale - xOffset,
                y: Math.max(0, -yOffset),
                w: maxScreenWidth - (config.mapScale - xOffset),
                h: maxScreenHeight - Math.max(0, -yOffset)
            },
            {
                x: -xOffset,
                y: 0,
                w: maxScreenWidth + xOffset,
                h: -yOffset
            },
            {
                x: Math.max(0, -xOffset),
                y: config.mapScale - yOffset,
                w: maxScreenWidth - Math.max(0, -xOffset) - Math.max(0, maxScreenWidth - (config.mapScale - xOffset)),
                h: maxScreenHeight - (config.mapScale - yOffset)
            }
        ];

        sides.forEach(side => {
            if (side.w > 0 && side.h > 0) {
                mainContext.fillRect(side.x, side.y, side.w, side.h);
            }
        });

        mainContext.globalAlpha = 1;

        // RENDER DAY/NIGHT TIME:
        let timing = 0.35;
        mainContext.fillStyle = `rgba(0, 0, 70, ${timing})`;
        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
        mainContext.strokeStyle = darkOutlineColor;

        // NIGHT TIME:
        if (nigthMode) {
            incr += (1 - incr) / 160;
        } else {
            incr -= incr / 160;
        }

        const trans = mainContext.getTransform();
        mainContext.setTransform(1, 0, 0, 1, 0, 0);
        mainContext.fillStyle = `rgba(${[24, 0, 82, incr * 0.3].join(", ")})`;
        mainContext.fillRect(0, 0, mainContext.canvas.width, mainContext.canvas.height);
        mainContext.setTransform(trans);

        // RENDER PLAYER AND AI UI:
        for (let i = 0; i < players.length + ais.length; ++i) {
            tmpObj = players[i] || ais[i - players.length];
            if (tmpObj.visible) {
                mainContext.strokeStyle = darkOutlineColor;

                // NAME AND HEALTH:
                let nameimg = WealthyMode && tmpObj.sid == player.sid && tmpObj.name ? tmpObj.name.startsWith("x-") ? tmpObj.name.slice(2) : tmpObj.name : tmpObj.name;
                let tmpText = (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (nameimg || "");

                if (tmpText != "") {
                    mainContext.save();

                    if (WealthyMode) {
                        mainContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        mainContext.shadowBlur = 10;
                        mainContext.shadowOffsetY = 5;
                    }
                    mainContext.font = (tmpObj.nameScale || 30) + "px Hammersmith One";
                    mainContext.fillStyle = "#fff";
                    mainContext.textBaseline = "middle";
                    mainContext.textAlign = "center";
                    mainContext.lineWidth = tmpObj.nameScale ? 11 : 8;
                    mainContext.lineJoin = "round";

                    let nameYscale = WealthyMode ? tmpObj.scale + config.nameY : -tmpObj.scale - config.nameY;

                    mainContext.strokeText(tmpText, tmpObj.x - xOffset, (tmpObj.y - yOffset) + nameYscale);
                    mainContext.fillText(tmpText, tmpObj.x - xOffset, (tmpObj.y - yOffset) + nameYscale);

                    if (tmpObj.isLeader && iconSprites.crown.isLoaded) {
                        let tmpS = config.crownIconScale;
                        let tmpX = tmpObj.x - xOffset - (tmpS / 2) - (mainContext.measureText(tmpText)
                            .width / 2) - config.crownPad;
                        mainContext.drawImage(iconSprites.crown, tmpX, (tmpObj.y - yOffset) + nameYscale - (tmpS / 2) - 5, tmpS, tmpS);
                    }
                    if (tmpObj.iconIndex == 1 && iconSprites.skull.isLoaded) {
                        let tmpS = config.crownIconScale;
                        let tmpX = tmpObj.x - xOffset - (tmpS / 2) + (mainContext.measureText(tmpText)
                            .width / 2) + config.crownPad;
                        mainContext.drawImage(iconSprites.skull, tmpX, (tmpObj.y - yOffset) + nameYscale - (tmpS / 2) - 5, tmpS, tmpS);
                    }

                    mainContext.restore();
                }

                if (WealthyMode) {
                    let color = tmpObj == player || tmpObj.team && tmpObj.team == player.team ? "#8ecc51" : "#cc5151";

                    if (tmpObj.isPlayer) {
                        mainContext.save();
                        mainContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        mainContext.shadowBlur = 10;
                        mainContext.shadowOffsetY = 5;
                        mainContext.fillStyle = darkOutlineColor;
                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + -tmpObj.scale - config.nameY, (config.healthBarWidth - 5) + 2 * config.healthBarPad, 17, 8);
                        mainContext.fill();
                        mainContext.fillStyle = color;
                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + -tmpObj.scale - config.nameY + config.healthBarPad, (config.healthBarWidth - 5) * (tmpObj.health / tmpObj.maxHealth), 17 - 2 * config.healthBarPad, 7);
                        mainContext.fill();
                        mainContext.fillStyle = darkOutlineColor;
                        mainContext.roundRect(tmpObj.x - xOffset + 5 - config.healthBarPad, tmpObj.y - yOffset + -tmpObj.scale - config.nameY, (config.healthBarWidth - 5) + 2 * config.healthBarPad, 17, 8);
                        mainContext.fill();
                        mainContext.fillStyle = "#7d59ff";
                        mainContext.roundRect(tmpObj.x - xOffset + 5, tmpObj.y - yOffset + -tmpObj.scale - config.nameY + config.healthBarPad, (config.healthBarWidth - 5) * (tmpObj.shameCount / 8), 17 - 2 * config.healthBarPad, 7);
                        mainContext.fill();
                        mainContext.restore();
                    } else {
                        mainContext.save();
                        mainContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        mainContext.shadowBlur = 10;
                        mainContext.shadowOffsetY = 5;

                        mainContext.fillStyle = darkOutlineColor;
                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset, 2 * config.healthBarWidth + 2 * config.healthBarPad, 17, 8);
                        mainContext.fill();
                        mainContext.fillStyle = color;
                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + config.healthBarPad, 2 * config.healthBarWidth * (tmpObj.health / tmpObj.maxHealth), 17 - 2 * config.healthBarPad, 7);
                        mainContext.fill();
                        mainContext.restore();
                    }
                } else {
                    // HEALTH HOLDER:
                    mainContext.fillStyle = darkOutlineColor;
                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad,
                        tmpObj.y - yOffset + tmpObj.scale + config.nameY, (config.healthBarWidth * 2) +
                        (config.healthBarPad * 2), 17, 8);
                    mainContext.fill();

                    // HEALTH BAR:
                    mainContext.fillStyle = (tmpObj === player || (tmpObj.team && tmpObj.team === player.team)) ? "#8ecc51" : "#cc5151";
                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                        tmpObj.y - yOffset + tmpObj.scale + config.nameY + config.healthBarPad,
                        (config.healthBarWidth * 2) * (tmpObj.health / tmpObj.maxHealth), 17 - config.healthBarPad * 2, 7);
                    mainContext.fill();
                }
            }
        }

        // RENDER ANIM TEXTS:
        textManager.update(delta, mainContext, xOffset, yOffset);

        // RENDER CHAT MESSAGES:
        for (let i = 0; i < players.length; ++i) {
            tmpObj = players[i];
            if (tmpObj.visible) {
                if (tmpObj.chatCountdown > 0) {
                    tmpObj.chatCountdown -= delta;
                    if (tmpObj.chatCountdown <= 0) tmpObj.chatCountdown = 0;
                    mainContext.font = "32px Hammersmith One";
                    let tmpSize = mainContext.measureText(tmpObj.chatMessage);
                    mainContext.textBaseline = "middle";
                    mainContext.textAlign = "center";
                    let tmpX = tmpObj.x - xOffset;
                    let tmpY = tmpObj.y - tmpObj.scale - yOffset - 90;
                    let tmpH = 47;
                    let tmpW = tmpSize.width + 17;
                    mainContext.fillStyle = "rgba(0,0,0,0.2)";
                    mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                    mainContext.fill();
                    mainContext.fillStyle = "#fff";
                    mainContext.fillText(tmpObj.chatMessage, tmpX, tmpY);
                }
            }
        }

        mainContext.globalAlpha = 1;

        // RENDER MINIMAP:
        renderMinimap(delta);
    }

    // UPDATE & ANIMATE:
    window.requestAnimFrame = function() {
        return null;
    }
    window.rAF = (function() {
        return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000 / 9);
            };
    })();

    function doUpdate() {
        now = performance.now();
        delta = now - lastUpdate;
        lastUpdate = now;

        if (Math.random() < 0.01) {
            hueDirection *= -1;
            hueSpeed = 2 + (Math.random() - 0.5) * hueRandomFactor
        }

        hue += hueDirection * hueSpeed;

        hue = hue % 360;
        if (hue < 0) {
            hue += 360;
        }

        updateGame();
        window.rAF(doUpdate);
    }

    prepareMenuBackground();
    doUpdate();

    window.debug = function() {
        my.waitHit = 0;
        my.autoAim = false;
        instaC.isTrue = false;
        traps.inTrap = false;
        itemSprites = [];
        objSprites = [];
        gameObjectSprites = [];
    };
}(); // ==UserScript==
// @name        New script
// @namespace   Violentmonkey Scripts
// @match
// @grant       none
// @version     1.0
// @author      -
// @description
// ==/UserScript==
// ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2025-04-06
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Your code here...
})(); // ==UserScript==
// @name         New Userscript
// @namespace    http://tampermonkey.net/
// @version      2025-04-07
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    /* How to use

    Copy and paste the code below to the end of your hack.
    This technically will auto-fix all hacks after the first update in 2021.

    If you do not have msgpack locally referencable, include the `// @require` line in your mod metadata as done above.

    */

    const PACKET_MAP = {
        // wont have all old packets, since they conflict with some of the new ones, add them yourself if you want to unpatch mods that are that old.
        "33": "9",
        // "7": "K",
        "ch": "6",
        "pp": "0",
        "13c": "c",

        // most recent packet changes
        "f": "9",
        "a": "9",
        "d": "F",
        "G": "z"
    }

    let originalSend = WebSocket.prototype.send;

    WebSocket.prototype.send = new Proxy(originalSend, {
        apply: ((target, websocket, argsList) => {
            let decoded = msgpack.decode(new Uint8Array(argsList[0]));

            if (PACKET_MAP.hasOwnProperty(decoded[0])) {
                decoded[0] = PACKET_MAP[decoded[0]];
            }

            return target.apply(websocket, [msgpack.encode(decoded)]);
        })
    });
})();
