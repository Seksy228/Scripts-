// ==UserScript==
// @name         ¿Secret Client? Real Public Version
// @namespace    Should be top 1 Public Mod
// @author       SUPER T R A S H
// @version      v1.2
// @description  Low Ms Mod + Real Public version of the 100 subs
// @match        *://*.moomoo.io/*
// @match        *://dev.moomoo.io/*
// @match        *://sandbox.moomoo.io/*
// @match        *://wc.moomoo.io/*
// @run-at       document_idle
// @grant        none
// ==/UserScript==

/*

Welcome To ¿Secret Client?

v1: Added all that a mod need.
v1.1: Added auto message ("mod" -> "¿Secret Client?")
v1.2: Added Time Type

The v1.2 of the mod will be shared to public at 100 subs in my channel.
The channel: "https://www.youtube.com/@SuperTrash-i6t"  (Copy and Paste the link)

*/

// ANTI ALTCHA
let altcha = document.getElementById("altcha");
let checkbox = document.getElementById("altcha_checkbox");
let enterGame = document.getElementById("enterGame");
let verifying = false;
let token = undefined;

enterGame.innerHTML = "Verifying...";
let antiAltcha = setInterval(() => {
    if (!altcha) altcha = document.getElementById("altcha"), verifying = false
    if (!checkbox) checkbox = document.getElementById('altcha_checkbox'), verifying = false
    if (token !== undefined) {
        enterGame.innerHTML = "Enter Game";
        clearInterval(antiAltcha);
    }
    if (enterGame.classList.contains("disabled")) {
        if (verifying) return
        verifying = true;
        altcha.style.display = "none";
        checkbox.click();
        setTimeout(()=>{
            verifying = false;
            setTimeout(()=>{
                if (enterGame.classList.contains("disabled")) {
                    window.location.reload();
                }
            }, 5000);
        }, 1000);
    } else enterGame.innerHTML = "Enter Game";
    /*
    if (token !== undefined) {
        enterGame.classList.remove("disabled");
        enterGame.innerHTML = "Enter Game";
        clearInterval(antiAltcha);
    }
    */
}, 1000);

window.addEventListener("load", () => {
    if (!altcha) return
    altcha.addEventListener("statechange", getToken);
});

function getToken(e) { // FOR BOTS(BROKEN)
    var t;
    if (((t = e == null ? undefined : e.detail) == null ? undefined : t.state) === "verified") {
        token = e.detail.payload; // OMG I FINALLY KNOW THAT TOKEN DOESNT NEED TO BE CHANGE
    }
}

const PACKET_MAP = {

    "33": "9",
    // "7": "K",
    "ch": "6",
    "pp": "0",
    "13c": "c",


    "f": "9",
    "a": "9",
    "d": "F",
    "G": "z"
}

let originalSend = WebSocket.prototype.send;

WebSocket.prototype.send = new Proxy(originalSend, {
    apply: ((target, websocket, argsList) => {
        let decoded = msgpack.decode(new Uint8Array(argsList[0]));

        if (PACKET_MAP.hasOwnProperty(decoded[0])) {
            decoded[0] = PACKET_MAP[decoded[0]];
        }

        return target.apply(websocket, [msgpack.encode(decoded)]);
    })
});

let useHack = true;

let log = console.log;
let testMode = window.location.hostname == "127.0.0.1";
let imueheua = true;

function getEl(id) {
    return document.getElementById(id);
}

var EasyStar = function(e) {
    var o = {};
    function r(t) {
        if (o[t]) return o[t].exports;
        var n = o[t] = {
            i: t,
            l: !1,
            exports: {}
        };
        return e[t].call(n.exports, n, n.exports, r), n.l = !0, n.exports
    }
    return r.m = e, r.c = o, r.d = function(t, n, e) {
        r.o(t, n) || Object.defineProperty(t, n, {
            enumerable: !0,
            get: e
        })
    }, r.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, r.t = function(n, t) {
        if (1 & t && (n = r(n)), 8 & t) return n;
        if (4 & t && "object" == typeof n && n && n.__esModule) return n;
        var e = Object.create(null);
        if (r.r(e), Object.defineProperty(e, "default", {
            enumerable: !0,
            value: n
        }), 2 & t && "string" != typeof n)
            for (var o in n) r.d(e, o, function(t) {
                return n[t]
            }.bind(null, o));
        return e
    }, r.n = function(t) {
        var n = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return r.d(n, "a", n), n
    }, r.o = function(t, n) {
        return Object.prototype.hasOwnProperty.call(t, n)
    }, r.p = "/bin/", r(r.s = 0)
}([function(t, n, e) {
    var P = {},
        M = e(1),
        _ = e(2),
        A = e(3);
    t.exports = P;
    var E = 1;
    P.js = function() {
        var c, i, f, s = 1.4,
            p = !1,
            u = {},
            o = {},
            r = {},
            l = {},
            a = !0,
            h = {},
            d = [],
            y = Number.MAX_VALUE,
            v = !1;
        this.setAcceptableTiles = function(t) {
            t instanceof Array ? f = t : !isNaN(parseFloat(t)) && isFinite(t) && (f = [t])
        }, this.enableSync = function() {
            p = !0
        }, this.disableSync = function() {
            p = !1
        }, this.enableDiagonals = function() {
            v = !0
        }, this.disableDiagonals = function() {
            v = !1
        }, this.setGrid = function(t) {
            c = t;
            for (var n = 0; n < c.length; n++)
                for (var e = 0; e < c[0].length; e++) o[c[n][e]] || (o[c[n][e]] = 1)
        }, this.setTileCost = function(t, n) {
            o[t] = n
        }, this.setAdditionalPointCost = function(t, n, e) {
            void 0 === r[n] && (r[n] = {}), r[n][t] = e
        }, this.removeAdditionalPointCost = function(t, n) {
            void 0 !== r[n] && delete r[n][t]
        }, this.removeAllAdditionalPointCosts = function() {
            r = {}
        }, this.setDirectionalCondition = function(t, n, e) {
            void 0 === l[n] && (l[n] = {}), l[n][t] = e
        }, this.removeAllDirectionalConditions = function() {
            l = {}
        }, this.setIterationsPerCalculation = function(t) {
            y = t
        }, this.avoidAdditionalPoint = function(t, n) {
            void 0 === u[n] && (u[n] = {}), u[n][t] = 1
        }, this.stopAvoidingAdditionalPoint = function(t, n) {
            void 0 !== u[n] && delete u[n][t]
        }, this.enableCornerCutting = function() {
            a = !0
        }, this.disableCornerCutting = function() {
            a = !1
        }, this.stopAvoidingAllAdditionalPoints = function() {
            u = {}
        }, this.findPath = function(t, n, e, o, r) {
            function i(t) {
                p ? r(t) : setTimeout(function() {
                    r(t)
                })
            }
            if (void 0 === f) throw new Error("You can't set a path without first calling setAcceptableTiles() on EasyStar.");
            if (void 0 === c) throw new Error("You can't set a path without first calling setGrid() on EasyStar.");
            if (t < 0 || n < 0 || e < 0 || o < 0 || t > c[0].length - 1 || n > c.length - 1 || e > c[0].length - 1 || o > c.length - 1) throw new Error("Your start or end point is outside the scope of your grid.");
            if (t !== e || n !== o) {
                for (var s = c[o][e], u = !1, l = 0; l < f.length; l++)
                    if (s === f[l]) {
                        u = !0;
                        break
                    } if (!1 !== u) {
                        var a = new M;
                        a.openList = new A(function(t, n) {
                            return t.bestGuessDistance() - n.bestGuessDistance()
                        }), a.isDoneCalculating = !1, a.nodeHash = {}, a.startX = t, a.startY = n, a.endX = e, a.endY = o, a.callback = i, a.openList.push(O(a, a.startX, a.startY, null, 1));
                        o = E++;
                        return h[o] = a, d.push(o), o
                    }
                i(null)
            } else i([])
        }, this.cancelPath = function(t) {
            return t in h && (delete h[t], !0)
        }, this.calculate = function() {
            if (0 !== d.length && void 0 !== c && void 0 !== f)
                for (i = 0; i < y; i++) {
                    if (0 === d.length) return;
                    p && (i = 0);
                    var t = d[0],
                        n = h[t];
                    if (void 0 !== n)
                        if (0 !== n.openList.size()) {
                            var e = n.openList.pop();
                            if (n.endX !== e.x || n.endY !== e.y) (e.list = 0) < e.y && T(n, e, 0, -1, +b(e.x, e.y - 1)), e.x < c[0].length - 1 && T(n, e, 1, 0, +b(e.x + 1, e.y)), e.y < c.length - 1 && T(n, e, 0, 1, +b(e.x, e.y + 1)), 0 < e.x && T(n, e, -1, 0, +b(e.x - 1, e.y)), v && (0 < e.x && 0 < e.y && (a || g(c, f, e.x, e.y - 1, e) && g(c, f, e.x - 1, e.y, e)) && T(n, e, -1, -1, s * b(e.x - 1, e.y - 1)), e.x < c[0].length - 1 && e.y < c.length - 1 && (a || g(c, f, e.x, e.y + 1, e) && g(c, f, e.x + 1, e.y, e)) && T(n, e, 1, 1, s * b(e.x + 1, e.y + 1)), e.x < c[0].length - 1 && 0 < e.y && (a || g(c, f, e.x, e.y - 1, e) && g(c, f, e.x + 1, e.y, e)) && T(n, e, 1, -1, s * b(e.x + 1, e.y - 1)), 0 < e.x && e.y < c.length - 1 && (a || g(c, f, e.x, e.y + 1, e) && g(c, f, e.x - 1, e.y, e)) && T(n, e, -1, 1, s * b(e.x - 1, e.y + 1)));
                            else {
                                var o = [];
                                o.push({
                                    x: e.x,
                                    y: e.y
                                });
                                for (var r = e.parent; null != r;) o.push({
                                    x: r.x,
                                    y: r.y
                                }), r = r.parent;
                                o.reverse(), n.callback(o), delete h[t], d.shift()
                            }
                        } else n.callback(null), delete h[t], d.shift();
                    else d.shift()
                }
        };
        var T = function(t, n, e, o, r) {
            e = n.x + e, o = n.y + o;
            void 0 !== u[o] && void 0 !== u[o][e] || !g(c, f, e, o, n) || (void 0 === (o = O(t, e, o, n, r)).list ? (o.list = 1, t.openList.push(o)) : n.costSoFar + r < o.costSoFar && (o.costSoFar = n.costSoFar + r, o.parent = n, t.openList.updateItem(o)))
        },
            g = function(t, n, e, o, r) {
                var i = l[o] && l[o][e];
                if (i) {
                    var s = x(r.x - e, r.y - o);
                    if (! function() {
                        for (var t = 0; t < i.length; t++)
                            if (i[t] === s) return !0;
                        return !1
                    }()) return !1
                }
                for (var u = 0; u < n.length; u++)
                    if (t[o][e] === n[u]) return !0;
                return !1
            },
            x = function(t, n) {
                if (0 === t && -1 === n) return P.TOP;
                if (1 === t && -1 === n) return P.TOP_RIGHT;
                if (1 === t && 0 === n) return P.RIGHT;
                if (1 === t && 1 === n) return P.BOTTOM_RIGHT;
                if (0 === t && 1 === n) return P.BOTTOM;
                if (-1 === t && 1 === n) return P.BOTTOM_LEFT;
                if (-1 === t && 0 === n) return P.LEFT;
                if (-1 === t && -1 === n) return P.TOP_LEFT;
                throw new Error("These differences are not valid: " + t + ", " + n)
            },
            b = function(t, n) {
                return r[n] && r[n][t] || o[c[n][t]]
            },
            O = function(t, n, e, o, r) {
                if (void 0 !== t.nodeHash[e]) {
                    if (void 0 !== t.nodeHash[e][n]) return t.nodeHash[e][n]
                } else t.nodeHash[e] = {};
                var i = m(n, e, t.endX, t.endY),
                    r = null !== o ? o.costSoFar + r : 0,
                    i = new _(o, n, e, r, i);
                return t.nodeHash[e][n] = i
            },
            m = function(t, n, e, o) {
                var r, i;
                return v ? (r = Math.abs(t - e)) < (i = Math.abs(n - o)) ? s * r + i : s * i + r : (r = Math.abs(t - e)) + (i = Math.abs(n - o))
            }
        }, P.TOP = "TOP", P.TOP_RIGHT = "TOP_RIGHT", P.RIGHT = "RIGHT", P.BOTTOM_RIGHT = "BOTTOM_RIGHT", P.BOTTOM = "BOTTOM", P.BOTTOM_LEFT = "BOTTOM_LEFT", P.LEFT = "LEFT", P.TOP_LEFT = "TOP_LEFT"
}, function(t, n) {
    t.exports = function() {
        this.pointsToAvoid = {}, this.startX, this.callback, this.startY, this.endX, this.endY, this.nodeHash = {}, this.openList
    }
}, function(t, n) {
    t.exports = function(t, n, e, o, r) {
        this.parent = t, this.x = n, this.y = e, this.costSoFar = o, this.simpleDistanceToTarget = r, this.bestGuessDistance = function() {
            return this.costSoFar + this.simpleDistanceToTarget
        }
    }
}, function(t, n, e) {
    t.exports = e(4)
}, function(u, T, t) {
    var g, x;
    (function() {
        var t, p, l, h, d, n, a, e, y, v, o, r, i, c, f;
        function s(t) {
            this.cmp = null != t ? t : p, this.nodes = []
        }
        l = Math.floor, v = Math.min, p = function(t, n) {
            return t < n ? -1 : n < t ? 1 : 0
        }, y = function(t, n, e, o, r) {
            var i;
            if (null == e && (e = 0), null == r && (r = p), e < 0) throw new Error("lo must be non-negative");
            for (null == o && (o = t.length); e < o;) r(n, t[i = l((e + o) / 2)]) < 0 ? o = i : e = i + 1;
            return [].splice.apply(t, [e, e - e].concat(n)), n
        }, n = function(t, n, e) {
            return null == e && (e = p), t.push(n), c(t, 0, t.length - 1, e)
        }, d = function(t, n) {
            var e, o;
            return null == n && (n = p), e = t.pop(), t.length ? (o = t[0], t[0] = e, f(t, 0, n)) : o = e, o
        }, e = function(t, n, e) {
            var o;
            return null == e && (e = p), o = t[0], t[0] = n, f(t, 0, e), o
        }, a = function(t, n, e) {
            var o;
            return null == e && (e = p), t.length && e(t[0], n) < 0 && (n = (o = [t[0], n])[0], t[0] = o[1], f(t, 0, e)), n
        }, h = function(e, t) {
            var n, o, r, i, s, u;
            for (null == t && (t = p), s = [], o = 0, r = (i = function() {
                u = [];
                for (var t = 0, n = l(e.length / 2); 0 <= n ? t < n : n < t; 0 <= n ? t++ : t--) u.push(t);
                return u
            }.apply(this).reverse()).length; o < r; o++) n = i[o], s.push(f(e, n, t));
            return s
        }, i = function(t, n, e) {
            if (null == e && (e = p), -1 !== (n = t.indexOf(n))) return c(t, 0, n, e), f(t, n, e)
        }, o = function(t, n, e) {
            var o, r, i, s, u;
            if (null == e && (e = p), !(r = t.slice(0, n)).length) return r;
            for (h(r, e), i = 0, s = (u = t.slice(n)).length; i < s; i++) o = u[i], a(r, o, e);
            return r.sort(e).reverse()
        }, r = function(t, n, e) {
            var o, r, i, s, u, l, a, c, f;
            if (null == e && (e = p), 10 * n <= t.length) {
                if (!(i = t.slice(0, n).sort(e)).length) return i;
                for (r = i[i.length - 1], s = 0, l = (a = t.slice(n)).length; s < l; s++) e(o = a[s], r) < 0 && (y(i, o, 0, null, e), i.pop(), r = i[i.length - 1]);
                return i
            }
            for (h(t, e), f = [], u = 0, c = v(n, t.length); 0 <= c ? u < c : c < u; 0 <= c ? ++u : --u) f.push(d(t, e));
            return f
        }, c = function(t, n, e, o) {
            var r, i, s;
            for (null == o && (o = p), r = t[e]; n < e && o(r, i = t[s = e - 1 >> 1]) < 0;) t[e] = i, e = s;
            return t[e] = r
        }, f = function(t, n, e) {
            var o, r, i, s, u;
            for (null == e && (e = p), r = t.length, i = t[u = n], o = 2 * n + 1; o < r;)(s = o + 1) < r && !(e(t[o], t[s]) < 0) && (o = s), t[n] = t[o], o = 2 * (n = o) + 1;
            return t[n] = i, c(t, u, n, e)
        }, s.push = n, s.pop = d, s.replace = e, s.pushpop = a, s.heapify = h, s.updateItem = i, s.nlargest = o, s.nsmallest = r, s.prototype.push = function(t) {
            return n(this.nodes, t, this.cmp)
        }, s.prototype.pop = function() {
            return d(this.nodes, this.cmp)
        }, s.prototype.peek = function() {
            return this.nodes[0]
        }, s.prototype.contains = function(t) {
            return -1 !== this.nodes.indexOf(t)
        }, s.prototype.replace = function(t) {
            return e(this.nodes, t, this.cmp)
        }, s.prototype.pushpop = function(t) {
            return a(this.nodes, t, this.cmp)
        }, s.prototype.heapify = function() {
            return h(this.nodes, this.cmp)
        }, s.prototype.updateItem = function(t) {
            return i(this.nodes, t, this.cmp)
        }, s.prototype.clear = function() {
            return this.nodes = []
        }, s.prototype.empty = function() {
            return 0 === this.nodes.length
        }, s.prototype.size = function() {
            return this.nodes.length
        }, s.prototype.clone = function() {
            var t = new s;
            return t.nodes = this.nodes.slice(0), t
        }, s.prototype.toArray = function() {
            return this.nodes.slice(0)
        }, s.prototype.insert = s.prototype.push, s.prototype.top = s.prototype.peek, s.prototype.front = s.prototype.peek, s.prototype.has = s.prototype.contains, s.prototype.copy = s.prototype.clone, t = s, g = [], void 0 === (x = "function" == typeof (x = function() {
            return t
        }) ? x.apply(T, g) : x) || (u.exports = x)
    }).call(this)
}]);
let easystar = new EasyStar.js();
!function(run) {
    if (!run) return;
    let codes = {
        setup: () => {
            "use strict";
            let newFont = document.createElement("link");
            newFont.rel = "stylesheet";
            newFont.href = "https://fonts.googleapis.com/css?family=Ubuntu:700";
            newFont.type = "text/css";
            document.body.append(newFont);
            let min = document.createElement("script");
            min.src = "https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js";
            document.body.append(min);
        },
        main: () => {
            "use strict";
            /*let scriptTags = document.getElementsByTagName("script");
      for (let i = 0; i < scriptTags.length; i++) {
          if (scriptTags[i].src.includes("bundle.js")) {
              scriptTags[i].remove();
              break;
          }
      }*/
            window.oncontextmenu = function() {
                return false;
            };
            let config = window.config;
            // CLIENT:
            config.clientSendRate = 0; // Aim Packet Send Rate
            config.serverUpdateRate = 9;
            // UI:
            config.deathFadeout = 0;
            // CHECK IN SANDBOX:
            config.isSandbox = window.location.hostname == "sandbox.moomoo.io";
            // CUSTOMIZATION:
            config.skinColors = ["#bf8f54", "#cbb091", "#896c4b",
                                 "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3",
                                 "#8bc373", "#91b2db"
                                ];
            config.weaponVariants = [{
                id: 0,
                src: "",
                xp: 0,
                val: 1,
            }, {
                id: 1,
                src: "_g",
                xp: 3000,
                val: 1.1,
            }, {
                id: 2,
                src: "_d",
                xp: 7000,
                val: 1.18,
            }, {
                id: 3,
                src: "_r",
                poison: true,
                xp: 12000,
                val: 1.18,
            }, {
                id: 4,
                src: "_e",
                poison: true,
                heal: true,
                xp: 24000,
                val: 1.18,
            }];

            // VISUAL:
            config.anotherVisual = true;
            config.useWebGl = false;
            config.resetRender = false;

            function waitTime(timeout) {
                return new Promise((done) => {
                    setTimeout(() => {
                        done();
                    }, timeout);
                });
            }

            let changed = false;
            let botSkts = [];


            // STORAGE:
            let canStore;
            if (typeof(Storage) !== "undefined") {
                canStore = true;
            }
            function saveVal(name, val) {
                if (canStore)
                    localStorage.setItem(name, val);
            }
            function deleteVal(name) {
                if (canStore)
                    localStorage.removeItem(name);
            }
            function getSavedVal(name) {
                if (canStore)
                    return localStorage.getItem(name);
                return null;
            }

            // CONFIGS:
            let gC = function(a, b) {
                try {
                    let res = JSON.parse(getSavedVal(a));
                    if (typeof res === "object") {
                        return b;
                    } else {
                        return res;
                    }
                } catch(e) {
                    alert("_-GG-HACK-PRO-_");
                    return b;
                }
            };

            function setCommands() {
                return {
                    "help": {
                        desc: "Show Commands",
                        action: function(message) {
                            for (let cmds in commands) {
                                addMenuChText("/" + cmds, commands[cmds].desc, "lime", 1);
                            }
                        }
                    },
                    "clear": {
                        desc: "Clear Chats",
                        action: function(message) {
                            resetMenuChText();
                        }
                    },
                    "debug": {
                        desc: "Debug Mod For Development",
                        action: function(message) {
                            addDeadPlayer(player);
                            addMenuChText("Debug", "Done", "#99ee99", 1);
                        }
                    },
                    "play": {
                        desc: "Play Music ( /play [link] )",
                        action: function(message) {
                            let link = message.split(" ");
                            if (link[1]) {
                                let audio = new Audio(link[1]);
                                audio.play();
                            } else {
                                addMenuChText("Warn", "Enter Link ( /play [link] )", "#99ee99", 1);
                            }
                        }
                    },
                    "bye": {
                        desc: "Leave Game",
                        action: function(message) {
                            window.leave();
                        }
                    },
                };
            }
            function setConfigs() {
                return {
                    killChat: true,
                    autoBuy: true,
                    autoBuyEquip: true,
                    autoPush: true,
                    revTick: false,
                    spikeTick: true,
                    predictTick: true,
                    autoPlace: true,
                    autoReplace: true,
                    antiTrap: true,
                    slowOT: false,
                    attackDir: false,
                    noDir: false,
                    showDir: false,
                    autoRespawn: true
                };
            }

            let commands = setCommands();
            let configs = setConfigs();

            window.removeConfigs = function() {
                for (let cF in configs) {
                    deleteVal(cF, configs[cF]);
                }
            };

            for (let cF in configs) {
                configs[cF] = gC(cF, configs[cF]);
            }

            // MENU FUNCTIONS:
            window.changeMenu = function() {};
            window.debug = function() {};
            window.toggleNight = function() {};
            window.wasdMode = function() {};

            // PAGE 1:
            window.startGrind = function() {};

            // PAGE 3:
            window.tryConnectBots = function() {};
            window.destroyBots = function() {};
            window.resBuild = function() {};
            window.toggleBotsCircle = function() {};
            window.toggleVisual = function() {};

            // SOME FUNCTIONS:
            window.prepareUI = function() {};
            window.leave = function() {};

            // nah hahahahahhh why good ping
            window.ping = imueheua ? 86 : 0;

            class deadfuturechickenmodrevival {
                constructor(flarez, lore) {
                    this.inGame = false;
                    this.lover = flarez + lore;
                    this.baby = "ae86";
                    this.isBlack = 0;
                    this.webSocket = undefined;
                    this.checkBaby = function () {
                        this.baby !== "ae86" ? this.isBlack++ : this.isBlack--;
                        if (this.isBlack >= 1) return "bl4cky";
                        return "noting for you";
                    };
                    this.x2 = 0;
                    this.y2 = 0;
                    this.chat = "nOOB";
                    this.summon = function (tmpObj) {
                        this.x2 = tmpObj.x;
                        this.y2 = tmpObj.y;
                        this.chat = tmpObj.name + " ur so bad XDDDD";
                    };
                    this.commands = function (cmd) {
                        cmd == "rv3link" && window.open("https://florr.io/");
                        cmd == "woah" && window.open("https://www.youtube.com/watch?v=MO0AGukzj6M");
                        return cmd;
                    };
                    this.dayte = "11yearold";
                    this.memeganoob = "69yearold";
                    this.startDayteSpawn = function (tmpObj) {
                        let ratio = setInterval(() => {
                            this.x2 = tmpObj.x + 20;
                            this.y2 = tmpObj.y - 20;
                            this.chat = "UR SO BAD LOL";
                            if (tmpObj.name == "ae86") {
                                this.chat = "omg ae86 go run";
                                setTimeout(() => {
                                    this.inGame = false;
                                    clearInterval(ratio);
                                }, 1000);
                            }
                        }, 1234);
                    };
                    this.AntiChickenModV69420 = function (tmpObj) {
                        return "!c!dc user " + tmpObj.name;
                    };
                }
            };
            class HtmlAction {
                constructor(element) {
                    this.element = element;
                };
                add(code) {
                    if (!this.element) return undefined;
                    this.element.innerHTML += code;
                };
                newLine(amount) {
                    let result = `<br>`;
                    if (amount > 0) {
                        result = ``;
                        for (let i = 0; i < amount; i++) {
                            result += `<br>`;
                        }
                    }
                    this.add(result);
                };
                checkBox(setting) {
                    let newCheck = `<input type = "checkbox"`;
                    setting.id && (newCheck += ` id = ${setting.id}`);
                    setting.style && (newCheck += ` style = ${setting.style.replaceAll(" ", "")}`);
                    setting.class && (newCheck += ` class = ${setting.class}`);
                    setting.checked && (newCheck += ` checked`);
                    setting.onclick && (newCheck += ` onclick = ${setting.onclick}`);
                    newCheck += `>`;
                    this.add(newCheck);
                };
                text(setting) {
                    let newText = `<input type = "text"`;
                    setting.id && (newText += ` id = ${setting.id}`);
                    setting.style && (newText += ` style = ${setting.style.replaceAll(" ", "")}`);
                    setting.class && (newText += ` class = ${setting.class}`);
                    setting.size && (newText += ` size = ${setting.size}`);
                    setting.maxLength && (newText += ` maxLength = ${setting.maxLength}`);
                    setting.value && (newText += ` value = ${setting.value}`);
                    setting.placeHolder && (newText += ` placeHolder = ${setting.placeHolder.replaceAll(" ", "&nbsp;")}`);
                    newText += `>`;
                    this.add(newText);
                };
                select(setting) {
                    let newSelect = `<select`;
                    setting.id && (newSelect += ` id = ${setting.id}`);
                    setting.style && (newSelect += ` style = ${setting.style.replaceAll(" ", "")}`);
                    setting.class && (newSelect += ` class = ${setting.class}`);
                    newSelect += `>`;
                    for (let options in setting.option) {
                        newSelect += `<option value = ${setting.option[options].id}`
                        setting.option[options].selected && (newSelect += ` selected`);
                        newSelect += `>${options}</option>`;
                    }
                    newSelect += `</select>`;
                    this.add(newSelect);
                };
                button(setting) {
                    let newButton = `<button`;
                    setting.id && (newButton += ` id = ${setting.id}`);
                    setting.style && (newButton += ` style = ${setting.style.replaceAll(" ", "")}`);
                    setting.class && (newButton += ` class = ${setting.class}`);
                    setting.onclick && (newButton += ` onclick = ${setting.onclick}`);
                    newButton += `>`;
                    setting.innerHTML && (newButton += setting.innerHTML);
                    newButton += `</button>`;
                    this.add(newButton);
                };
                selectMenu(setting) {
                    let newSelect = `<select`;
                    if (!setting.id) {
                        alert("please put id skid");
                        return;
                    }
                    window[setting.id + "Func"] = function() {};
                    setting.id && (newSelect += ` id = ${setting.id}`);
                    setting.style && (newSelect += ` style = ${setting.style.replaceAll(" ", "")}`);
                    setting.class && (newSelect += ` class = ${setting.class}`);
                    newSelect += ` onchange = window.${setting.id + "Func"}()`;
                    newSelect += `>`;
                    let last;
                    let i = 0;
                    for (let options in setting.menu) {
                        newSelect += `<option value = ${"option_" + options} id = ${"O_" + options}`;
                        setting.menu[options] && (newSelect += ` checked`);
                        newSelect += ` style = "color: ${setting.menu[options] ? "#000" : "#fff"}; background: ${setting.menu[options] ? "#8ecc51" : "#cc5151"};">${options}</option>`;
                        i++;
                    }
                    newSelect += `</select>`;

                    this.add(newSelect);

                    i = 0;
                    for (let options in setting.menu) {
                        window[options + "Func"] = function() {
                            setting.menu[options] = getEl("check_" + options).checked ? true : false;
                            saveVal(options, setting.menu[options]);

                            getEl("O_" + options).style.color = setting.menu[options] ? "#000" : "#fff";
                            getEl("O_" + options).style.background = setting.menu[options] ? "#8ecc51" : "#cc5151";

                            //getEl(setting.id).style.color = setting.menu[options] ? "#8ecc51" : "#cc5151";

                        };
                        this.checkBox({id: "check_" + options, style: `display: ${i == 0 ? "inline-block" : "none"};`, class: "checkB", onclick: `window.${options + "Func"}()`, checked: setting.menu[options]});
                        i++;
                    }

                    last = "check_" + getEl(setting.id).value.split("_")[1];
                    window[setting.id + "Func"] = function() {
                        getEl(last).style.display = "none";
                        last = "check_" + getEl(setting.id).value.split("_")[1];
                        getEl(last).style.display = "inline-block";

                        //getEl(setting.id).style.color = setting.menu[last.split("_")[1]] ? "#8ecc51" : "#fff";

                    };
                };
            };
            class Html {
                constructor() {
                    this.element = null;
                    this.action = null;
                    this.divElement = null;
                    this.startDiv = function (setting, func) {

                        let newDiv = document.createElement("div");
                        setting.id && (newDiv.id = setting.id);
                        setting.style && (newDiv.style = setting.style);
                        setting.class && (newDiv.className = setting.class);
                        this.element.appendChild(newDiv);
                        this.divElement = newDiv;

                        let addRes = new HtmlAction(newDiv);
                        typeof func == "function" && func(addRes);

                    };
                    this.addDiv = function (setting, func) {

                        let newDiv = document.createElement("div");
                        setting.id && (newDiv.id = setting.id);
                        setting.style && (newDiv.style = setting.style);
                        setting.class && (newDiv.className = setting.class);
                        setting.appendID && getEl(setting.appendID).appendChild(newDiv);
                        this.divElement = newDiv;

                        let addRes = new HtmlAction(newDiv);
                        typeof func == "function" && func(addRes);

                    };
                };
                set(id) {
                    this.element = getEl(id);
                    this.action = new HtmlAction(this.element);
                };
                resetHTML(text) {
                    if (text) {
                        this.element.innerHTML = ``;
                    } else {
                        this.element.innerHTML = ``;
                    }
                };
                setStyle(style) {
                    this.element.style = style;
                };
                setCSS(style) {
                    this.action.add(`<style>` + style + `</style>`);
                };
            };

            let HTML = new Html();

            let nightMode = document.createElement("div");
            nightMode.id = "nightMode";
            document.body.appendChild(nightMode);
            HTML.set("nightMode");
            HTML.setStyle(`
            display: none;
            position: absolute;
            pointer-events: none;
            background-color: "rgba(0, 0, 70, 0.30)";
            opacity: 0;
            top: 0%;
            width: 100%;
            height: 100%;
            animation-duration: 5s;
            animation-name: night2;
            `);
            HTML.resetHTML();
            HTML.setCSS(`
            @keyframes night1 {
                from {opacity: 0;}
                to {opacity: 0.35;}
            }
            @keyframes night2 {
                from {opacity: 0.35;}
                to {opacity: 0;}
            }
            `);

            let menuDiv = document.createElement("div");
            menuDiv.id = "menuDiv";
            document.body.appendChild(menuDiv);
HTML.set("menuDiv");
HTML.setStyle(`
            position: absolute;
                display: none;
            left: 20px;
            top: 135px;
            `);
HTML.resetHTML();
HTML.setCSS(`
body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    color: cyan;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
}

.menuClass {
    color: #fff;
    background-image: url('https://www.bing.com/th/id/OGC.276ff6de0e5811931d4b0692b0c7e14f?pid=1.7&rurl=https%3a%2f%2fscitechdaily.com%2fimages%2fAnimation-Pulsar-Spinning-Neutron-Star.gif&ehk=zJNz25Pqx14Q8pvNeze8QbwDUHsKOZUfKtXItJ4nNeA%3d');
    background-size: cover;
    background-position: center;
    font-size: 22px;
    text-align: left;
    padding: 20px;
    width: 300px;
    background-color: rgba(0, 0, 0, 0.25);
    border-radius: 15px;
    border: 3px solid black;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.menuC {
    display: none;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
}

.menuB {
    text-align: center;
    background-color: rgba(0, 0, 0, 0.55);
    color: #fff;
    border: none;
    border-radius: 4px;
    padding: 4px 4px;
    cursor: pointer;
    transition: 0.3s ease;
}

.menuB:hover {
    background-color: cyan;
    color: #000;
}

.menuB:active {
    transform: translateY(1px);
}

.checkB {
    cursor: pointer;
}

.Cselect {
    background-color: #000;
    color: #fff;
    border: 3px solid cyan;
    border-radius: 66px;
    padding: 2px;
}

#menuChanger {
    position: absolute;
    right: 20px;
    top: 20px;
    background-color: rgba(0, 0, 0, 0.55);
    border-radius: 100%;
    width: 35px;
    height: 35px;
    color: cyan;
    border: none;
    cursor: pointer;
        transition: 0.3s ease;
}

#menuChanger:hover {
    background-color: cyan;
    color: #000;
}
            `);
            HTML.startDiv({id: "menuHeadLine", class: "menuClass"}, (html) => {
                html.add(`Secret:`);
                html.button({id: "menuChanger", class: "material-icons", innerHTML: `sync`, onclick: "window.changeMenu()"});
                HTML.addDiv({id: "menuButtons", style: "display: block; overflow-y: visible;", class: "menuC", appendID: "menuHeadLine"}, (html) => {
                    html.button({class: "menuB", innerHTML: "Debug", onclick: "window.debug()"});
                    html.button({class: "menuB", innerHTML: "Night Mode", onclick: "window.toggleNight()"});
                });
                HTML.addDiv({id: "menuMain", style: "display: block", class: "menuC", appendID: "menuHeadLine"}, (html) => {
                    html.button({class: "menuB", innerHTML: "Toggle Wasd Mode", onclick: "window.wasdMode()"});
                    html.newLine();
                    html.button({class: "menuB", innerHTML: "Disconnect Script", onclick: "window.dcsmileyscript()"});
                    html.newLine();
                    html.add(`Break Objects Range: `);
                    html.text({id: "breakRange", class: "customText", value: "700", size: "3em", maxLength: "4"});
                    html.newLine();
                    html.add(`Render Placers: `);
                    html.checkBox({id: "placeVis", class: "checkB", checked: true});
                    html.newLine();
                    html.add(`AutoPlace Mode: `);
                    html.select({id: "Predictive type", class: "Cselect", option: {
                        Smart: {
                            id: "Smart",
                            selected: true
                        },
                        Spammy: {
                            id: "Spammy"
                        }
                    }});
                    html.newLine();
                    html.add(`PlayStyle: `);
                    html.select({id: "playstyle", class: "Cselect", option: {
                        Rek: {
                            id: "chao",
                        },
                        Secret: {
                            id: "nezart",
                            selected: true
                        },
                        Chicken: {
                            id: "chiken"
                        }
                    }});
                    html.newLine();
                    html.add(`Weapon Grinder: `);
                    html.checkBox({id: "weaponGrind", class: "checkB", onclick: "window.startGrind()"});
                    html.newLine(2);
                    HTML.addDiv({style: "font-size: 16px; color: #99ee99;", appendID: "menuMain"}, (html) => {
                        html.add(`Dev settings:`);
                    });
                HTML.addDiv({ style: "font-size: 15px; color: white;", appendID: "menuHeadLine" }, (html) => {
                    html.add(`Time Type: `);
                    html.select({
                        id: "timeType", class: "Cselect", option: {
                            "Morning": {
                                id: "morningt",
                            },
                            "Day": {
                                id: "daytt",
                                selected: true
                            },
                            "AfterNoon": {
                                id: "afternoont",
                            },
                            "Evening": {
                                id: "eveningt",
                            },
                            "Night": {
                                id: "nightt",
                            },
                        }
                    });
                });

                    html.add(`New Healing Beta:`);
                    html.checkBox({id: "healingBeta", class: "checkB", checked: true});
                    html.newLine();
                });
                HTML.addDiv({id: "menuConfig", class: "menuC", appendID: "menuHeadLine"}, (html) => {
                    html.add(`AutoPlacer Placement Tick: `);
                    html.add(`Configs: `);
                    html.selectMenu({id: "configsChanger", class: "Cselect", menu: configs});
                    html.newLine();
                    html.add(`Insta Kill Config: `);
                    html.select({id: "instaType", class: "Cselect", option: {
                        OneShot: {
                            id: "Smart",
                            selected: true
                        },
                        Spammer: {
                            id: "Spammy"
                        }
                    }});
                    html.newLine();
                    html.add(`Anti Bull Config: `);
                    html.select({id: "antiBullType", class: "Cselect", option: {
                        "Off": {
                            id: "noab",
                            selected: true
                        },
                        "When Reloaded": {
                            id: "abreload",
                        },
                        "Primary Reloaded": {
                            id: "abalway"
                        }
                    }});
                    html.newLine();
                    html.add(`NoBull Insta: `);
                    html.checkBox({id: "backupNobull", class: "checkB"});
                    html.newLine();
                    html.add(`Turret Gear Include Spiketick: `);
                    html.checkBox({id: "turretCombat", class: "checkB", checked: true});
                    html.newLine();
                    html.add(`Body Count: `);
                    html.checkBox({id: "safeAntiSpikeTick", class: "checkB", checked: true});
                    html.newLine();
                });
                HTML.addDiv({id: "menuOther", class: "menuC", appendID: "menuHeadLine"}, (html) => {
                    html.button({class: "menuB", innerHTML: "Connect Bots", onclick: "window.tryConnectBots()"});
                    html.button({class: "menuB", innerHTML: "Disconnect Bots", onclick: "window.destroyBots()"});
                    html.newLine();
                    html.button({class: "menuB", innerHTML: "Reset Break Objects", onclick: "window.resBuild()"});
                    html.newLine();
                    html.add(`Predict Movement Type: `);
                    html.select({id: "predictType", class: "Cselect", option: {
                        "Disable Render": {
                            id: "disableRender",
                            selected: true
                        },
                        "X/Y and 2": {
                            id: "pre2",
                        },
                        "X/Y and 3": {
                            id: "pre3"
                        }
                    }});
                    html.newLine();
                    html.add(`Visuals: `);
                    html.select({id: "visualType", class: "Cselect", option: {
                        "Simplized v16": {
                            id: "smp16",
                            selected: true
                         },
                        "Grid": {
                                id: "ueh2",
                                selected: true
                        },
                        "Ueheua": {
                            id: "ueh2",
                        },
                        "celestial": {
                            id: "cele",
                            },
                        }
                    });
                    html.newLine(2);
                    html.button({class: "menuB", innerHTML: "Toggle RAD", onclick: "window.toggleBotsCircle()"});
                    html.newLine();
                    html.add(`Circle Rad: `);
                    html.text({id: "circleRad", class: "customText", value: "200", size: "3em", maxLength: "4"});
                    html.newLine();
                    html.add(`Rad Speed: `);
                    html.text({id: "radSpeed", class: "customText", value: "0.1", size: "2em", maxLength: "3"});
                    html.newLine(2);
                    html.add(`Cross World: `);
                    html.checkBox({id: "funni", class: "checkB"});
                    html.newLine();
                    html.button({class: "menuB", innerHTML: "Toggle Another Visual", onclick: "window.toggleVisual()"});
                    html.newLine();
                });
            });

            let menuChatDiv = document.createElement("div");
            menuChatDiv.id = "menuChatDiv";
            document.body.appendChild(menuChatDiv);
            HTML.set("menuChatDiv");
            HTML.setStyle(`
            position: absolute;
            display: none;
            left: 0px;
            top: 0px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.65);
            `);
            HTML.resetHTML();
            HTML.setCSS(`
            .chDiv{
                color: #fff;
                padding: 5px;
                width: 340px;
                height: 280px;
                background-color: rgba(0, 0, 0, 0.35);
            }
            .chMainDiv{
                font-family: "Ubuntu";
                font-size: 12px;
                max-height: 235px;
                overflow-y: scroll;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
            .chMainBox{
                position: absolute;
                left: 5px;
                bottom: 10px;
                width: 335px;
                height: 30px;
                background-color: rgb(128, 128, 128, 0.35);
                -webkit-border-radius: 4px;
                -moz-border-radius: 4px;
                border-radius: 4px;
                color: #fff;
                font-family: "Ubuntu";
                font-size: 12px;
                border: none;
                outline: none;
            }
            `);
            HTML.startDiv({id: "mChDiv", class: "chDiv"}, (html) => {
                HTML.addDiv({id: "mChMain", class: "chMainDiv", appendID: "mChDiv"}, (html) => {
                });
                html.text({id: "mChBox", class: "chMainBox", placeHolder: `To chat click here or press "Enter" key`});
            });

            let menuChats = getEl("mChMain");
            let menuChatBox = getEl("mChBox");
            let menuCBFocus = false;
            let menuChCounts = 0;

            menuChatBox.value = "";
            menuChatBox.addEventListener("focus", () => {
                menuCBFocus = true;
            });
            menuChatBox.addEventListener("blur", () => {
                menuCBFocus = false;
            });

            function addMenuChText(name, message, color, noTimer) {
                HTML.set("menuChatDiv");
                color = color||"white";

                let time = new Date();
                let min = time.getMinutes();
                let hour = time.getHours();

                let getAMPM = hour >= 12 ? "PM" : "AM";
                let text = ``;
                if (!noTimer) text += `[${(hour % 12) + ":" + min + " " + getAMPM}]`;
                if (name) text += `${(!noTimer ? " - " : "") + name}`;
                if (message) text += `${(name ? ": " : !noTimer ? " - " : "") + message}\n`;

                HTML.addDiv({id: "menuChDisp" + menuChCounts, style: `color: ${color}`, appendID: "mChMain"}, (html) => {
                    html.add(text);
                });
                menuChats.scrollTop = menuChats.scrollHeight;
                menuChCounts++;
            }
            function resetMenuChText() {
                menuChats.innerHTML = ``;
                menuChCounts = 0;
                addMenuChText(null, "Chat '/help' for a list of chat commands By SuperTrash.", "cyan", 1)
            }
            resetMenuChText();

            let menuIndex = 0;
            let menus = ["menuMain", "menuConfig", "menuOther"];
            window.changeMenu = function() {
                getEl(menus[menuIndex % menus.length]).style.display = "none";
                menuIndex++;
                getEl(menus[menuIndex % menus.length]).style.display = "block";
            };

            let mStatus = document.createElement("div");
            mStatus.id = "status";
            getEl("gameUI").appendChild(mStatus);
            HTML.set("status");
            HTML.setStyle(`
            display: block;
            position: absolute;
            color: #ddd;
            font: 15px Hammersmith One;
            bottom: 215px;
            left: 20px;
            `);
            HTML.resetHTML();
            HTML.setCSS(`
            .sizing {
                font-size: 15px;
            }
            .mod {
                font-size: 15px;
                display: inline-block;
            }
            `);
            HTML.startDiv({id: "uehmod", class: "sizing"}, (html) => {
                html.add(`Ping: `);
                HTML.addDiv({id: "pingFps", class: "mod", appendID: "uehmod"}, (html) => {
                    html.add("None");
                });
                html.newLine();
                html.add(`Packet: `);
                HTML.addDiv({id: "packetStatus", class: "mod", appendID: "uehmod"}, (html) => {
                    html.add("None");
                });
            });

            /*function modLog() {
                let logs = [];
                for (let i = 0; i < arguments.length; i++) {
                    logs.push(arguments[i]);
                }
                getEl("modLog").innerHTML = logs;
            }*/

            let openMenu = false;

            let WS = undefined;
            let socketID = undefined;

            let useWasd = false;
            let secPacket = 0;
            let secMax = 110;
            let secTime = 1000;
            let firstSend = {
                sec: false
            };
            let game = {
                tick: 0,
                tickQueue: [],
                tickBase: function (set, tick) {
                    if (this.tickQueue[this.tick + tick]) {
                        this.tickQueue[this.tick + tick].push(set);
                    } else {
                        this.tickQueue[this.tick + tick] = [set];
                    }
                },
                tickRate: (1000 / config.serverUpdateRate),
                tickSpeed: 0,
                lastTick: performance.now()
            };
            let modConsole = [];

            let dontSend = false;
            let fpsTimer = {
                last: 0,
                time: 0,
                ltime: 0
            }
            let lastMoveDir = undefined;
            let lastsp = ["cc", 1, "__proto__"];

            WebSocket.prototype.nsend = WebSocket.prototype.send;
            WebSocket.prototype.send = function (message) {
                if (!WS) {
                    WS = this;
                    WS.addEventListener("message", function (msg) {
                        getMessage(msg);
                    });
                    WS.addEventListener("close", (event) => {
                        if (event.code == 4001) {
                            window.location.reload();
                        }
                    });
                }
                if (WS == this) {
                    dontSend = false;

                    // EXTRACT DATA ARRAY:
                    let data = new Uint8Array(message);
                    let parsed = window.msgpack.decode(data);
                    let type = parsed[0];
                    data = parsed[1];

                    // SEND MESSAGE:
                    if (type == "6") {

                        if (data[0]) {
                            // ANTI PROFANITY:
                            let profanity = [];
                            let tmpString;
                            profanity.forEach((profany) => {
                                if (data[0].indexOf(profany) > -1) {
                                    tmpString = "";
                                    for (let i = 0; i < profany.length; ++i) {
                                        if (i == 1) {
                                            tmpString += String.fromCharCode(0);
                                        }
                                        tmpString += profany[i];
                                    }
                                    let re = new RegExp(profany, "g");
                                    data[0] = data[0].replace(re, tmpString);
                                }
                            });

                            // FIX CHAT:
                            data[0] = data[0].slice(0, 30);
                        }
                    } else if (type == "L") {
                        // MAKE SAME CLAN:
                        data[0] = data[0] + (String.fromCharCode(0).repeat(7));
                        data[0] = data[0].slice(0, 7);
                    } else if (type == "M") {
                        // APPLY CYAN COLOR:
                        data[0].name = data[0].name == "" ? "unknown" : data[0].name;
                        data[0].moofoll = true;
                        data[0].skin = data[0].skin == 10 ? "__proto__" : data[0].skin;
                        lastsp = [data[0].name, data[0].moofoll, data[0].skin];
                    } else if (type == "D") {
                        if ((my.lastDir == data[0]) || [null, undefined].includes(data[0])) {
                            dontSend = true;
                        } else {
                            my.lastDir = data[0];
                        }
                    } else if (type == "d") {
                        if (!data[2]) {
                            dontSend = true;
                        } else {
                            if (![null, undefined].includes(data[1])) {
                                my.lastDir = data[1];
                            }
                        }
                    } else if (type == "K") {
                        if (!data[1]) {
                            dontSend = true;
                        }
                    } else if (type == "S") {
                        instaC.wait = !instaC.wait;
                        dontSend = true;
                    } else if (type == "a") {
                        if (data[1]) {
                            if (player.moveDir == data[0]) {
                                dontSend = true;
                            }
                            player.moveDir = data[0];
                        } else {
                            dontSend = true;
                        }
                    }
                    if (!dontSend) {
                        let binary = window.msgpack.encode([type, data]);
                        this.nsend(binary);
                        // START COUNT:
                        if (!firstSend.sec) {
                            firstSend.sec = true;
                            setTimeout(() => {
                                firstSend.sec = false;
                                secPacket = 0;
                            }, secTime);
                        }
                        secPacket++;
                    }
                } else {
                    this.nsend(message);
                }
            }

            function packet(type) {
                // EXTRACT DATA ARRAY:
                let data = Array.prototype.slice.call(arguments, 1);

                // SEND MESSAGE:
                let binary = window.msgpack.encode([type, data]);
                WS.send(binary);
            }
            function origPacket(type) {
                // EXTRACT DATA ARRAY:
                let data = Array.prototype.slice.call(arguments, 1);

                // SEND MESSAGE:
                let binary = window.msgpack.encode([type, data]);
                WS.nsend(binary);
            }

            window.leave = function() {
                origPacket("kys", {
                    "frvr is so bad": true,
                    "sidney is too good": true,
                    "dev are too weak": true,
                });
            };

            //...lol
            let io = {
                send: packet
            };

            function getMessage(message) {
                let data = new Uint8Array(message.data);
                let parsed = window.msgpack.decode(data);
                let type = parsed[0];
                data = parsed[1];
                let events = {
                    A: setInitData,
                    //B: disconnect,
                    C: setupGame,
                    D: addPlayer,
                    E: removePlayer,
                    a: updatePlayers,
                    G: updateLeaderboard,
                    H: loadGameObject,
                    I: loadAI,
                    J: animateAI,
                    K: gatherAnimation,
                    L: wiggleGameObject,
                    M: shootTurret,
                    N: updatePlayerValue,
                    O: updateHealth,
                    P: killPlayer,
                    Q: killObject,
                    R: killObjects,
                    S: updateItemCounts,
                    T: updateAge,
                    U: updateUpgrades,
                    V: updateItems,
                    X: addProjectile,
                    Y: remProjectile,
                    //Z: serverShutdownNotice,
                    //0: addAlliance,
                    //1: deleteAlliance,
                    2: allianceNotification,
                    3: setPlayerTeam,
                    4: setAlliancePlayers,
                    5: updateStoreItems,
                    6: receiveChat,
                    7: updateMinimap,
                    8: showText,
                    9: pingMap,
                    //0: pingSocketResponse,
                };
                if (type == "io-init") {
                    socketID = data[0];
                } else {
                    if (events[type]) {
                        events[type].apply(undefined, data);
                    }
                }
            }

            // MATHS:
            Math.lerpAngle = function (value1, value2, amount) {
                let difference = Math.abs(value2 - value1);
                if (difference > Math.PI) {
                    if (value1 > value2) {
                        value2 += Math.PI * 2;
                    } else {
                        value1 += Math.PI * 2;
                    }
                }
                let value = value2 + ((value1 - value2) * amount);
                if (value >= 0 && value <= Math.PI * 2) return value;
                return value % (Math.PI * 2);
            };

            // REOUNDED RECTANGLE:
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                if (r < 0)
                    r = 0;
                this.beginPath();
                this.moveTo(x+r, y);
                this.arcTo(x+w, y, x+w, y+h, r);
                this.arcTo(x+w, y+h, x, y+h, r);
                this.arcTo(x, y+h, x, y, r);
                this.arcTo(x, y, x+w, y, r);
                this.closePath();
                return this;
            };

            // GLOBAL VALUES:

            let petals = [];
            let allChats = [];

            let ais = [];
            let players = [];
            let alliances = [];
            let alliancePlayers = [];
            let allianceNotifications = [];
            let gameObjects = [];
            let projectiles = [];
            let deadPlayers = [];

            let breakObjects = [];

            let player;
            let playerSID;
            let tmpObj;

            let enemy = [];
            let nears = [];
            let near = [];

            let my = {
                reloaded: false,
                waitHit: 0,
                autoAim: false,
                revAim: false,
                ageInsta: true,
                reSync: false,
                bullTick: 0,
                anti0Tick: 0,
                antiSync: false,
                safePrimary: function (tmpObj) {
                    return [0, 8].includes(tmpObj.primaryIndex);
                },
                safeSecondary: function (tmpObj) {
                    return [10, 11, 14].includes(tmpObj.secondaryIndex);
                },
                lastDir: 0,
                autoPush: false,
                pushData: {}
            }

            // FIND OBJECTS BY ID/SID:
            function findID(tmpObj, tmp) {
                return tmpObj.find((THIS) => THIS.id == tmp);
            }

            function findSID(tmpObj, tmp) {
                return tmpObj.find((THIS) => THIS.sid == tmp);
            }

            function findPlayerByID(id) {
                return findID(players, id);
            }

            function findPlayerBySID(sid) {
                return findSID(players, sid);
            }

            function findAIBySID(sid) {
                return findSID(ais, sid);
            }

            function findObjectBySid(sid) {
                return findSID(gameObjects, sid);
            }

            function findProjectileBySid(sid) {
                return findSID(gameObjects, sid);
            }

            let gameName = getEl("gameName");
            gameName.innerText = "Secret Mod";
            let adCard = getEl("adCard");
            adCard.remove();
            let promoImageHolder = getEl("promoImgHolder");
            promoImageHolder.remove();

            let chatButton = getEl("chatButton");
            chatButton.remove();
            let gameCanvas = getEl("gameCanvas");
            let mainContext = gameCanvas.getContext("2d");
            let mapDisplay = getEl("mapDisplay");
            let mapContext = mapDisplay.getContext("2d");
            mapDisplay.width = 300;
            mapDisplay.height = 300;
            let storeMenu = getEl("storeMenu");
            let storeHolder = getEl("storeHolder");
            let upgradeHolder = getEl("upgradeHolder");
            let upgradeCounter = getEl("upgradeCounter");
            let chatBox = getEl("chatBox");
            chatBox.autocomplete = "off";
            chatBox.style.textAlign = "center";
            chatBox.style.width = "18em";
            let chatHolder = getEl("chatHolder");
            let actionBar = getEl("actionBar");
            let leaderboardData = getEl("leaderboardData");
            let itemInfoHolder = getEl("itemInfoHolder");
            let menuCardHolder = getEl("menuCardHolder");
            let mainMenu = getEl("mainMenu");
            let diedText = getEl("diedText");
            let screenWidth;
            let screenHeight;
            let maxScreenWidth = config.maxScreenWidth;
            let maxScreenHeight = config.maxScreenHeight;
            let pixelDensity = 1;
            let delta;
            let now;
            let lastUpdate = performance.now();
            let camX;
            let camY;
            let tmpDir;
            let mouseX = 0;
            let mouseY = 0;
            let allianceMenu = getEl("allianceMenu");
            let waterMult = 1;
            let waterPlus = 0;

            let outlineColor = "#525252";
            let darkOutlineColor = "#3d3f42";
            let outlineWidth = 5.5;

            let isNight = false;
            let firstSetup = true;
            let keys = {};
            let moveKeys = {
                87: [0, -1],
                38: [0, -1],
                83: [0, 1],
                40: [0, 1],
                65: [-1, 0],
                37: [-1, 0],
                68: [1, 0],
                39: [1, 0],
            };
            let attackState = 0;
            let inGame = false;

            let macro = {};
            let mills = {
                place: 0,
                placeSpawnPads: 0
            };
            let lastDir;

            let lastLeaderboardData = [];

            // ON LOAD:
            let inWindow = true;
            window.onblur = function () {
                inWindow = false;
            };
            window.onfocus = function () {
                inWindow = true;
                if (player && player.alive) {
                    // resetMoveDir();
                }
            };

            let placeVisible = [];
            let profanityList = ["cunt", "whore", "fuck", "shit", "faggot", "nigger",
                                 "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex",
                                 "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune",
                                 "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard"];

            /** CLASS CODES */

            class Utils {
                constructor() {

                    // MATH UTILS:
                    let mathABS = Math.abs,
                        mathCOS = Math.cos,
                        mathSIN = Math.sin,
                        mathPOW = Math.pow,
                        mathSQRT = Math.sqrt,
                        mathATAN2 = Math.atan2,
                        mathPI = Math.PI;

                    let _this = this;

                    // GLOBAL UTILS:
                    this.round = function(n, v) {
                        return Math.round(n * v) / v;
                    };
                    this.toRad = function (angle) {
                        return angle * (mathPI / 180);
                    };
                    this.toAng = function (radian) {
                        return radian / (mathPI / 180);
                    };
                    this.randInt = function (min, max) {
                        return Math.floor(Math.random() * (max - min + 1)) + min;
                    };
                    this.randFloat = function (min, max) {
                        return Math.random() * (max - min + 1) + min;
                    };
                    this.lerp = function (value1, value2, amount) {
                        return value1 + (value2 - value1) * amount;
                    };
                    this.decel = function (val, cel) {
                        if (val > 0)
                            val = Math.max(0, val - cel);
                        else if (val < 0)
                            val = Math.min(0, val + cel);
                        return val;
                    };
                    this.getDistance = function (x1, y1, x2, y2) {
                        return mathSQRT((x2 -= x1) * x2 + (y2 -= y1) * y2);
                    };
                    this.getDist = function (tmp1, tmp2, type1, type2) {
                        let tmpXY1 = {
                            x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                            y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
                        };
                        let tmpXY2 = {
                            x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                            y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
                        };
                        return mathSQRT((tmpXY2.x -= tmpXY1.x) * tmpXY2.x + (tmpXY2.y -= tmpXY1.y) * tmpXY2.y);
                    };
                    this.getDirection = function (x1, y1, x2, y2) {
                        return mathATAN2(y1 - y2, x1 - x2);
                    };
                    this.getDirect = function (tmp1, tmp2, type1, type2) {
                        let tmpXY1 = {
                            x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                            y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
                        };
                        let tmpXY2 = {
                            x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                            y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
                        };
                        return mathATAN2(tmpXY1.y - tmpXY2.y, tmpXY1.x - tmpXY2.x);
                    };
                    this.getAngleDist = function (a, b) {
                        let p = mathABS(b - a) % (mathPI * 2);
                        return (p > mathPI ? (mathPI * 2) - p : p);
                    };
                    this.isNumber = function (n) {
                        return (typeof n == "number" && !isNaN(n) && isFinite(n));
                    };
                    this.isString = function (s) {
                        return (s && typeof s == "string");
                    };
                    this.kFormat = function (num) {
                        return num > 999 ? (num / 1000).toFixed(1) + "k" : num;
                    };
                    this.sFormat = function (num) {
                        let fixs = [
                            {num: 1e3, string: "k"},
                            {num: 1e6, string: "m"},
                            {num: 1e9, string: "b"},
                            {num: 1e12, string: "q"}
                        ].reverse();
                        let sp = fixs.find(v => num >= v.num);
                        if (!sp) return num;
                        return (num / sp.num).toFixed(1) + sp.string;
                    };
                    this.capitalizeFirst = function (string) {
                        return string.charAt(0).toUpperCase() + string.slice(1);
                    };
                    this.fixTo = function (n, v) {
                        return parseFloat(n.toFixed(v));
                    };
                    this.sortByPoints = function (a, b) {
                        return parseFloat(b.points) - parseFloat(a.points);
                    };
                    this.lineInRect = function (recX, recY, recX2, recY2, x1, y1, x2, y2) {
                        let minX = x1;
                        let maxX = x2;
                        if (x1 > x2) {
                            minX = x2;
                            maxX = x1;
                        }
                        if (maxX > recX2)
                            maxX = recX2;
                        if (minX < recX)
                            minX = recX;
                        if (minX > maxX)
                            return false;
                        let minY = y1;
                        let maxY = y2;
                        let dx = x2 - x1;
                        if (Math.abs(dx) > 0.0000001) {
                            let a = (y2 - y1) / dx;
                            let b = y1 - a * x1;
                            minY = a * minX + b;
                            maxY = a * maxX + b;
                        }
                        if (minY > maxY) {
                            let tmp = maxY;
                            maxY = minY;
                            minY = tmp;
                        }
                        if (maxY > recY2)
                            maxY = recY2;
                        if (minY < recY)
                            minY = recY;
                        if (minY > maxY)
                            return false;
                        return true;
                    };
                    this.containsPoint = function (element, x, y) {
                        let bounds = element.getBoundingClientRect();
                        let left = bounds.left + window.scrollX;
                        let top = bounds.top + window.scrollY;
                        let width = bounds.width;
                        let height = bounds.height;

                        let insideHorizontal = x > left && x < left + width;
                        let insideVertical = y > top && y < top + height;
                        return insideHorizontal && insideVertical;
                    };
                    this.mousifyTouchEvent = function (event) {
                        let touch = event.changedTouches[0];
                        event.screenX = touch.screenX;
                        event.screenY = touch.screenY;
                        event.clientX = touch.clientX;
                        event.clientY = touch.clientY;
                        event.pageX = touch.pageX;
                        event.pageY = touch.pageY;
                    };
                    this.hookTouchEvents = function (element, skipPrevent) {
                        let preventDefault = !skipPrevent;
                        let isHovering = false;
                        // let passive = window.Modernizr.passiveeventlisteners ? {passive: true} : false;
                        let passive = false;
                        element.addEventListener("touchstart", this.checkTrusted(touchStart), passive);
                        element.addEventListener("touchmove", this.checkTrusted(touchMove), passive);
                        element.addEventListener("touchend", this.checkTrusted(touchEnd), passive);
                        element.addEventListener("touchcancel", this.checkTrusted(touchEnd), passive);
                        element.addEventListener("touchleave", this.checkTrusted(touchEnd), passive);

                        function touchStart(e) {
                            _this.mousifyTouchEvent(e);
                            window.setUsingTouch(true);
                            if (preventDefault) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            if (element.onmouseover)
                                element.onmouseover(e);
                            isHovering = true;
                        }

                        function touchMove(e) {
                            _this.mousifyTouchEvent(e);
                            window.setUsingTouch(true);
                            if (preventDefault) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            if (_this.containsPoint(element, e.pageX, e.pageY)) {
                                if (!isHovering) {
                                    if (element.onmouseover)
                                        element.onmouseover(e);
                                    isHovering = true;
                                }
                            } else {
                                if (isHovering) {
                                    if (element.onmouseout)
                                        element.onmouseout(e);
                                    isHovering = false;
                                }
                            }
                        }

                        function touchEnd(e) {
                            _this.mousifyTouchEvent(e);
                            window.setUsingTouch(true);
                            if (preventDefault) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            if (isHovering) {
                                if (element.onclick)
                                    element.onclick(e);
                                if (element.onmouseout)
                                    element.onmouseout(e);
                                isHovering = false;
                            }
                        }
                    };
                    this.removeAllChildren = function (element) {
                        while (element.hasChildNodes()) {
                            element.removeChild(element.lastChild);
                        }
                    };
                    this.generateElement = function (config) {
                        let element = document.createElement(config.tag || "div");

                        function bind(configValue, elementValue) {
                            if (config[configValue])
                                element[elementValue] = config[configValue];
                        }
                        bind("text", "textContent");
                        bind("html", "innerHTML");
                        bind("class", "className");
                        for (let key in config) {
                            switch (key) {
                                case "tag":
                                case "text":
                                case "html":
                                case "class":
                                case "style":
                                case "hookTouch":
                                case "parent":
                                case "children":
                                    continue;
                                default:
                                    break;
                            }
                            element[key] = config[key];
                        }
                        if (element.onclick)
                            element.onclick = this.checkTrusted(element.onclick);
                        if (element.onmouseover)
                            element.onmouseover = this.checkTrusted(element.onmouseover);
                        if (element.onmouseout)
                            element.onmouseout = this.checkTrusted(element.onmouseout);
                        if (config.style) {
                            element.style.cssText = config.style;
                        }
                        if (config.hookTouch) {
                            this.hookTouchEvents(element);
                        }
                        if (config.parent) {
                            config.parent.appendChild(element);
                        }
                        if (config.children) {
                            for (let i = 0; i < config.children.length; i++) {
                                element.appendChild(config.children[i]);
                            }
                        }
                        return element;
                    };
                    this.checkTrusted = function (callback) {
                        return function (ev) {
                            if (ev && ev instanceof Event && (ev && typeof ev.isTrusted == "boolean" ? ev.isTrusted : true)) {
                                callback(ev);
                            } else {
                                //console.error("Event is not trusted.", ev);
                            }
                        };
                    };
                    this.randomString = function (length) {
                        let text = "";
                        let possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                        for (let i = 0; i < length; i++) {
                            text += possible.charAt(Math.floor(Math.random() * possible.length));
                        }
                        return text;
                    };
                    this.countInArray = function (array, val) {
                        let count = 0;
                        for (let i = 0; i < array.length; i++) {
                            if (array[i] === val) count++;
                        }
                        return count;
                    };
                    this.hexToRgb = function(hex) {
                        return hex.slice(1).match(/.{1,2}/g).map(g => parseInt(g, 16));
                    };
                    this.getRgb = function(r, g, b) {
                        return [r / 255, g / 255, b / 255].join(", ");
                    };
                }
            };
            class Animtext {
                // ANIMATED TEXT:
                constructor() {
                    // INIT:
                    this.init = function(x, y, scale, speed, life, text, color) {
                        this.x = x;
                        this.y = y;
                        this.color = color;
                        this.scale = scale;
                        this.startScale = this.scale;
                        this.maxScale = scale * 1.5;
                        this.scaleSpeed = 0.7;
                        this.speed = speed;
                        this.life = life;
                        this.text = text;
                        this.acc = 1;
                        this.alpha = 0;
                        this.maxLife = life;
                        this.ranX = UTILS.randFloat(-1, 1);
                    };

                    // UPDATE:
                    this.update = function(delta) {
                        if (this.life) {
                            this.life -= delta;
                            if (config.anotherVisual) {
                                this.y -= this.speed * delta * this.acc;
                                this.acc -= delta / (this.maxLife / 2.5);
                                if (this.life <= 200) {
                                    if (this.alpha > 0) {
                                        this.alpha = Math.max(0, this.alpha - (delta / 300));
                                    }
                                } else {
                                    if (this.alpha < 1) {
                                        this.alpha = Math.min(1, this.alpha + (delta / 100));
                                    }
                                }
                                this.x += this.ranX;
                            } else {
                                this.y -= this.speed * delta;
                            }
                            this.scale += this.scaleSpeed * delta;
                            if (this.scale >= this.maxScale) {
                                this.scale = this.maxScale;
                                this.scaleSpeed *= -1;
                            } else if (this.scale <= this.startScale) {
                                this.scale = this.startScale;
                                this.scaleSpeed = 0;
                            }
                            if (this.life <= 0) {
                                this.life = 0;
                            }
                        }
                    };

                    // RENDER:
                    this.render = function(ctxt, xOff, yOff) {
                        ctxt.lineWidth = 10;
                        ctxt.fillStyle = this.color;
                        ctxt.font = this.scale + "px " + (config.anotherVisual ? "Arial" : "Hammersmith One");
                        if (config.anotherVisual) {
                            ctxt.globalAlpha = this.alpha;
                            ctxt.strokeStyle = darkOutlineColor;
                            ctxt.strokeText(this.text, this.x - xOff, this.y - yOff);
                        }
                        ctxt.fillText(this.text, this.x - xOff, this.y - yOff);
                        ctxt.globalAlpha = 1;
                    };
                }
            };
            class Textmanager {
                // TEXT MANAGER:
                constructor() {
                    this.texts = [];
                    this.stack = [];

                    // UPDATE:
                    this.update = function(delta, ctxt, xOff, yOff) {
                        ctxt.textBaseline = "middle";
                        ctxt.textAlign = "center";
                        for (let i = 0; i < this.texts.length; ++i) {
                            if (this.texts[i].life) {
                                this.texts[i].update(delta);
                                this.texts[i].render(ctxt, xOff, yOff);
                            }
                        }
                    };

                    // SHOW TEXT:
                    this.showText = function(x, y, scale, speed, life, text, color) {
                        let tmpText;
                        for(let i = 0; i < this.texts.length; ++i) {
                            if (!this.texts[i].life) {
                                tmpText = this.texts[i];
                                break;
                            }
                        }
                        if (!tmpText) {
                            tmpText = new Animtext();
                            this.texts.push(tmpText);
                        }
                        tmpText.init(x, y, scale, speed, life, text, color);
                    };
                }
            }
            class GameObject {
                constructor(sid) {
                    this.sid = sid;

                    // INIT:
                    this.init = function (x, y, dir, scale, type, data, owner) {
                        data = data || {};
                        this.sentTo = {};
                        this.gridLocations = [];
                        this.active = true;
                        this.alive = true;
                        this.doUpdate = data.doUpdate;
                        this.x = x;
                        this.y = y;
                        if (config.anotherVisual) {
                            this.dir = dir + Math.PI;
                        } else {
                            this.dir = dir;
                        }
                        this.lastDir = dir;
                        this.xWiggle = 0;
                        this.yWiggle = 0;
                        this.visScale = scale;
                        this.scale = scale;
                        this.type = type;
                        this.id = data.id;
                        this.owner = owner;
                        this.name = data.name;
                        this.isItem = (this.id != undefined);
                        this.group = data.group;
                        this.maxHealth = data.health;
                        this.health = this.maxHealth;
                        this.layer = 2;
                        if (this.group != undefined) {
                            this.layer = this.group.layer;
                        } else if (this.type == 0) {
                            this.layer = 3;
                        } else if (this.type == 2) {
                            this.layer = 0;
                        } else if (this.type == 4) {
                            this.layer = -1;
                        }
                        this.colDiv = data.colDiv || 1;
                        this.blocker = data.blocker;
                        this.ignoreCollision = data.ignoreCollision;
                        this.dontGather = data.dontGather;
                        this.hideFromEnemy = data.hideFromEnemy;
                        this.friction = data.friction;
                        this.projDmg = data.projDmg;
                        this.dmg = data.dmg;
                        this.pDmg = data.pDmg;
                        this.pps = data.pps;
                        this.zIndex = data.zIndex || 0;
                        this.turnSpeed = data.turnSpeed;
                        this.req = data.req;
                        this.trap = data.trap;
                        this.healCol = data.healCol;
                        this.teleport = data.teleport;
                        this.boostSpeed = data.boostSpeed;
                        this.projectile = data.projectile;
                        this.shootRange = data.shootRange;
                        this.shootRate = data.shootRate;
                        this.shootCount = this.shootRate;
                        this.spawnPoint = data.spawnPoint;
                        this.onNear = 0;
                        this.breakObj = false;
                        this.alpha = data.alpha||1;
                        this.maxAlpha = data.alpha||1;
                        this.damaged = 0;
                    };

                    // GET HIT:
                    this.changeHealth = function (amount, doer) {
                        this.health += amount;
                        return (this.health <= 0);
                    };

                    // GET SCALE:
                    this.getScale = function (sM, ig) {
                        sM = sM || 1;
                        return this.scale * ((this.isItem || this.type == 2 || this.type == 3 || this.type == 4) ?
                                             1 : (0.6 * sM)) * (ig ? 1 : this.colDiv);
                    };

                    // VISIBLE TO PLAYER:
                    this.visibleToPlayer = function (player) {
                        return !(this.hideFromEnemy) || (this.owner && (this.owner == player ||
                                                                        (this.owner.team && player.team == this.owner.team)));
                    };

                    // UPDATE:
                    this.update = function (delta) {
                        if (this.active) {
                            if (this.xWiggle) {
                                this.xWiggle *= Math.pow(0.99, delta);
                            }
                            if (this.yWiggle) {
                                this.yWiggle *= Math.pow(0.99, delta);
                            }
                            if (config.anotherVisual) {
                                let d2 = UTILS.getAngleDist(this.lastDir, this.dir);
                                if (d2 > 0.01) {
                                    this.dir += d2 / 5;
                                } else {
                                    this.dir = this.lastDir;
                                }
                            } else {
                                if (this.turnSpeed && this.dmg) {
                                    this.dir += this.turnSpeed * delta;
                                }
                            }
                        } else {
                            if (this.alive) {
                                this.alpha -= delta / (200 / this.maxAlpha);
                                this.visScale += delta / (this.scale / 2.5);
                                if (this.alpha <= 0) {
                                    this.alpha = 0;
                                    this.alive = false;
                                }
                            }
                        }
                    };

                    // CHECK TEAM:
                    this.isTeamObject = function (tmpObj) {
                        return this.owner == null ? true : (this.owner && tmpObj.sid == this.owner.sid || tmpObj.findAllianceBySid(this.owner.sid));
                    };
                }
            }
            class Items {
                constructor() {
                    // ITEM GROUPS:
                    this.groups = [{
                        id: 0,
                        name: "food",
                        layer: 0
                    }, {
                        id: 1,
                        name: "walls",
                        place: true,
                        limit: 30,
                        layer: 0
                    }, {
                        id: 2,
                        name: "spikes",
                        place: true,
                        limit: 15,
                        layer: 0
                    }, {
                        id: 3,
                        name: "mill",
                        place: true,
                        limit: 7,
                        layer: 1
                    }, {
                        id: 4,
                        name: "mine",
                        place: true,
                        limit: 1,
                        layer: 0
                    }, {
                        id: 5,
                        name: "trap",
                        place: true,
                        limit: 6,
                        layer: -1
                    }, {
                        id: 6,
                        name: "booster",
                        place: true,
                        limit: 12,
                        layer: -1
                    }, {
                        id: 7,
                        name: "turret",
                        place: true,
                        limit: 2,
                        layer: 1
                    }, {
                        id: 8,
                        name: "watchtower",
                        place: true,
                        limit: 12,
                        layer: 1
                    }, {
                        id: 9,
                        name: "buff",
                        place: true,
                        limit: 4,
                        layer: -1
                    }, {
                        id: 10,
                        name: "spawn",
                        place: true,
                        limit: 1,
                        layer: -1
                    }, {
                        id: 11,
                        name: "sapling",
                        place: true,
                        limit: 2,
                        layer: 0
                    }, {
                        id: 12,
                        name: "blocker",
                        place: true,
                        limit: 3,
                        layer: -1
                    }, {
                        id: 13,
                        name: "teleporter",
                        place: true,
                        limit: 2,
                        layer: -1
                    }];

                    // PROJECTILES:
                    this.projectiles = [{
                        indx: 0,
                        layer: 0,
                        src: "arrow_1",
                        dmg: 25,
                        speed: 1.6,
                        scale: 103,
                        range: 1000
                    }, {
                        indx: 1,
                        layer: 1,
                        dmg: 25,
                        scale: 20
                    }, {
                        indx: 0,
                        layer: 0,
                        src: "arrow_1",
                        dmg: 35,
                        speed: 2.5,
                        scale: 103,
                        range: 1200
                    }, {
                        indx: 0,
                        layer: 0,
                        src: "arrow_1",
                        dmg: 30,
                        speed: 2,
                        scale: 103,
                        range: 1200
                    }, {
                        indx: 1,
                        layer: 1,
                        dmg: 16,
                        scale: 20
                    }, {
                        indx: 0,
                        layer: 0,
                        src: "bullet_1",
                        dmg: 50,
                        speed: 3.6,
                        scale: 160,
                        range: 1400
                    }];

                    // WEAPONS:
                    this.weapons = [{
                        id: 0,
                        type: 0,
                        name: "tool hammer",
                        desc: "tool for gathering all resources",
                        src: "hammer_1",
                        length: 140,
                        width: 140,
                        xOff: -3,
                        yOff: 18,
                        dmg: 25,
                        range: 65,
                        gather: 1,
                        speed: 300
                    }, {
                        id: 1,
                        type: 0,
                        age: 2,
                        name: "hand axe",
                        desc: "gathers resources at a higher rate",
                        src: "axe_1",
                        length: 140,
                        width: 140,
                        xOff: 3,
                        yOff: 24,
                        dmg: 30,
                        spdMult: 1,
                        range: 70,
                        gather: 2,
                        speed: 400
                    }, {
                        id: 2,
                        type: 0,
                        age: 8,
                        pre: 1,
                        name: "great axe",
                        desc: "deal more damage and gather more resources",
                        src: "great_axe_1",
                        length: 140,
                        width: 140,
                        xOff: -8,
                        yOff: 25,
                        dmg: 35,
                        spdMult: 1,
                        range: 75,
                        gather: 4,
                        speed: 400
                    }, {
                        id: 3,
                        type: 0,
                        age: 2,
                        name: "short sword",
                        desc: "increased attack power but slower move speed",
                        src: "sword_1",
                        iPad: 1.3,
                        length: 130,
                        width: 210,
                        xOff: -8,
                        yOff: 46,
                        dmg: 35,
                        spdMult: 0.85,
                        range: 110,
                        gather: 1,
                        speed: 300
                    }, {
                        id: 4,
                        type: 0,
                        age: 8,
                        pre: 3,
                        name: "katana",
                        desc: "greater range and damage",
                        src: "samurai_1",
                        iPad: 1.3,
                        length: 130,
                        width: 210,
                        xOff: -8,
                        yOff: 59,
                        dmg: 40,
                        spdMult: 0.8,
                        range: 118,
                        gather: 1,
                        speed: 300
                    }, {
                        id: 5,
                        type: 0,
                        age: 2,
                        name: "polearm",
                        desc: "long range melee weapon",
                        src: "spear_1",
                        iPad: 1.3,
                        length: 130,
                        width: 210,
                        xOff: -8,
                        yOff: 53,
                        dmg: 45,
                        knock: 0.2,
                        spdMult: 0.82,
                        range: 142,
                        gather: 1,
                        speed: 700
                    }, {
                        id: 6,
                        type: 0,
                        age: 2,
                        name: "bat",
                        desc: "fast long range melee weapon",
                        src: "bat_1",
                        iPad: 1.3,
                        length: 110,
                        width: 180,
                        xOff: -8,
                        yOff: 53,
                        dmg: 20,
                        knock: 0.7,
                        range: 110,
                        gather: 1,
                        speed: 300
                    }, {
                        id: 7,
                        type: 0,
                        age: 2,
                        name: "daggers",
                        desc: "really fast short range weapon",
                        src: "dagger_1",
                        iPad: 0.8,
                        length: 110,
                        width: 110,
                        xOff: 18,
                        yOff: 0,
                        dmg: 20,
                        knock: 0.1,
                        range: 65,
                        gather: 1,
                        hitSlow: 0.1,
                        spdMult: 1.13,
                        speed: 100
                    }, {
                        id: 8,
                        type: 0,
                        age: 2,
                        name: "stick",
                        desc: "great for gathering but very weak",
                        src: "stick_1",
                        length: 140,
                        width: 140,
                        xOff: 3,
                        yOff: 24,
                        dmg: 1,
                        spdMult: 1,
                        range: 70,
                        gather: 7,
                        speed: 400
                    }, {
                        id: 9,
                        type: 1,
                        age: 6,
                        name: "hunting bow",
                        desc: "bow used for ranged combat and hunting",
                        src: "bow_1",
                        req: ["wood", 4],
                        length: 120,
                        width: 120,
                        xOff: -6,
                        yOff: 0,
                        Pdmg: 25,
                        projectile: 0,
                        spdMult: 0.75,
                        speed: 600
                    }, {
                        id: 10,
                        type: 1,
                        age: 6,
                        name: "great hammer",
                        desc: "hammer used for destroying structures",
                        src: "great_hammer_1",
                        length: 140,
                        width: 140,
                        xOff: -9,
                        yOff: 25,
                        dmg: 10,
                        Pdmg: 10,
                        spdMult: 0.88,
                        range: 75,
                        sDmg: 7.5,
                        gather: 1,
                        speed: 400
                    }, {
                        id: 11,
                        type: 1,
                        age: 6,
                        name: "wooden shield",
                        desc: "blocks projectiles and reduces melee damage",
                        src: "shield_1",
                        length: 120,
                        width: 120,
                        shield: 0.2,
                        xOff: 6,
                        yOff: 0,
                        Pdmg: 0,
                        spdMult: 0.7
                    }, {
                        id: 12,
                        type: 1,
                        age: 8,
                        pre: 9,
                        name: "crossbow",
                        desc: "deals more damage and has greater range",
                        src: "crossbow_1",
                        req: ["wood", 5],
                        aboveHand: true,
                        armS: 0.75,
                        length: 120,
                        width: 120,
                        xOff: -4,
                        yOff: 0,
                        Pdmg: 35,
                        projectile: 2,
                        spdMult: 0.7,
                        speed: 700
                    }, {
                        id: 13,
                        type: 1,
                        age: 9,
                        pre: 12,
                        name: "repeater crossbow",
                        desc: "high firerate crossbow with reduced damage",
                        src: "crossbow_2",
                        req: ["wood", 10],
                        aboveHand: true,
                        armS: 0.75,
                        length: 120,
                        width: 120,
                        xOff: -4,
                        yOff: 0,
                        Pdmg: 30,
                        projectile: 3,
                        spdMult: 0.7,
                        speed: 230
                    }, {
                        id: 14,
                        type: 1,
                        age: 6,
                        name: "mc grabby",
                        desc: "steals resources from enemies",
                        src: "grab_1",
                        length: 130,
                        width: 210,
                        xOff: -8,
                        yOff: 53,
                        dmg: 0,
                        Pdmg: 0,
                        steal: 250,
                        knock: 0.2,
                        spdMult: 1.05,
                        range: 125,
                        gather: 0,
                        speed: 700
                    }, {
                        id: 15,
                        type: 1,
                        age: 9,
                        pre: 12,
                        name: "musket",
                        desc: "slow firerate but high damage and range",
                        src: "musket_1",
                        req: ["stone", 10],
                        aboveHand: true,
                        rec: 0.35,
                        armS: 0.6,
                        hndS: 0.3,
                        hndD: 1.6,
                        length: 205,
                        width: 205,
                        xOff: 25,
                        yOff: 0,
                        Pdmg: 50,
                        projectile: 5,
                        hideProjectile: true,
                        spdMult: 0.6,
                        speed: 1500
                    }];

                    // ITEMS:
                    this.list = [{
                        group: this.groups[0],
                        name: "apple",
                        desc: "restores 20 health when consumed",
                        req: ["food", 10],
                        consume: function (doer) {
                            return doer.changeHealth(20, doer);
                        },
                        scale: 22,
                        holdOffset: 15,
                        healing: 20,
                        itemID: 0,
                        itemAID: 16,
                    }, {
                        age: 3,
                        group: this.groups[0],
                        name: "cookie",
                        desc: "restores 40 health when consumed",
                        req: ["food", 15],
                        consume: function (doer) {
                            return doer.changeHealth(40, doer);
                        },
                        scale: 27,
                        holdOffset: 15,
                        healing: 40,
                        itemID: 1,
                        itemAID: 17,
                    }, {
                        age: 7,
                        group: this.groups[0],
                        name: "cheese",
                        desc: "restores 30 health and another 50 over 5 seconds",
                        req: ["food", 25],
                        consume: function (doer) {
                            if (doer.changeHealth(30, doer) || doer.health < 100) {
                                doer.dmgOverTime.dmg = -10;
                                doer.dmgOverTime.doer = doer;
                                doer.dmgOverTime.time = 5;
                                return true;
                            }
                            return false;
                        },
                        scale: 27,
                        holdOffset: 15,
                        healing: 30,
                        itemID: 2,
                        itemAID: 18,
                    }, {
                        group: this.groups[1],
                        name: "wood wall",
                        desc: "provides protection for your village",
                        req: ["wood", 10],
                        projDmg: true,
                        health: 380,
                        scale: 50,
                        holdOffset: 20,
                        placeOffset: -5,
                        itemID: 3,
                        itemAID: 19,
                    }, {
                        age: 3,
                        group: this.groups[1],
                        name: "stone wall",
                        desc: "provides improved protection for your village",
                        req: ["stone", 25],
                        health: 900,
                        scale: 50,
                        holdOffset: 20,
                        placeOffset: -5,
                        itemID: 4,
                        itemAID: 20,
                    }, {
                        age: 7,
                        group: this.groups[1],
                        name: "castle wall",
                        desc: "provides powerful protection for your village",
                        req: ["stone", 35],
                        health: 1500,
                        scale: 52,
                        holdOffset: 20,
                        placeOffset: -5,
                        itemID: 5,
                        itemAID: 21,
                    }, {
                        group: this.groups[2],
                        name: "spikes",
                        desc: "damages enemies when they touch them",
                        req: ["wood", 20, "stone", 5],
                        health: 400,
                        dmg: 20,
                        scale: 49,
                        spritePadding: -23,
                        holdOffset: 8,
                        placeOffset: -5,
                        itemID: 6,
                        itemAID: 22,
                    }, {
                        age: 5,
                        group: this.groups[2],
                        name: "greater spikes",
                        desc: "damages enemies when they touch them",
                        req: ["wood", 30, "stone", 10],
                        health: 500,
                        dmg: 35,
                        scale: 52,
                        spritePadding: -23,
                        holdOffset: 8,
                        placeOffset: -5,
                        itemID: 7,
                        itemAID: 23,
                    }, {
                        age: 9,
                        group: this.groups[2],
                        name: "poison spikes",
                        desc: "poisons enemies when they touch them",
                        req: ["wood", 35, "stone", 15],
                        health: 600,
                        dmg: 30,
                        pDmg: 5,
                        scale: 52,
                        spritePadding: -23,
                        holdOffset: 8,
                        placeOffset: -5,
                        itemID: 8,
                        itemAID: 24,
                    }, {
                        age: 9,
                        group: this.groups[2],
                        name: "spinning spikes",
                        desc: "damages enemies when they touch them",
                        req: ["wood", 30, "stone", 20],
                        health: 500,
                        dmg: 45,
                        turnSpeed: 0.003,
                        scale: 52,
                        spritePadding: -23,
                        holdOffset: 8,
                        placeOffset: -5,
                        itemID: 9,
                        itemAID: 25,
                    }, {
                        group: this.groups[3],
                        name: "windmill",
                        desc: "generates gold over time",
                        req: ["wood", 50, "stone", 10],
                        health: 400,
                        pps: 1,
                        turnSpeed: 0.0016,
                        spritePadding: 25,
                        iconLineMult: 12,
                        scale: 45,
                        holdOffset: 20,
                        placeOffset: 5,
                        itemID: 10,
                        itemAID: 26,
                    }, {
                        age: 5,
                        group: this.groups[3],
                        name: "faster windmill",
                        desc: "generates more gold over time",
                        req: ["wood", 60, "stone", 20],
                        health: 500,
                        pps: 1.5,
                        turnSpeed: 0.0025,
                        spritePadding: 25,
                        iconLineMult: 12,
                        scale: 47,
                        holdOffset: 20,
                        placeOffset: 5,
                        itemID: 11,
                        itemAID: 27,
                    }, {
                        age: 8,
                        group: this.groups[3],
                        name: "power mill",
                        desc: "generates more gold over time",
                        req: ["wood", 100, "stone", 50],
                        health: 800,
                        pps: 2,
                        turnSpeed: 0.005,
                        spritePadding: 25,
                        iconLineMult: 12,
                        scale: 47,
                        holdOffset: 20,
                        placeOffset: 5,
                        itemID: 12,
                        itemAID: 28,
                    }, {
                        age: 5,
                        group: this.groups[4],
                        type: 2,
                        name: "mine",
                        desc: "allows you to mine stone",
                        req: ["wood", 20, "stone", 100],
                        iconLineMult: 12,
                        scale: 65,
                        holdOffset: 20,
                        placeOffset: 0,
                        itemID: 13,
                        itemAID: 29,
                    }, {
                        age: 5,
                        group: this.groups[11],
                        type: 0,
                        name: "sapling",
                        desc: "allows you to farm wood",
                        req: ["wood", 150],
                        iconLineMult: 12,
                        colDiv: 0.5,
                        scale: 110,
                        holdOffset: 50,
                        placeOffset: -15,
                        itemID: 14,
                        itemAID: 30,
                    }, {
                        age: 4,
                        group: this.groups[5],
                        name: "pit trap",
                        desc: "pit that traps enemies if they walk over it",
                        req: ["wood", 30, "stone", 30],
                        trap: true,
                        ignoreCollision: true,
                        hideFromEnemy: true,
                        health: 500,
                        colDiv: 0.2,
                        scale: 50,
                        holdOffset: 20,
                        placeOffset: -5,
                        alpha: 0.6,
                        itemID: 15,
                        itemAID: 31,
                    }, {
                        age: 4,
                        group: this.groups[6],
                        name: "boost pad",
                        desc: "provides boost when stepped on",
                        req: ["stone", 20, "wood", 5],
                        ignoreCollision: true,
                        boostSpeed: 1.5,
                        health: 150,
                        colDiv: 0.7,
                        scale: 45,
                        holdOffset: 20,
                        placeOffset: -5,
                        itemID: 16,
                        itemAID: 32,
                    }, {
                        age: 7,
                        group: this.groups[7],
                        doUpdate: true,
                        name: "turret",
                        desc: "defensive structure that shoots at enemies",
                        req: ["wood", 200, "stone", 150],
                        health: 800,
                        projectile: 1,
                        shootRange: 700,
                        shootRate: 2200,
                        scale: 43,
                        holdOffset: 20,
                        placeOffset: -5,
                        itemID: 17,
                        itemAID: 33,
                    }, {
                        age: 7,
                        group: this.groups[8],
                        name: "platform",
                        desc: "platform to shoot over walls and cross over water",
                        req: ["wood", 20],
                        ignoreCollision: true,
                        zIndex: 1,
                        health: 300,
                        scale: 43,
                        holdOffset: 20,
                        placeOffset: -5,
                        itemID: 18,
                        itemAID: 34,
                    }, {
                        age: 7,
                        group: this.groups[9],
                        name: "healing pad",
                        desc: "standing on it will slowly heal you",
                        req: ["wood", 30, "food", 10],
                        ignoreCollision: true,
                        healCol: 15,
                        health: 400,
                        colDiv: 0.7,
                        scale: 45,
                        holdOffset: 20,
                        placeOffset: -5,
                        itemID: 19,
                        itemAID: 35,
                    }, {
                        age: 9,
                        group: this.groups[10],
                        name: "spawn pad",
                        desc: "you will spawn here when you die but it will dissapear",
                        req: ["wood", 100, "stone", 100],
                        health: 400,
                        ignoreCollision: true,
                        spawnPoint: true,
                        scale: 45,
                        holdOffset: 20,
                        placeOffset: -5,
                        itemID: 20,
                        itemAID: 36,
                    }, {
                        age: 7,
                        group: this.groups[12],
                        name: "blocker",
                        desc: "blocks building in radius",
                        req: ["wood", 30, "stone", 25],
                        ignoreCollision: true,
                        blocker: 300,
                        health: 400,
                        colDiv: 0.7,
                        scale: 45,
                        holdOffset: 20,
                        placeOffset: -5,
                        itemID: 21,
                        itemAID: 37,
                    }, {
                        age: 7,
                        group: this.groups[13],
                        name: "teleporter",
                        desc: "teleports you to a random point on the map",
                        req: ["wood", 60, "stone", 60],
                        ignoreCollision: true,
                        teleport: true,
                        health: 200,
                        colDiv: 0.7,
                        scale: 45,
                        holdOffset: 20,
                        placeOffset: -5,
                        itemID: 22,
                        itemAID: 38
                    }];

                    // CHECK ITEM ID:
                    this.checkItem = {
                        index: function(id, myItems) {
                            return [0, 1, 2].includes(id) ? 0 :
                            [3, 4, 5].includes(id) ? 1 :
                            [6, 7, 8, 9].includes(id) ? 2 :
                            [10, 11, 12].includes(id) ? 3 :
                            [13, 14].includes(id) ? 5 :
                            [15, 16].includes(id) ? 4 :
                            [17, 18, 19, 21, 22].includes(id) ?
                                [13, 14].includes(myItems) ? 6 :
                            5 :
                            id == 20 ?
                                [13, 14].includes(myItems) ? 7 :
                            6 :
                            undefined;
                        }
                    }

                    // ASSIGN IDS:
                    for (let i = 0; i < this.list.length; ++i) {
                        this.list[i].id = i;
                        if (this.list[i].pre) this.list[i].pre = i - this.list[i].pre;
                    }

                    // TROLOLOLOL:
                    if (typeof window !== "undefined") {
                        function shuffle(a) {
                            for (let i = a.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [a[i], a[j]] = [a[j], a[i]];
                            }
                            return a;
                        }
                        //shuffle(this.list);
                    }
                }
            }
            class Objectmanager {
                constructor(GameObject, gameObjects, UTILS, config, players, server) {
                    let mathFloor = Math.floor,
                        mathABS = Math.abs,
                        mathCOS = Math.cos,
                        mathSIN = Math.sin,
                        mathPOW = Math.pow,
                        mathSQRT = Math.sqrt;

                    this.ignoreAdd = false;
                    this.hitObj = [];

                    // DISABLE OBJ:
                    this.disableObj = function (obj) {
                        obj.active = false;
                        if (config.anotherVisual) {
                        } else {
                            obj.alive = false;
                        }
                    };
            //antispiral visuals
                    (function() {
})();var moomooVer = $('#linksContainer2 .menuLink').html(),
    hideSelectors = ['#mobileDownloadButtonContainer',
                     '#followText',
                     '#smallLinks',
                     '#linksContainer1',
                     '#twitterFollow',
                     '#youtubeFollow',
                     '#cdm-zone-02',
                     '#youtuberOf',
                     '#downloadButtonContainer',
                     '#promoImg',
                     '.menuHeader',
                     '.menuLink',
                     '.menuHeader:nth-child(5)',
                     '.menuHeader:nth-child(6)',
                     '.menuText',
                     '#adCard',
                     '#promoImgHolder',
                    ],

    css = '#rightCardHolder {display: block!important}',
    head = document.head || document.getElementsByTagName('head')[0],
    style = document.createElement('style');

style.type = 'text/css';
if (style.styleSheet){
    style.styleSheet.cssText = css;
} else {
    style.appendChild(document.createTextNode(css));
}

for ( let i = 0; i < hideSelectors.length; i++ ) {
    $(hideSelectors[i]).hide();
}

head.appendChild(style);
$('#linksContainer2').html('<a href="./docs/versions.txt" target="_blank" class="menuLink">' + moomooVer + '</a>');

function onBoxMouseOver() {
    this.style.transform = 'scale(1.1)';
    this.style.borderRadius = '15px';
    this.style.boxShadow = '0 0 0 3px rgba(0, 0, 0, 0.10';
}

function onBoxMouseLeave() {
    this.style.transform = 'scale(1)';
    this.style.borderRadius = '0';
    this.style.boxShadow = 'none';
}


function onEnterGameMouseOver() {
    const enterGameBox = document.getElementById('enterGame');
    enterGameBox.style.transform = 'scale(1.05)';
    enterGameBox.style.backgroundColor = 'rgba(0, 0, 0, 0.10)';
    enterGameBox.style.borderRadius = '20px';
}


function onEnterGameMouseLeave() {
    const enterGameBox = document.getElementById('enterGame');
    enterGameBox.style.transform = 'scale(1)';
    enterGameBox.style.backgroundColor = 'rgba(0, 0, 0, 0.10';
    enterGameBox.style.borderRadius = '0';
}


const boxes = document.querySelectorAll('.menuCard');
boxes.forEach(box => {
    box.style.transition = 'transform 0.5s ease';
    box.addEventListener('mouseenter', onBoxMouseOver);
    box.addEventListener('mouseleave', onBoxMouseLeave);
});


const enterGameBox = document.getElementById('enterGame');
enterGameBox.addEventListener('mouseenter', onEnterGameMouseOver);
enterGameBox.addEventListener('mouseleave', onEnterGameMouseLeave);
var gameTitle = getEl("gameName");
document.getElementById("ageText").style.color = "#ffffff";
document.getElementById('ageText').style = "text-shadow: white 2px 2px 40px;";
document.getElementById("leaderboard").style.color = "#ffffff"
document.getElementById('gameName').style.color = "#ffffff"
document.getElementById("mainMenu").style.backgroundImage = "url('"
document.getElementById('chatBox').style.color = "#ffffff"
document.getElementById('chatBox').style.backgroundColor = "rgba(0, 0, 0, 0.10"
document.getElementById("pingDisplay").style.color = "rgba(0, 0, 0, 0.10"
document.getElementById("enterGame").style.backgroundColor = "rgba(0, 0, 0, 0.10"
$('.menuCard').css({'white-space': 'normal',
                    'text-align': 'center',
                    'background-color': 'rgba(0, 0, 0, 0.10',
                    '-moz-box-shadow': '0px 0px rgba(255, 255, 255, 0)',
                    '-webkit-box-shadow': '0px 0px rgba(255, 255, 255, 0)',
                    'box-shadow': '0px 0px rgba(255, 255, 255, 0)',
                    '-webkit-border-radius': '0px',
                    '-moz-border-radius': '0px',
                    'border-radius': '0px',
                    'margin': '15px',
                    'margin-top': '15px'});

$('#menuContainer').css({'white-space': 'normal'});

$('#nativeResolution').css({'cursor': 'pointer'});

$('#playMusic').css({'cursor': 'pointer'});

$('#guideCard').css({'overflow-y': 'hidden',
                     'margin-top': 'auto',
                     'margin-bottom': '30px'});

$('#serverSelect').css({'margin-bottom': '30.75px'});

$('#skinColorHolder').css({'margin-bottom': '30.75px'});

$('.settingRadio').css({'margin-bottom': '30.75px'});

$('#partyButton').css({'right': '70%',
                       'left': '10%',
                       'text-align': 'center',
                       'bottom': '48px',
                       'font-size': '24px',
                       'top': 'unset'});

$('#joinPartyButton').css({'right': '10%',
                           'left': '70%',
                           'text-align': 'center',
                           'bottom': '48px',
                           'font-size': '24px',
                           'top': 'unset'});

$('#linksContainer2').css({'-webkit-border-radius': '0px 0 0 0',
                           '-moz-border-radius': '0px 0 0 0',
                           'border-radius': '0px 0 0 0',
                           'right': '44%',
                           'left': '44%',
                           'background-color': 'rgba(255, 255, 255, 0)',
                           'text-align': 'center',
                           'bottom': '12px'});

$('.ytLink').css({'color': '#ff00e6',
                  'padding': '8px',
                  'background-color': 'rgba(255, 255, 255, 0)'});

$('.menuLink').css({'color': '#ff00e6'});

$('#nameInput').css({'border-radius': '0px',
                     '-moz-border-radius': '0px',
                     '-webkit-border-radius': '0px',
                     'border': 'hidden'});

$('#serverSelect').css({'cursor': 'pointer',
                        'color': '#000',
                        'background-color': 'rgba(255, 255, 255, 0)',
                        'border': 'hidden',
                        'font-size': '20px'});

$('.menuButton').css({'border-radius': '0px',
                      '-moz-border-radius': '0px',
                      '-webkit-border-radius': '0px'});

$('#promoImgHolder').css({'position': 'absolute',
                          'bottom': '-7%',
                          'left': '20px',
                          'width': '420px',
                          'height': '236.25px',
                          'padding-bottom': '18px',
                          'margin-top': '0px'});

$('#adCard').css({'position': 'absolute',
                  'bottom': '-7%',
                  'right': '20px',
                  'width': '420px',
                  'height': '236.25px',
                  'padding-bottom': '18px'});

$('#mapDisplay').css({'-webkit-border-radius': '0px',
                      '-moz-border-radius': '0px',
                      'border-radius': '0px'});

$('.menuHeader').css({'color': 'rgba(0, 0, 0, 0,5)'});

$('#killCounter').css({'color': '#ededed'});

$('#diedText').css({'background-color': 'rgba(0, 0, 0, 0.10'});

$('#gameCanvas').css({'background-color': 'rgba(255, 255, 255, 0)'});

$('#allianceButton').css({'color': 'rgba(0, 0, 0, 1)'});

$('#storeButton').css({'color': 'rgba(0, 0, 0, 1)'});

$('#chatButton').css({'color': 'rgba(0, 0, 0, 1)'});

$('.gameButton').css({'-webkit-border-radius': '0px 0 0 0',
                      '-moz-border-radius': '0px 0 0 0',
                      'border-radius': '0px 0 0 0',
                      'background-color': 'rgba(0, 0, 0, 0.4)'});

$('.uiElement, .resourceDisplay').css({'-webkit-border-radius': '0px',
                                       '-moz-border-radius': '0px',
                                       'border-radius': '0px',
                                       'background-color': 'rgba(0, 0, 0, 0.4)'});

$('#chatBox').css({'-webkit-border-radius': '0px',
                   '-moz-border-radius': '0px',
                   'border-radius': '0px',
                   'background-color': 'rgba(0, 0, 0, 0.4)',
                   'text-align': 'center'});

$('#foodDisplay').css({'color': '#ae4d54'});

$('#woodDisplay').css({'color': '#758f58'});

$('#stoneDisplay').css({'color': '#818198'});

$('#scoreDisplay').css({'color': '#c2b17a'});

$('#leaderboard').css({'-webkit-border-radius': '0px',
                       '-moz-border-radius': '0px',
                       'border-radius': '0px',
                       'background-color': 'rgb((255,240,245))',
                       'text-align': 'center'});
                    // ADD NEW:
                    let tmpObj;
                    this.add = function (sid, x, y, dir, s, type, data, setSID, owner) {
                        tmpObj = findObjectBySid(sid);
                        if (!tmpObj) {
                            tmpObj = gameObjects.find((tmp) => !tmp.active);
                            if (!tmpObj) {
                                tmpObj = new GameObject(sid);
                                gameObjects.push(tmpObj);
                            }
                        }
                        if (setSID) {
                            tmpObj.sid = sid;
                        }
                        tmpObj.init(x, y, dir, s, type, data, owner);
                    };

                    // DISABLE BY SID:
                    this.disableBySid = function (sid) {
                        let find = findObjectBySid(sid);
                        if (find) {
                            this.disableObj(find);
                        }
                    };

                    // REMOVE ALL FROM PLAYER:
                    this.removeAllItems = function (sid, server) {
                        gameObjects.filter((tmp) => tmp.active && tmp.owner && tmp.owner.sid == sid).forEach((tmp) => this.disableObj(tmp));
                    };

                    // CHECK IF PLACABLE:
                    this.checkItemLocation = function (x, y, s, sM, indx, ignoreWater, placer) {
                        let cantPlace = gameObjects.find((tmp) => tmp.active && UTILS.getDistance(x, y, tmp.x, tmp.y) < s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem)));
                        if (cantPlace) return false;
                        if (!ignoreWater && indx != 18 && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2) return false;
                        return true;
                    };

                }
            }
            class Projectile {
                constructor(players, ais, objectManager, items, config, UTILS, server) {

                    // INIT:
                    this.init = function (indx, x, y, dir, spd, dmg, rng, scl, owner) {
                        this.active = true;
                        this.tickActive = true;
                        this.indx = indx;
                        this.x = x;
                        this.y = y;
                        this.x2 = x;
                        this.y2 = y;
                        this.dir = dir;
                        this.skipMov = true;
                        this.speed = spd;
                        this.dmg = dmg;
                        this.scale = scl;
                        this.range = rng;
                        this.r2 = rng;
                        this.owner = owner;
                    };

                    // UPDATE:
                    this.update = function (delta) {
                        if (this.active) {
                            let tmpSpeed = this.speed * delta;
                            if (!this.skipMov) {
                                this.x += tmpSpeed * Math.cos(this.dir);
                                this.y += tmpSpeed * Math.sin(this.dir);
                                this.range -= tmpSpeed;
                                if (this.range <= 0) {
                                    this.x += this.range * Math.cos(this.dir);
                                    this.y += this.range * Math.sin(this.dir);
                                    tmpSpeed = 1;
                                    this.range = 0;
                                    this.active = false;
                                }
                            } else {
                                this.skipMov = false;
                            }
                        }
                    };
                    this.tickUpdate = function (delta) {
                        if (this.tickActive) {
                            let tmpSpeed = this.speed * delta;
                            if (!this.skipMov) {
                                this.x2 += tmpSpeed * Math.cos(this.dir);
                                this.y2 += tmpSpeed * Math.sin(this.dir);
                                this.r2 -= tmpSpeed;
                                if (this.r2 <= 0) {
                                    this.x2 += this.r2 * Math.cos(this.dir);
                                    this.y2 += this.r2 * Math.sin(this.dir);
                                    tmpSpeed = 1;
                                    this.r2 = 0;
                                    this.tickActive = false;
                                }
                            } else {
                                this.skipMov = false;
                            }
                        }
                    };
                }
            };
            class Store {
                constructor() {
                    // STORE HATS:
                    this.hats = [{
                        id: 45,
                        name: "Shame!",
                        dontSell: true,
                        price: 0,
                        scale: 120,
                        desc: "hacks are for winners"
                    }, {
                        id: 51,
                        name: "Moo Cap",
                        price: 0,
                        scale: 120,
                        desc: "coolest mooer around"
                    }, {
                        id: 50,
                        name: "Apple Cap",
                        price: 0,
                        scale: 120,
                        desc: "apple farms remembers"
                    }, {
                        id: 28,
                        name: "Moo Head",
                        price: 0,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 29,
                        name: "Pig Head",
                        price: 0,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 30,
                        name: "Fluff Head",
                        price: 0,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 36,
                        name: "Pandou Head",
                        price: 0,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 37,
                        name: "Bear Head",
                        price: 0,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 38,
                        name: "Monkey Head",
                        price: 0,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 44,
                        name: "Polar Head",
                        price: 0,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 35,
                        name: "Fez Hat",
                        price: 0,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 42,
                        name: "Enigma Hat",
                        price: 0,
                        scale: 120,
                        desc: "join the enigma army"
                    }, {
                        id: 43,
                        name: "Blitz Hat",
                        price: 0,
                        scale: 120,
                        desc: "hey everybody i'm blitz"
                    }, {
                        id: 49,
                        name: "Bob XIII Hat",
                        price: 0,
                        scale: 120,
                        desc: "like and subscribe"
                    }, {
                        id: 57,
                        name: "Pumpkin",
                        price: 50,
                        scale: 120,
                        desc: "Spooooky"
                    }, {
                        id: 8,
                        name: "Bummle Hat",
                        price: 100,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 2,
                        name: "Straw Hat",
                        price: 500,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 15,
                        name: "Winter Cap",
                        price: 600,
                        scale: 120,
                        desc: "allows you to move at normal speed in snow",
                        coldM: 1
                    }, {
                        id: 5,
                        name: "Cowboy Hat",
                        price: 1000,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 4,
                        name: "Ranger Hat",
                        price: 2000,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 18,
                        name: "Explorer Hat",
                        price: 2000,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 31,
                        name: "Flipper Hat",
                        price: 2500,
                        scale: 120,
                        desc: "have more control while in water",
                        watrImm: true
                    }, {
                        id: 1,
                        name: "Marksman Cap",
                        price: 3000,
                        scale: 120,
                        desc: "increases arrow speed and range",
                        aMlt: 1.3
                    }, {
                        id: 10,
                        name: "Bush Gear",
                        price: 3000,
                        scale: 160,
                        desc: "allows you to disguise yourself as a bush"
                    }, {
                        id: 48,
                        name: "Halo",
                        price: 3000,
                        scale: 120,
                        desc: "no effect"
                    }, {
                        id: 6,
                        name: "Soldier Helmet",
                        price: 4000,
                        scale: 120,
                        desc: "reduces damage taken but slows movement",
                        spdMult: 0.94,
                        dmgMult: 0.75
                    }, {
                        id: 23,
                        name: "Anti Venom Gear",
                        price: 4000,
                        scale: 120,
                        desc: "makes you immune to poison",
                        poisonRes: 1
                    }, {
                        id: 13,
                        name: "Medic Gear",
                        price: 5000,
                        scale: 110,
                        desc: "slowly regenerates health over time",
                        healthRegen: 3
                    }, {
                        id: 9,
                        name: "Miners Helmet",
                        price: 5000,
                        scale: 120,
                        desc: "earn 1 extra gold per resource",
                        extraGold: 1
                    }, {
                        id: 32,
                        name: "Musketeer Hat",
                        price: 5000,
                        scale: 120,
                        desc: "reduces cost of projectiles",
                        projCost: 0.5
                    }, {
                        id: 7,
                        name: "Bull Helmet",
                        price: 6000,
                        scale: 120,
                        desc: "increases damage done but drains health",
                        healthRegen: -5,
                        dmgMultO: 1.5,
                        spdMult: 0.96
                    }, {
                        id: 22,
                        name: "Emp Helmet",
                        price: 6000,
                        scale: 120,
                        desc: "turrets won't attack but you move slower",
                        antiTurret: 1,
                        spdMult: 0.7
                    }, {
                        id: 12,
                        name: "Booster Hat",
                        price: 6000,
                        scale: 120,
                        desc: "increases your movement speed",
                        spdMult: 1.16
                    }, {
                        id: 26,
                        name: "Barbarian Armor",
                        price: 8000,
                        scale: 120,
                        desc: "knocks back enemies that attack you",
                        dmgK: 0.6
                    }, {
                        id: 21,
                        name: "Plague Mask",
                        price: 10000,
                        scale: 120,
                        desc: "melee attacks deal poison damage",
                        poisonDmg: 5,
                        poisonTime: 6
                    }, {
                        id: 46,
                        name: "Bull Mask",
                        price: 10000,
                        scale: 120,
                        desc: "bulls won't target you unless you attack them",
                        bullRepel: 1
                    }, {
                        id: 14,
                        name: "Windmill Hat",
                        topSprite: true,
                        price: 10000,
                        scale: 120,
                        desc: "generates points while worn",
                        pps: 1.5
                    }, {
                        id: 11,
                        name: "Spike Gear",
                        topSprite: true,
                        price: 10000,
                        scale: 120,
                        desc: "deal damage to players that damage you",
                        dmg: 0.45
                    }, {
                        id: 53,
                        name: "Turret Gear",
                        topSprite: true,
                        price: 10000,
                        scale: 120,
                        desc: "you become a walking turret",
                        turret: {
                            proj: 1,
                            range: 700,
                            rate: 2500
                        },
                        spdMult: 0.7
                    }, {
                        id: 20,
                        name: "Samurai Armor",
                        price: 12000,
                        scale: 120,
                        desc: "increased attack speed and fire rate",
                        atkSpd: 0.78
                    }, {
                        id: 58,
                        name: "Dark Knight",
                        price: 12000,
                        scale: 120,
                        desc: "restores health when you deal damage",
                        healD: 0.4
                    }, {
                        id: 27,
                        name: "Scavenger Gear",
                        price: 15000,
                        scale: 120,
                        desc: "earn double points for each kill",
                        kScrM: 2
                    }, {
                        id: 40,
                        name: "Tank Gear",
                        price: 15000,
                        scale: 120,
                        desc: "increased damage to buildings but slower movement",
                        spdMult: 0.3,
                        bDmg: 3.3
                    }, {
                        id: 52,
                        name: "Thief Gear",
                        price: 15000,
                        scale: 120,
                        desc: "steal half of a players gold when you kill them",
                        goldSteal: 0.5
                    }, {
                        id: 55,
                        name: "Bloodthirster",
                        price: 20000,
                        scale: 120,
                        desc: "Restore Health when dealing damage. And increased damage",
                        healD: 0.25,
                        dmgMultO: 1.2,
                    }, {
                        id: 56,
                        name: "Assassin Gear",
                        price: 20000,
                        scale: 120,
                        desc: "Go invisible when not moving. Can't eat. Increased speed",
                        noEat: true,
                        spdMult: 1.1,
                        invisTimer: 1000
                    }];

                    // STORE ACCESSORIES:
                    this.accessories = [{
                        id: 12,
                        name: "Snowball",
                        price: 1000,
                        scale: 105,
                        xOff: 18,
                        desc: "no effect"
                    }, {
                        id: 9,
                        name: "Tree Cape",
                        price: 1000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 10,
                        name: "Stone Cape",
                        price: 1000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 3,
                        name: "Cookie Cape",
                        price: 1500,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 8,
                        name: "Cow Cape",
                        price: 2000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 11,
                        name: "Monkey Tail",
                        price: 2000,
                        scale: 97,
                        xOff: 25,
                        desc: "Super speed but reduced damage",
                        spdMult: 1.35,
                        dmgMultO: 0.2
                    }, {
                        id: 17,
                        name: "Apple Basket",
                        price: 3000,
                        scale: 80,
                        xOff: 12,
                        desc: "slowly regenerates health over time",
                        healthRegen: 1
                    }, {
                        id: 6,
                        name: "Winter Cape",
                        price: 3000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 4,
                        name: "Skull Cape",
                        price: 4000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 5,
                        name: "Dash Cape",
                        price: 5000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 2,
                        name: "Dragon Cape",
                        price: 6000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 1,
                        name: "Super Cape",
                        price: 8000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 7,
                        name: "Troll Cape",
                        price: 8000,
                        scale: 90,
                        desc: "no effect"
                    }, {
                        id: 14,
                        name: "Thorns",
                        price: 10000,
                        scale: 115,
                        xOff: 20,
                        desc: "no effect"
                    }, {
                        id: 15,
                        name: "Blockades",
                        price: 10000,
                        scale: 95,
                        xOff: 15,
                        desc: "no effect"
                    }, {
                        id: 20,
                        name: "Devils Tail",
                        price: 10000,
                        scale: 95,
                        xOff: 20,
                        desc: "no effect"
                    }, {
                        id: 16,
                        name: "Sawblade",
                        price: 12000,
                        scale: 90,
                        spin: true,
                        xOff: 0,
                        desc: "deal damage to players that damage you",
                        dmg: 0.15
                    }, {
                        id: 13,
                        name: "Angel Wings",
                        price: 15000,
                        scale: 138,
                        xOff: 22,
                        desc: "slowly regenerates health over time",
                        healthRegen: 3
                    }, {
                        id: 19,
                        name: "Shadow Wings",
                        price: 15000,
                        scale: 138,
                        xOff: 22,
                        desc: "increased movement speed",
                        spdMult: 1.1
                    }, {
                        id: 18,
                        name: "Blood Wings",
                        price: 20000,
                        scale: 178,
                        xOff: 26,
                        desc: "restores health when you deal damage",
                        healD: 0.2
                    }, {
                        id: 21,
                        name: "Corrupt X Wings",
                        price: 20000,
                        scale: 178,
                        xOff: 26,
                        desc: "deal damage to players that damage you",
                        dmg: 0.25
                    }];
                }
            };
            class ProjectileManager {
                constructor(Projectile, projectiles, players, ais, objectManager, items, config, UTILS, server) {
                    this.addProjectile = function (x, y, dir, range, speed, indx, owner, ignoreObj, layer, inWindow) {
                        let tmpData = items.projectiles[indx];
                        let tmpProj;
                        for (let i = 0; i < projectiles.length; ++i) {
                            if (!projectiles[i].active) {
                                tmpProj = projectiles[i];
                                break;
                            }
                        }
                        if (!tmpProj) {
                            tmpProj = new Projectile(players, ais, objectManager, items, config, UTILS, server);
                            tmpProj.sid = projectiles.length;
                            projectiles.push(tmpProj);
                        }
                        tmpProj.init(indx, x, y, dir, speed, tmpData.dmg, range, tmpData.scale, owner);
                        tmpProj.ignoreObj = ignoreObj;
                        tmpProj.layer = layer || tmpData.layer;
                        tmpProj.inWindow = inWindow;
                        tmpProj.src = tmpData.src;
                        return tmpProj;
                    };
                }
            };
            class AiManager {

                // AI MANAGER:
                constructor(ais, AI, players, items, objectManager, config, UTILS, scoreCallback, server) {

                    // AI TYPES:
                    this.aiTypes = [{
                        id: 0,
                        src: "cow_1",
                        killScore: 150,
                        health: 500,
                        weightM: 0.8,
                        speed: 0.00095,
                        turnSpeed: 0.001,
                        scale: 72,
                        drop: ["food", 50]
                    }, {
                        id: 1,
                        src: "pig_1",
                        killScore: 200,
                        health: 800,
                        weightM: 0.6,
                        speed: 0.00085,
                        turnSpeed: 0.001,
                        scale: 72,
                        drop: ["food", 80]
                    }, {
                        id: 2,
                        name: "Bull",
                        src: "bull_2",
                        hostile: true,
                        dmg: 20,
                        killScore: 1000,
                        health: 1800,
                        weightM: 0.5,
                        speed: 0.00094,
                        turnSpeed: 0.00074,
                        scale: 78,
                        viewRange: 800,
                        chargePlayer: true,
                        drop: ["food", 100]
                    }, {
                        id: 3,
                        name: "Bully",
                        src: "bull_1",
                        hostile: true,
                        dmg: 20,
                        killScore: 2000,
                        health: 2800,
                        weightM: 0.45,
                        speed: 0.001,
                        turnSpeed: 0.0008,
                        scale: 90,
                        viewRange: 900,
                        chargePlayer: true,
                        drop: ["food", 400]
                    }, {
                        id: 4,
                        name: "Wolf",
                        src: "wolf_1",
                        hostile: true,
                        dmg: 8,
                        killScore: 500,
                        health: 300,
                        weightM: 0.45,
                        speed: 0.001,
                        turnSpeed: 0.002,
                        scale: 84,
                        viewRange: 800,
                        chargePlayer: true,
                        drop: ["food", 200]
                    }, {
                        id: 5,
                        name: "Quack",
                        src: "chicken_1",
                        dmg: 8,
                        killScore: 2000,
                        noTrap: true,
                        health: 300,
                        weightM: 0.2,
                        speed: 0.0018,
                        turnSpeed: 0.006,
                        scale: 70,
                        drop: ["food", 100]
                    }, {
                        id: 6,
                        name: "MOOSTAFA",
                        nameScale: 50,
                        src: "enemy",
                        hostile: true,
                        dontRun: true,
                        fixedSpawn: true,
                        spawnDelay: 60000,
                        noTrap: true,
                        colDmg: 100,
                        dmg: 40,
                        killScore: 8000,
                        health: 18000,
                        weightM: 0.4,
                        speed: 0.0007,
                        turnSpeed: 0.01,
                        scale: 80,
                        spriteMlt: 1.8,
                        leapForce: 0.9,
                        viewRange: 1000,
                        hitRange: 210,
                        hitDelay: 1000,
                        chargePlayer: true,
                        drop: ["food", 100]
                    }, {
                        id: 7,
                        name: "Treasure",
                        hostile: true,
                        nameScale: 35,
                        src: "crate_1",
                        fixedSpawn: true,
                        spawnDelay: 120000,
                        colDmg: 200,
                        killScore: 5000,
                        health: 20000,
                        weightM: 0.1,
                        speed: 0.0,
                        turnSpeed: 0.0,
                        scale: 70,
                        spriteMlt: 1.0
                    }, {
                        id: 8,
                        name: "MOOFIE",
                        src: "wolf_2",
                        hostile: true,
                        fixedSpawn: true,
                        dontRun: true,
                        hitScare: 4,
                        spawnDelay: 30000,
                        noTrap: true,
                        nameScale: 35,
                        dmg: 10,
                        colDmg: 100,
                        killScore: 3000,
                        health: 7000,
                        weightM: 0.45,
                        speed: 0.0015,
                        turnSpeed: 0.002,
                        scale: 90,
                        viewRange: 800,
                        chargePlayer: true,
                        drop: ["food", 1000]
                    }];

                    // SPAWN AI:
                    this.spawn = function (x, y, dir, index) {
                        let tmpObj = ais.find((tmp) => !tmp.active);
                        if (!tmpObj) {
                            tmpObj = new AI(ais.length, objectManager, players, items, UTILS, config, scoreCallback, server);
                            ais.push(tmpObj);
                        }
                        tmpObj.init(x, y, dir, index, this.aiTypes[index]);
                        return tmpObj;
                    };
                }

            };
            class AI {
                constructor(sid, objectManager, players, items, UTILS, config, scoreCallback, server) {
                    this.sid = sid;
                    this.isAI = true;
                    this.nameIndex = UTILS.randInt(0, config.cowNames.length - 1);

                    // INIT:
                    this.init = function (x, y, dir, index, data) {
                        this.x = x;
                        this.y = y;
                        this.startX = data.fixedSpawn ? x : null;
                        this.startY = data.fixedSpawn ? y : null;
                        this.xVel = 0;
                        this.yVel = 0;
                        this.zIndex = 0;
                        this.dir = dir;
                        this.dirPlus = 0;
                        this.index = index;
                        this.src = data.src;
                        if (data.name) this.name = data.name;
                        this.weightM = data.weightM;
                        this.speed = data.speed;
                        this.killScore = data.killScore;
                        this.turnSpeed = data.turnSpeed;
                        this.scale = data.scale;
                        this.maxHealth = data.health;
                        this.leapForce = data.leapForce;
                        this.health = this.maxHealth;
                        this.chargePlayer = data.chargePlayer;
                        this.viewRange = data.viewRange;
                        this.drop = data.drop;
                        this.dmg = data.dmg;
                        this.hostile = data.hostile;
                        this.dontRun = data.dontRun;
                        this.hitRange = data.hitRange;
                        this.hitDelay = data.hitDelay;
                        this.hitScare = data.hitScare;
                        this.spriteMlt = data.spriteMlt;
                        this.nameScale = data.nameScale;
                        this.colDmg = data.colDmg;
                        this.noTrap = data.noTrap;
                        this.spawnDelay = data.spawnDelay;
                        this.hitWait = 0;
                        this.waitCount = 1000;
                        this.moveCount = 0;
                        this.targetDir = 0;
                        this.active = true;
                        this.alive = true;
                        this.runFrom = null;
                        this.chargeTarget = null;
                        this.dmgOverTime = {};
                    };

                    let tmpRatio = 0;
                    let animIndex = 0;
                    this.animate = function (delta) {
                        if (this.animTime > 0) {
                            this.animTime -= delta;
                            if (this.animTime <= 0) {
                                this.animTime = 0;
                                this.dirPlus = 0;
                                tmpRatio = 0;
                                animIndex = 0;
                            } else {
                                if (animIndex == 0) {
                                    tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                    this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                                    if (tmpRatio >= 1) {
                                        tmpRatio = 1;
                                        animIndex = 1;
                                    }
                                } else {
                                    tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                                    this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                                }
                            }
                        }
                    };

                    // ANIMATION:
                    this.startAnim = function () {
                        this.animTime = this.animSpeed = 600;
                        this.targetAngle = Math.PI * 0.8;
                        tmpRatio = 0;
                        animIndex = 0;
                    };

                };

            };
            class Petal {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.damage = 10;
                    this.health = 10;
                    this.maxHealth = this.health;
                    this.active = false;
                    this.alive = false;
                    this.timer = 1500;
                    this.time = 0;
                    this.damaged = 0;
                    this.alpha = 1;
                    this.scale = 9;
                    this.visScale = this.scale;
                }
            };
            class addCh {
                constructor(x, y, chat, tmpObj) {
                    this.x = x;
                    this.y = y;
                    this.alpha = 0;
                    this.active = true;
                    this.alive = false;
                    this.chat = chat;
                    this.owner = tmpObj;
                };
            };
            class DeadPlayer {
                constructor(x, y, dir, buildIndex, weaponIndex, weaponVariant, skinColor, scale, name) {
                    this.x = x;
                    this.y = y;
                    this.lastDir = dir;
                    this.dir = dir + Math.PI;
                    this.buildIndex = buildIndex;
                    this.weaponIndex = weaponIndex;
                    this.weaponVariant = weaponVariant;
                    this.skinColor = skinColor;
                    this.scale = scale;
                    this.visScale = 0;
                    this.name = name;
                    this.alpha = 1;
                    this.active = true;
                    this.animate = function(delta) {
                        let d2 = UTILS.getAngleDist(this.lastDir, this.dir);
                        if (d2 > 0.01) {
                            this.dir += d2 / 20;
                        } else {
                            this.dir = this.lastDir;
                        }
                        if (this.visScale < this.scale) {
                            this.visScale += delta / (this.scale / 2);
                            if (this.visScale >= this.scale) {
                                this.visScale = this.scale;
                            }
                        }
                        this.alpha -= delta / 30000;
                        if (this.alpha <= 0) {
                            this.alpha = 0;
                            this.active = false;
                        }
                    }
                }
            };
            class Player {
                constructor(id, sid, config, UTILS, projectileManager, objectManager, players, ais, items, hats, accessories, server, scoreCallback, iconCallback) {
                    this.id = id;
                    this.sid = sid;
                    this.tmpScore = 0;
                    this.team = null;
                    this.latestSkin = 0;
                    this.oldSkinIndex = 0;
                    this.skinIndex = 0;
                    this.latestTail = 0;
                    this.oldTailIndex = 0;
                    this.tailIndex = 0;
                    this.hitTime = 0;
                    this.lastHit = 0;
                    this.tails = {};
                    for (let i = 0; i < accessories.length; ++i) {
                        if (accessories[i].price <= 0)
                            this.tails[accessories[i].id] = 1;
                    }
                    this.skins = {};
                    for (let i = 0; i < hats.length; ++i) {
                        if (hats[i].price <= 0)
                            this.skins[hats[i].id] = 1;
                    }
                    this.points = 0;
                    this.dt = 0;
                    this.hidden = false;
                    this.itemCounts = {};
                    this.isPlayer = true;
                    this.pps = 0;
                    this.moveDir = undefined;
                    this.skinRot = 0;
                    this.lastPing = 0;
                    this.iconIndex = 0;
                    this.skinColor = 0;
                    this.dist2 = 0;
                    this.aim2 = 0;
                    this.maxSpeed = 1;
                    this.chat = {
                        message: null,
                        count: 0
                    };
                    this.backupNobull = false;
                    this.circle = false;
                    this.circleRad = 200;
                    this.circleRadSpd = 0.1;
                    this.cAngle = 0;

                    // SPAWN:
                    this.spawn = function (moofoll) {
                        this.attacked = false;
                        this.death = false;
                        this.spinDir = 0;
                        this.sync = false;
                        this.antiBull = 0;
                        this.bullTimer = 0;
                        this.poisonTimer = 0;
                        this.active = true;
                        this.alive = true;
                        this.lockMove = false;
                        this.lockDir = false;
                        this.minimapCounter = 0;
                        this.chatCountdown = 0;
                        this.shameCount = 0;
                        this.shameTimer = 0;
                        this.sentTo = {};
                        this.gathering = 0;
                        this.gatherIndex = 0;
                        this.shooting = {};
                        this.shootIndex = 9;
                        this.autoGather = 0;
                        this.animTime = 0;
                        this.animSpeed = 0;
                        this.mouseState = 0;
                        this.buildIndex = -1;
                        this.weaponIndex = 0;
                        this.weaponCode = 0;
                        this.weaponVariant = 0;
                        this.primaryIndex = undefined;
                        this.secondaryIndex = undefined;
                        this.dmgOverTime = {};
                        this.noMovTimer = 0;
                        this.maxXP = 300;
                        this.XP = 0;
                        this.age = 1;
                        this.kills = 0;
                        this.upgrAge = 2;
                        this.upgradePoints = 0;
                        this.x = 0;
                        this.y = 0;
                        this.oldXY = {
                            x: 0,
                            y: 0
                        };
                        this.zIndex = 0;
                        this.xVel = 0;
                        this.yVel = 0;
                        this.slowMult = 1;
                        this.dir = 0;
                        this.dirPlus = 0;
                        this.targetDir = 0;
                        this.targetAngle = 0;
                        this.maxHealth = 100;
                        this.health = this.maxHealth;
                        this.oldHealth = this.maxHealth;
                        this.damaged = 0;
                        this.scale = config.playerScale;
                        this.speed = config.playerSpeed;
                        this.resetMoveDir();
                        this.resetResources(moofoll);
                        this.items = [0, 3, 6, 10];
                        this.weapons = [0];
                        this.shootCount = 0;
                        this.weaponXP = [];
                        this.reloads = {
                            0: 0,
                            1: 0,
                            2: 0,
                            3: 0,
                            4: 0,
                            5: 0,
                            6: 0,
                            7: 0,
                            8: 0,
                            9: 0,
                            10: 0,
                            11: 0,
                            12: 0,
                            13: 0,
                            14: 0,
                            15: 0,
                            53: 0,
                        };
                        this.bowThreat = {
                            9: 0,
                            12: 0,
                            13: 0,
                            15: 0,
                        };
                        this.damageThreat = 0;
                        this.inTrap = false;
                        this.canEmpAnti = false;
                        this.empAnti = false;
                        this.soldierAnti = false;
                        this.poisonTick = 0;
                        this.bullTick = 0;
                        this.setPoisonTick = false;
                        this.setBullTick = false;
                        this.antiTimer = 2;
                    };

                    // RESET MOVE DIR:
                    this.resetMoveDir = function () {
                        this.moveDir = undefined;
                    };

                    // RESET RESOURCES:
                    this.resetResources = function (moofoll) {
                        for (let i = 0; i < config.resourceTypes.length; ++i) {
                            this[config.resourceTypes[i]] = moofoll ? 100 : 0;
                        }
                    };

                    // ADD ITEM:
                    this.getItemType = function(id) {
                        let findindx = this.items.findIndex((ids) => ids == id);
                        if (findindx != -1) {
                            return findindx;
                        } else {
                            return items.checkItem.index(id, this.items);
                        }
                    };

                    // SET DATA:
                    this.setData = function (data) {
                        this.id = data[0];
                        this.sid = data[1];
                        this.name = data[2];
                        this.x = data[3];
                        this.y = data[4];
                        this.dir = data[5];
                        this.health = data[6];
                        this.maxHealth = data[7];
                        this.scale = data[8];
                        this.skinColor = data[9];
                    };

                    // UPDATE POISON TICK:
                    this.updateTimer = function() {

                        this.bullTimer -= 1;
                        if (this.bullTimer <= 0) {
                            this.setBullTick = false;
                            this.bullTick = game.tick - 1;
                            this.bullTimer = config.serverUpdateRate;
                        }
                        this.poisonTimer -= 1;
                        if (this.poisonTimer <= 0) {
                            this.setPoisonTick = false;
                            this.poisonTick = game.tick - 1;
                            this.poisonTimer = config.serverUpdateRate;
                        }

                    };
                    this.update = function(delta) {
                        if (this.sid == playerSID) {
                            this.circleRad = parseInt(getEl("circleRad").value)||0;
                            this.circleRadSpd = parseFloat(getEl("radSpeed").value)||0;
                            this.cAngle += this.circleRadSpd;
                        }
                        if (this.active) {

                            // MOVE:
                            let gear = {
                                skin: findID(hats, this.skinIndex),
                                tail: findID(accessories, this.tailIndex)
                            }
                            let spdMult = ((this.buildIndex >= 0) ? 0.5 : 1) * (items.weapons[this.weaponIndex].spdMult || 1) * (gear.skin ? (gear.skin.spdMult || 1) : 1) * (gear.tail ? (gear.tail.spdMult || 1) : 1) * (this.y <= config.snowBiomeTop ? ((gear.skin && gear.skin.coldM) ? 1 : config.snowSpeed) : 1) * this.slowMult;
                            this.maxSpeed = spdMult;

                        }
                    };

                    let tmpRatio = 0;
                    let animIndex = 0;
                    this.animate = function(delta) {
                        if (this.animTime > 0) {
                            this.animTime -= delta;
                            if (this.animTime <= 0) {
                                this.animTime = 0;
                                this.dirPlus = 0;
                                tmpRatio = 0;
                                animIndex = 0;
                            } else {
                                if (animIndex == 0) {
                                    tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                    this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                                    if (tmpRatio >= 1) {
                                        tmpRatio = 1;
                                        animIndex = 1;
                                    }
                                } else {
                                    tmpRatio -= delta / (this.animSpeed * (1-config.hitReturnRatio));
                                    this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                                }
                            }
                        }
                    };

                    // GATHER ANIMATION:
                    this.startAnim = function (didHit, index) {
                        this.animTime = this.animSpeed = items.weapons[index].speed;
                        this.targetAngle = (didHit ? -config.hitAngle : -Math.PI);
                        tmpRatio = 0;
                        animIndex = 0;
                    };

                    // CAN SEE:
                    this.canSee = function(other) {
                        if (!other) return false;
                        let dx = Math.abs(other.x - this.x) - other.scale;
                        let dy = Math.abs(other.y - this.y) - other.scale;
                        return dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3;
                    };

                    // SHAME SYSTEM:
                    this.judgeShame = function () {
                        if (this.oldHealth < this.health) {
                            if (this.hitTime) {
                                let timeSinceHit = game.tick - this.hitTime;
                                this.lastHit = game.tick;
                                this.hitTime = 0;
                                if (timeSinceHit < 2) {
                                    this.shameCount++;
                                } else {
                                    this.shameCount = Math.max(0, this.shameCount - 2);
                                }
                            }
                        } else if (this.oldHealth > this.health) {
                            this.hitTime = game.tick;
                        }
                    };
                    this.addShameTimer = function () {
                        this.shameCount = 0;
                        this.shameTimer = 30;
                        let interval = setInterval(() => {
                            this.shameTimer--;
                            if (this.shameTimer <= 0) {
                                clearInterval(interval);
                            }
                        }, 1000);
                    };

                    // CHECK TEAM:
                    this.isTeam = function (tmpObj) {
                        return (this == tmpObj || (this.team && this.team == tmpObj.team));
                    };

                    // FOR THE PLAYER:
                    this.findAllianceBySid = function (sid) {
                        return this.team ? alliancePlayers.find((THIS) => THIS === sid) : null;
                    };
                    this.checkCanInsta = function (nobull) {
                        let totally = 0;
                        if (this.alive && inGame) {
                            let primary = {
                                weapon: this.weapons[0],
                                variant: this.primaryVariant,
                                dmg: this.weapons[0] == undefined ? 0 : items.weapons[this.weapons[0]].dmg,
                            };
                            let secondary = {
                                weapon: this.weapons[1],
                                variant: this.secondaryVariant,
                                dmg: this.weapons[1] == undefined ? 0 : items.weapons[this.weapons[1]].Pdmg,
                            };
                            let bull = this.skins[7] && !nobull ? 1.5 : 1;
                            let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1;
                            if (primary.weapon != undefined && this.reloads[primary.weapon] == 0) {
                                totally += primary.dmg * pV * bull;
                            }
                            if (secondary.weapon != undefined && this.reloads[secondary.weapon] == 0) {
                                totally += secondary.dmg;
                            }
                            if (this.skins[53] && this.reloads[53] <= (player.weapons[1] == 10 ? 0 : game.tickRate) && near.skinIndex != 22) {
                                totally += 25;
                            }
                            totally *= near.skinIndex == 6 ? 0.75 : 1;
                            return totally;
                        }
                        return 0;
                    };

                    // UPDATE WEAPON RELOAD:
                    this.manageReload = function () {
                        if (this.shooting[53]) {
                            this.shooting[53] = 0;
                            this.reloads[53] = (2500 - game.tickRate);
                        } else {
                            if (this.reloads[53] > 0) {
                                this.reloads[53] = Math.max(0, this.reloads[53] - game.tickRate);
                            }
                        }
                        if (this.gathering || this.shooting[1]) {
                            if (this.gathering) {
                                this.gathering = 0;
                                this.reloads[this.gatherIndex] = (items.weapons[this.gatherIndex].speed * (this.skinIndex == 20 ? 0.78 : 1));
                                this.attacked = true;
                            }
                            if (this.shooting[1]) {
                                this.shooting[1] = 0;
                                this.reloads[this.shootIndex] = (items.weapons[this.shootIndex].speed * (this.skinIndex == 20 ? 0.78 : 1));
                                this.attacked = true;
                            }
                        } else {
                            this.attacked = false;
                            if (this.buildIndex < 0) {
                                if (this.reloads[this.weaponIndex] > 0) {
                                    this.reloads[this.weaponIndex] = Math.max(0, this.reloads[this.weaponIndex] - game.tickRate);
                                    if (this == player) {
                                        if (getEl("weaponGrind").checked) {
                                            for (let i = 0; i < Math.PI * 2; i+= Math.PI / 2) {
                                                checkPlace(player.getItemType(22), i);
                                            }
                                        }
                                    }
                                    if (this.reloads[this.primaryIndex] == 0 && this.reloads[this.weaponIndex] == 0) {
                                        this.antiBull++;
                                        game.tickBase(() => {
                                            this.antiBull = 0;
                                        }, 1);
                                    }
                                }
                            }
                        }
                    };

                    // FOR ANTI INSTA:
                    this.addDamageThreat = function (tmpObj) {
                        let primary = {
                            weapon: this.primaryIndex,
                            variant: this.primaryVariant
                        };
                        primary.dmg = primary.weapon == undefined ? 45 : items.weapons[primary.weapon].dmg;
                        let secondary = {
                            weapon: this.secondaryIndex,
                            variant: this.secondaryVariant
                        };
                        secondary.dmg = secondary.weapon == undefined ? 50 : items.weapons[secondary.weapon].Pdmg;
                        let bull = 1.5;
                        let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1.18;
                        let sV = secondary.variant != undefined ? [9, 12, 13, 15].includes(secondary.weapon) ? 1 : config.weaponVariants[secondary.variant].val : 1.18;
                        if (primary.weapon == undefined ? true : this.reloads[primary.weapon] == 0) {
                            this.damageThreat += primary.dmg * pV * bull;
                        }
                        if (secondary.weapon == undefined ? true : this.reloads[secondary.weapon] == 0) {
                            this.damageThreat += secondary.dmg * sV;
                        }
                        if (this.reloads[53] <= game.tickRate) {
                            this.damageThreat += 25;
                        }
                        this.damageThreat *= tmpObj.skinIndex == 6 ? 0.75 : 1;
                        if (!this.isTeam(tmpObj)) {
                            if (this.dist2 <= 300) {
                                tmpObj.damageThreat += this.damageThreat;
                            }
                        }
                    };

                }
            };

            // SOME CODES:
            function sendUpgrade(index) {
                player.reloads[index] = 0;
                packet("H", index);
            }

            function storeEquip(id, index) {
                packet("c", 0, id, index);
            }

            function storeBuy(id, index) {
                packet("c", 1, id, index);
            }

            function buyEquip(id, index) {
                let nID = player.skins[6] ? 6 : 0;
                if (player.alive && inGame) {
                    if (index == 0) {
                        if (player.skins[id]) {
                            if (player.latestSkin != id) {
                                packet("c", 0, id, 0);
                            }
                        } else {
                            if (configs.autoBuyEquip) {
                                let find = findID(hats, id);
                                if (find) {
                                    if (player.points >= find.price) {
                                        //setTimeout(()=>{
                                        packet("c", 1, id, 0);
                                        //setTimeout(()=>{
                                        packet("c", 0, id, 0);
                                        //}, 120);
                                        //}, 120);
                                    } else {
                                        if (player.latestSkin != nID) {
                                            packet("c", 0, nID, 0);
                                        }
                                    }
                                } else {
                                    if (player.latestSkin != nID) {
                                        packet("c", 0, nID, 0);
                                    }
                                }
                            } else {
                                if (player.latestSkin != nID) {
                                    packet("c", 0, nID, 0);
                                }
                            }
                        }
                    } else if (index == 1) {
                        if (useWasd && (id != 11 && id != 0)) {
                            if (player.latestTail != 0) {
                                packet("c", 0, 0, 1);
                            }
                            return;
                        }
                        if (player.tails[id]) {
                            if (player.latestTail != id) {
                                packet("c", 0, id, 1);
                            }
                        } else {
                            if (configs.autoBuyEquip) {
                                let find = findID(accessories, id);
                                if (find) {
                                    if (player.points >= find.price) {
                                        packet("c", 1, id, 1);
                                        // setTimeout(()=>{
                                        packet("c", 0, id, 1);
                                        //}, 120);
                                    } else {
                                        if (player.latestTail != 0) {
                                            packet("c", 0, 0, 1);
                                        }
                                    }
                                } else {
                                    if (player.latestTail != 0) {
                                        packet("c", 0, 0, 1);
                                    }
                                }
                            } else {
                                if (player.latestTail != 0) {
                                    packet("c", 0, 0, 1);
                                }
                            }
                        }
                    }
                }
            }
            function selectToBuild(index, wpn) {
                packet("G", index, wpn);
            }
            function selectWeapon(index, isPlace) {
                if (!isPlace) {
                    player.weaponCode = index;
                }
                packet("G", index, 1);
            }
            function sendAutoGather() {
                packet("K", 1, 1);
            }
            function sendAtck(id, angle) {
                packet("d", id, angle, 1);
            }


            function place(id, rad, rmd) {
                try {
                    if (id == undefined) return;
                    let item = items.list[player.items[id]];
                    let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                    let tmpX = player.x2 + tmpS * Math.cos(rad);
                    let tmpY = player.y2 + tmpS * Math.sin(rad);
                    if (id === 0 || testMode || (player.alive && inGame && player.itemCounts[item.group.id] == undefined ? true : player.itemCounts[item.group.id] < (config.isSandbox ? id === 3 || id === 5 ? 299 : 99 : item.group.limit ? item.group.limit : 99))) {
                        selectToBuild(player.items[id]);
                        sendAtck(1, rad);
                        selectWeapon(player.weaponCode, 1);
                        if (rmd && getEl("placeVis").checked) {
                placeVisible.push({
                    x: tmpX,
                    y: tmpY,
                    name: item.name,
                    scale: item.scale,
                    dir: rad
                });
                game.tickBase(() => {
                    placeVisible.shift();
                }, 1)
            }
        }
    } catch (e) {}
}

            function checkPlace(id, rad) {
                try {
                    if (id == undefined) return;
                    let item = items.list[player.items[id]];
                    let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                    let tmpX = player.x2 + tmpS * Math.cos(rad);
                    let tmpY = player.y2 + tmpS * Math.sin(rad);
                    if (objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, player)) {
                        place(id, rad, 1);
                    }
                } catch (e) {}
            }

            // HEALING:
            function soldierMult() {
                return player.latestSkin == 6 ? 0.75 : 1;
            }

            function healthBased() {
                if (player.health == 100)
                    return 0;
                if ((player.skinIndex != 45 && player.skinIndex != 56)) {
                    return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
                }
                return 0;
            }

            function getAttacker(damaged) {
                let attackers = enemy.filter(tmp => {
                    //let damages = new Damages(items);
                    //let dmg = damages.weapons[tmp.weaponIndex];
                    //let by = tmp.weaponIndex < 9 ? [dmg[0], dmg[1], dmg[2], dmg[3]] : [dmg[0], dmg[1]];
                    let rule = {
                        //one: tmp.dist2 <= 300,
                        //two: by.includes(damaged),
                        three: tmp.attacked
                    }
                    return /*rule.one && rule.two && */rule.three;
                });
                return attackers;
            }

            function healer() {
                for (let i = 0; i < healthBased(); i++) {
                    place(0, getAttackDir());
                }
            }

            function antiSyncHealing(timearg) {
                my.antiSync = true;
                let healAnti = setInterval(() => {
                    if (player.shameCount < 5) {
                        place(0, getAttackDir());
                    }
                }, 75);
                setTimeout(() => {
                    clearInterval(healAnti);
                    setTimeout(() => {
                        my.antiSync = false;
                    }, game.tickRate);
                }, game.tickRate);
            }

            function biomeGear(mover, returns) {
                if (clicks.right || clicks.left) return
                if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                    if (returns) return 31;
                    buyEquip(31, 0);
                } else {
                    if (player.y2 <= config.snowBiomeTop) {
                        if (returns) return mover && player.moveDir == undefined ? 22 : 15;
                        buyEquip(mover && player.moveDir == undefined ? 22 : 15, 0);
                    } else {
                        if (returns) return mover && player.moveDir == undefined ? 22 : 12;
                        buyEquip(mover && player.moveDir == undefined ? 22 : 12, 0);
                    }
                }
                if (returns) return 0;
            }

            function woah(mover) {
                buyEquip(mover && player.moveDir == undefined ? 0 : 11, 1);
            }

            let advHeal = [];

            class Traps {
                constructor(UTILS, items) {
                    this.dist = 0;
                    this.aim = 0;
                    this.inTrap = false;
                    this.replaced = false;
                    this.antiTrapped = false;
                    this.info = {};
                    this.notFast = function() {
                        return player.weapons[1] == 10 && ((this.info.health > items.weapons[player.weapons[0]].dmg) || player.weapons[0] == 5);
                    }
                    this.testCanPlace = function (id, first = -(Math.PI / 2), repeat = (Math.PI / 2), plus = (Math.PI / 18), radian, replacer, yaboi) {
                        try {
                            let item = items.list[player.items[id]];
                            let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                            let counts = {
                                attempts: 0,
                                placed: 0
                            };
                            let tmpObjects = [];
                            gameObjects.forEach((p) => {
                                tmpObjects.push({
                                    x: p.x,
                                    y: p.y,
                                    active: p.active,
                                    blocker: p.blocker,
                                    scale: p.scale,
                                    isItem: p.isItem,
                                    type: p.type,
                                    colDiv: p.colDiv,
                                    getScale: function(sM, ig) {
                                        sM = sM||1;
                                        return this.scale * ((this.isItem||this.type==2||this.type==3||this.type==4)
                                                             ?1:(0.6*sM)) * (ig?1:this.colDiv);
                                    },
                                });
                            });
                            for (let i = first; i < repeat; i += plus) {
                                counts.attempts++;
                                let relAim = radian + i;
                                let tmpX = player.x2 + tmpS * Math.cos(relAim);
                                let tmpY = player.y2 + tmpS * Math.sin(relAim);
                                let cantPlace = tmpObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                if (cantPlace) continue;
                                if (item.id != 18 && tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                if ((!replacer && yaboi) || useWasd) {
                                    if (useWasd ? false : yaboi.inTrap) {
                                        if (UTILS.getAngleDist(near.aim2 + Math.PI, relAim + Math.PI) <= Math.PI) {
                                            place(2, relAim, 1);
                                        } else {
                                            player.items[4] == 15 && place(4, relAim, 1);
                                        }
                                    } else {
                                        if (UTILS.getAngleDist(near.aim2, relAim) <= config.gatherAngle / 1.5) {
                                            place(2, relAim, 1);
                                        } else {
                                            player.items[4] == 15 && place(4, relAim, 1);
                                        }
                                    }
                                } else {
                                    place(id, relAim, 1);
                                }
                                tmpObjects.push({
                                    x: tmpX,
                                    y: tmpY,
                                    active: true,
                                    blocker: item.blocker,
                                    scale: item.scale,
                                    isItem: true,
                                    type: null,
                                    colDiv: item.colDiv,
                                    getScale: function() {
                                        return this.scale;
                                    },
                                });
                                if (UTILS.getAngleDist(near.aim2, relAim) <= 1) {
                                    counts.placed++;
                                }
                            }
                            if (counts.placed > 0 && replacer && item.dmg) {
                                if (near.dist2 <= items.weapons[player.weapons[0]].range + (player.scale * 1.8) && configs.spikeTick) {
                                    instaC.canSpikeTick = true;
                                }
                            }
                        } catch (err) {
                        }
                    };
                    this.checkSpikeTick = function() {
                        try {
                            if (![3, 4, 5].includes(near.primaryIndex)) return false;
                            if ((getEl("safeAntiSpikeTick").checked || my.autoPush) ? false : near.primaryIndex == undefined ? true : (near.reloads[near.primaryIndex] > game.tickRate)) return false;
                            // more range for safe. also testing near.primaryIndex || 5
                            if (near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                let item = items.list[9];
                                let tmpS = near.scale + item.scale + (item.placeOffset || 0);
                                let danger = 0;
                                let counts = {
                                    attempts: 0,
                                    block: `unblocked`
                                };
                                for (let i = -1; i <= 1; i += 1/10) {
                                    counts.attempts++;
                                    let relAim = UTILS.getDirect(player, near, 2, 2) + i;
                                    let tmpX = near.x2 + tmpS * Math.cos(relAim);
                                    let tmpY = near.y2 + tmpS * Math.sin(relAim);
                                    let cantPlace = gameObjects.find((tmp) => tmp.active && UTILS.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                                    if (cantPlace) continue;
                                    if (tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                                    danger++;
                                    counts.block = `blocked`;
                                    break;
                                }
                                if (danger) {
                                    my.anti0Tick = 1;
                                    player.chat.count = 2000;
                                    return true;
                                }
                            }
                        } catch (err) {
                            return null;
                        }
                        return false;
                    }
                    this.protect = function (aim) {
                        if (!configs.antiTrap) return;
                        if (player.items[4]) {
                            this.testCanPlace(2, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), aim + Math.PI);
                            this.antiTrapped = true;
                        }
                    };
                    this.autoPlace = function () {
                        if (enemy.length && configs.autoPlace && !instaC.ticking) {
                                if (gameObjects.length) {
                                    let near2 = {
                                        inTrap: false,
                                    };
                                    let nearTrap = gameObjects.filter(e => e.trap && e.active && e.isTeamObject(player) && UTILS.getDist(e, near, 0, 2) <= (near.scale + e.getScale() + 5)).sort(function (a, b) {
                                        return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                                    })[0];
                                    if (nearTrap) {
                                        near2.inTrap = true;
                                    } else {
                                        near2.inTrap = false;
                                    }
                                    if (testMode ? enemy.length : (near.dist2 <= 450)) {
                                        if (near.dist2 <= 200) {
                                            this.testCanPlace(2, 0, (Math.PI * 2), (Math.PI / 24), near.aim2, 0, {inTrap: near2.inTrap});
                                            this.testCanPlace(2, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                        } else {
                                            player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                        }
                                    }
                                } else {
                                    if (testMode ? enemy.length : (near.dist2 <= 450)) {
                                        player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), near.aim2);
                                    }
                                }
                        }
                    };
                    this.replacer = function (findObj) {
                        if (!findObj || !configs.autoReplace) return;
                        if (!inGame) return;
                        if (this.antiTrapped) return;
                        game.tickBase(() => {
                            let objAim = UTILS.getDirect(findObj, player, 0, 2);
                            let objDst = UTILS.getDist(findObj, player, 0, 2);
                            if (getEl("weaponGrind").checked && objDst <= items.weapons[player.weaponIndex].range + player.scale) return;
                            if (objDst <= 400 && near.dist2 <= 400) {
                                let danger = this.checkSpikeTick();
                                if (!danger && near.dist2 <= items.weapons[near.primaryIndex || 5].range + (near.scale * 1.8)) {
                                    //this.testCanPlace(2, -(Math.PI / 2), (Math.PI / 2), (Math.PI / 18), objAim, 1);
                                    this.testCanPlace(2, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                } else {
                                    player.items[4] == 15 && this.testCanPlace(4, 0, (Math.PI * 2), (Math.PI / 24), objAim, 1);
                                }
                                this.replaced = true;
                            }
                        }, 1);
                    };
                }
            };

            class Instakill {
                constructor() {
                    this.wait = false;
                    this.can = false;
                    this.isTrue = false;
                    this.nobull = false;
                    this.ticking = false;
                    this.canSpikeTick = false;
                    this.startTick = false;
                    this.readyTick = false;
                    this.canCounter = false;
                    this.revTick = false;
                    this.syncHit = false;
                    this.changeType = function (type) {
                        this.wait = false;
                        this.isTrue = true;
                        my.autoAim = true;
                        let instaLog = [type];
                        let backupNobull = near.backupNobull;
                        near.backupNobull = false;
                        game.tickBase(() => {
                            instaLog.push(player.skinIndex);
                            game.tickBase(() => {
                                if (near.skinIndex == 22 && getEl("backupNobull").checked) {
                                    near.backupNobull = true;
                                }
                                instaLog.push(player.skinIndex);
                            }, 1);
                        }, 1);
                        if (type == "rev") {
                            selectWeapon(player.weapons[1]);
                            buyEquip(53, 0);
                            buyEquip(21, 1);
                            sendAutoGather();
                            game.tickBase(() => {
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                buyEquip(21, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 1);
                            }, 1);
                        } else if (type == "nobull") {
                            selectWeapon(player.weapons[0]);
                            if (getEl("backupNobull").checked && backupNobull) {
                                buyEquip(7, 0);
                            } else {
                                buyEquip(6, 0);
                            }
                            buyEquip(21, 1);
                            sendAutoGather();
                            game.tickBase(() => {
                                if (near.skinIndex == 22) {
                                    if (getEl("backupNobull").checked) {
                                        near.backupNobull = true;
                                    }
                                    buyEquip(6, 0);
                                } else {
                                    buyEquip(53, 0);
                                }
                                selectWeapon(player.weapons[1]);
                                buyEquip(21, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 1);
                            }, 1);
                        } else if (type == "normal") {
                            selectWeapon(player.weapons[1]);
                            buyEquip(53, 0);
                            buyEquip(21, 1);
                            sendAutoGather();
                            game.tickBase(() => {
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                buyEquip(21, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 1);
                            }, 1);
                        } else {
                            setTimeout(() => {
                                this.isTrue = false;
                                my.autoAim = false;
                            }, 50);
                        }
                    };
                    this.spikeTickType = function () {
                        this.isTrue = true;
                        my.autoAim = true;
                        selectWeapon(player.weapons[0]);
                        buyEquip(7, 0);
                        buyEquip(21, 1);
                        sendAutoGather();
                        game.tickBase(() => {
                            if (player.reloads[53] == 0 && getEl("turretCombat").checked) {
                                selectWeapon(player.weapons[0]);
                                buyEquip(53, 0);
                                buyEquip(21, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 1);
                            } else {
                                sendAutoGather();
                                this.isTrue = false;
                                my.autoAim = false;
                            }
                        }, 1);
                    };
                    this.counterType = function () {
                        this.isTrue = true;
                        my.autoAim = true;
                        selectWeapon(player.weapons[0]);
                        buyEquip(7, 0);
                        buyEquip(21, 1);
                        sendAutoGather();
                        game.tickBase(() => {
                            if (player.reloads[53] == 0 && getEl("turretCombat").checked) {
                                selectWeapon(player.weapons[0]);
                                buyEquip(53, 0);
                                buyEquip(21, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                }, 1);
                            } else {
                                sendAutoGather();
                                this.isTrue = false;
                                my.autoAim = false;
                            }
                        }, 1);
                    };
                    this.rangeType = function (type) {
                        this.isTrue = true;
                        my.autoAim = true;
                        if (type == "ageInsta") {
                            my.ageInsta = false;
                            if (player.items[5] == 18) {
                                place(5, near.aim2);
                            }
                            packet("a", undefined, 1);
                            buyEquip(6, 0);
                            buyEquip(21, 1);
                            game.tickBase(() => {
                                selectWeapon(player.weapons[1]);
                                buyEquip(53, 0);
                                buyEquip(21, 1);
                                sendAutoGather();
                                game.tickBase(() => {
                                    sendUpgrade(12);
                                    selectWeapon(player.weapons[1]);
                                    buyEquip(53, 0);
                                    buyEquip(21, 1);
                                    game.tickBase(() => {
                                        sendUpgrade(15);
                                        selectWeapon(player.weapons[1]);
                                        buyEquip(53, 0);
                                        buyEquip(21, 1);
                                        game.tickBase(() => {
                                            sendAutoGather();
                                            this.isTrue = false;
                                            my.autoAim = false;
                                        }, 1);
                                    }, 1);
                                }, 1);
                            }, 1);
                        } else {
                            selectWeapon(player.weapons[1]);
                            if (player.reloads[53] == 0 && near.dist2 <= 700 && near.skinIndex != 22) {
                                buyEquip(53, 0);
                            } else {
                                buyEquip(20, 0);
                            }
                            buyEquip(11, 1);
                            sendAutoGather();
                            game.tickBase(() => {
                                sendAutoGather();
                                this.isTrue = false;
                                my.autoAim = false;
                            }, 1);
                        }
                    };
                    this.oneTickType = function () {
                        this.isTrue = true;
                        my.autoAim = true;
                        selectWeapon(player.weapons[1]);
                        buyEquip(53, 0);
                        buyEquip(11, 1);
                        packet("a", near.aim2, 1);
                        if (player.weapons[1] == 15) {
                            my.revAim = true;
                            sendAutoGather();
                        }
                        game.tickBase(() => {
                            my.revAim = false;
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            buyEquip(19, 1);
                            packet("a", near.aim2, 1);
                            if (player.weapons[1] != 15) {
                                sendAutoGather();
                            }
                            game.tickBase(() => {
                                sendAutoGather();
                                this.isTrue = false;
                                my.autoAim = false;
                                packet("a", undefined, 1);
                            }, 1);
                        }, 1);
                    };
                    this.threeOneTickType = function () {
                        this.isTrue = true;
                        my.autoAim = true;
                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                        biomeGear();
                        buyEquip(11, 1);
                        packet("a", near.aim2, 1);
                        game.tickBase(() => {
                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                            buyEquip(53, 0);
                            buyEquip(11, 1);
                            packet("a", near.aim2, 1);
                            game.tickBase(() => {
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                buyEquip(19, 1);
                                sendAutoGather();
                                packet("a", near.aim2, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                    packet("a", undefined, 1);
                                }, 1);
                            }, 1);
                        }, 1);
                    };
                    this.kmTickType = function () {
                        this.isTrue = true;
                        my.autoAim = true;
                        my.revAim = true;
                        selectWeapon(player.weapons[1]);
                        buyEquip(53, 0);
                        buyEquip(11, 1);
                        sendAutoGather();
                        packet("a", near.aim2, 1);
                        game.tickBase(() => {
                            my.revAim = false;
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            buyEquip(19, 1);
                            packet("a", near.aim2, 1);
                            game.tickBase(() => {
                                sendAutoGather();
                                this.isTrue = false;
                                my.autoAim = false;
                                packet("a", undefined, 1);
                            }, 1);
                        }, 1);
                    };
                    this.boostTickType = function () {
                        /*this.isTrue = true;
                        my.autoAim = true;
                        selectWeapon(player.weapons[0]);
                        buyEquip(53, 0);
                        buyEquip(11, 1);
                        packet("33", near.aim2);
                        game.tickBase(() => {
                            place(4, near.aim2);
                            selectWeapon(player.weapons[1]);
                            biomeGear();
                            buyEquip(11, 1);
                            sendAutoGather();
                            packet("33", near.aim2);
                            game.tickBase(() => {
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                buyEquip(19, 1);
                                packet("33", near.aim2);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                    packet("33", undefined);
                                }, 1);
                            }, 1);
                        }, 1);*/
                        this.isTrue = true;
                        my.autoAim = true;
                        biomeGear();
                        buyEquip(11, 1);
                        packet("a", near.aim2, 1);
                        game.tickBase(() => {
                            if (player.weapons[1] == 15) {
                                my.revAim = true;
                            }
                            selectWeapon(player.weapons[[9, 12, 13, 15].includes(player.weapons[1]) ? 1 : 0]);
                            buyEquip(53, 0);
                            buyEquip(11, 1);
                            if ([9, 12, 13, 15].includes(player.weapons[1])) {
                                sendAutoGather();
                            }
                            packet("a", near.aim2, 1);
                            place(4, near.aim2);
                            game.tickBase(() => {
                                my.revAim = false;
                                selectWeapon(player.weapons[0]);
                                buyEquip(7, 0);
                                buyEquip(19, 1);
                                if (![9, 12, 13, 15].includes(player.weapons[1])) {
                                    sendAutoGather();
                                }
                                packet("a", near.aim2, 1);
                                game.tickBase(() => {
                                    sendAutoGather();
                                    this.isTrue = false;
                                    my.autoAim = false;
                                    packet("a", undefined, 1);
                                }, 1);
                            }, 1);
                        }, 1);
                    };
                    this.gotoGoal = function (goto, OT) {
                        let slowDists = (weeeee) => weeeee * config.playerScale;
                        let goal = {
                            a: goto - OT,
                            b: goto + OT,
                            c: goto - slowDists(1),
                            d: goto + slowDists(1),
                            e: goto - slowDists(2),
                            f: goto + slowDists(2),
                            g: goto - slowDists(4),
                            h: goto + slowDists(4)
                        };
                        let bQ = function(wwww, awwww) {
                            if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2 && awwww == 0) {
                                buyEquip(31, 0);
                            } else {
                                buyEquip(wwww, awwww);
                            }
                        }
                        if (enemy.length) {
                            let dst = near.dist2;
                            this.ticking = true;
                            if (dst >= goal.a && dst <= goal.b) {
                                bQ(6, 0);
                                bQ(11, 1);
                                if (player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0] || player.buildIndex > -1) {
                                    selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                }
                                return {
                                    dir: undefined,
                                    action: 1
                                };
                            } else {
                                if (dst < goal.a) {
                                    if (dst >= goal.g) {
                                        if (dst >= goal.e) {
                                            if (dst >= goal.c) {
                                                bQ(40, 0);
                                                bQ(10, 1);
                                                if (configs.slowOT) {
                                                    player.buildIndex != player.items[1] && selectToBuild(player.items[1]);
                                                } else {
                                                    if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                    }
                                                }
                                            } else {
                                                bQ(6, 0);
                                                bQ(19, 1);
                                                if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                    selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                }
                                            }
                                        } else {
                                            bQ(6, 0);
                                            bQ(12, 1);
                                            if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                            }
                                        }
                                    } else {
                                        biomeGear();
                                        bQ(11, 1);
                                        if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                        }
                                    }
                                    return {
                                        dir: near.aim2 + Math.PI,
                                        action: 0
                                    };
                                } else if (dst > goal.b) {
                                    if (dst <= goal.h) {
                                        if (dst <= goal.f) {
                                            if (dst <= goal.d) {
                                                bQ(40, 0);
                                                bQ(9, 1);
                                                if (configs.slowOT) {
                                                    player.buildIndex != player.items[1] && selectToBuild(player.items[1]);
                                                } else {
                                                    if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                        selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                    }
                                                }
                                            } else {
                                                bQ(6, 0);
                                                bQ(19, 1);
                                                if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                    selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                                }
                                            }
                                        } else {
                                            bQ(6, 0);
                                            bQ(12, 1);
                                            if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                                selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                            }
                                        }
                                    } else {
                                        biomeGear();
                                        bQ(11, 1);
                                        if ((player.weaponIndex != player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]) || player.buildIndex > -1) {
                                            selectWeapon(player.weapons[[10, 14].includes(player.weapons[1]) ? 1 : 0]);
                                        }
                                    }
                                    return {
                                        dir: near.aim2,
                                        action: 0
                                    };
                                }
                                return {
                                    dir: undefined,
                                    action: 0
                                };
                            }
                        } else {
                            this.ticking = false;
                            return {
                                dir: undefined,
                                action: 0
                            };
                        }
                    }
                    /** wait 1 tick for better quality */
                    this.bowMovement = function () {
                        let moveMent = this.gotoGoal(685, 3);
                        if (moveMent.action) {
                            if (player.reloads[53] == 0 && !this.isTrue) {
                                this.rangeType("ageInsta");
                            } else {
                                packet("a", moveMent.dir, 1);
                            }
                        } else {
                            packet("a", moveMent.dir, 1);
                        }
                    },
                        this.tickMovement = function () {
                        let moveMent = this.gotoGoal(([10, 14].includes(player.weapons[1]) && player.y2 > config.snowBiomeTop) ? 240 : player.weapons[1] == 15 ? 250 : player.y2 <= config.snowBiomeTop ? [10, 14].includes(player.weapons[1]) ? 270 : 265 : 275, 3);
                        if (moveMent.action) {
                            if (![6, 22].includes(near.skinIndex) && player.reloads[53] == 0 && !this.isTrue) {
                                ([10, 14].includes(player.weapons[1]) && player.y2 > config.snowBiomeTop) || (player.weapons[1] == 15) ? this.oneTickType() : this.threeOneTickType();
                            } else {
                                packet("a", moveMent.dir, 1);
                            }
                        } else {
                            packet("a", moveMent.dir, 1);
                        }
                    },
                        this.kmTickMovement = function () {
                        let moveMent = this.gotoGoal(240, 3);
                        if (moveMent.action) {
                            if (near.skinIndex != 22 && player.reloads[53] == 0 && !this.isTrue && ((game.tick - near.poisonTick) % config.serverUpdateRate == 8)) {
                                this.kmTickType();
                            } else {
                                packet("a", moveMent.dir, 1);
                            }
                        } else {
                            packet("a", moveMent.dir, 1);
                        }
                    },
                        this.boostTickMovement = function () {
                        let dist = player.weapons[1] == 9 ? 365 : player.weapons[1] == 12 ? 380 : player.weapons[1] == 13 ? 390 : player.weapons[1] == 15 ? 365 : 370;
                        let actionDist = player.weapons[1] == 9 ? 2 : player.weapons[1] == 12 ? 1.5 : player.weapons[1] == 13 ? 1.5 : player.weapons[1] == 15 ? 2 : 3;
                        let moveMent = this.gotoGoal(dist, actionDist);
                        if (moveMent.action) {
                            if (player.reloads[53] == 0 && !this.isTrue) {
                                this.boostTickType();
                            } else {
                                packet("a", moveMent.dir, 1);
                            }
                        } else {
                            packet("a", moveMent.dir, 1);
                        }
                    }
                    /** wait 1 tick for better quality */
                    this.perfCheck = function(pl, nr) {
                        if (nr.weaponIndex == 11 && UTILS.getAngleDist(nr.aim2 + Math.PI, nr.d2) <= config.shieldAngle) return false;
                        if (![9, 12, 13, 15].includes(player.weapons[1])) return true;
                        let pjs = {
                            x: nr.x2 + (70 * Math.cos(nr.aim2 + Math.PI)),
                            y: nr.y2 + (70 * Math.sin(nr.aim2 + Math.PI))
                        };
                        if (UTILS.lineInRect(pl.x2 - pl.scale, pl.y2 - pl.scale, pl.x2 + pl.scale, pl.y2 + pl.scale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                            return true;
                        }
                        let finds = ais.filter(tmp => tmp.visible).find((tmp) => {
                            if (UTILS.lineInRect(tmp.x2 - tmp.scale, tmp.y2 - tmp.scale, tmp.x2 + tmp.scale, tmp.y2 + tmp.scale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                                return true;
                            }
                        });
                        if (finds) return false;
                        finds = gameObjects.filter(tmp => tmp.active).find((tmp) => {
                            let tmpScale = tmp.getScale();
                            if (!tmp.ignoreCollision && UTILS.lineInRect(tmp.x - tmpScale, tmp.y - tmpScale, tmp.x + tmpScale, tmp.y + tmpScale, pjs.x, pjs.y, pjs.x, pjs.y)) {
                                return true;
                            }
                        });
                        if (finds) return false;
                        return true;
                    }
                }
            };
            class Autobuy {
                constructor(buyHat, buyAcc) {
                    this.hat = function() {
                        buyHat.forEach((id) => {
                            let find = findID(hats, id);
                            if (find && !player.skins[id] && player.points >= find.price) packet("c", 1, id, 0);
                        });
                    };
                    this.acc = function() {
                        buyAcc.forEach((id) => {
                            let find = findID(accessories, id);
                            if (find && !player.tails[id] && player.points >= find.price) packet("c", 1, id, 1);
                        });
                    };
                }
            };

            class Autoupgrade {
                constructor() {
                    this.sb = function(upg) {
                        upg(3);
                        upg(17);
                        upg(31);
                        upg(23);
                        upg(9);
                        upg(38);
                    };
                    this.kh = function(upg) {
                        upg(3);
                        upg(17);
                        upg(31);
                        upg(23);
                        upg(10);
                        upg(38);
                        upg(4);
                        upg(25);
                    };
                    this.pb = function(upg) {
                        upg(5);
                        upg(17);
                        upg(32);
                        upg(23);
                        upg(9);
                        upg(38);
                    };
                    this.ph = function(upg) {
                        upg(5);
                        upg(17);
                        upg(32);
                        upg(23);
                        upg(10);
                        upg(38);
                        upg(28);
                        upg(25);
                    };
                    this.db = function(upg) {
                        upg(7);
                        upg(17);
                        upg(31);
                        upg(23);
                        upg(9);
                        upg(34);
                    };
                    /* old functions */
                    this.km = function(upg) {
                        upg(7);
                        upg(17);
                        upg(31);
                        upg(23);
                        upg(10);
                        upg(38);
                        upg(4);
                        upg(15);
                    };
                };
            };

            class Damages {
                constructor(items) {
                    // 0.75 1 1.125 1.5
                    this.calcDmg = function(dmg, val) {
                        return dmg * val;
                    };
                    this.getAllDamage = function(dmg) {
                        return [this.calcDmg(dmg, 0.75), dmg, this.calcDmg(dmg, 1.125), this.calcDmg(dmg, 1.5)];
                    };
                    this.weapons = [];
                    for (let i = 0; i < items.weapons.length; i++) {
                        let wp = items.weapons[i];
                        let name = wp.name.split(" ").length <= 1 ? wp.name : (wp.name.split(" ")[0] + "_" + wp.name.split(" ")[1]);
                        this.weapons.push(this.getAllDamage(i > 8 ? wp.Pdmg : wp.dmg));
                        this[name] = this.weapons[i];
                    }
                }
            }

            /** CLASS CODES */
            // jumpscare code warn
            let tmpList = [];

            // LOADING:
            let UTILS = new Utils();
            let items = new Items();
            let objectManager = new Objectmanager(GameObject, gameObjects, UTILS, config);
            let store = new Store();
            let hats = store.hats;
            let accessories = store.accessories;
            let projectileManager = new ProjectileManager(Projectile, projectiles, players, ais, objectManager, items, config, UTILS);
            let aiManager = new AiManager(ais, AI, players, items, null, config, UTILS);
            let textManager = new Textmanager();

            let traps = new Traps(UTILS, items);
            let instaC = new Instakill();
            let autoBuy = new Autobuy([15, 31, 6, 7, 22, 12, 53, 20, 40], [11, 13, 19, 18, 21]);
            let autoUpgrade = new Autoupgrade();

            let lastDeath;
            let minimapData;
            let mapMarker = {};
            let mapPings = [];
            let tmpPing;

            let breakTrackers = [];

            let pathFindTest = 0;
            let grid = [];
            let pathFind = {
                active: false,
                grid: 40,
                scale: 1440,
                x: 14400,
                y: 14400,
                chaseNear: false,
                array: [],
                lastX: this.grid / 2,
                lastY: this.grid / 2
            };

            function sendChat(message) {
                packet("6", message.slice(0, 30));
            }

            let runAtNextTick = [];
            function checkProjectileHolder(x, y, dir, range, speed, indx, layer, sid) {
                let weaponIndx = indx == 0 ? 9 : indx == 2 ? 12 : indx == 3 ? 13 : indx == 5 && 15;
                let projOffset = config.playerScale * 2;
                let projXY = {
                    x: indx == 1 ? x : x - projOffset * Math.cos(dir),
                    y: indx == 1 ? y : y - projOffset * Math.sin(dir),
                };
                let nearPlayer = players.filter((e) => e.visible && UTILS.getDist(projXY, e, 0, 2) <= e.scale).sort(function (a, b) {
                    return UTILS.getDist(projXY, a, 0, 2) - UTILS.getDist(projXY, b, 0, 2);
                })[0];
                if (nearPlayer) {
                    if (indx == 1) {
                        nearPlayer.shooting[53] = 1;
                    } else {
                        nearPlayer.shootIndex = weaponIndx;
                        nearPlayer.shooting[1] = 1;
                        antiProj(nearPlayer, dir, range, speed, indx, weaponIndx);
                    }
                }
            }
            let projectileCount = 0;

            function antiProj(tmpObj, dir, range, speed, index, weaponIndex) {
                if (!tmpObj.isTeam(player)) {
                    tmpDir = UTILS.getDirect(player, tmpObj, 2, 2);
                    if (UTILS.getAngleDist(tmpDir, dir) <= 0.2) {
                        tmpObj.bowThreat[weaponIndex]++;
                        if (index == 5) {
                            projectileCount++;
                        }
                        setTimeout(() => {
                            tmpObj.bowThreat[weaponIndex]--;
                            if (index == 5) {
                                projectileCount--;
                            }
                        }, range / speed);
                        if (tmpObj.bowThreat[9] >= 1 && (tmpObj.bowThreat[12] >= 1 || tmpObj.bowThreat[15] >= 1)) {
                            place(1, tmpObj.aim2);
                            my.anti0Tick = 4;
                            if (!my.antiSync) {
                                antiSyncHealing(4);
                            }
                        } else {
                            if (projectileCount >= 2) {
                                place(1, tmpObj.aim2);
                                my.anti0Tick = 4;
                                if (!my.antiSync) {
                                    antiSyncHealing(4);
                                }
                            }
                        }
                    }
                }
            }

            // SHOW ITEM INFO:
            function showItemInfo(item, isWeapon, isStoreItem) {
                if (player && item) {
                    UTILS.removeAllChildren(itemInfoHolder);
                    itemInfoHolder.classList.add("visible");
                    UTILS.generateElement({
                        id: "itemInfoName",
                        text: UTILS.capitalizeFirst(item.name),
                        parent: itemInfoHolder
                    });
                    UTILS.generateElement({
                        id: "itemInfoDesc",
                        text: item.desc,
                        parent: itemInfoHolder
                    });
                    if (isStoreItem) {

                    } else if (isWeapon) {
                        UTILS.generateElement({
                            class: "itemInfoReq",
                            text: !item.type?"primary":"secondary",
                            parent: itemInfoHolder
                        });
                    } else {
                        for (let i = 0; i < item.req.length; i += 2) {
                            UTILS.generateElement({
                                class: "itemInfoReq",
                                html: item.req[i] + "<span class='itemInfoReqVal'> x" + item.req[i + 1] + "</span>",
                                parent: itemInfoHolder
                            });
                        }
                        if (item.group.limit) {
                            UTILS.generateElement({
                                class: "itemInfoLmt",
                                text: (player.itemCounts[item.group.id] || 0) + "/" + (config.isSandbox ? 99 : item.group.limit),
                                parent: itemInfoHolder
                            });
                        }
                    }
                } else {
                    itemInfoHolder.classList.remove("visible");
                }
            }


            // RESIZE:
            window.addEventListener("resize", UTILS.checkTrusted(resize));

            function resize() {
                screenWidth = window.innerWidth;
                screenHeight = window.innerHeight;
                /*let scaleFillNative = Math.max(screenWidth / maxScreenWidth, screenHeight / maxScreenHeight) * pixelDensity;
                gameCanvas.width = screenWidth * pixelDensity;
                gameCanvas.height = screenHeight * pixelDensity;
                gameCanvas.style.width = screenWidth + "px";
                gameCanvas.style.height = screenHeight + "px";
                mainContext.setTransform(
                    scaleFillNative, 0,
                    0, scaleFillNative,
                    (screenWidth * pixelDensity - (maxScreenWidth * scaleFillNative)) / 2,
                    (screenHeight * pixelDensity - (maxScreenHeight * scaleFillNative)) / 2
                );*/
            }
            resize();
gameCanvas = document.getElementById("touch-controls-fullscreen");
            // MOUSE INPUT:
            gameCanvas.addEventListener("mousemove", gameInput, false);

            function gameInput(e) {
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
            let clicks = {
                left: false,
                middle: false,
                right: false,
            };
            gameCanvas.addEventListener("mousedown", mouseDown, false);

            function mouseDown(e) {
                if (attackState != 1) {
                    attackState = 1;
                    if (e.button == 0) {
                        clicks.left = true;
                    } else if (e.button == 1) {
                        clicks.middle = true;
                    } else if (e.button == 2) {
                        clicks.right = true;
                    }
                }
            }
            window.addEventListener("mouseup", UTILS.checkTrusted(mouseUp));

            function mouseUp(e) {
                if (attackState != 0) {
                    attackState = 0;
                    if (e.button == 0) {
                        clicks.left = false;
                    } else if (e.button == 1) {
                        clicks.middle = false;
                    } else if (e.button == 2) {
                        clicks.right = false;
                    }
                }
            }
            gameCanvas.addEventListener("wheel", wheel, false);

            function wheel(e) {
                if (e.deltaY < 0) {
                    my.reSync = true;
                } else {
                    my.reSync = false;
                }
            }
            // INPUT UTILS:
            function getMoveDir() {
                let dx = 0;
                let dy = 0;
                for (let key in moveKeys) {
                    let tmpDir = moveKeys[key];
                    dx += !!keys[key] * tmpDir[0];
                    dy += !!keys[key] * tmpDir[1];
                }
                return dx == 0 && dy == 0 ? undefined : Math.atan2(dy, dx);
            }

            function getSafeDir() {
                if (!player)
                    return 0;
                if (!player.lockDir) {
                    lastDir = Math.atan2(mouseY - (screenHeight / 2), mouseX - (screenWidth / 2));
                }
                return lastDir || 0;
            }

            function getAttackDir(debug) {
                if (debug) {
                    if (!player)
                        return "0";
                    if (my.autoAim || ((clicks.left || (useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap)) && player.reloads[player.weapons[0]] == 0))
                        lastDir = getEl("weaponGrind").checked ? "getSafeDir()" : enemy.length ? my.revAim ? "(near.aim2 + Math.PI)" : "near.aim2" : "getSafeDir()";
                    else
                    if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)
                        lastDir = "getSafeDir()";
                    else
                    if (traps.inTrap && player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0)
                        lastDir = "traps.aim";
                    else
                    if (!player.lockDir) {
                        if (configs.noDir) return "undefined";
                        lastDir = "getSafeDir()";
                    }
                    return lastDir;
                } else {
                    if (!player)
                        return 0;
                    if (my.autoAim || ((clicks.left || (useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap)) && player.reloads[player.weapons[0]] == 0))
                        lastDir = getEl("weaponGrind").checked ? getSafeDir() : enemy.length ? my.revAim ? (near.aim2 + Math.PI) : near.aim2 : getSafeDir();
                    else
                    if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)
                        lastDir = getSafeDir();
                    else
                    if (traps.inTrap && player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0)
                        lastDir = traps.aim;
                    else
                    if (!player.lockDir) {
                        if (configs.noDir) return undefined;
                        lastDir = getSafeDir();
                    }
                    return lastDir || 0;
                }
            }

            function getVisualDir() {
                if (!player)
                    return 0;
                if (my.autoAim || ((clicks.left || (useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap)) && player.reloads[player.weapons[0]] == 0))
                    lastDir = getEl("weaponGrind").checked ? getSafeDir() : enemy.length ? my.revAim ? (near.aim2 + Math.PI) : near.aim2 : getSafeDir();
                else
                if (clicks.right && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)
                    lastDir = getSafeDir();
                else
                if (traps.inTrap && player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0)
                    lastDir = traps.aim;
                else
                if (!player.lockDir) {
                    lastDir = getSafeDir();
                }
                return lastDir || 0;
            }

            // KEYS:
            function keysActive() {
                return (allianceMenu.style.display != "block" &&
                        chatHolder.style.display != "block" &&
                        !menuCBFocus);
            }

            function toggleMenuChat() {
                if (menuChatDiv.style.display != "none") {
                    chatHolder.style.display = "none";
                    if (menuChatBox.value != "") {
                        //commands[command.slice(1)]
                        let cmd = function(command) {
                            return {
                                found: command.startsWith("/") && commands[command.slice(1).split(" ")[0]],
                                fv: commands[command.slice(1).split(" ")[0]]
                            }
                        }
                        let command = cmd(menuChatBox.value);
                        if (command.found) {
                            if (typeof command.fv.action === "function") {
                                command.fv.action(menuChatBox.value);
                            }
                        } else {
                            sendChat(menuChatBox.value);
                        }
                        menuChatBox.value = "";
                        menuChatBox.blur();
                    } else {
                        if (menuCBFocus) {
                            menuChatBox.blur();
                        } else {
                            menuChatBox.focus();
                        }
                    }
                }
            }

            function keyDown(event) {
                let keyNum = event.which || event.keyCode || 0;
                if (player && player.alive && keysActive()) {
                    if (!keys[keyNum]) {
                        keys[keyNum] = 1;
                        macro[event.key] = 1;
                        if (keyNum == 27) {
                            openMenu = !openMenu;
                            $("#menuDiv").toggle();
                            $("#menuChatDiv").toggle();
                        } else if (keyNum == 69) {
                            sendAutoGather();
                        } else if (keyNum == 67) {
                            updateMapMarker();
                        } else if (player.weapons[keyNum - 49] != undefined) {
                            player.weaponCode = player.weapons[keyNum - 49];
                        } else if (moveKeys[keyNum]) {
                            sendMoveDir();
                        } else if (event.key == "m") {
                            mills.placeSpawnPads = !mills.placeSpawnPads;
                        } else if (event.key == "z") {
                            mills.place = !mills.place;
                        } else if (event.key == "Z") {
                            typeof window.debug == "function" && window.debug();
                        } else if (keyNum == 32) {
                            packet("d", 1, getSafeDir(), 1);
                            packet("d", 0, getSafeDir(), 1);
                        } else if (event.key == ",") {
                            player.sync = true;
                        }
                    }
                }
            }
            addEventListener("keydown", UTILS.checkTrusted(keyDown));

            function keyUp(event) {
                if (player && player.alive) {
                    let keyNum = event.which || event.keyCode || 0;
                    if (keyNum == 13) {
                        toggleMenuChat();
                    } else if (keysActive()) {
                        if (keys[keyNum]) {
                            keys[keyNum] = 0;
                            macro[event.key] = 0;
                            if (moveKeys[keyNum]) {
                                sendMoveDir();
                            } else if (event.key == ",") {
                                player.sync = false;
                            }
                        }
                    }
                }
            }
            window.addEventListener("keyup", UTILS.checkTrusted(keyUp));

            function sendMoveDir() {
                let newMoveDir = getMoveDir();
                if (lastMoveDir == undefined || newMoveDir == undefined || Math.abs(newMoveDir - lastMoveDir) > 0.3) {
                    if (!my.autoPush) {
                        packet("a", newMoveDir, 1);
                    }
                    lastMoveDir = newMoveDir;
                }
            }

            // BUTTON EVENTS:
            function bindEvents() {}
            bindEvents();

            /** PATHFIND TEST */
            function chechPathColl(tmp) {
                return ((player.scale + tmp.getScale()) / (player.maxSpeed * items.weapons[player.weaponIndex].spdMult)) + (tmp.dmg && !tmp.isTeamObject(player) ? 35 : 0);
                return tmp.colDiv == 0.5 ? (tmp.scale * tmp.colDiv) :
                    !tmp.isTeamObject(player) && tmp.dmg ? (tmp.scale + player.scale) :
                tmp.isTeamObject(player) && tmp.trap ? 0 : tmp.scale;
            }

            function checkObject() {
                let checkColl = gameObjects.filter(tmp => player.canSee(tmp) && tmp.active);
                for (let y = 0; y < pathFind.grid; y++) {
                    grid[y] = [];
                    for (let x = 0; x < pathFind.grid; x++) {
                        let tmpXY = {
                            x: (player.x2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * x),
                            y: (player.y2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * y)
                        }
                        if (UTILS.getDist(pathFind.chaseNear ? near : pathFind, tmpXY, pathFind.chaseNear ? 2 : 0, 0) <= (pathFind.chaseNear ? 35 : 60)) {
                            pathFind.lastX = x;
                            pathFind.lastY = y;
                            grid[y][x] = 0;
                            continue;
                        }
                        let find = checkColl.find(tmp => UTILS.getDist(tmp, tmpXY, 0, 0) <= chechPathColl(tmp));
                        if (find) {
                            if (find.trap) {
                                grid[y][x] = 0;
                                continue;
                            }
                            grid[y][x] = 1;
                        } else {
                            grid[y][x] = 0;
                        }
                    }
                }
            }

            function createPath() {
                grid = [];
                checkObject();
            }

            function Pathfinder() {
                pathFind.scale = (config.maxScreenWidth / 2) * 1.3;
                if (!traps.inTrap && (pathFind.chaseNear ? enemy.length : true)) {
                    if (near.dist2 <= items.weapons[player.weapons[0]].range) {
                        packet("a", undefined, 1);
                    } else {
                        createPath();
                        easystar.setGrid(grid);
                        easystar.setAcceptableTiles([0]);
                        easystar.enableDiagonals();
                        easystar.findPath((grid[0].length / 2), (grid.length / 2), pathFind.lastX, pathFind.lastY, function (path) {
                            if (path === null) {
                                pathFind.array = [];
                                if (near.dist2 <= items.weapons[player.weapons[0]].range) {
                                    packet("a", undefined, 1);
                                } else {
                                    packet("a", near.aim2, 1);
                                }
                            } else {
                                pathFind.array = path;
                                if (pathFind.array.length > 1) {
                                    let tmpXY = {
                                        x: (player.x2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * path[1].x),
                                        y: (player.y2 - (pathFind.scale / 2)) + ((pathFind.scale / pathFind.grid) * path[1].y)
                                    }
                                    packet("a", UTILS.getDirect(tmpXY, player, 0, 2), 1);
                                }
                            }
                        });
                        easystar.calculate();
                    }
                }
            }
            /** PATHFIND TEST */

            // ITEM COUNT DISPLAY:
            let isItemSetted = [];
            function updateItemCountDisplay(index = undefined) {
                for (let i = 3; i < items.list.length; ++i) {
                    let id = items.list[i].group.id;
                    let tmpI = items.weapons.length + i;
                    if (!isItemSetted[tmpI]) {
                        isItemSetted[tmpI] = document.createElement("div");
                        isItemSetted[tmpI].id = "itemCount" + tmpI;
                        getEl("actionBarItem" + tmpI).appendChild(isItemSetted[tmpI]);
                        isItemSetted[tmpI].style = `
                        display: block;
                        position: absolute;
                        padding-left: 5px;
                        font-size: 2em;
                        color: #fff;
                        `;
                        isItemSetted[tmpI].innerHTML = player.itemCounts[id] || 0;
                    } else {
                        if (index == id) isItemSetted[tmpI].innerHTML = player.itemCounts[index] || 0;
                    }
                }
            }

            // AUTOPUSH:
            function autoPush() {
                let nearTrap = gameObjects.filter(tmp => tmp.trap && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 2) <= (near.scale + tmp.getScale() + 5)).sort(function (a, b) {
                    return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                })[0];
                if (nearTrap) {
                    let spike = gameObjects.filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, nearTrap, 0, 0) <= (near.scale + nearTrap.scale + tmp.scale)).sort(function (a, b) {
                        return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                    })[0];
                    if (spike) {
                        let pos = {
                            x: spike.x + (250 * Math.cos(UTILS.getDirect(near, spike, 2, 0))),
                            y: spike.y + (250 * Math.sin(UTILS.getDirect(near, spike, 2, 0))),
                            x2: spike.x + ((UTILS.getDist(near, spike, 2, 0) + player.scale) * Math.cos(UTILS.getDirect(near, spike, 2, 0))),
                            y2: spike.y + ((UTILS.getDist(near, spike, 2, 0) + player.scale) * Math.sin(UTILS.getDirect(near, spike, 2, 0)))
                        };
                        let finds = gameObjects.filter(tmp => tmp.active).find((tmp) => {
                            let tmpScale = tmp.getScale();
                            if (!tmp.ignoreCollision && UTILS.lineInRect(tmp.x - tmpScale, tmp.y - tmpScale, tmp.x + tmpScale, tmp.y + tmpScale, player.x2, player.y2, pos.x2, pos.y2)) {
                                return true;
                            }
                        });
                        if (finds) {
                            if (my.autoPush) {
                                my.autoPush = false;
                                packet("a", lastMoveDir||undefined, 1);
                            }
                        } else {
                            my.autoPush = true;
                            my.pushData = {
                                x: spike.x,
                                y: spike.y,
                                x2: pos.x2,
                                y2: pos.y2
                            };
                            let scale = (player.scale / 10);
                            if (UTILS.lineInRect(player.x2 - scale, player.y2 - scale, player.x2 + scale, player.y2 + scale, near.x2, near.y2, pos.x, pos.y)) {
                                packet("a", near.aim2, 1);
                            } else {
                                packet("a", UTILS.getDirect(pos, player, 2, 2), 1);
                            }
                        }
                    } else {
                        if (my.autoPush) {
                            my.autoPush = false;
                            packet("a", lastMoveDir||undefined, 1);
                        }
                    }
                } else {
                    if (my.autoPush) {
                        my.autoPush = false;
                        packet("a", lastMoveDir||undefined, 1);
                    }
                }
            }

            // ADD DEAD PLAYER:
            function addDeadPlayer(tmpObj) {
                deadPlayers.push(new DeadPlayer(tmpObj.x, tmpObj.y, tmpObj.dir, tmpObj.buildIndex, tmpObj.weaponIndex, tmpObj.weaponVariant, tmpObj.skinColor, tmpObj.scale, tmpObj.name));
            }

            /** APPLY SOCKET CODES */

            // SET INIT DATA:
            function setInitData(data) {
                alliances = data.teams;
            }

            // SETUP GAME:
            function setupGame(yourSID) {
                keys = {};
                macro = {};
                playerSID = yourSID;
                attackState = 0;
                inGame = true;
                packet("d", 0, getAttackDir(), 1);
                my.ageInsta = true;
                if (firstSetup) {
                    firstSetup = false;
                    gameObjects.length = 0;
                }
            }

            // ADD NEW PLAYER:
            function addPlayer(data, isYou) {
                let tmpPlayer = findPlayerByID(data[0]);
                if (!tmpPlayer) {
                    tmpPlayer = new Player(data[0], data[1], config, UTILS, projectileManager,
                                           objectManager, players, ais, items, hats, accessories);
                    players.push(tmpPlayer);
                    if (data[1] != playerSID) {
                        addMenuChText("Game", `Encountered ${data[2]} {${data[1]}}.`, "lightblue");
                    }
                } else {
                    if (data[1] != playerSID) {
                        addMenuChText("Game", `Encountered ${data[2]} {${data[1]}} times.`, "lightblue");
                    }
                }
                tmpPlayer.spawn(isYou ? true : null);
                tmpPlayer.visible = false;
                tmpPlayer.oldPos = {
                    x2: undefined,
                    y2: undefined
                };
                tmpPlayer.x2 = undefined;
                tmpPlayer.y2 = undefined;
                tmpPlayer.x3 = undefined;
                tmpPlayer.y3 = undefined;
                tmpPlayer.setData(data);
                if (isYou) {
                    if (!player) {
                        window.prepareUI(tmpPlayer);
                    }
                    player = tmpPlayer;
                    camX = player.x;
                    camY = player.y;
                    my.lastDir = 0;
                    updateItems();
                    updateAge();
                    updateItemCountDisplay();
                    for (let i = 0; i < 5; i++) {
                        petals.push(new Petal(player.x, player.y));
                    }
                    if (player.skins[7]) {
                        my.reSync = true;
                    }
                }
            }

            // REMOVE PLAYER:
            function removePlayer(id) {
                for (let i = 0; i < players.length; i++) {
                    if (players[i].id == id) {
                        addMenuChText("Game", players[i].name + " left the game", "yellow");
                        players.splice(i, 1);
                        break;
                    }
                }
            }

            /* OLD UPDATE HEALTH:
            function updateHealth(sid, value) {
                tmpObj = findPlayerBySID(sid);
                if (tmpObj) {
                    tmpObj.oldHealth = tmpObj.health;
                    tmpObj.health = value;
                    tmpObj.judgeShame();
                    if (tmpObj.oldHealth > tmpObj.health) {
                        tmpObj.damaged = tmpObj.oldHealth - tmpObj.health;
                        advHeal.push([sid, value, tmpObj.damaged]);
                    } else {
                    }
                    if (tmpObj.health <= 0) {
                        bots.forEach((hmm) => {
                            hmm.whyDie = tmpObj.name;
                        });
                    }
                }
            }
            */
            // UPDATE HEALTH:
function updateHealth(sid, value) {
    tmpObj = findPlayerBySID(sid);
    if (tmpObj) {
        // tmpObj.lastshamecount = tmpObj.shameCount;
        tmpObj.oldHealth = tmpObj.health;
        tmpObj.health = value;
        tmpObj.judgeShame();
        if (tmpObj.oldHealth > tmpObj.health) {
            tmpObj.timeDamaged = Date.now(); //here'
            tmpObj.damaged = tmpObj.oldHealth - tmpObj.health;
            let damaged = tmpObj.damaged;
            tmpObj = findPlayerBySID(sid);

            let bullTicked = false;

            if (tmpObj.health <= 0) {
                if (!tmpObj.death) {
                    tmpObj.death = true;
                    if (tmpObj != player) {
                        if(tmpObj.skinIndex == 45) {
                            addMenuChText("Game", `${tmpObj.name}[${tmpObj.sid}] has died due to clown`, "red");
                        } else if(tmpObj.shameCount >= 5) {
                            addMenuChText("Game", `${tmpObj.name}[${tmpObj.sid}] has died due to high shame`, "red");
                        } else {
                            addMenuChText("Game", `${tmpObj.name}[${tmpObj.sid}] has died`, "red");
                        }
                    }
                    addDeadPlayer(tmpObj);
                }
            }
            if (tmpObj == player) {
                if (tmpObj.skinIndex == 7 && (damaged == 5 || (tmpObj.latestTail == 13 && damaged == 2))) {
                    if (my.reSync) {
                        my.reSync = false;
                        tmpObj.setBullTick = true;
                    }
                    bullTicked = true;
                }
                if (inGame) {
                    let attackers = getAttacker(damaged);
                    let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg * soldierMult());
                    let includeSpikeDmgs = !bullTicked && gearDmgs.includes(damaged);
                    let healTimeout = (1000/9);
                    let slowHeal = function(timer) {
                        setTimeout(() => {
                            healer();
                        }, timer);
                    }
                    let total = 0;
                    if (damaged >= 10 && player.damageThreat >= 100) { //&& (game.tick - player.antiTimer) > 1) {
                        player.canEmpAnti = true;
                        player.antiTimer = game.tick;
                        let shame = Math.floor(Math.random() * (6 - 4) + 3);
                        if (tmpObj.shameCount < shame) {
                            healer();
                        } else {
                            if(tmpObj.shameCount <= 7)
                                slowHeal(healTimeout);
                        }
                    } else {
                        if(tmpObj.shameCount <= 7)
                            slowHeal(healTimeout);
                    }
                    // if (damaged >= 20 && (player.skinIndex == 11 || near.skinIndex == 53)) instaC.canCounter = true;
                }
                // if (damaged >= 20 && player.skinIndex == 11) instaC.canCounter = true;
            } else {
                if (!tmpObj.setPoisonTick && (tmpObj.damaged == 5 || (tmpObj.latestTail == 13 && tmpObj.damaged == 2))) {
                    tmpObj.setPoisonTick = true;
                }
            }
        } else {
            tmpObj.timeHealed = Date.now(); //
            // game.tickBase(() => {
            // }, 2)
        }
        if (tmpObj.health <= 0) {
            bots.forEach((hmm) => {
                hmm.whyDie = tmpObj.name;
            });
        }
    }
}

            // KILL PLAYER:
            function killPlayer() {
                petals = [];
                inGame = false;
                lastDeath = {
                    x: player.x,
                    y: player.y,
                };
                /*menuCardHolder.style.display = "block";
                mainMenu.style.display = "block";
                diedText.style.display = "none";*/
                if (configs.autoRespawn) {
                    getEl("ot-sdk-btn-floating").style.display = "none";
                    packet("M", {
                        name: lastsp[0],
                        moofoll: lastsp[1],
                        skin: lastsp[2]
                    });
                }
            }

            // UPDATE PLAYER ITEM VALUES:
            function updateItemCounts(index, value) {
                if (player) {
                    player.itemCounts[index] = value;
                    updateItemCountDisplay(index);
                }
            }

            // UPDATE AGE:
            function updateAge(xp, mxp, age) {
                if (xp != undefined)
                    player.XP = xp;
                if (mxp != undefined)
                    player.maxXP = mxp;
                if (age != undefined)
                    player.age = age;
            }

            // UPDATE UPGRADES:
            function updateUpgrades(points, age) {
                player.upgradePoints = points;
                player.upgrAge = age;
                if (points > 0) {
                    tmpList.length = 0;
                    UTILS.removeAllChildren(upgradeHolder);
                    for (let i = 0; i < items.weapons.length; ++i) {
                        if (items.weapons[i].age == age && (testMode || items.weapons[i].pre == undefined || player.weapons.indexOf(items.weapons[i].pre) >= 0)) {
                            let e = UTILS.generateElement({
                                id: "upgradeItem" + i,
                                class: "actionBarItem",
                                onmouseout: function () {
                                    showItemInfo();
                                },
                                parent: upgradeHolder
                            });
                            e.style.backgroundImage = getEl("actionBarItem" + i).style.backgroundImage;
                            tmpList.push(i);
                        }
                    }
                    for (let i = 0; i < items.list.length; ++i) {
                        if (items.list[i].age == age && (testMode || items.list[i].pre == undefined || player.items.indexOf(items.list[i].pre) >= 0)) {
                            let tmpI = (items.weapons.length + i);
                            let e = UTILS.generateElement({
                                id: "upgradeItem" + tmpI,
                                class: "actionBarItem",
                                onmouseout: function () {
                                    showItemInfo();
                                },
                                parent: upgradeHolder
                            });
                            e.style.backgroundImage = getEl("actionBarItem" + tmpI).style.backgroundImage;
                            tmpList.push(tmpI);
                        }
                    }
                    for (let i = 0; i < tmpList.length; i++) {
                        (function (i) {
                            let tmpItem = getEl('upgradeItem' + i);
                            tmpItem.onmouseover = function () {
                                if (items.weapons[i]) {
                                    showItemInfo(items.weapons[i], true);
                                } else {
                                    showItemInfo(items.list[i - items.weapons.length]);
                                }
                            };
                            tmpItem.onclick = UTILS.checkTrusted(function () {
                                packet("H", i);
                            });
                            UTILS.hookTouchEvents(tmpItem);
                        })(tmpList[i]);
                    }
                    if (tmpList.length) {
                        upgradeHolder.style.display = "block";
                        upgradeCounter.style.display = "block";
                        upgradeCounter.innerHTML = "SELECT ITEMS (" + points + ")";
                    } else {
                        upgradeHolder.style.display = "none";
                        upgradeCounter.style.display = "none";
                        showItemInfo();
                    }
                } else {
                    upgradeHolder.style.display = "none";
                    upgradeCounter.style.display = "none";
                    showItemInfo();
                }
            }

            // KILL OBJECT:
            function killObject(sid) {
                let findObj = findObjectBySid(sid);
                objectManager.disableBySid(sid);
                if (player) {
                    for (let i = 0; i < breakObjects.length; i++) {
                        if (breakObjects[i].sid == sid) {
                            breakObjects.splice(i, 1);
                            break;
                        }
                    }
                    if (!player.canSee(findObj)) {
                        breakTrackers.push({x: findObj.x, y: findObj.y});
                    }
                    if (breakTrackers.length > 8) {
                        breakTrackers.shift();
                    }
                    traps.replacer(findObj);
                }
            }

            // KILL ALL OBJECTS BY A PLAYER:
            function killObjects(sid) {
                if (player) objectManager.removeAllItems(sid);
            }

            // UPDATE PLAYER DATA:
            function updatePlayers(data) {
                game.tick++;
                enemy = [];
                nears = [];
                near = [];
                game.tickSpeed = performance.now() - game.lastTick;
                game.lastTick = performance.now();
                players.forEach((tmp) => {
                    tmp.forcePos = !tmp.visible;
                    tmp.visible = false;
                });
                for (let i = 0; i < data.length;) {
                    tmpObj = findPlayerBySID(data[i]);
                    if (tmpObj) {
                        tmpObj.t1 = (tmpObj.t2 === undefined) ? game.lastTick : tmpObj.t2;
                        tmpObj.t2 = game.lastTick;
                        tmpObj.oldPos.x2 = tmpObj.x2;
                        tmpObj.oldPos.y2 = tmpObj.y2;
                        tmpObj.x1 = tmpObj.x;
                        tmpObj.y1 = tmpObj.y;
                        tmpObj.x2 = data[i + 1];
                        tmpObj.y2 = data[i + 2];
                        tmpObj.x3 = tmpObj.x2 + (tmpObj.x2 - tmpObj.oldPos.x2);
                        tmpObj.y3 = tmpObj.y2 + (tmpObj.y2 - tmpObj.oldPos.y2);
                        tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 3] : tmpObj.d2;
                        tmpObj.d2 = data[i + 3];
                        tmpObj.dt = 0;
                        tmpObj.buildIndex = data[i + 4];
                        tmpObj.weaponIndex = data[i + 5];
                        tmpObj.weaponVariant = data[i + 6];
                        tmpObj.team = data[i + 7];
                        tmpObj.isLeader = data[i + 8];
                        tmpObj.oldSkinIndex = tmpObj.skinIndex;
                        tmpObj.oldTailIndex = tmpObj.tailIndex;
                        tmpObj.skinIndex = data[i + 9];
                        tmpObj.tailIndex = data[i + 10];
                        tmpObj.iconIndex = data[i + 11];
                        tmpObj.zIndex = data[i + 12];
                        tmpObj.visible = true;
                        tmpObj.update(game.tickSpeed);
                        tmpObj.dist2 = UTILS.getDist(tmpObj, player, 2, 2);
                        tmpObj.aim2 = UTILS.getDirect(tmpObj, player, 2, 2);
                        tmpObj.dist3 = UTILS.getDist(tmpObj, player, 3, 3);
                        tmpObj.aim3 = UTILS.getDirect(tmpObj, player, 3, 3);
                        tmpObj.damageThreat = 0;
                        if (tmpObj.skinIndex == 45 && tmpObj.shameTimer <= 0) {
                            tmpObj.addShameTimer();
                        }
                        if (tmpObj.oldSkinIndex == 45 && tmpObj.skinIndex != 45) {
                            tmpObj.shameTimer = 0;
                            tmpObj.shameCount = 0;
                            if (tmpObj == player) {
                                healer();
                            }
                        }
                        if (tmpObj == player) {
                            if (gameObjects.length) {
                                gameObjects.forEach((tmp) => {
                                    tmp.onNear = false;
                                    if (tmp.active) {
                                        if (!tmp.onNear && UTILS.getDist(tmp, tmpObj, 0, 2) <= tmp.scale + items.weapons[tmpObj.weapons[0]].range) {
                                            tmp.onNear = true;
                                        }
                                        if (tmp.isItem && tmp.owner) {
                                            if (!tmp.pps && tmpObj.sid == tmp.owner.sid && UTILS.getDist(tmp, tmpObj, 0, 2) > (parseInt(getEl("breakRange").value)||0) && !tmp.breakObj && ![13, 14, 20].includes(tmp.id)) {
                                                tmp.breakObj = true;
                                                breakObjects.push({
                                                    x: tmp.x,
                                                    y: tmp.y,
                                                    sid: tmp.sid
                                                });
                                            }
                                        }
                                    }
                                });
                                let nearTrap = gameObjects.filter(e => e.trap && e.active && UTILS.getDist(e, tmpObj, 0, 2) <= (tmpObj.scale + e.getScale() + 5) && !e.isTeamObject(tmpObj)).sort(function (a, b) {
                                    return UTILS.getDist(a, tmpObj, 0, 2) - UTILS.getDist(b, tmpObj, 0, 2);
                                })[0];
                                if (nearTrap) {
                                    traps.dist = UTILS.getDist(nearTrap, tmpObj, 0, 2);
                                    traps.aim = UTILS.getDirect(nearTrap, tmpObj, 0, 2);
                                    if (!traps.inTrap) {
                                        traps.protect(traps.aim);
                                    }
                                    traps.inTrap = true;
                                    traps.info = nearTrap;
                                } else {
                                    traps.inTrap = false;
                                    traps.info = {};
                                }
                            } else {
                                traps.inTrap = false;
                            }
                        }
                        if (tmpObj.weaponIndex < 9) {
                            tmpObj.primaryIndex = tmpObj.weaponIndex;
                            tmpObj.primaryVariant = tmpObj.weaponVariant;
                        } else if (tmpObj.weaponIndex > 8) {
                            tmpObj.secondaryIndex = tmpObj.weaponIndex;
                            tmpObj.secondaryVariant = tmpObj.weaponVariant;
                        }
                    }
                    i += 13;
                }
                if (textManager.stack.length) {
                    let stacks = [];
                    let notstacks = [];
                    let num = 0;
                    let num2 = 0;
                    let pos = {
                        x: null,
                        y: null
                    };
                    let pos2 = {
                        x: null,
                        y: null
                    }
                    textManager.stack.forEach((text) => {
                        if (text.value >= 0) {
                            if (num == 0) pos = {
                                x: text.x,
                                y: text.y
                            };
                            num += Math.abs(text.value);
                        } else {
                            if (num2 == 0) pos2 = {
                                x: text.x,
                                y: text.y
                            };
                            num2 += Math.abs(text.value);
                        }
                    });
                    if (num2 > 0) {
                        textManager.showText(pos2.x, pos2.y, Math.max(45, Math.min(50, num2)), 0.18, 500, num2, "#8ecc51");
                    }
                    if (num > 0) {
                        textManager.showText(pos.x, pos.y, Math.max(45, Math.min(50, num)), 0.18, 500, num, "#fff");
                    }
                    textManager.stack = [];
                }
                if (runAtNextTick.length) {
                    runAtNextTick.forEach((tmp) => {
                        checkProjectileHolder(...tmp);
                    });
                    runAtNextTick = [];
                }
                for (let i = 0; i < data.length;) {
                    tmpObj = findPlayerBySID(data[i]);
                    if (tmpObj) {
                        if (!tmpObj.isTeam(player)) {
                            enemy.push(tmpObj);
                            if (tmpObj.dist2 <= items.weapons[tmpObj.primaryIndex == undefined ? 5 : tmpObj.primaryIndex].range + (player.scale * 2)) {
                                nears.push(tmpObj);
                            }
                        }
                        tmpObj.manageReload();
                        if (tmpObj != player) {
                            tmpObj.addDamageThreat(player);
                        }
                    }
                    i += 13;
                }
                /*projectiles.forEach((proj) => {
                    tmpObj = proj;
                    if (tmpObj.active) {
                        tmpObj.tickUpdate(game.tickSpeed);
                    }
                });*/
                if (player && player.alive) {
                    if (enemy.length) {
                        near = enemy.sort(function (tmp1, tmp2) {
                            return tmp1.dist2 - tmp2.dist2;
                        })[0];
                    } else {
                        // console.log("no enemy");
                    }
                    if (game.tickQueue[game.tick]) {
                        game.tickQueue[game.tick].forEach((action) => {
                            action();
                        });
                        game.tickQueue[game.tick] = null;
                    }
                    if (advHeal.length) {
                        advHeal.forEach((updHealth) => {
                            let sid = updHealth[0];
                            let value = updHealth[1];
                            let damaged = updHealth[2];
                            tmpObj = findPlayerBySID(sid);

                            let bullTicked = false;

                            if (tmpObj.health <= 0) {
                                if (!tmpObj.death) {
                                    tmpObj.death = true;
                                    if (tmpObj != player) {
                                        addMenuChText("", `${tmpObj.name} {${tmpObj.sid}} has died.`, "red");
                                    }
                                    addDeadPlayer(tmpObj);
                                }
                            }
                            if (tmpObj == player) {
                                if (tmpObj.skinIndex == 7 && (damaged == 5 || (tmpObj.latestTail == 13 && damaged == 2))) {
                                    if (my.reSync) {
                                        my.reSync = false;
                                        tmpObj.setBullTick = true;
                                    }
                                    bullTicked = true;
                                }
                                if (inGame) {
                                    let attackers = getAttacker(damaged);
                                    let gearDmgs = [0.25, 0.45].map((val) => val * items.weapons[player.weapons[0]].dmg * soldierMult());
                                    let includeSpikeDmgs = !bullTicked && gearDmgs.includes(damaged);
                                    let healTimeout = 1000/9;
                                    let slowHeal = function(timer) {
                                        setTimeout(() => {
                                            healer();
                                        }, timer);
                                    }
                                    if (getEl("healingBeta").checked) {
                                        if (attackers.length) {
                                            let by = attackers.filter((tmp) => {
                                                if (tmp.dist2 <= (tmp.weaponIndex < 9 ? 300 : 700)) {
                                                    tmpDir = UTILS.getDirect(player, tmp, 2, 2);
                                                    if (UTILS.getAngleDist(tmpDir, tmp.d2) <= Math.PI) {
                                                        return tmp;
                                                    }
                                                }
                                            });
                                            if (by.length) {
                                                let maxDamage = (includeSpikeDmgs ? 10 : 10);
                                                if (damaged > maxDamage && (game.tick - tmpObj.antiTimer) > 1) {
                                                    tmpObj.canEmpAnti = true;
                                                    tmpObj.antiTimer = game.tick;
                                                    let shame = 5;
                                                    if (tmpObj.shameCount < shame) {
                                                        healer();
                                                    } else {
                                                        slowHeal(healTimeout);
                                                    }
                                                } else {
                                                    slowHeal(healTimeout);
                                                }
                                            } else {
                                                slowHeal(healTimeout);
                                            }
                                        } else {
                                            slowHeal(healTimeout);
                                        }
                                    } else {
                                        if (damaged >= (includeSpikeDmgs ? 8 : 20) && tmpObj.damageThreat >= 25 && (game.tick - tmpObj.antiTimer) > 1) {
                                            tmpObj.canEmpAnti = true;
                                            tmpObj.antiTimer = game.tick;
                                            let shame = 5;
                                            if (tmpObj.shameCount < shame) {
                                                healer();
                                            } else {
                                                slowHeal(healTimeout);
                                            }
                                        } else {
                                            slowHeal(healTimeout);
                                        }
                                    }
                                    if (damaged >= 20 && player.skinIndex == 11) instaC.canCounter = true;
                                }
                            } else {
                                if (!tmpObj.setPoisonTick && (tmpObj.damaged == 5 || (tmpObj.latestTail == 13 && tmpObj.damaged == 2))) {
                                    tmpObj.setPoisonTick = true;
                                }
                            }
                        });
                        advHeal = [];
                    }
                    players.forEach((tmp) => {
                        if (!tmp.visible && player != tmp) {
                            tmp.reloads = {
                                0: 0,
                                1: 0,
                                2: 0,
                                3: 0,
                                4: 0,
                                5: 0,
                                6: 0,
                                7: 0,
                                8: 0,
                                9: 0,
                                10: 0,
                                11: 0,
                                12: 0,
                                13: 0,
                                14: 0,
                                15: 0,
                                53: 0,
                            };
                        }
                        if (tmp.setBullTick) {
                            tmp.bullTimer = 0;
                        }
                        if (tmp.setPoisonTick) {
                            tmp.poisonTimer = 0;
                        }
                        tmp.updateTimer();
                    });
                    if (inGame) {
                        if (enemy.length) {
                            if (player.canEmpAnti) {
                                player.canEmpAnti = false;
                                if (near.dist2 <= 300 && !my.safePrimary(near) && !my.safeSecondary(near)) {
                                    if (near.reloads[53] == 0){
                                        player.empAnti = true;
                                        player.soldierAnti = false;
                                        //modLog("EmpAnti");
                                    } else {
                                        player.empAnti = false;
                                        player.soldierAnti = true;
                                        //modLog("SoldierAnti");
                                    }
                                }
                            }
                            let prehit = gameObjects.filter(tmp => tmp.dmg && tmp.active && tmp.isTeamObject(player) && UTILS.getDist(tmp, near, 0, 3) <= (tmp.scale + near.scale)).sort(function (a, b) {
                                return UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2);
                            })[0];
                            if (prehit) {
                                if (near.dist2 <= items.weapons[player.weapons[0]].range + player.scale * 1.8 && configs.predictTick) {
                                    instaC.canSpikeTick = true;
                                    instaC.syncHit = true;
                                    if (configs.revTick && player.weapons[1] == 15 && player.reloads[53] == 0 && instaC.perfCheck(player, near)) {
                                        instaC.revTick = true;
                                    }
                                }
                            }
                            let antiSpikeTick = gameObjects.filter(tmp => tmp.dmg && tmp.active && !tmp.isTeamObject(player) && UTILS.getDist(tmp, player, 0, 3) < (tmp.scale + player.scale)).sort(function (a, b) {
                                return UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2);
                            })[0];
                            if (antiSpikeTick && !traps.inTrap) {
                                if (near.dist2 <= items.weapons[5].range + near.scale * 1.8) {
                                    my.anti0Tick = 1;
                                    player.chat.count = 2000;
                                }
                            }
                        }
                        if ((useWasd ? true : ((player.checkCanInsta(true) >= 100 ? player.checkCanInsta(true) : player.checkCanInsta(false)) >= (player.weapons[1] == 10 ? 95 : 100))) && near.dist2 <= items.weapons[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]].range + near.scale * 1.8 && (instaC.wait || (useWasd && Math.floor(Math.random() * 5) == 0)) && !instaC.isTrue && !my.waitHit && player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0 && (useWasd ? true : getEl("instaType").value == "oneShot" ? (player.reloads[53] <= (player.weapons[1] == 10 ? 0 : game.tickRate)) : true) && instaC.perfCheck(player, near)) {
                            if (player.checkCanInsta(true) >= 100) {
                                instaC.nobull = false;
                            } else {
                                instaC.nobull = false;
                            }
                            instaC.can = true;
                        } else {
                            instaC.can = false;
                        }
                        macro.q && place(0, getAttackDir());
                        macro.f && place(4, getSafeDir());
                        macro.v && place(2, getSafeDir());
                        macro.y && place(5, getSafeDir());
                        macro.h && place(player.getItemType(22), getSafeDir());
                        macro.n && place(3, getSafeDir());
                        if (game.tick % 2 == 0) {
                            if (mills.place) {
                                let plcAng = 1.25;
                                for (let i = -plcAng; i <= plcAng; i += plcAng) {
                                    checkPlace(3, UTILS.getDirect(player.oldPos, player, 2, 2) + i);
                                }
                            } else {
                                if (mills.placeSpawnPads) {
                                    for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                        checkPlace(player.getItemType(20), UTILS.getDirect(player.oldPos, player, 2, 2) + i);
                                    }
                                }
                            }
                        }
                        if (instaC.can) {
                            instaC.changeType(player.weapons[1] == 10 ? "rev" : "normal");
                        }
                        if (instaC.canCounter) {
                            instaC.canCounter = false;
                            if (player.reloads[player.weapons[0]] == 0 && !instaC.isTrue) {
                                instaC.counterType();
                            }
                        }
                        if (instaC.canSpikeTick) {
                            instaC.canSpikeTick = false;
                            if (instaC.revTick) {
                                instaC.revTick = false;
                                if ([1, 2, 3, 4, 5, 6].includes(player.weapons[0]) && player.reloads[player.weapons[1]] == 0 && !instaC.isTrue) {
                                    instaC.changeType("rev");
                                    addMenuChText("[Game]", "Rev SyncHit", "green");
                                }
                            } else {
                                if ([1, 2, 3, 4, 5, 6].includes(player.weapons[0]) && player.reloads[player.weapons[0]] == 0 && !instaC.isTrue) {
                                    instaC.spikeTickType();
                                    if (instaC.syncHit) {
                                        addMenuChText("[Game]", "SyncHit", "green");
                                    }
                                }
                            }
                        }
                        if (!clicks.middle && (clicks.left || clicks.right) && !instaC.isTrue) {
                            if ((player.weaponIndex != (clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0])) || player.buildIndex > -1) {
                                selectWeapon(clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]);
                            }
                            if (player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 && !my.waitHit) {
                                sendAutoGather();
                                my.waitHit = 1;
                                game.tickBase(() => {
                                    sendAutoGather();
                                    my.waitHit = 0;
                                }, 1);
                            }
                        }
                        if (useWasd && !clicks.left && !clicks.right && !instaC.isTrue && near.dist2 <= (items.weapons[player.weapons[0]].range + near.scale * 1.8) && !traps.inTrap) {
                            if ((player.weaponIndex != player.weapons[0]) || player.buildIndex > -1) {
                                selectWeapon(player.weapons[0]);
                            }
                            if (player.reloads[player.weapons[0]] == 0 && !my.waitHit) {
                                sendAutoGather();
                                my.waitHit = 1;
                                game.tickBase(() => {
                                    sendAutoGather();
                                    my.waitHit = 0;
                                }, 1);
                            }
                        }
                        if (traps.inTrap) {
                            if (!clicks.left && !clicks.right && !instaC.isTrue) {
                                if (player.weaponIndex != (traps.notFast() ? player.weapons[1] : player.weapons[0]) || player.buildIndex > -1) {
                                    selectWeapon(traps.notFast() ? player.weapons[1] : player.weapons[0]);
                                }
                                if (player.reloads[traps.notFast() ? player.weapons[1] : player.weapons[0]] == 0 && !my.waitHit) {
                                    sendAutoGather();
                                    my.waitHit = 1;
                                    game.tickBase(() => {
                                        sendAutoGather();
                                        my.waitHit = 0;
                                    }, 1);
                                }
                            }
                        }
                        if (clicks.middle && !traps.inTrap) {
                            if (!instaC.isTrue && player.reloads[player.weapons[1]] == 0) {
                                if (my.ageInsta && player.weapons[0] != 4 && player.weapons[1] == 9 && player.age >= 9 && enemy.length) {
                                    instaC.bowMovement();
                                } else {
                                    instaC.rangeType();
                                }
                            }
                        }
                        if (macro.t && !traps.inTrap) {
                            if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0 && (player.weapons[1] == 15 ? (player.reloads[player.weapons[1]] == 0) : true) && (player.weapons[0] == 5 || (player.weapons[0] == 4 && player.weapons[1] == 15))) {
                                instaC[(player.weapons[0] == 4 && player.weapons[1] == 15) ? "kmTickMovement" : "tickMovement"]();
                            }
                        }
                        if (macro["."] && !traps.inTrap) {
                            if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0 && ([9, 12, 13, 15].includes(player.weapons[1]) ? (player.reloads[player.weapons[1]] == 0) : true)) {
                                instaC.boostTickMovement();
                            }
                        }
                        if (player.weapons[1] && !clicks.left && !clicks.right && !traps.inTrap && !instaC.isTrue && !(useWasd && near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8)) {
                            if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0) {
                                if (!my.reloaded) {
                                    my.reloaded = true;
                                    let fastSpeed = items.weapons[player.weapons[0]].spdMult < items.weapons[player.weapons[1]].spdMult ? 1 : 0;
                                    if (player.weaponIndex != player.weapons[fastSpeed] || player.buildIndex > -1) {
                                        selectWeapon(player.weapons[fastSpeed]);
                                    }
                                }
                            } else {
                                my.reloaded = false;
                                if (player.reloads[player.weapons[0]] > 0) {
                                    if (player.weaponIndex != player.weapons[0] || player.buildIndex > -1) {
                                        selectWeapon(player.weapons[0]);
                                    }
                                } else if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] > 0) {
                                    if (player.weaponIndex != player.weapons[1] || player.buildIndex > -1) {
                                        selectWeapon(player.weapons[1]);
                                    }
                                }
                            }
                        }
                        if (!instaC.isTrue && !traps.inTrap && !traps.replaced) {
                            traps.autoPlace();
                        }
                        if (!macro.q && !macro.f && !macro.v && !macro.h && !macro.n) {
                            packet("D", getAttackDir());
                        }
                        let hatChanger = function () {
                            if (my.anti0Tick > 0) {
                                buyEquip(6, 0);
                            } else {
                                if (clicks.left || clicks.right) {
                                        if (clicks.left) {
                                            buyEquip(player.reloads[player.weapons[0]] == 0 ? getEl("weaponGrind").checked ? 40 : 7 : player.empAnti ? 6 : player.soldierAnti ? 6 : (getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : near.dist2 <= 300 ? (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6 : biomeGear(1, 1), 0);
                                        } else if (clicks.right) {
                                            buyEquip(player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 ? 40 : player.empAnti ? 6 : player.soldierAnti ? 6 : (getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : near.dist2 <= 300 ? (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6 : biomeGear(1, 1), 0);
                                        }
                                } else if (traps.inTrap) {
                                    if (traps.info.health <= items.weapons[player.weaponIndex].dmg ? false : (player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                                        buyEquip(40, 0);
                                    } else {
                                            buyEquip((player.empAnti || near.dist2 > 300 || !enemy.length) ? 6 : 6, 0);
                                    }
                                } else {
                                    if (player.empAnti || player.soldierAnti) {
                                        buyEquip(player.empAnti ? 6 : 6, 0);
                                    } else {
                                            if (near.dist2 <= 300) {
                                                buyEquip((getEl("antiBullType").value == "abreload" && near.antiBull > 0) ? 11 : (getEl("antiBullType").value == "abalway" && near.reloads[near.primaryIndex] == 0) ? 11 : 6, 0);
                                            } else {
                                                biomeGear(1);
                                            }
                                    }
                                }
                            }
                        }
                        let accChanger = function () {
                            if (clicks.left || clicks.right) {
                                buyEquip(21, 1);
                                } else if (traps.inTrap) {
                                buyEquip(clicks.right ? 11 : player.reloads[player.weapons[0]] == 0 ? 21 : 11, 1);
                            } else if (traps.inTrap) {
                                buyEquip(near.dist3 <= (items.weapons[player.weaponIndex].range + (player.scale * 1.8)) && player.reloads[player.weaponIndex] == 0 ? 21 : 11, 1);
                            } else {
                                            if (near.dist2 <= 300) {
                                                buyEquip(19, 1);
                                            } else {
                                                buyEquip(11, 1);
                                            }
                            }
                        }
                        let wasdGears = function() {
                            if (my.anti0Tick > 0) {
                                buyEquip(6, 0);
                            } else {
                                if (clicks.left || clicks.right) {
                                    if ((player.shameCount > 0 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) {
                                        buyEquip(7, 0);
                                    } else {
                                        if (clicks.left) {
                                            buyEquip(player.reloads[player.weapons[0]] == 0 ? getEl("weaponGrind").checked ? 40 : 7 : player.empAnti ? 6 : 6, 0);
                                        } else if (clicks.right) {
                                            buyEquip(player.reloads[clicks.right && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 ? 40 : player.empAnti ? 6 : 6, 0);
                                        }
                                    }
                                } else if (near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap) {
                                    if ((player.shameCount > 0 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) {
                                        buyEquip(7, 0);
                                    } else {
                                        buyEquip(player.reloads[player.weapons[0]] == 0 ? 7 : player.empAnti ? 6 : 6, 0);
                                    }
                                } else if (traps.inTrap) {
                                    if (traps.info.health <= items.weapons[player.weaponIndex].dmg ? false : (player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                                        buyEquip(40, 0);
                                    } else {
                                        if ((player.shameCount > 0 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) {
                                            buyEquip(7, 0);
                                        } else {
                                            buyEquip(player.empAnti ? 6 : 6, 0);
                                        }
                                    }
                                } else {
                                    if (player.empAnti) {
                                        buyEquip(6, 0);
                                    } else {
                                        if ((player.shameCount > 0 && (game.tick - player.bullTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || my.reSync) {
                                            buyEquip(7, 0);
                                        } else {
                                            buyEquip(6, 0);
                                        }
                                    }
                                }
                            }
                            if (clicks.left || clicks.right) {
                                if (clicks.left) {
                                    buyEquip(21, 1);
                                } else if (clicks.right) {
                                    buyEquip(21, 1);
                                }
                            } else if (near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8 && !traps.inTrap) {
                                buyEquip(0, 1);
                            } else if (traps.inTrap) {
                                buyEquip(0, 1);
                            } else {
                                buyEquip(11, 1);
                            }
                        }
                        if (storeMenu.style.display != "block" && !instaC.isTrue && !instaC.ticking) {
                            if (useWasd) {
                                wasdGears();
                            } else {
                                hatChanger();
                                accChanger();
                            }
                        }
                        //lastMoveDir = getSafeDir();
                        //packet("33", lastMoveDir, 1);
                        if (configs.autoPush && enemy.length && !traps.inTrap && !instaC.ticking) {
                            autoPush();
                        } else {
                            if (my.autoPush) {
                                my.autoPush = false;
                                packet("a", lastMoveDir||undefined, 1);
                            }
                        }
                        if (!my.autoPush && pathFind.active) {
                            Pathfinder();
                        }
                        if (instaC.ticking) {
                            instaC.ticking = false;
                        }
                        if (instaC.syncHit) {
                            instaC.syncHit = false;
                        }
                        if (player.empAnti) {
                            player.empAnti = false;
                        }
                        if (player.soldierAnti) {
                            player.soldierAnti = false;
                        }
                        if (my.anti0Tick > 0) {
                            my.anti0Tick--;
                        }
                        if (traps.replaced) {
                            traps.replaced = false;
                        }
                        if (traps.antiTrapped) {
                            traps.antiTrapped = false;
                        }
                    }
                }
                if (botSkts.length) {
                    botSkts.forEach((bots) => {
                        if (true) {
                            bots[0].ssend("player", player, near, botIDS);
                        }
                    });
                }
            }

            // UPDATE LEADERBOARD:
            function updateLeaderboard(data) {
                lastLeaderboardData = data;
                return;
                UTILS.removeAllChildren(leaderboardData);
                let tmpC = 1;
                for (let i = 0; i < data.length; i += 3) {
                    (function(i) {
                        UTILS.generateElement({
                            class: "leaderHolder",
                            parent: leaderboardData,
                            children: [
                                UTILS.generateElement({
                                    class: "leaderboardItem",
                                    style: "color:" + ((data[i] == playerSID) ? "#fff" : "rgba(255,255,255,0.6)"),
                                    text: tmpC + ". " + (data[i+1] != "" ? data[i+1] : "unknown")
                                }),
                                UTILS.generateElement({
                                    class: "leaderScore",
                                    text: UTILS.sFormat(data[i+2]) || "0"
                                })
                            ]
                        });
                    })(i);
                    tmpC++;
                }
            }

            // LOAD GAME OBJECT:
            function loadGameObject(data) {
                for (let i = 0; i < data.length;) {
                    objectManager.add(data[i], data[i + 1], data[i + 2], data[i + 3], data[i + 4],
                                      data[i + 5], items.list[data[i + 6]], true, (data[i + 7] >= 0 ? {
                        sid: data[i + 7]
                    } : null));
                    // sid, x, y, dir, s, type, data, setSID, owner
                    /*let dist = UTILS.getDist({
                        x: data[i + 1],
                        y: data[i + 2]
                    }, player, 0, 2);
                    let aim = UTILS.getDirect({
                        x: data[i + 1],
                        y: data[i + 2]
                    }, player, 0, 2);
                    find = findObjectBySid(data[i]);
                    if (data[i + 6] == 15) {
                        if (find && !find.isTeamObject(player)) {
                            if (dist <= 100) {
                                traps.dist = dist;
                                traps.aim = aim;
                                traps.protect(aim);
                            }
                        }
                    }*/
                    i += 8;
                }
            }

            // ADD AI:
            function loadAI(data) {
                for (let i = 0; i < ais.length; ++i) {
                    ais[i].forcePos = !ais[i].visible;
                    ais[i].visible = false;
                }
                if (data) {
                    let tmpTime = performance.now();
                    for (let i = 0; i < data.length;) {
                        tmpObj = findAIBySID(data[i]);
                        if (tmpObj) {
                            tmpObj.index = data[i + 1];
                            tmpObj.t1 = (tmpObj.t2 === undefined) ? tmpTime : tmpObj.t2;
                            tmpObj.t2 = tmpTime;
                            tmpObj.x1 = tmpObj.x;
                            tmpObj.y1 = tmpObj.y;
                            tmpObj.x2 = data[i + 2];
                            tmpObj.y2 = data[i + 3];
                            tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 4] : tmpObj.d2;
                            tmpObj.d2 = data[i + 4];
                            tmpObj.health = data[i + 5];
                            tmpObj.dt = 0;
                            tmpObj.visible = true;
                        } else {
                            tmpObj = aiManager.spawn(data[i + 2], data[i + 3], data[i + 4], data[i + 1]);
                            tmpObj.x2 = tmpObj.x;
                            tmpObj.y2 = tmpObj.y;
                            tmpObj.d2 = tmpObj.dir;
                            tmpObj.health = data[i + 5];
                            if (!aiManager.aiTypes[data[i + 1]].name)
                                tmpObj.name = config.cowNames[data[i + 6]];
                            tmpObj.forcePos = true;
                            tmpObj.sid = data[i];
                            tmpObj.visible = true;
                        }
                        i += 7;
                    }
                }
            }

            // ANIMATE AI:
            function animateAI(sid) {
                tmpObj = findAIBySID(sid);
                if (tmpObj) tmpObj.startAnim();
            }

            // GATHER ANIMATION:
            function gatherAnimation(sid, didHit, index) {
                tmpObj = findPlayerBySID(sid);
                if (tmpObj) {
                    tmpObj.startAnim(didHit, index);
                    tmpObj.gatherIndex = index;
                    tmpObj.gathering = 1;
                    if (didHit) {
                        let tmpObjects = objectManager.hitObj;
                        objectManager.hitObj = [];
                        game.tickBase(() => {
                            // refind
                            tmpObj = findPlayerBySID(sid);
                            let val = items.weapons[index].dmg * (config.weaponVariants[tmpObj[(index < 9 ? "prima" : "seconda") + "ryVariant"]].val) * (items.weapons[index].sDmg || 1) * (tmpObj.skinIndex == 40 ? 3.3 : 1);
                            tmpObjects.forEach((healthy) => {
                                healthy.health -= val;
                            });
                        }, 1);
                    }
                }
            }

            // WIGGLE GAME OBJECT:
            function wiggleGameObject(dir, sid) {
                tmpObj = findObjectBySid(sid);
                if (tmpObj) {
                    tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir);
                    tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir);
                    if (tmpObj.health) {
                        //tmpObj.damaged = Math.min(255, tmpObj.damaged + 60);
                        objectManager.hitObj.push(tmpObj);
                    }
                }
            }

            // SHOOT TURRET:
            function shootTurret(sid, dir) {
                tmpObj = findObjectBySid(sid);
                if (tmpObj) {
                    if (config.anotherVisual) {
                        tmpObj.lastDir = dir;
                    } else {
                        tmpObj.dir = dir;
                    }
                    tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir + Math.PI);
                    tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir + Math.PI);
                }
            }

            // UPDATE PLAYER VALUE:
            function updatePlayerValue(index, value, updateView) {
                if (player) {
                    player[index] = value;
                    if (index == "points") {
                        if (configs.autoBuy) {
                            autoBuy.hat();
                            autoBuy.acc();
                        }
                    } else if (index == "kills") {
                        if (configs.killChat) {
                            sendChat("Auto GG - Secret Client");
                        }
                    }
                }
            }

            // ACTION BAR:
            function updateItems(data, wpn) {
                if (data) {
                    if (wpn) {
                        player.weapons = data;
                        player.primaryIndex = player.weapons[0];
                        player.secondaryIndex = player.weapons[1];
                        if (!instaC.isTrue) {
                            selectWeapon(player.weapons[0]);
                        }
                    } else {
                        player.items = data;
                    }
                }
                for (let i = 0; i < items.list.length; i++) {
                    let tmpI = items.weapons.length + i;
                    getEl("actionBarItem" + tmpI).style.display = player.items.indexOf(items.list[i].id) >= 0 ? "inline-block" : "none";
                }
                for (let i = 0; i < items.weapons.length; i++) {
                    getEl("actionBarItem" + i).style.display = player.weapons[items.weapons[i].type] == items.weapons[i].id ? "inline-block" : "none";
                }
                let kms = player.weapons[0] == 3 && player.weapons[1] == 15;
                if (kms) {
                    getEl("actionBarItem3").style.display = "none";
                    getEl("actionBarItem4").style.display = "inline-block";
                }
            }

            // ADD PROJECTILE:
            function addProjectile(x, y, dir, range, speed, indx, layer, sid) {
                projectileManager.addProjectile(x, y, dir, range, speed, indx, null, null, layer, inWindow).sid = sid;
                runAtNextTick.push(Array.prototype.slice.call(arguments));
            }

            // REMOVE PROJECTILE:
            function remProjectile(sid, range) {
                for (let i = 0; i < projectiles.length; ++i) {
                    if (projectiles[i].sid == sid) {
                        projectiles[i].range = range;
                        let tmpObjects = objectManager.hitObj;
                        objectManager.hitObj = [];
                        game.tickBase(() => {
                            let val = projectiles[i].dmg;
                            tmpObjects.forEach((healthy) => {
                                if (healthy.projDmg) {
                                    healthy.health -= val;
                                }
                            });
                        }, 1);
                    }
                }
            }

            // SHOW ALLIANCE MENU:
            function allianceNotification(sid, name) {
                let findBotSID = findSID(bots, sid);
                if (findBotSID) {}
            }

            function setPlayerTeam(team, isOwner) {
                if (player) {
                    player.team = team;
                    player.isOwner = isOwner;
                    if (team == null)
                        alliancePlayers = [];
                }
            }

            function setAlliancePlayers(data) {
                alliancePlayers = data;
            }

            // STORE MENU:
            function updateStoreItems(type, id, index) {
                if (index) {
                    if (!type)
                        player.tails[id] = 1;
                    else {
                        player.latestTail = id;
                    }
                } else {
                    if (!type)
                        player.skins[id] = 1,
                            id == 7 && (my.reSync = true); // testing perfect bulltick...
                    else {
                        player.latestSkin = id;
                    }
                }
            }

// SEND MESSAGE:
function receiveChat(sid, message) {
    if (/img/i.test(message)) return; // Anti img kick
    if (/iframe/i.test(message)) return;
    if (/ZOV/i.test(message)) return;
    let kawaii = false;
    let tmpPlayer = findPlayerBySID(sid);
        addMenuChText(`${tmpPlayer.name}[${tmpPlayer.sid}]`, message, "white");
    tmpPlayer.chatMessage = message;
    tmpPlayer.chatCountdown = config.chatCountdown;
                                if (getEl("autochat").checked) {
                    if (message.includes("mod")) {
                        packet("6", "¿Secret Client?")
                    }
                    if (message.includes("what mod")) {
                        packet("6", "¿Secret Client?")
                    }
                    if (message.includes("bad")) {
                        io.send("6", "Yeah of curse you bad :)");
                    } else if (message.includes("lag")) {
                        io.send("6", "your issue");
                    } else if (message.includes("Lag")) {
                        io.send("6", "your issue");
                    } else if (message.includes("cringe")) {
                        io.send("6", "Yeah you cringe!");
                    } else if (message.includes("mad")) {
                        io.send("6", "I'm never mad, I am a chill guy :)");
                    } else if (message.includes("idiot")) {
                        io.send("6", "Your an idiot, I am smart :)");
                    } else if (message.includes("retard")) {
                        io.send("6", "Yeah you retarded");
                    } else if (message.includes("ok and")) {
                        io.send("6", "ok, I don't asked you");
                    } else if (message.includes("get a life")) {
                        io.send("6", "then i will steal ur life :)");
                    } else if (message.includes("cry about it")) {
                        io.send("6", "cry about your skill issue ;-;");
                    } else if (message.includes("fell off")) {
                        io.send("6", "I leveled up and I pro");
                    } else if (message.includes("get good")) {
                        io.send("6", "Your right you should get good");
                    } else if (message.includes("stupid")) {
                        io.send("6", "Weirdo");
                    } else if (message.includes("homo")) {
                        io.send("6", "Lesbian?");
                    } else if (message.includes("noob")) {
                        io.send("6", "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
                    } else if (message.includes("dumb")) {
                        io.send("6", "Yeah I known I always known that your dumb");
                    } else if (message.includes("Dumb")) {
                        io.send("6", "Ok, weirdo");
                    } else if (message.includes("moron")) {
                        io.send("6", "Nah ik it's you the moron :)");
                    } else if (message.includes("not fun")) {
                        io.send("6", "so funny! HAHAHAHAHa");
                    } else if (message.includes("Noob")) {
                        io.send("6", "Your noob I known");
                    } else if (message.includes("nub")) {
                        io.send("6", "nub = u nub?");
                    } else if (message.includes("nob")) {
                        io.send("6", "nob = u nob?");
                    } else if (message.includes("nab")) {
                        io.send("6", "nab = u nab?");
                    } else if (message.includes("Nigga")) {
                        io.send("6", "Nigga = u Nigger?");
                    } else if (message.includes("Nigger")) {
                        io.send("6", "Nigger = u Nigger?");
                    } else if (message.includes("niggA")) {
                        io.send("6", "Nigga = u Nigger?");
                    } else if (message.includes("nigger")) {
                        io.send("6", "Nigger = u Nigger?");
                    } else if (message.includes("real")) {
                        io.send("6", "yes im real");
                    } else if (message.includes("loser")) {
                        io.send("6", "loser = u loser?");
                    } else if (message.includes("!c!dc")) {
                        io.send("6", "Bro thinked I was using chicken mod ;-;");
                    } else if (message.includes("gay")) {
                        io.send("6", "gay = u gay ?");
                    } else if (message.includes("gae")) {
                        io.send("6", "gae = u gay ?");
                    } else if (message.includes("Gay")) {
                        io.send("6", "Gay = You gay ?");
                    } else if (message.includes("love u")) {
                        io.send("6", "Gay??");
                    } else if (message.includes("love you")) {
                        io.send("6", "Gay??");
                    } else if (message.includes("luv you")) {
                        io.send("6", "Gay??");
                    } else if (message.includes("luv u")) {
                        io.send("6", "Gay??");
                    } else if (message.includes("hi")) {
                        io.send("6", "hi");
                    } else if (message.includes("ngu")) {
                        io.send("6", "ngu = u stupid?");
                    } else if (message.includes("Ngu")) {
                        io.send("6", "Ngu = u stupid?");
                    } else if (message.includes("NGU")) {
                        io.send("6", "Ngu = u NGU?");
                    } else if (message.includes("hehe")) {
                        io.send("6", "haha");
                    } else if (message.includes("haha")) {
                        io.send("6", "hahahahahaha");
                    } else if (message.includes("huhu")) {
                        io.send("6", "huhuhuhuhuhu");
                    } else if (message.includes("ez")) {
                        io.send("6", "ik you ez");
                    } else if (message.includes("Ez")) {
                        io.send("6", "ik you ez");
                    } else if (message.includes("easy")) {
                        io.send("6", "ik you ez");
                    } else if (message.includes("gg")) {
                        io.send("6", "gg ez");
                    } else if (message.includes("Gg")) {
                        io.send("6", "gg ez");
                    } else if (message.includes("lol")) {
                        io.send("6", "LOL LOL LOL");
                    } else if (message.includes("Lol")) {
                        io.send("6", "LOL LOL LOL");
                    } else if (message.includes("lmao")) {
                        io.send("6", "lmao LMAO LMAO LMAO");
                    } else if (message.includes("Lmao")) {
                        io.send("6", "lmao LMAO LMAO LMAO");
                    } else if (message.includes("lvl")) {
                        io.send("6", "why");
                    } else if (message.includes("1v1")) {
                        io.send("6", "why");
                    } else if (message.includes("hello")) {
                        io.send("6", "hello");
                    } else if (message.includes("idk")) {
                        io.send("6", "-_-");
                    } else if (message.includes("xd")) {
                        io.send("6", "lol");
                    } else if (message.includes("Xd")) {
                        io.send("6", "lol lol lol");
                    } else if (message.includes("xD")) {
                        io.send("6", "lol lol");
                    } else if (message.includes("XD")) {
                        io.send("6", "lmaooo");
                    } else if (message.includes(":<")) {
                        io.send("6", ":>");
                    } else if (message.includes(":(")) {
                        io.send("6", ":)");
                    } else if (message.includes("):")) {
                        io.send("6", "(:");
                    } else if (message.includes(":C")) {
                        io.send("6", "C:");
                    } else if (message.includes(":c")) {
                        io.send("6", "c:");
                    } else if (message.includes("D:")) {
                        io.send("6", ":D");
                    } else if (message.includes("-_-")) {
                        io.send("6", "xd");
                    } else if (message.includes("sb")) { //chinese meaning. (stupid)
                        io.send("6", "sb = u SB?");
                    } else if (message.includes("AutoGG")) {
                        io.send("6", "GG! EZ!");
                    } else if (message.includes("Master Race")) {
                        io.send("6", "GG! EZ!");
                    } else if (message.includes("autoclicker")) {
                        io.send("6", "autoclicker = Good");
                    } else if (message.includes("auto clicker")) {
                        io.send("6", "autoclicker = Good");
                    } else if (message.includes("trash")) {
                        io.send("6", "trash = u trash?");
                    } else if (message.includes("suck")) {
                        io.send("6", "suck = u suck?");
                    } else if (message.includes("fatherless")) {
                        io.send("6", "Yes you are fatherless");
                    } else if (message.includes("motherless")) {
                        io.send("6", "Yes you are motherless");
                    }
                }
            }
            // SEND MESSAGE:
            function receiveChat(sid, message) {
                let tmpPlayer = findPlayerBySID(sid);
                if (tmpPlayer) {

                    function get() {
                        if(tmpPlayer != player && player.team != tmpPlayer.team) {
                            return "#c95563";
                        } else if (player.team && player.team == tmpPlayer.team) {
                            return "#fff";
                        } else {
                            return "#0949aa"; //2394e8
                        }
                    }
                    let me = false;
                    if(tmpPlayer == player) me = true
                    else me = false;

                    addMenuChText(`${tmpPlayer.name} {${tmpPlayer.sid}}`, message, get());
                    if (config.anotherVisual) {
                        allChats.push(new addCh(tmpPlayer.x, tmpPlayer.y, message, tmpPlayer));
                    } else {
                        tmpPlayer.chatMessage = ((text) => {
                            let tmpString;
                            profanityList.forEach((list) => {
                                if (text.indexOf(list) > -1) {
                                    tmpString = "";
                                    for (var y = 0; y < list.length; ++y) {
                                        tmpString += tmpString.length?"o":"M";
                                    }
                                    var re = new RegExp(list, 'g');
                                    text = text.replace(re, tmpString);
                                }
                            });
                            return text;
                        })(message);
                        tmpPlayer.chatCountdown = config.chatCountdown;
                    }
                } else {
                    addMenuChText(`${"Anonymous"} {null}`, message, "white");
                }
            }

            // MINIMAP:
            function updateMinimap(data) {
                minimapData = data;
            }

            // SHOW ANIM TEXT:
            function showText(x, y, value, type) {
                if (config.anotherVisual) {
                    textManager.stack.push({x: x, y: y, value: value});
                } else {
                    textManager.showText(x, y, 50, 0.18, 500, Math.abs(value), (value>=0)?"#fff":"#8ecc51");
                }
            }

            /** APPLY SOCKET CODES */

            // BOT:
            let bots = [];
            let ranLocation = {
                x: UTILS.randInt(35, 14365),
                y: UTILS.randInt(35, 14365)
            };
            setInterval(() => {
                ranLocation = {
                    x: UTILS.randInt(35, 14365),
                    y: UTILS.randInt(35, 14365)
                };
            }, 60000);
            class Bot {
                constructor(id, sid, hats, accessories) {
                    this.id = id;
                    this.sid = sid;
                    this.team = null;
                    this.skinIndex = 0;
                    this.tailIndex = 0;
                    this.hitTime = 0;
                    this.iconIndex = 0;
                    this.enemy = [];
                    this.near = [];
                    this.dist2 = 0;
                    this.aim2 = 0;
                    this.tick = 0;
                    this.itemCounts = {};
                    this.latestSkin = 0;
                    this.latestTail = 0;
                    this.points = 0;
                    this.tails = {};
                    for (let i = 0; i < accessories.length; ++i) {
                        if (accessories[i].price <= 0)
                            this.tails[accessories[i].id] = 1;
                    }
                    this.skins = {};
                    for (let i = 0; i < hats.length; ++i) {
                        if (hats[i].price <= 0)
                            this.skins[hats[i].id] = 1;
                    }
                    this.spawn = function(moofoll) {
                        this.upgraded = 0;
                        this.enemy = [];
                        this.near = [];
                        this.active = true;
                        this.alive = true;
                        this.lockMove = false;
                        this.lockDir = false;
                        this.minimapCounter = 0;
                        this.chatCountdown = 0;
                        this.shameCount = 0;
                        this.shameTimer = 0;
                        this.sentTo = {};
                        this.gathering = 0;
                        this.autoGather = 0;
                        this.animTime = 0;
                        this.animSpeed = 0;
                        this.mouseState = 0;
                        this.buildIndex = -1;
                        this.weaponIndex = 0;
                        this.dmgOverTime = {};
                        this.noMovTimer = 0;
                        this.maxXP = 300;
                        this.XP = 0;
                        this.age = 1;
                        this.kills = 0;
                        this.upgrAge = 2;
                        this.upgradePoints = 0;
                        this.x = 0;
                        this.y = 0;
                        this.zIndex = 0;
                        this.xVel = 0;
                        this.yVel = 0;
                        this.slowMult = 1;
                        this.dir = 0;
                        this.nDir = 0;
                        this.dirPlus = 0;
                        this.targetDir = 0;
                        this.targetAngle = 0;
                        this.maxHealth = 100;
                        this.health = this.maxHealth;
                        this.oldHealth = this.maxHealth;
                        this.scale = config.playerScale;
                        this.speed = config.playerSpeed;
                        this.resetMoveDir();
                        this.resetResources(moofoll);
                        this.items = [0, 3, 6, 10];
                        this.weapons = [0];
                        this.shootCount = 0;
                        this.weaponXP = [];
                        this.reloads = {};
                        this.whyDie = "";
                    };
                    // RESET MOVE DIR:
                    this.resetMoveDir = function () {
                        this.moveDir = undefined;
                    };

                    // RESET RESOURCES:
                    this.resetResources = function (moofoll) {
                        for (let i = 0; i < config.resourceTypes.length; ++i) {
                            this[config.resourceTypes[i]] = moofoll ? 100 : 0;
                        }
                    };

                    // SET DATA:
                    this.setData = function (data) {
                        this.id = data[0];
                        this.sid = data[1];
                        this.name = data[2];
                        this.x = data[3];
                        this.y = data[4];
                        this.dir = data[5];
                        this.health = data[6];
                        this.maxHealth = data[7];
                        this.scale = data[8];
                        this.skinColor = data[9];
                    };


                    // SHAME SYSTEM:
                    tthis.judgeShame = function() {
            this.lastshamecount = this.shameCount;
            if (this.oldHealth < this.health) {
                if (this.hitTime) {
                    let timeSinceHit = game.tick - this.hitTime;
                    this.lastHit = game.tick;
                    this.hitTime = 0;
                    if (timeSinceHit < 2) {
                        this.shameCount++;
                    } else {
                        this.shameCount = Math.max(0, this.shameCount - 2);
                    }
                }
            } else if (this.oldHealth > this.health) {
                this.hitTime = game.tick;
            }
        };
        this.addShameTimer = function() {
            this.shameCount = 0;
            this.shameTimer = 30;
            let interval = setInterval(() => {
                this.shameTimer--;
                if (this.shameTimer <= 0) {
                    clearInterval(interval);
                }
            }, 1000);
        };

                    // INIT:
                    this.init = function (x, y, dir, scale, type, data, owner) {
                        data = data || {};
                        this.active = true;
                        this.x = x;
                        this.y = y;
                        this.scale = scale;
                        this.owner = owner;
                        this.id = data.id;
                        this.dmg = data.dmg;
                        this.trap = data.trap;
                        this.teleport = data.teleport;
                        this.isItem = this.id != undefined;
                    };

                }
            };
            class BotObjManager {
                constructor(botObj, fOS) {
                    // DISABLE OBJ:
                    this.disableObj = function (obj) {
                        obj.active = false;
                        if (config.anotherVisual) {
                        } else {
                            obj.alive = false;
                        }
                    };

                    // ADD NEW:
                    let tmpObj;
                    this.add = function (sid, x, y, dir, s, type, data, setSID, owner) {
                        tmpObj = fOS(sid);
                        if (!tmpObj) {
                            tmpObj = botObj.find((tmp) => !tmp.active);
                            if (!tmpObj) {
                                tmpObj = new BotObject(sid);
                                botObj.push(tmpObj);
                            }
                        }
                        if (setSID) {
                            tmpObj.sid = sid;
                        }
                        tmpObj.init(x, y, dir, s, type, data, owner);
                    };

                    // DISABLE BY SID:
                    this.disableBySid = function (sid) {
                        let find = fOS(sid);
                        if (find) {
                            this.disableObj(find);
                        }
                    };

                    // REMOVE ALL FROM PLAYER:
                    this.removeAllItems = function (sid, server) {
                        botObj.filter((tmp) => tmp.active && tmp.owner && tmp.owner.sid == sid).forEach((tmp) => this.disableObj(tmp));
                    };
                }
            };

            function botSpawn(id) {
                let bot;
                if (testMode) {
                    return;
                    bot = id && new WebSocket(`wss://elon_musk_hentai.io/websocket`);
                } else {
                    bot = id && new WebSocket(WS.url.split("&")[0] + "&token=" + encodeURIComponent(id));
                }
                let botPlayer = new Map();
                let botSID;
                let botObj = [];
                let nearObj = [];
                let bD = {
                    x: 0,
                    y: 0,
                    inGame: false,
                    closeSocket: false,
                    whyDie: "disney"
                };
                let oldXY = {
                    x: 0,
                    y: 0,
                };

                let botObjManager = new BotObjManager(botObj, function(sid) { return findSID(botObj, sid); });

                bot.binaryType = "arraybuffer";
                bot.first = true;
                bot.sendWS = function (type) {
                    // EXTRACT DATA ARRAY:
                    let data = Array.prototype.slice.call(arguments, 1);

                    // SEND MESSAGE:
                    let binary = window.msgpack.encode([type, data]);
                    bot.send(binary);
                };
                bot.spawn = function () {
                    bot.sendWS("M", {
                        name: "XDDD ASS PUB",
                        moofoll: 1,
                        skin: "__proto__"
                    });
                };
                bot.sendUpgrade = function(index) {
                    bot.sendWS("H", index);
                };
                bot.place = function(id, a) {
                    try {
                        let item = items.list[botPlayer.items[id]];
                        if (botPlayer.itemCounts[item.group.id] == undefined ? true : botPlayer.itemCounts[item.group.id] < (config.isSandbox ? 99 : item.group.limit ? item.group.limit : 99)) {
                            bot.sendWS("G", botPlayer.items[id]);
                            bot.sendWS("d", 1, a);
                            bot.sendWS("G", botPlayer.weaponIndex, true);
                        }
                    } catch (e) {
                    }
                };
                bot.buye = function(id, index) {
                    let nID = 0;
                    if (botPlayer.alive && botPlayer.inGame) {
                        if (index == 0) {
                            if (botPlayer.skins[id]) {
                                if (botPlayer.latestSkin != id) {
                                    bot.sendWS("c", 0, id, 0);
                                }
                            } else {
                                let find = findID(hats, id);
                                if (find) {
                                    if (botPlayer.points >= find.price) {
                                        bot.sendWS("c", 1, id, 0);
                                        bot.sendWS("c", 0, id, 0);
                                    } else {
                                        if (botPlayer.latestSkin != nID) {
                                            bot.sendWS("c", 0, nID, 0);
                                        }
                                    }
                                } else {
                                    if (botPlayer.latestSkin != nID) {
                                        bot.sendWS("c", 0, nID, 0);
                                    }
                                }
                            }
                        } else if (index == 1) {
                            if (botPlayer.tails[id]) {
                                if (botPlayer.latestTail != id) {
                                    bot.sendWS("c", 0, id, 1);
                                }
                            } else {
                                let find = findID(accessories, id);
                                if (find) {
                                    if (botPlayer.points >= find.price) {
                                        bot.sendWS("c", 1, id, 1);
                                        bot.sendWS("c", 0, id, 1);
                                    } else {
                                        if (botPlayer.latestTail != 0) {
                                            bot.sendWS("c", 0, 0, 1);
                                        }
                                    }
                                } else {
                                    if (botPlayer.latestTail != 0) {
                                        bot.sendWS("c", 0, 0, 1);
                                    }
                                }
                            }
                        }
                    }
                };
                bot.fastGear = function() {
                    if (botPlayer.y2 >= config.mapScale / 2 - config.riverWidth / 2 && botPlayer.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                        bot.buye(31, 0);
                    } else {
                        if (botPlayer.moveDir == undefined) {
                            bot.buye(22, 0);
                        } else {
                            if (botPlayer.y2 <= config.snowBiomeTop) {
                                bot.buye(15, 0);
                            } else {
                                bot.buye(12, 0);
                            }
                        }
                    }
                };
                let heal = function() {
                    let healthBased = function() {
                        if (botPlayer.health == 100)
                            return 0;
                        if (botPlayer.skinIndex != 45 && botPlayer.skinIndex != 56) {
                            return Math.ceil((100 - botPlayer.health) / items.list[botPlayer.items[0]].healing);
                        }
                        return 0;
                    };
                    for (let i = 0; i < healthBased(); i++) {
                        bot.place(0, botPlayer.nDir);
                    }
                };
                bot.onmessage = function(message) {
                    let data = new Uint8Array(message.data);
                    let parsed = window.msgpack.decode(data);
                    let type = parsed[0];
                    data = parsed[1];
                    if (type == "C") {
                        bot.spawn();
                    }
                    if (type == "C") {
                        botSID = data[0];
                    }
                    if (type == "D") {
                        if (data[1]) {
                            botPlayer = new Bot(data[0][0], data[0][1], hats, accessories);
                            botPlayer.setData(data[0]);
                            botPlayer.inGame = true;
                            botPlayer.alive = true;
                            botPlayer.x2 = undefined;
                            botPlayer.y2 = undefined;
                            botPlayer.spawn(1);
                            oldXY = {
                                x: data[0][3],
                                y: data[0][4]
                            }
                            bD.inGame = true;
                            bot.sendWS("K", 1);
                            if (bot.first) {
                                bot.first = false;
                                bots.push(bD);
                            }
                        }
                    }
                    if (type == "P") {
                        bot.spawn();
                        botPlayer.inGame = false;
                        bD.inGame = false;
                    }
                    if (type == "a") {
                        let tmpData = data[0];
                        botPlayer.tick++;
                        botPlayer.enemy = [];
                        //botPlayer.perfectReplace();
                        botPlayer.near = [];
                        nearObj = [];
                        for (let i = 0; i < tmpData.length;) {
                            if (tmpData[i] == botPlayer.sid) {
                                botPlayer.x2 = tmpData[i + 1];
                                botPlayer.y2 = tmpData[i + 2];
                                botPlayer.d2 = tmpData[i + 3];
                                botPlayer.buildIndex = tmpData[i + 4];
                                botPlayer.weaponIndex = tmpData[i + 5];
                                botPlayer.weaponVariant = tmpData[i + 6];
                                botPlayer.team = tmpData[i + 7];
                                botPlayer.isLeader = tmpData[i + 8];
                                botPlayer.skinIndex = tmpData[i + 9];
                                botPlayer.tailIndex = tmpData[i + 10];
                                botPlayer.iconIndex = tmpData[i + 11];
                                botPlayer.zIndex = tmpData[i + 12];
                                botPlayer.visible = true;
                                bD.x2 = botPlayer.x2;
                                bD.y2 = botPlayer.y2;
                            }
                            i += 13;
                        }
                        if (bD.closeSocket) {
                            botPlayer.closeSockets(bot);
                        }
                        if (bD.whyDie != "") {
                            botPlayer.whyDieChat(bot, bD.whyDie);
                            bD.whyDie = "";
                        }
                        if (botPlayer.alive) {
                            if (player.team) {
                                if (botPlayer.team != player.team && (botPlayer.tick % 9 === 0)) {
                                    botPlayer.team && (bot.sendWS("N"));
                                    bot.sendWS("10", player.team);
                                }
                            }
                            if (botPlayer.inGame) {
                                if (botObj.length > 0) {
                                    if (breakObjects.length > 0) {
                                        let gotoDist = UTILS.getDist(breakObjects[0], botPlayer, 0, 2);
                                        let gotoAim = UTILS.getDirect(breakObjects[0], botPlayer, 0, 2);
                                        nearObj = botObj.filter((e) => e.active && (findSID(breakObjects, e.sid) ? true : !(e.trap && (player.sid == e.owner.sid || player.findAllianceBySid(e.owner.sid)))) && e.isItem && UTILS.getDist(e, botPlayer, 0, 2) <= (items.weapons[botPlayer.weaponIndex].range + e.scale)).sort(function(a, b) {
                                            return UTILS.getDist(a, botPlayer, 0, 2) - UTILS.getDist(b, botPlayer, 0, 2);
                                        })[0];
                                        if (nearObj) {
                                            let isPassed = UTILS.getDist(breakObjects[0], nearObj, 0, 0);
                                            if ((gotoDist - isPassed) > 0) {
                                                if (findSID(breakObjects, nearObj.sid) ? true : (nearObj.dmg || nearObj.trap || nearObj.teleport)) {
                                                    if (botPlayer.moveDir != undefined) {
                                                        botPlayer.moveDir = undefined;
                                                        bot.sendWS("a", botPlayer.moveDir);
                                                    }
                                                } else {
                                                    botPlayer.moveDir = gotoAim;
                                                    bot.sendWS("a", botPlayer.moveDir);
                                                }
                                                if (botPlayer.nDir != UTILS.getDirect(nearObj, botPlayer, 0, 2)) {
                                                    botPlayer.nDir = UTILS.getDirect(nearObj, botPlayer, 0, 2);
                                                    bot.sendWS("D", botPlayer.nDir);
                                                }
                                                bot.buye(40, 0);
                                                bot.buye(11, 1);
                                            } else {
                                                botPlayer.moveDir = gotoAim;
                                                bot.sendWS("a", botPlayer.moveDir);
                                                bot.fastGear();
                                                bot.buye(11, 1);
                                            }
                                        } else {
                                            botPlayer.moveDir = gotoAim;
                                            bot.sendWS("a", botPlayer.moveDir);
                                            bot.fastGear();
                                            bot.buye(11, 1);
                                        }
                                        if (gotoDist > 300) {
                                            if (UTILS.getDist(oldXY, botPlayer, 0, 2) > 90) {
                                                let aim = UTILS.getDirect(oldXY, botPlayer, 0, 2);
                                                bot.place(3, aim + (Math.PI / 2.3));
                                                bot.place(3, aim - (Math.PI / 2.3));
                                                bot.place(3, aim);
                                                oldXY = {
                                                    x: botPlayer.x2,
                                                    y: botPlayer.y2
                                                };
                                            }
                                        }
                                    } else {
                                        if (botPlayer.moveDir != undefined) {
                                            botPlayer.moveDir = undefined;
                                            bot.sendWS("a", botPlayer.moveDir);
                                        }
                                        nearObj = botObj.filter((e) => e.active && (findSID(breakObjects, e.sid) ? true : !(e.trap && (player.sid == e.owner.sid || player.findAllianceBySid(e.owner.sid)))) && e.isItem && UTILS.getDist(e, botPlayer, 0, 2) <= (items.weapons[botPlayer.weaponIndex].range + e.scale)).sort(function(a, b) {
                                            return UTILS.getDist(a, botPlayer, 0, 2) - UTILS.getDist(b, botPlayer, 0, 2);
                                        })[0];
                                        if (nearObj) {
                                            if (botPlayer.nDir != UTILS.getDirect(nearObj, botPlayer, 0, 2)) {
                                                botPlayer.nDir = UTILS.getDirect(nearObj, botPlayer, 0, 2);
                                                bot.sendWS("D", botPlayer.nDir);
                                            }
                                            bot.buye(40, 0);
                                            bot.buye(11, 1);
                                        } else {
                                            bot.fastGear();
                                            bot.buye(11, 1);
                                        }
                                    }
                                } else {
                                    if (botPlayer.moveDir != undefined) {
                                        botPlayer.moveDir = undefined;
                                        bot.sendWS("a", botPlayer.moveDir);
                                    }
                                }
                            }
                        }
                    }
                    if (type == "H") {
                        let tmpData = data[0];
                        for (let i = 0; i < tmpData.length;) {
                            botObjManager.add(tmpData[i], tmpData[i + 1], tmpData[i + 2], tmpData[i + 3], tmpData[i + 4],
                                              tmpData[i + 5], items.list[tmpData[i + 6]], true, (tmpData[i + 7] >= 0 ? {
                                sid: tmpData[i + 7]
                            } : null));
                            i += 8;
                        }
                    }
                    if (type == "N") {
                        let index = data[0];
                        let value = data[1];
                        if (botPlayer) {
                            botPlayer[index] = value;
                        }
                    }
                    if (type == "O") {
                        if (data[0] == botSID) {
                            botPlayer.oldHealth = botPlayer.health;
                            botPlayer.health = data[1];
                            botPlayer.judgeShame();
                            if (botPlayer.oldHealth > botPlayer.health) {
                                if (botPlayer.shameCount < 5) {
                                    heal();
                                } else {
                                    setTimeout(() => {
                                        heal();
                                    }, 70);
                                }
                            }
                        }
                    }
                    if (type == "Q") {
                        let sid = data[0];
                        botObjManager.disableBySid(sid);
                    }
                    if (type == "R") {
                        let sid = data[0];
                        if (botPlayer.alive) botObjManager.removeAllItems(sid);
                    }
                    if (type == "S") {
                        let index = data[0];
                        let value = data[1];
                        if (botPlayer) {
                            botPlayer.itemCounts[index] = value;
                        }
                    }
                    if (type == "U") {
                        if (data[0] > 0) {
                            if (botPlayer.upgraded == 0) {
                                bot.sendUpgrade(3);
                            } else if (botPlayer.upgraded == 1) {
                                bot.sendUpgrade(17);
                            } else if (botPlayer.upgraded == 2) {
                                bot.sendUpgrade(31);
                            } else if (botPlayer.upgraded == 3) {
                                bot.sendUpgrade(27);
                            } else if (botPlayer.upgraded == 4) {
                                bot.sendUpgrade(9);
                            } else if (botPlayer.upgraded == 5) {
                                bot.sendUpgrade(38);
                            } else if (botPlayer.upgraded == 6) {
                                bot.sendUpgrade(4);
                            } else if (botPlayer.upgraded == 7) {
                                bot.sendUpgrade(25);
                            }
                            botPlayer.upgraded++;
                        }
                    }
                    if (type == "V") {
                        let tmpData = data[0];
                        let wpn = data[1];
                        if (tmpData) {
                            if (wpn) botPlayer.weapons = tmpData;
                            else botPlayer.items = tmpData;
                        }
                        bot.sendWS("G", botPlayer.weapons[0], true);
                    }
                    if (type == "5") {
                        let type = data[0];
                        let id = data[1];
                        let index = data[2];
                        if (index) {
                            if (!type)
                                botPlayer.tails[id] = 1;
                            else
                                botPlayer.latestTail = id;
                        } else {
                            if (!type)
                                botPlayer.skins[id] = 1;
                            else
                                botPlayer.latestSkin = id;
                        }
                    }
                };
                bot.onclose = function() {
                    botPlayer.inGame = false;
                    bD.inGame = false;
                };
            }

            // RENDER LEAF:
            function renderLeaf(x, y, l, r, ctxt) {
                let endX = x + (l * Math.cos(r));
                let endY = y + (l * Math.sin(r));
                let width = l * 0.4;
                ctxt.moveTo(x, y);
                ctxt.beginPath();
                ctxt.quadraticCurveTo(((x + endX) / 2) + (width * Math.cos(r + Math.PI / 2)),
                                      ((y + endY) / 2) + (width * Math.sin(r + Math.PI / 2)), endX, endY);
                ctxt.quadraticCurveTo(((x + endX) / 2) - (width * Math.cos(r + Math.PI / 2)),
                                      ((y + endY) / 2) - (width * Math.sin(r + Math.PI / 2)), x, y);
                ctxt.closePath();
                ctxt.fill();
                ctxt.stroke();
            }

            // RENDER CIRCLE:
            function renderCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
                tmpContext = tmpContext || mainContext;
                tmpContext.beginPath();
                tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
                if (!dontFill) tmpContext.fill();
                if (!dontStroke) tmpContext.stroke();
            }

            function renderHealthCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
                tmpContext = tmpContext || mainContext;
                tmpContext.beginPath();
                tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
                if (!dontFill) tmpContext.fill();
                if (!dontStroke) tmpContext.stroke();
            }

            // RENDER STAR SHAPE:
            function renderStar(ctxt, spikes, outer, inner) {
                let rot = Math.PI / 2 * 3;
                let x, y;
                let step = Math.PI / spikes;
                ctxt.beginPath();
                ctxt.moveTo(0, -outer);
                for (let i = 0; i < spikes; i++) {
                    x = Math.cos(rot) * outer;
                    y = Math.sin(rot) * outer;
                    ctxt.lineTo(x, y);
                    rot += step;
                    x = Math.cos(rot) * inner;
                    y = Math.sin(rot) * inner;
                    ctxt.lineTo(x, y);
                    rot += step;
                }
                ctxt.lineTo(0, -outer);
                ctxt.closePath();
            }

            function renderHealthStar(ctxt, spikes, outer, inner) {
                let rot = Math.PI / 2 * 3;
                let x, y;
                let step = Math.PI / spikes;
                ctxt.beginPath();
                ctxt.moveTo(0, -outer);
                for (let i = 0; i < spikes; i++) {
                    x = Math.cos(rot) * outer;
                    y = Math.sin(rot) * outer;
                    ctxt.lineTo(x, y);
                    rot += step;
                    x = Math.cos(rot) * inner;
                    y = Math.sin(rot) * inner;
                    ctxt.lineTo(x, y);
                    rot += step;
                }
                ctxt.lineTo(0, -outer);
                ctxt.closePath();
            }

            // RENDER RECTANGLE:
            function renderRect(x, y, w, h, ctxt, dontStroke, dontFill) {
                if (!dontFill) ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
                if (!dontStroke) ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
            }

            function renderHealthRect(x, y, w, h, ctxt, dontStroke, dontFill) {
                if (!dontFill) ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
                if (!dontStroke) ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
            }

            // RENDER RECTCIRCLE:
            function renderRectCircle(x, y, s, sw, seg, ctxt, dontStroke, dontFill) {
                ctxt.save();
                ctxt.translate(x, y);
                seg = Math.ceil(seg / 2);
                for (let i = 0; i < seg; i++) {
                    renderRect(0, 0, s * 2, sw, ctxt, dontStroke, dontFill);
                    ctxt.rotate(Math.PI / seg);
                }
                ctxt.restore();
            }

            // RENDER BLOB:
            function renderBlob(ctxt, spikes, outer, inner) {
                let rot = Math.PI / 2 * 3;
                let x, y;
                let step = Math.PI / spikes;
                let tmpOuter;
                ctxt.beginPath();
                ctxt.moveTo(0, -inner);
                for (let i = 0; i < spikes; i++) {
                    tmpOuter = UTILS.randInt(outer + 0.9, outer * 1.2);
                    ctxt.quadraticCurveTo(Math.cos(rot + step) * tmpOuter, Math.sin(rot + step) * tmpOuter,
                                          Math.cos(rot + (step * 2)) * inner, Math.sin(rot + (step * 2)) * inner);
                    rot += step * 2;
                }
                ctxt.lineTo(0, -inner);
                ctxt.closePath();
            }

            // RENDER TRIANGLE:
            function renderTriangle(s, ctx) {
                ctx = ctx || mainContext;
                let h = s * (Math.sqrt(3) / 2);
                ctx.beginPath();
                ctx.moveTo(0, -h / 2);
                ctx.lineTo(-s / 2, h / 2);
                ctx.lineTo(s / 2, h / 2);
                ctx.lineTo(0, -h / 2);
                ctx.fill();
                ctx.closePath();
            }

            // PREPARE MENU BACKGROUND:
            function prepareMenuBackground() {
                var tmpMid = config.mapScale / 2;
                objectManager.add(0, tmpMid, tmpMid + 200, 0, config.treeScales[3], 0);
                objectManager.add(1, tmpMid, tmpMid - 480, 0, config.treeScales[3], 0);
                objectManager.add(2, tmpMid + 300, tmpMid + 450, 0, config.treeScales[3], 0);
                objectManager.add(3, tmpMid - 950, tmpMid - 130, 0, config.treeScales[2], 0);
                objectManager.add(4, tmpMid - 750, tmpMid - 400, 0, config.treeScales[3], 0);
                objectManager.add(5, tmpMid - 700, tmpMid + 400, 0, config.treeScales[2], 0);
                objectManager.add(6, tmpMid + 800, tmpMid - 200, 0, config.treeScales[3], 0);
                objectManager.add(7, tmpMid - 260, tmpMid + 340, 0, config.bushScales[3], 1);
                objectManager.add(8, tmpMid + 760, tmpMid + 310, 0, config.bushScales[3], 1);
                objectManager.add(9, tmpMid - 800, tmpMid + 100, 0, config.bushScales[3], 1);
                objectManager.add(10, tmpMid - 800, tmpMid + 300, 0, items.list[4].scale, items.list[4].id, items.list[10]);
                objectManager.add(11, tmpMid + 650, tmpMid - 390, 0, items.list[4].scale, items.list[4].id, items.list[10]);
                objectManager.add(12, tmpMid - 400, tmpMid - 450, 0, config.rockScales[2], 2);
            }
            const speed = 35;

            // RENDER PLAYERS:
            function renderDeadPlayers(xOffset, yOffset) {
                mainContext.fillStyle = "#91b2db";
                deadPlayers.filter(dead => dead.active).forEach((dead) => {
                    dead.animate(delta);

                    mainContext.globalAlpha = dead.alpha;
                    mainContext.strokeStyle = outlineColor;

                    mainContext.save();
                    mainContext.translate(dead.x - xOffset, dead.y - yOffset);

                    // RENDER PLAYER:
                    mainContext.rotate(dead.dir);
                    mainContext.scale(dead.visScale / dead.scale, dead.visScale / dead.scale);
                    renderDeadPlayer(dead, mainContext);
                    mainContext.restore();

                    mainContext.font = "20px Ubuntu";
                    let tmpSize = mainContext.measureText("imagine using fixed mod L");
                    let tmpH = 60;
                    let tmpW = tmpSize.width + 10;
                    mainContext.textBaseline = "middle";
                    mainContext.textAlign = "center";

                    mainContext.fillStyle = "#ccc";
                    mainContext.strokeStyle = "#999";
                    mainContext.roundRect(dead.x - xOffset - (tmpW / 2), dead.y - yOffset - (tmpH / 2) + (dead.scale * 1.5), tmpW, tmpH, 6);
                    mainContext.fill();
                    mainContext.stroke();

                    mainContext.fillStyle = "#fff";
                    mainContext.strokeStyle = "#000";
                    mainContext.strokeText("disney", dead.x - xOffset, dead.y + (dead.scale * 1.5) - yOffset);
                    mainContext.fillText("fixed", dead.x - xOffset, dead.y + (dead.scale * 1.5) - yOffset);
                    mainContext.strokeText(dead.name, dead.x - xOffset, dead.y + (dead.scale * 1.5) + 20 - yOffset);
                    mainContext.fillText(dead.name, dead.x - xOffset, dead.y + (dead.scale * 1.5) + 20 - yOffset);

                    // same color in bundle
                    mainContext.fillStyle = "#91b2db";

                });
            }

            // RENDER PLAYERS:
            function renderPlayers(xOffset, yOffset, zIndex) {
                mainContext.globalAlpha = 1;
                mainContext.fillStyle = "#91b2db";
                for (var i = 0; i < players.length; ++i) {
                    tmpObj = players[i];
                    if (tmpObj.zIndex == zIndex) {
                        tmpObj.animate(delta);
                        if (tmpObj.visible) {
                            tmpObj.skinRot += (0.002 * delta);
                            tmpDir = (!configs.showDir && !useWasd && tmpObj == player) ? configs.attackDir ? getVisualDir() : getSafeDir() : (tmpObj.dir||0);
                            mainContext.save();
                            mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);

                            // RENDER PLAYER:
                            mainContext.rotate(tmpDir + tmpObj.dirPlus);
                            renderPlayer(tmpObj, mainContext);
                            mainContext.restore();

                        }
                    }
                }
            }

            // RENDER DEAD PLAYER:
            function renderDeadPlayer(obj, ctxt) {
                ctxt = ctxt || mainContext;
                ctxt.lineWidth = outlineWidth;
                ctxt.lineJoin = "miter";
                let handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS||1);
                let oHandAngle = (obj.buildIndex < 0)?(items.weapons[obj.weaponIndex].hndS||1):1;
                let oHandDist = (obj.buildIndex < 0)?(items.weapons[obj.weaponIndex].hndD||1):1;

                // WEAPON BELLOW HANDS:
                if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
                    renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                    if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                        renderProjectile(obj.scale, 0,
                                         items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                    }
                }

                // HANDS:
                ctxt.fillStyle = config.skinColors[obj.skinColor];
                renderCircle(obj.scale * Math.cos(handAngle), (obj.scale * Math.sin(handAngle)), 14);
                renderCircle((obj.scale * oHandDist) * Math.cos(-handAngle * oHandAngle),
                             (obj.scale * oHandDist) * Math.sin(-handAngle * oHandAngle), 14);

                // WEAPON ABOVE HANDS:
                if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
                    renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                    if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                        renderProjectile(obj.scale, 0,
                                         items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                    }
                }

                // BUILD ITEM:
                if (obj.buildIndex >= 0) {
                    var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
                    ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
                }

                // BODY:
                renderCircle(0, 0, obj.scale, ctxt);

                ctxt.lineWidth = 2;
                ctxt.fillStyle = "#555";
                ctxt.font = "35px Hammersmith One";
                ctxt.textBaseline = "middle";
                ctxt.textAlign = "center";

                ctxt.fillText("(", 20, 5);

                ctxt.rotate(Math.PI / 2);
                ctxt.font = "30px Hammersmith One";
                ctxt.fillText("X", -15, 15/2);
                ctxt.fillText("D", 15, 15/2);

            }

            // RENDER PLAYER:
            function renderPlayer(obj, ctxt) {
                ctxt = ctxt || mainContext;
                ctxt.lineWidth = outlineWidth;
                ctxt.lineJoin = "miter";
                let handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS||1);
                let oHandAngle = (obj.buildIndex < 0)?(items.weapons[obj.weaponIndex].hndS||1):1;
                let oHandDist = (obj.buildIndex < 0)?(items.weapons[obj.weaponIndex].hndD||1):1;

                let katanaMusket = (obj == player && obj.weapons[0] == 3 && obj.weapons[1] == 15);

                // TAIL/CAPE:
                if (obj.tailIndex > 0) {
                    renderTail(obj.tailIndex, ctxt, obj);
                }

                // WEAPON BELLOW HANDS:
                if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
                    renderTool(items.weapons[katanaMusket ? 4 : obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                    if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                        renderProjectile(obj.scale, 0,
                                         items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                    }
                }

                // HANDS:
                ctxt.fillStyle = config.skinColors[obj.skinColor];
                renderCircle(obj.scale * Math.cos(handAngle), (obj.scale * Math.sin(handAngle)), 14);
                renderCircle((obj.scale * oHandDist) * Math.cos(-handAngle * oHandAngle),
                             (obj.scale * oHandDist) * Math.sin(-handAngle * oHandAngle), 14);

                // WEAPON ABOVE HANDS:
                if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
                    renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                    if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                        renderProjectile(obj.scale, 0,
                                         items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                    }
                }

                // BUILD ITEM:
                if (obj.buildIndex >= 0) {
                    var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
                    ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
                }

                // BODY:
                renderCircle(0, 0, obj.scale, ctxt);

                // SKIN:
                if (obj.skinIndex > 0) {
                    ctxt.rotate(Math.PI/2);
                    renderSkin(obj.skinIndex, ctxt, null, obj);
                }

            }

            // RENDER SKINS:
            let skinSprites = {};
            let skinPointers = {};
            let tmpSkin;
            function renderSkin(index, ctxt, parentSkin, owner) {
                tmpSkin = skinSprites[index];
                if (!tmpSkin) {
                    let tmpImage = new Image();
                    tmpImage.onload = function() {
                        this.isLoaded = true;
                        this.onload = null;
                    };
                    tmpImage.src = "https://moomoo.io/img/hats/hat_" + index + ".png";
                    skinSprites[index] = tmpImage;
                    tmpSkin = tmpImage;
                }
                let tmpObj = parentSkin||skinPointers[index];
                if (!tmpObj) {
                    for (let i = 0; i < hats.length; ++i) {
                        if (hats[i].id == index) {
                            tmpObj = hats[i];
                            break;
                        }
                    }
                    skinPointers[index] = tmpObj;
                }
                if (tmpSkin.isLoaded)
                    ctxt.drawImage(tmpSkin, -tmpObj.scale/2, -tmpObj.scale/2, tmpObj.scale, tmpObj.scale);
                if (!parentSkin && tmpObj.topSprite) {
                    ctxt.save();
                    ctxt.rotate(owner.skinRot);
                    renderSkin(index + "_top", ctxt, tmpObj, owner);
                    ctxt.restore();
                }
            }

            // RENDER TAIL:
            let accessSprites = {};
            let accessPointers = {};
            function renderTail(index, ctxt, owner) {
                tmpSkin = accessSprites[index];
                if (!tmpSkin) {
                    let tmpImage = new Image();
                    tmpImage.onload = function() {
                        this.isLoaded = true;
                        this.onload = null;
                    };
                    tmpImage.src = "https://moomoo.io/img/accessories/access_" + index + ".png";
                    accessSprites[index] = tmpImage;
                    tmpSkin = tmpImage;
                }
                let tmpObj = accessPointers[index];
                if (!tmpObj) {
                    for (let i = 0; i < accessories.length; ++i) {
                        if (accessories[i].id == index) {
                            tmpObj = accessories[i];
                            break;
                        }
                    }
                    accessPointers[index] = tmpObj;
                }
                if (tmpSkin.isLoaded) {
                    ctxt.save();
                    ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
                    if (tmpObj.spin)
                        ctxt.rotate(owner.skinRot);
                    ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
                    ctxt.restore();
                }
            }

            // RENDER TOOL:
            let toolSprites = {};
            function renderTool(obj, variant, x, y, ctxt) {
                let tmpSrc = obj.src + (variant||"");
                let tmpSprite = toolSprites[tmpSrc];
                if (!tmpSprite) {
                    tmpSprite = new Image();
                    tmpSprite.onload = function() {
                        this.isLoaded = true;
                    }
                    tmpSprite.src = "https://moomoo.io/img/weapons/" + tmpSrc + ".png";
                    toolSprites[tmpSrc] = tmpSprite;
                }
                if (tmpSprite.isLoaded)
                    ctxt.drawImage(tmpSprite, x + obj.xOff - (obj.length / 2), y + obj.yOff - (obj.width / 2), obj.length, obj.width);
            }

            // RENDER PROJECTILES:
            function renderProjectiles(layer, xOffset, yOffset) {
                for(let i = 0; i < projectiles.length; i++) {
                    tmpObj = projectiles[i];
                    if (tmpObj.active && tmpObj.layer == layer && tmpObj.inWindow) {
                        tmpObj.update(delta);
                        if (tmpObj.active && isOnScreen(tmpObj.x - xOffset, tmpObj.y - yOffset, tmpObj.scale)) {
                            mainContext.save();
                            mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                            mainContext.rotate(tmpObj.dir);
                            renderProjectile(0, 0, tmpObj, mainContext, 1);
                            mainContext.restore();
                        }
                    }
                };
            }

            // RENDER PROJECTILE:
            let projectileSprites = {};
            function renderProjectile(x, y, obj, ctxt, debug) {
                if (obj.src) {
                    let tmpSrc = items.projectiles[obj.indx].src;
                    let tmpSprite = projectileSprites[tmpSrc];
                    if (!tmpSprite) {
                        tmpSprite = new Image();
                        tmpSprite.onload = function() {
                            this.isLoaded = true;
                        }
                        tmpSprite.src = "https://moomoo.io/img/weapons/" + tmpSrc + ".png";
                        projectileSprites[tmpSrc] = tmpSprite;
                    }
                    if (tmpSprite.isLoaded)
                        ctxt.drawImage(tmpSprite, x - (obj.scale / 2), y - (obj.scale / 2), obj.scale, obj.scale);
                } else if (obj.indx == 1) {
                    ctxt.fillStyle = "#939393";
                    renderCircle(x, y, obj.scale, ctxt);
                }
            }

            // RENDER AI:
            let aiSprites = {};
            function renderAI(obj, ctxt) {
                let tmpIndx = obj.index;
                let tmpSprite = aiSprites[tmpIndx];
                if (!tmpSprite) {
                    let tmpImg = new Image();
                    tmpImg.onload = function() {
                        this.isLoaded = true;
                        this.onload = null;
                    };
                    tmpImg.src = "https://moomoo.io/img/animals/" + obj.src + ".png";
                    tmpSprite = tmpImg;
                    aiSprites[tmpIndx] = tmpSprite;
                }
                if (tmpSprite.isLoaded) {
                    let tmpScale = obj.scale * 1.2 * (obj.spriteMlt || 1);
                    ctxt.drawImage(tmpSprite, -tmpScale, -tmpScale, tmpScale * 2, tmpScale * 2);
                }
            }

            // RENDER WATER BODIES:
            function renderWaterBodies(xOffset, yOffset, ctxt, padding) {

                // MIDDLE RIVER:
                let tmpW = config.riverWidth + padding;
                let tmpY = (config.mapScale / 2) - yOffset - (tmpW / 2);
                if (tmpY < maxScreenHeight && tmpY + tmpW > 0) {
                    ctxt.fillRect(0, tmpY, maxScreenWidth, tmpW);
                }
            }

            // RENDER GAME OBJECTS:
            let gameObjectSprites = {};
            function getResSprite(obj) {
                let biomeID = (obj.y>=config.mapScale-config.snowBiomeTop)?2:((obj.y<=config.snowBiomeTop)?1:0);
                let tmpIndex = (obj.type + "_" + obj.scale + "_" + biomeID);
                let tmpSprite = gameObjectSprites[tmpIndex];
                if (!tmpSprite) {
                    let blurScale = 15;
                    let tmpCanvas = document.createElement("canvas");
                    tmpCanvas.width = tmpCanvas.height = (obj.scale * 2.1) + outlineWidth;
                    let tmpContext = tmpCanvas.getContext('2d');
                    tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                    tmpContext.rotate(UTILS.randFloat(0, Math.PI));
                    tmpContext.strokeStyle = outlineColor;
                    tmpContext.lineWidth = outlineWidth;
                    if (isNight) {
                        tmpContext.shadowBlur = blurScale;
                        tmpContext.shadowColor = `rgba(0, 0, 0, ${obj.alpha})`;
                    }
                    if (obj.type == 0) {
                        let tmpScale;
                        let tmpCount = UTILS.randInt(5, 7);
                        tmpContext.globalAlpha = isNight ? 0.6 : 0.8;
                        for (let i = 0; i < 2; ++i) {
                            tmpScale = tmpObj.scale * (!i?1:0.5);
                            renderStar(tmpContext, tmpCount, tmpScale, tmpScale * 0.7);
                            tmpContext.fillStyle = !biomeID?(!i?"#9ebf57":"#b4db62"):(!i?"#e3f1f4":"#fff");
                            tmpContext.fill();
                            if (!i) {
                                tmpContext.stroke();
                                tmpContext.shadowBlur = null;
                                tmpContext.shadowColor = null;
                                tmpContext.globalAlpha = 1;
                            }
                        }
                    } else if (obj.type == 1) {
                        if (biomeID == 2) {
                            tmpContext.fillStyle = "#606060";
                            renderStar(tmpContext, 6, obj.scale * 0.3, obj.scale * 0.71);
                            tmpContext.fill();
                            tmpContext.stroke();

                            //tmpContext.shadowBlur = null;
                            //tmpContext.shadowColor = null;

                            tmpContext.fillStyle = "#89a54c";
                            renderCircle(0, 0, obj.scale * 0.55, tmpContext);
                            tmpContext.fillStyle = "#a5c65b";
                            renderCircle(0, 0, obj.scale * 0.3, tmpContext, true);
                        } else {
                            renderBlob(tmpContext, 6, tmpObj.scale, tmpObj.scale * 0.7);
                            tmpContext.fillStyle = biomeID?"#e3f1f4":"#89a54c";
                            tmpContext.fill();
                            tmpContext.stroke();

                            //tmpContext.shadowBlur = null;
                            //tmpContext.shadowColor = null;

                            tmpContext.fillStyle = biomeID?"#6a64af":"#c15555";
                            let tmpRange;
                            let berries = 4;
                            let rotVal = (Math.PI * 2) / berries;
                            for (let i = 0; i < berries; ++i) {
                                tmpRange = UTILS.randInt(tmpObj.scale/3.5, tmpObj.scale/2.3);
                                renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                             UTILS.randInt(10, 12), tmpContext);
                            }
                        }
                    } else if (obj.type == 2 || obj.type == 3) {
                        tmpContext.fillStyle = (obj.type==2)?(biomeID==2?"#938d77":"#939393"):"#e0c655";
                        renderStar(tmpContext, 3, obj.scale, obj.scale);
                        tmpContext.fill();
                        tmpContext.stroke();

                        tmpContext.shadowBlur = null;
                        tmpContext.shadowColor = null;

                        tmpContext.fillStyle = (obj.type==2)?(biomeID==2?"#b2ab90":"#bcbcbc"):"#ebdca3";
                        renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                        tmpContext.fill();
                    }
                    tmpSprite = tmpCanvas;
                    gameObjectSprites[tmpIndex] = tmpSprite;
                }
                return tmpSprite;
            }

            // GET ITEM SPRITE:
            let itemSprites = [];
            function getItemSprite(obj, asIcon) {
                let tmpSprite = itemSprites[obj.id];
                if (!tmpSprite || asIcon) {
                    let blurScale = !asIcon && isNight ? 15 : 0;
                    let tmpCanvas = document.createElement("canvas");
                    let reScale = ((!asIcon && obj.name == "windmill") ? items.list[4].scale : obj.scale);
                    tmpCanvas.width = tmpCanvas.height = (reScale * 2.5) + outlineWidth + (items.list[obj.id].spritePadding || 0) + blurScale;
                    if (config.useWebGl) {
                        let gl = tmpCanvas.getContext("webgl");
                        gl.clearColor(0, 0, 0, 0);
                        gl.clear(gl.COLOR_BUFFER_BIT);

                        let buffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

                        function render(vs, fs, vertice, type) {

                            let vShader = gl.createShader(gl.VERTEX_SHADER);
                            gl.shaderSource(vShader, vs);
                            gl.compileShader(vShader);
                            gl.getShaderParameter(vShader, gl.COMPILE_STATUS);

                            let fShader = gl.createShader(gl.FRAGMENT_SHADER);
                            gl.shaderSource(fShader, fs);
                            gl.compileShader(fShader);
                            gl.getShaderParameter(fShader, gl.COMPILE_STATUS);

                            let program = gl.createProgram();
                            gl.attachShader(program, vShader);
                            gl.attachShader(program, fShader);
                            gl.linkProgram(program);
                            gl.getProgramParameter(program, gl.LINK_STATUS);
                            gl.useProgram(program);

                            let vertex = gl.getAttribLocation(program, "vertex");
                            gl.enableVertexAttribArray(vertex);
                            gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, 0, 0);

                            let vertices = vertice.length / 2;
                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertice), gl.DYNAMIC_DRAW);
                            gl.drawArrays(type, 0, vertices);
                        }

                        function hexToRgb(hex) {
                            return hex.slice(1).match(/.{1,2}/g).map(g => parseInt(g, 16));
                        }

                        function getRgb(r, g, b) {
                            return [r / 255, g / 255, b / 255].join(", ");
                        }

                        let max = 100;
                        for (let i = 0; i < max; i++) {
                            let radian = (Math.PI * (i / (max / 2)));
                            render(`
                            precision mediump float;
                            attribute vec2 vertex;
                            void main(void) {
                                gl_Position = vec4(vertex, 0, 1);
                            }
                            `,`
                            precision mediump float;
                            void main(void) {
                                gl_FragColor = vec4(${getRgb(...hexToRgb("#fff"))}, 1);
                            }
                            `, [
                                0 + (Math.cos(radian) * 0.5), 0 + (Math.sin(radian) * 0.5),
                                0, 0,
                            ], gl.LINE_LOOP);
                        }
                    } else {
                        let tmpContext = tmpCanvas.getContext("2d");
                        tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                        tmpContext.rotate(asIcon ? 0 : (Math.PI / 2));
                        tmpContext.strokeStyle = outlineColor;
                        tmpContext.lineWidth = outlineWidth * (asIcon ? (tmpCanvas.width / 81) : 1);
                        if (isNight && !asIcon) {
                            tmpContext.shadowBlur = blurScale;
                            tmpContext.shadowColor = `rgba(0, 0, 0, ${Math.min(obj.name == "pit trap" ? 0.6 : 0.3, obj.alpha)})`;
                        }
                        if (obj.name == "apple") {
                            tmpContext.fillStyle = "#c15555";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fillStyle = "#89a54c";
                            let leafDir = -(Math.PI / 2);
                            renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir),
                                       25, leafDir + Math.PI / 2, tmpContext);
                        } else if (obj.name == "cookie") {
                            tmpContext.fillStyle = "#cca861";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fillStyle = "#937c4b";
                            let chips = 4;
                            let rotVal = (Math.PI * 2) / chips;
                            let tmpRange;
                            for (let i = 0; i < chips; ++i) {
                                tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                                renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                             UTILS.randInt(4, 5), tmpContext, true);
                            }
                        } else if (obj.name == "cheese") {
                            tmpContext.fillStyle = "#f4f3ac";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fillStyle = "#c3c28b";
                            let chips = 4;
                            let rotVal = (Math.PI * 2) / chips;
                            let tmpRange;
                            for (let i = 0; i < chips; ++i) {
                                tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                                renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                             UTILS.randInt(4, 5), tmpContext, true);
                            }
                        } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                            tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
                                "#a5974c" : "#939393";
                            let sides = (obj.name == "castle wall") ? 4 : 3;
                            renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
                                "#c9b758" : "#bcbcbc";
                            renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                            tmpContext.fill();
                        } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
                                   obj.name == "spinning spikes") {
                            tmpContext.fillStyle = (obj.name == "poison spikes") ? "#FFFFFF" : "#FFFFFF";
                            let tmpScale = (obj.scale * 0.6);
                            renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#FFFFFF";
                            renderCircle(0, 0, tmpScale, tmpContext);
                            tmpContext.fillStyle = "#FFFFFF";
                            renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                        } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                            tmpContext.fillStyle = "#FFFFFF";
                            renderCircle(0, 0, reScale, tmpContext);
                            tmpContext.fillStyle = "#FFFFFF";
                            renderRectCircle(0, 0, reScale * 1.5, 29, 4, tmpContext);
                            tmpContext.fillStyle = "#FFFFFF";
                            renderCircle(0, 0, reScale * 0.5, tmpContext);
                        } else if (obj.name == "mine") {
                            tmpContext.fillStyle = "#939393";
                            renderStar(tmpContext, 3, obj.scale, obj.scale);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#bcbcbc";
                            renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                            tmpContext.fill();
                        } else if (obj.name == "sapling") {
                            for (let i = 0; i < 2; ++i) {
                                let tmpScale = obj.scale * (!i ? 1 : 0.5);
                                renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                                tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
                                tmpContext.fill();
                                if (!i) tmpContext.stroke();
                            }
                        } else if (obj.name == "pit trap") {
                            tmpContext.fillStyle = "#a5974c";
                            renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = outlineColor;
                            renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                            tmpContext.fill();
                        } else if (obj.name == "boost pad") {
                            tmpContext.fillStyle = "#7e7f82";
                            renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#dbd97d";
                            renderTriangle(obj.scale * 1, tmpContext);
                        } else if (obj.name == "turret") {
                            tmpContext.fillStyle = "#a5974c";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#939393";
                            let tmpLen = 50;
                            renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                            renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                        } else if (obj.name == "platform") {
                            tmpContext.fillStyle = "#cebd5f";
                            let tmpCount = 4;
                            let tmpS = obj.scale * 2;
                            let tmpW = tmpS / tmpCount;
                            let tmpX = -(obj.scale / 2);
                            for (let i = 0; i < tmpCount; ++i) {
                                renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                                tmpContext.fill();
                                tmpContext.stroke();
                                tmpX += tmpS / tmpCount;
                            }
                        } else if (obj.name == "healing pad") {
                            tmpContext.fillStyle = "#7e7f82";
                            renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#db6e6e";
                            renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                        } else if (obj.name == "spawn pad") {
                            tmpContext.fillStyle = "#7e7f82";
                            renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#71aad6";
                            renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                        } else if (obj.name == "blocker") {
                            tmpContext.fillStyle = "#7e7f82";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.rotate(Math.PI / 4);
                            tmpContext.fillStyle = "#db6e6e";
                            renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                        } else if (obj.name == "teleporter") {
                            tmpContext.fillStyle = "#7e7f82";
                            renderCircle(0, 0, obj.scale, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.rotate(Math.PI / 4);
                            tmpContext.fillStyle = "#d76edb";
                            renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                        }
                    }
                    tmpSprite = tmpCanvas;
                    if (!asIcon)
                        itemSprites[obj.id] = tmpSprite;
                }
                return tmpSprite;
            }

            function getItemSprite2(obj, tmpX, tmpY) {
                let tmpContext = mainContext;
                let reScale = (obj.name == "windmill" ? items.list[4].scale : obj.scale);
                tmpContext.save();
                tmpContext.translate(tmpX, tmpY);
                tmpContext.rotate(obj.dir);
                tmpContext.strokeStyle = outlineColor;
                tmpContext.lineWidth = outlineWidth;
                if (obj.name == "apple") {
                    tmpContext.fillStyle = "#c15555";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#89a54c";
                    let leafDir = -(Math.PI / 2);
                    renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir),
                               25, leafDir + Math.PI / 2, tmpContext);
                } else if (obj.name == "cookie") {
                    tmpContext.fillStyle = "#cca861";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#937c4b";
                    let chips = 4;
                    let rotVal = (Math.PI * 2) / chips;
                    let tmpRange;
                    for (let i = 0; i < chips; ++i) {
                        tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                        renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                     UTILS.randInt(4, 5), tmpContext, true);
                    }
                } else if (obj.name == "cheese") {
                    tmpContext.fillStyle = "#f4f3ac";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#c3c28b";
                    let chips = 4;
                    let rotVal = (Math.PI * 2) / chips;
                    let tmpRange;
                    for (let i = 0; i < chips; ++i) {
                        tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                        renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i),
                                     UTILS.randInt(4, 5), tmpContext, true);
                    }
                } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                    tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
                        "#a5974c" : "#939393";
                    let sides = (obj.name == "castle wall") ? 4 : 3;
                    renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
                        "#c9b758" : "#bcbcbc";
                    renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                    tmpContext.fill();
                } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
                           obj.name == "spinning spikes") {
                    tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
                    let tmpScale = (obj.scale * 0.6);
                    renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, tmpScale, tmpContext);
                    tmpContext.fillStyle = "#c9b758";
                    renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, reScale, tmpContext);
                    tmpContext.fillStyle = "#c9b758";
                    renderRectCircle(0, 0, reScale * 1.5, 29, 4, tmpContext);
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, reScale * 0.5, tmpContext);
                } else if (obj.name == "mine") {
                    tmpContext.fillStyle = "#939393";
                    renderStar(tmpContext, 3, obj.scale, obj.scale);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#bcbcbc";
                    renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                    tmpContext.fill();
                } else if (obj.name == "sapling") {
                    for (let i = 0; i < 2; ++i) {
                        let tmpScale = obj.scale * (!i ? 1 : 0.5);
                        renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                        tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
                        tmpContext.fill();
                        if (!i) tmpContext.stroke();
                    }
                } else if (obj.name == "pit trap") {
                    tmpContext.fillStyle = "#a5974c";
                    renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = outlineColor;
                    renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                    tmpContext.fill();
                } else if (obj.name == "boost pad") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#dbd97d";
                    renderTriangle(obj.scale * 1, tmpContext);
                } else if (obj.name == "turret") {
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#939393";
                    let tmpLen = 50;
                    renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                    renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                } else if (obj.name == "platform") {
                    tmpContext.fillStyle = "#cebd5f";
                    let tmpCount = 4;
                    let tmpS = obj.scale * 2;
                    let tmpW = tmpS / tmpCount;
                    let tmpX = -(obj.scale / 2);
                    for (let i = 0; i < tmpCount; ++i) {
                        renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpX += tmpS / tmpCount;
                    }
                } else if (obj.name == "healing pad") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#db6e6e";
                    renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                } else if (obj.name == "spawn pad") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#71aad6";
                    renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                } else if (obj.name == "blocker") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.rotate(Math.PI / 4);
                    tmpContext.fillStyle = "#db6e6e";
                    renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                } else if (obj.name == "teleporter") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.rotate(Math.PI / 4);
                    tmpContext.fillStyle = "#d76edb";
                    renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                }
                tmpContext.restore();
            }

            let objSprites = [];
            function getObjSprite(obj) {
                let tmpSprite = objSprites[obj.id];
                if (!tmpSprite) {
                    let blurScale = isNight ? 15 : 0;
                    let tmpCanvas = document.createElement("canvas");
                    tmpCanvas.width = tmpCanvas.height = obj.scale * 2.5 + outlineWidth + (items.list[obj.id].spritePadding || 0) + blurScale;
                    let tmpContext = tmpCanvas.getContext("2d");
                    tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                    tmpContext.rotate(Math.PI / 2);
                    tmpContext.strokeStyle = outlineColor;
                    tmpContext.lineWidth = outlineWidth;
                    if (isNight) {
                        tmpContext.shadowBlur = blurScale;
                        tmpContext.shadowColor = `rgba(0, 0, 0, ${Math.min(0.3, obj.alpha)})`;
                    }
                    if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                        tmpContext.fillStyle = obj.name == "poison spikes" ? "#7b935d" : "#939393";
                        let tmpScale = obj.scale * 0.6;
                        renderStar(tmpContext, obj.name == "spikes" ? 5 : 6, obj.scale, tmpScale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, tmpScale, tmpContext);
                        tmpContext.fillStyle = "#cc5151";
                        renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                    } else if (obj.name == "pit trap") {
                        tmpContext.fillStyle = "#a5974c";
                        renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#cc5151";
                        renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    }
                    tmpSprite = tmpCanvas;
                    objSprites[obj.id] = tmpSprite;
                }
                return tmpSprite;
            }

            // GET MARK SPRITE:
            function getMarkSprite(obj, tmpContext, tmpX, tmpY) {
                tmpContext.lineWidth = outlineWidth;
                tmpContext.globalAlpha = 1;
                tmpContext.strokeStyle = outlineColor;
                tmpContext.save();
                tmpContext.translate(tmpX, tmpY);
                tmpContext.rotate(obj.dir);
                if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                    let sides = obj.name == "castle wall" ? 4 : 3;
                    renderHealthStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                    tmpContext.stroke();
                } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                    let tmpScale = obj.scale * 0.6;
                    renderHealthStar(tmpContext, obj.name == "spikes" ? 5 : 6, obj.scale, tmpScale);
                    tmpContext.stroke();
                } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                    renderHealthCircle(0, 0, obj.scale, tmpContext, false, true);
                } else if (obj.name == "mine") {
                    renderHealthStar(tmpContext, 3, obj.scale, obj.scale);
                    tmpContext.stroke();
                } else if (obj.name == "sapling") {
                    let tmpScale = obj.scale * 0.7;
                    renderHealthStar(tmpContext, 7, obj.scale, tmpScale);
                    tmpContext.stroke();
                } else if (obj.name == "pit trap") {
                    renderHealthStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                    tmpContext.stroke();
                } else if (obj.name == "boost pad") {
                    renderHealthRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext, false, true);
                } else if (obj.name == "turret") {
                    renderHealthCircle(0, 0, obj.scale, tmpContext, false, true);
                } else if (obj.name == "platform") {
                    renderHealthRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext, false, true);
                } else if (obj.name == "healing pad") {
                    renderHealthRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext, false, true);
                } else if (obj.name == "spawn pad") {
                    renderHealthRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext, false, true);
                } else if (obj.name == "blocker") {
                    renderHealthCircle(0, 0, obj.scale, tmpContext, false, true);
                } else if (obj.name == "teleporter") {
                    renderHealthCircle(0, 0, obj.scale, tmpContext, false, true);
                }
                tmpContext.restore();
            }
            //renderCircle(tmpObj.x - xOffset, tmpObj.y - yOffset, tmpObj.getScale(0.6, true), mainContext, false, true);

            // OBJECT ON SCREEN:
            function isOnScreen(x, y, s) {
                return (x + s >= 0 && x - s <= maxScreenWidth && y + s >= 0 && (y,
                                                                                s,
                                                                                maxScreenHeight));
            }

// RENDER GAME OBJECTS:
            function renderGameObjects(layer, xOffset, yOffset) {
                let tmpSprite;
                let tmpX;
                let tmpY;
                gameObjects.forEach((tmp) => {
                    tmpObj = tmp;
                    if (tmpObj.alive) {
                        tmpX = tmpObj.x + tmpObj.xWiggle - xOffset;
                        tmpY = tmpObj.y + tmpObj.yWiggle - yOffset;
                        if (layer == 0) {
                            tmpObj.update(delta);
                        }
                        mainContext.globalAlpha = tmpObj.alpha;
                        if (tmpObj.layer == layer && isOnScreen(tmpX, tmpY, tmpObj.scale + (tmpObj.blocker || 0))) {
                            if (tmpObj.isItem) {
                                if ((tmpObj.dmg || tmpObj.trap) && !tmpObj.isTeamObject(player)) {
                                    tmpSprite = getObjSprite(tmpObj);
                                } else {
                                    tmpSprite = getItemSprite(tmpObj);
                                }

                                mainContext.save();
                                mainContext.translate(tmpX, tmpY);
                                mainContext.rotate(tmpObj.dir);
                                if (!tmpObj.active) {
                                    mainContext.scale(tmpObj.visScale / tmpObj.scale, tmpObj.visScale / tmpObj.scale);
                                }
                                mainContext.drawImage(tmpSprite, -(tmpSprite.width / 2), -(tmpSprite.height / 2));

                                if (tmpObj.blocker) {
                                    mainContext.strokeStyle = "#db6e6e";
                                    mainContext.globalAlpha = 0.3;
                                    mainContext.lineWidth = 6;
                                    renderCircle(0, 0, tmpObj.blocker, mainContext, false, true);
                                }
                                mainContext.restore();
                            } else {
                                tmpSprite = getResSprite(tmpObj);
                                mainContext.drawImage(tmpSprite, tmpX - (tmpSprite.width / 2), tmpY - (tmpSprite.height / 2));
                            }
                        }
                        if (layer == 3 && !useWasd) {
                            if (tmpObj.health < tmpObj.maxHealth) {
          var centerX = tmpObj.x - xOffset;
          var centerY = tmpObj.y - yOffset;


          var outerRadius = config.healthBarWidth / 2 + 2;
          var innerRadius = outerRadius - 4;

          var startAngle = -Math.PI / 2;
          var endAngle = startAngle + (tmpObj.maxHealth / tmpObj.health) * (Math.PI * 2);

          // HEALTH HOLDER:
          mainContext.beginPath();
          mainContext.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
          mainContext.arc(centerX, centerY, innerRadius, 0, Math.PI * 2, true);
          mainContext.closePath();
          mainContext.fill();
          mainContext.stroke();

          // HEALTH BAR:

         mainContext.fillStyle = tmpObj.isTeamObject(player) ? "#0088ff" : "#ff1414";
          mainContext.beginPath();
          mainContext.arc(centerX, centerY, outerRadius, startAngle, endAngle);
          mainContext.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
          mainContext.closePath();
          mainContext.fill();
                            }
                        }
                    }
                });

                // PLACE VISIBLE:
                if (layer == 0) {
                    if (placeVisible.length) {
                        placeVisible.forEach((places) => {
                            tmpX = places.x - xOffset;
                            tmpY = places.y - yOffset;
                            markObject(places, tmpX, tmpY);
                        });
                    }
                }
            }
            function markObject(tmpObj, tmpX, tmpY) {
                getMarkSprite(tmpObj, mainContext, tmpX, tmpY);
            }

            // RENDER MINIMAP:
            class MapPing {
                constructor(color, scale) {
                    this.init = function (x, y) {
                        this.scale = 0;
                        this.x = x;
                        this.y = y;
                        this.active = true;
                    };
                    this.update = function (ctxt, delta) {
                        if (this.active) {
                            this.scale += 0.05 * delta;
                            if (this.scale >= scale) {
                                this.active = false;
                            } else {
                                ctxt.globalAlpha = (1 - Math.max(0, this.scale / scale));
                                ctxt.beginPath();
                                ctxt.arc((this.x / config.mapScale) * mapDisplay.width, (this.y / config.mapScale)
                                         * mapDisplay.width, this.scale, 0, 2 * Math.PI);
                                ctxt.stroke();
                            }
                        }
                    };
                    this.color = color;
                }
            }
            function pingMap(x, y) {
                tmpPing = mapPings.find(pings => !pings.active);
                if (!tmpPing) {
                    tmpPing = new MapPing("#fff", config.mapPingScale);
                    mapPings.push(tmpPing);
                }
                tmpPing.init(x, y);
            }
            function updateMapMarker() {
                mapMarker.x = player.x;
                mapMarker.y = player.y;
            }
            function renderMinimap(delta) {
                if (player && player.alive) {
                    mapContext.clearRect(0, 0, mapDisplay.width, mapDisplay.height);

                    // RENDER PINGS:
                    mapContext.lineWidth = 4;
                    for (let i = 0; i < mapPings.length; ++i) {
                        tmpPing = mapPings[i];
                        mapContext.strokeStyle = tmpPing.color;
                        tmpPing.update(mapContext, delta);
                    }

                    // RENDER BREAK TRACKS:
                    mapContext.globalAlpha = 1;
                    mapContext.fillStyle = "#ff0000";
                    if (breakTrackers.length) {
                        mapContext.fillStyle = "#abcdef";
                        mapContext.font = "34px Hammersmith One";
                        mapContext.textBaseline = "middle";
                        mapContext.textAlign = "center";
                        for (let i = 0; i < breakTrackers.length;) {
                            mapContext.fillText("!", (breakTrackers[i].x/config.mapScale)*mapDisplay.width,
                                                (breakTrackers[i].y/config.mapScale)*mapDisplay.height);
                            i += 2;
                        }
                    }

                    // RENDER PLAYERS:
                    mapContext.globalAlpha = 1;
                    mapContext.fillStyle = "#fff";
                    renderCircle((player.x/config.mapScale)*mapDisplay.width,
                                 (player.y/config.mapScale)*mapDisplay.height, 7, mapContext, true);
                    mapContext.fillStyle = "rgba(255,255,255,0.35)";
                    if (player.team && minimapData) {
                        for (let i = 0; i < minimapData.length;) {
                            renderCircle((minimapData[i]/config.mapScale)*mapDisplay.width,
                                         (minimapData[i+1]/config.mapScale)*mapDisplay.height, 7, mapContext, true);
                            i+=2;
                        }
                    }

                    // RENDER BOTS:
                    if (bots.length) {
                        bots.forEach((tmp) => {
                            if (tmp.inGame) {
                                mapContext.globalAlpha = 1;
                                mapContext.strokeStyle = "#cc5151";
                                renderCircle((tmp.x2 / config.mapScale) * mapDisplay.width,
                                             (tmp.y2 / config.mapScale) * mapDisplay.height, 7, mapContext, false, true);
                            }
                        });
                    }

                    // DEATH LOCATION:
                    if (lastDeath) {
                        mapContext.fillStyle = "#fc5553";
                        mapContext.font = "34px Hammersmith One";
                        mapContext.textBaseline = "middle";
                        mapContext.textAlign = "center";
                        mapContext.fillText("x", (lastDeath.x/config.mapScale)*mapDisplay.width,
                                            (lastDeath.y/config.mapScale)*mapDisplay.height);
                    }

                    // MAP MARKER:
                    if (mapMarker) {
                        mapContext.fillStyle = "#fff";
                        mapContext.font = "34px Hammersmith One";
                        mapContext.textBaseline = "middle";
                        mapContext.textAlign = "center";
                        mapContext.fillText("x", (mapMarker.x/config.mapScale)*mapDisplay.width,
                                            (mapMarker.y/config.mapScale)*mapDisplay.height);
                    }
                }
            }

            // ICONS:
            let crossHairs = ["https://i.imgur.com/s2Vq4mH.png", "https://i.imgur.com/s2Vq4mH.png"];
            let crossHairSprites = {};
            let iconSprites = {};
            let icons = ["crown", "skull"];
            function loadIcons() {
                for (let i = 0; i < icons.length; ++i) {
                    let tmpSprite = new Image();
                    tmpSprite.onload = function() {
                        this.isLoaded = true;
                    };
                    tmpSprite.src = "./../img/icons/" + icons[i] + ".png";
                    iconSprites[icons[i]] = tmpSprite;
                }
                for (let i = 0; i < crossHairs.length; ++i) {
                    let tmpSprite = new Image();
                    tmpSprite.onload = function () {
                        this.isLoaded = true;
                    };
                    tmpSprite.src = crossHairs[i];
                    crossHairSprites[i] = tmpSprite;
                }
            }
            loadIcons();

            // UPDATE GAME:
            function updateGame() {

                if (config.resetRender) {
                    mainContext.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
                    mainContext.beginPath();
                }

                if (true) {

                    // MOVE CAMERA:
                    if (player) {
                        if (false) {
                            camX = player.x;
                            camY = player.y;
                        } else {
                            let tmpDist = UTILS.getDistance(camX, camY, player.x, player.y);
                            let tmpDir = UTILS.getDirection(player.x, player.y, camX, camY);
                            let camSpd = Math.min(tmpDist * 0.01 * delta, tmpDist);
                            if (tmpDist > 0.05) {
                                camX += camSpd * Math.cos(tmpDir);
                                camY += camSpd * Math.sin(tmpDir);
                            } else {
                                camX = player.x;
                                camY = player.y;
                            }
                        }
                    } else {
                        camX = config.mapScale / 2;
                        camY = config.mapScale / 2;
                    }

                    // INTERPOLATE PLAYERS AND AI:
                    let lastTime = now - (1000 / config.serverUpdateRate);
                    let tmpDiff;
                    for (let i = 0; i < players.length + ais.length; ++i) {
                        tmpObj = players[i] || ais[i - players.length];
                        if (tmpObj && tmpObj.visible) {
                            if (tmpObj.forcePos) {
                                tmpObj.x = tmpObj.x2;
                                tmpObj.y = tmpObj.y2;
                                tmpObj.dir = tmpObj.d2;
                            } else {
                                let total = tmpObj.t2 - tmpObj.t1;
                                let fraction = lastTime - tmpObj.t1;
                                let ratio = (fraction / total);
                                let rate = 170;
                                tmpObj.dt += delta;
                                let tmpRate = Math.min(1.7, tmpObj.dt / rate);
                                tmpDiff = (tmpObj.x2 - tmpObj.x1);
                                tmpObj.x = tmpObj.x1 + (tmpDiff * tmpRate);
                                tmpDiff = (tmpObj.y2 - tmpObj.y1);
                                tmpObj.y = tmpObj.y1 + (tmpDiff * tmpRate);
                                if (config.anotherVisual) {
                                    tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                                } else {
                                    tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                                }
                            }
                        }
                    }

                    if (player) {
                        if (false) {
                            camX = player.x;
                            camY = player.y;
                        } else {
                            let tmpDist = UTILS.getDistance(camX, camY, player.x, player.y);
                            let tmpDir = UTILS.getDirection(player.x, player.y, camX, camY);
                            let camSpd = Math.min(tmpDist * 0.01 * delta, tmpDist);
                            if (tmpDist > 0.05) {
                                camX += camSpd * Math.cos(tmpDir);
                                camY += camSpd * Math.sin(tmpDir);
                            } else {
                                camX = player.x;
                                camY = player.y;
                            }
                        }
                    } else {
                        camX = config.mapScale / 2;
                        camY = config.mapScale / 2;
                    }

                    // RENDER CORDS:
                    let xOffset = camX - (maxScreenWidth / 2);
                    let yOffset = camY - (maxScreenHeight / 2);

                    // RENDER BACKGROUND:
                    if (config.snowBiomeTop - yOffset <= 0 && config.mapScale - config.snowBiomeTop - yOffset >= maxScreenHeight) {
                        mainContext.fillStyle = "#b6db66";
                        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                    } else if (config.mapScale - config.snowBiomeTop - yOffset <= 0) {
                        mainContext.fillStyle = "#dbc666";
                        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                    } else if (config.snowBiomeTop - yOffset >= maxScreenHeight) {
                        mainContext.fillStyle = "#fff";
                        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                    } else if (config.snowBiomeTop - yOffset >= 0) {
                        mainContext.fillStyle = "#fff";
                        mainContext.fillRect(0, 0, maxScreenWidth, config.snowBiomeTop - yOffset);
                        mainContext.fillStyle = "#b6db66";
                        mainContext.fillRect(0, config.snowBiomeTop - yOffset, maxScreenWidth,
                                             maxScreenHeight - (config.snowBiomeTop - yOffset));
                    } else {
                        mainContext.fillStyle = "#b6db66";
                        mainContext.fillRect(0, 0, maxScreenWidth,
                                             (config.mapScale - config.snowBiomeTop - yOffset));
                        mainContext.fillStyle = "#dbc666";
                        mainContext.fillRect(0, (config.mapScale - config.snowBiomeTop - yOffset), maxScreenWidth,
                                             maxScreenHeight - (config.mapScale - config.snowBiomeTop - yOffset));
                    }

                    // RENDER WATER AREAS:
                    if (!firstSetup) {
                        waterMult += waterPlus * config.waveSpeed * delta;
                        if (waterMult >= config.waveMax) {
                            waterMult = config.waveMax;
                            waterPlus = -1;
                        } else if (waterMult <= 1) {
                            waterMult = waterPlus = 1;
                        }
                        mainContext.globalAlpha = 1;
                        mainContext.fillStyle = "#dbc666";
                        renderWaterBodies(xOffset, yOffset, mainContext, config.riverPadding);
                        mainContext.fillStyle = "#91b2db";
                        renderWaterBodies(xOffset, yOffset, mainContext, (waterMult - 1) * 250);
                    }

                    if (getEl("visualType").value != "smp16") {

                        // RENDER GRID:
                        mainContext.lineWidth = 4;
                        mainContext.strokeStyle = "#000";
                        mainContext.globalAlpha = 0.06;
                        mainContext.beginPath();
                        for (let x = -camX; x < maxScreenWidth; x += useWasd ? 60 : 120) {
                            if (x > 0) {
                                mainContext.moveTo(x, 0);
                                mainContext.lineTo(x, maxScreenHeight);
                            }
                        }
                        for (let y = -camY; y < maxScreenHeight; y += useWasd ? 60 : 120) {
                            if (y > 0) {
                                mainContext.moveTo(0, y);
                                mainContext.lineTo(maxScreenWidth, y);
                            }
                        }
                        mainContext.stroke();

                    }
                    if (player) {

                        // DEATH LOCATION:
                        if (lastDeath) {
                            mainContext.globalAlpha = 1;
                            mainContext.fillStyle = "#fc5553";
                            mainContext.font = "100px Hammersmith One";
                            mainContext.textBaseline = "middle";
                            mainContext.textAlign = "center";
                            mainContext.fillText("x", lastDeath.x - xOffset, lastDeath.y - yOffset);
                        }

                        // PATHFINDER LINE:
                        if (pathFind.active) {
                            if (pathFind.array && (pathFind.chaseNear ? enemy.length : true)) {
                                mainContext.lineWidth = player.scale / 5;
                                mainContext.globalAlpha = 1;
                                mainContext.strokeStyle = "red";
                                mainContext.beginPath();
                                pathFind.array.forEach((path, i) => {
                                    let pathXY = {
                                        x: (pathFind.scale / pathFind.grid) * path.x,
                                        y: (pathFind.scale / pathFind.grid) * path.y
                                    }
                                    let render = {
                                        x: ((player.x2 - (pathFind.scale / 2)) + pathXY.x) - xOffset,
                                        y: ((player.y2 - (pathFind.scale / 2)) + pathXY.y) - yOffset
                                    }
                                    if (i == 0) {
                                        mainContext.moveTo(render.x, render.y);
                                    } else {
                                        mainContext.lineTo(render.x, render.y);
                                    }
                                });
                                mainContext.stroke();
                            }
                        }

                    }

                    // RENDER DEAD PLAYERS:
                    mainContext.globalAlpha = 1;
                    mainContext.strokeStyle = outlineColor;
                    renderDeadPlayers(xOffset, yOffset);

                    // RENDER BOTTOM LAYER:
                    mainContext.globalAlpha = 1;
                    mainContext.strokeStyle = outlineColor;
                    renderGameObjects(-1, xOffset, yOffset);

                    // RENDER PROJECTILES:
                    mainContext.globalAlpha = 1;
                    mainContext.lineWidth = outlineWidth;
                    renderProjectiles(0, xOffset, yOffset);

                    // RENDER PLAYERS:
                    renderPlayers(xOffset, yOffset, 0);

                    // RENDER AI:
                    mainContext.globalAlpha = 1;
                    for (let i = 0; i < ais.length; ++i) {
                        tmpObj = ais[i];
                        if (tmpObj.active && tmpObj.visible) {
                            tmpObj.animate(delta);
                            mainContext.save();
                            mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                            mainContext.rotate(tmpObj.dir + tmpObj.dirPlus - (Math.PI / 2));
                            renderAI(tmpObj, mainContext);
                            mainContext.restore();
                        }
                    }

                    // RENDER GAME OBJECTS (LAYERED):
                    renderGameObjects(0, xOffset, yOffset);
                    renderProjectiles(1, xOffset, yOffset);
                    renderGameObjects(1, xOffset, yOffset);
                    renderPlayers(xOffset, yOffset, 1);
                    renderGameObjects(2, xOffset, yOffset);
                    renderGameObjects(3, xOffset, yOffset);

                    // MAP BOUNDARIES:
                    mainContext.fillStyle = "#000";
                    mainContext.globalAlpha = 0.09;
                    if (xOffset <= 0) {
                        mainContext.fillRect(0, 0, -xOffset, maxScreenHeight);
                    } if (config.mapScale - xOffset <= maxScreenWidth) {
                        let tmpY = Math.max(0, -yOffset);
                        mainContext.fillRect(config.mapScale - xOffset, tmpY, maxScreenWidth - (config.mapScale - xOffset), maxScreenHeight - tmpY);
                    } if (yOffset <= 0) {
                        mainContext.fillRect(-xOffset, 0, maxScreenWidth + xOffset, -yOffset);
                    } if (config.mapScale - yOffset <= maxScreenHeight) {
                        let tmpX = Math.max(0, -xOffset);
                        let tmpMin = 0;
                        if (config.mapScale - xOffset <= maxScreenWidth)
                            tmpMin = maxScreenWidth - (config.mapScale - xOffset);
                        mainContext.fillRect(tmpX, config.mapScale - yOffset,
                                             (maxScreenWidth - tmpX) - tmpMin, maxScreenHeight - (config.mapScale - yOffset));
                    }

        // RENDER DAY/NIGHT TIME:
        mainContext.globalAlpha = 1;
        if(getEl("timeType").value == "eveningt") {
            mainContext.fillStyle = "rgba(0, 0, 70, 0.50)";
            mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
        } else if(getEl("timeType").value == "nightt") {
            mainContext.fillStyle = "rgba(0, 0, 70, 0.60)";
            mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
        } else if(getEl("timeType").value == "morningt") {
            mainContext.fillStyle = "rgba(0, 0, 70, 0.30)";
            mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
        } else if(getEl("timeType").value == "afternoont") {
            mainContext.fillStyle = "rgba(0, 0, 70, 0.40)";
            mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
        }
        mainContext.fillStyle = "rgba(0, 0, 70, 0.35)";
        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);


                    // RENDER PLAYER AND AI UI:
                    mainContext.strokeStyle = darkOutlineColor;
                    mainContext.globalAlpha = 1;
                    for (let i = 0; i < players.length + ais.length; ++i) {
                        tmpObj = players[i] || ais[i - players.length];
                        if (tmpObj.visible) {
                            mainContext.strokeStyle = darkOutlineColor;

                            // NAME AND HEALTH:
                            if (tmpObj.skinIndex != 10 || (tmpObj==player) || (tmpObj.team && tmpObj.team==player.team)) {
                            let tmpText = ((tmpObj.isPlayer && getEl("visualType").value == "smp16") ? `${tmpObj.shameCount} / ` : '') + (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (tmpObj.name || "") + ((tmpObj.isPlayer && getEl("visualType").value != "ueh") ? " {" + tmpObj.sid + "}" : "");
                                if (tmpText != "") {
                                    mainContext.font = (tmpObj.nameScale||30) + "px Hammersmith One";
                                    mainContext.fillStyle = "#fff";
                                    mainContext.textBaseline = "middle";
                                    mainContext.textAlign = "center";
                                    mainContext.lineWidth = (tmpObj.nameScale?11:8);
                                    mainContext.lineJoin = "round";
                                    mainContext.strokeText(tmpText, tmpObj.x - xOffset, (tmpObj.y - yOffset - tmpObj.scale) - config.nameY);
                                    mainContext.fillText(tmpText, tmpObj.x - xOffset, (tmpObj.y - yOffset - tmpObj.scale) - config.nameY);
                                    if (tmpObj.isLeader && iconSprites["crown"].isLoaded) {
                                        let tmpS = config.crownIconScale;
                                        let tmpX = tmpObj.x - xOffset - (tmpS/2) - (mainContext.measureText(tmpText).width / 2) - config.crownPad;
                                        mainContext.drawImage(iconSprites["crown"], tmpX, (tmpObj.y - yOffset - tmpObj.scale)
                                                              - config.nameY - (tmpS/2) - 5, tmpS, tmpS);
                                    } if (tmpObj.iconIndex == 1 && iconSprites["skull"].isLoaded) {
                                        let tmpS = config.crownIconScale / 1;
                                        let tmpX = tmpObj.x - xOffset - (tmpS/2) + (mainContext.measureText(tmpText).width / 2) + config.crownPad;
                                        mainContext.drawImage(iconSprites["skull"], tmpX, (tmpObj.y - yOffset - tmpObj.scale)
                                                              - config.nameY - (tmpS/2) - 5, tmpS, tmpS);
                                    } if (tmpObj.isPlayer && instaC.wait && near == tmpObj && (tmpObj.backupNobull ? crossHairSprites[1].isLoaded : crossHairSprites[0].isLoaded) && enemy.length) {
                                        let tmpS = tmpObj.scale * 2.2;
                                        mainContext.drawImage((tmpObj.backupNobull ? crossHairSprites[1] : crossHairSprites[0]), tmpObj.x - xOffset - tmpS / 2, tmpObj.y - yOffset - tmpS / 2, tmpS, tmpS);
                                    }
                                } if (tmpObj.health > 0) {

                                    // HEALTH HOLDER:
                                    mainContext.fillStyle = darkOutlineColor;
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad,
                                                          (tmpObj.y - yOffset + tmpObj.scale) + config.nameY, (config.healthBarWidth * 2) +
                                                          (config.healthBarPad * 2), 17, 8);
                                    mainContext.fill();

                                    // HEALTH BAR:
                                    mainContext.fillStyle = (tmpObj==player||(tmpObj.team&&tmpObj.team==player.team))?"#8ecc51":"#cc5151";
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                                                          (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + config.healthBarPad,
                                                          ((config.healthBarWidth * 2) * (tmpObj.health / tmpObj.maxHealth)), 17 - config.healthBarPad * 2, 7);
                                    mainContext.fill();

                                    if (tmpObj.isPlayer) {

                                        mainContext.globalAlpha = 1;

                                        if (getEl("visualType").value == "smp16") {
                                            let reloads = {
                                                primary: (tmpObj.primaryIndex == undefined ? 1 : ((items.weapons[tmpObj.primaryIndex].speed - tmpObj.reloads[tmpObj.primaryIndex]) / items.weapons[tmpObj.primaryIndex].speed)),
                                                secondary: (tmpObj.secondaryIndex == undefined ? 1 : ((items.weapons[tmpObj.secondaryIndex].speed - tmpObj.reloads[tmpObj.secondaryIndex]) / items.weapons[tmpObj.secondaryIndex].speed)),
                                                turret: (2500 - tmpObj.reloads[53]) / 2500
                                            };

                                            // SECONDARY RELOAD HOLDER:
                                            mainContext.fillStyle = darkOutlineColor;
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarPad,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY - 13, config.healthBarWidth +
                                                                  (config.healthBarPad * 2), 17, 8);
                                            mainContext.fill();

                                            // SECONDARY RELOAD BAR:
                                            mainContext.fillStyle = "#136E6E";
                                            mainContext.roundRect(tmpObj.x - xOffset,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY - 13 + config.healthBarPad,
                                                                  (config.healthBarWidth * reloads.secondary), 17 - config.healthBarPad * 2, 7);
                                            mainContext.fill();

                                            // PRIMARY RELOAD HOLDER:
                                            mainContext.fillStyle = darkOutlineColor;
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY - 13, config.healthBarWidth +
                                                                  (config.healthBarPad * 2), 17, 8);
                                            mainContext.fill();

                                            // PRIMARY RELOAD BAR:
                                            mainContext.fillStyle = "#136E6E";
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY - 13 + config.healthBarPad,
                                                                  (config.healthBarWidth * reloads.primary), 17 - config.healthBarPad * 2, 7);
                                            mainContext.fill();
                                        } else {
                                            mainContext.fillStyle = "#136E6E";
                                            if (tmpObj.primaryIndex == undefined ? false : (tmpObj.reloads[tmpObj.primaryIndex] > 0)) {
                                                // PRIMARY RELOAD BAR:
                                                mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                                                                      (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + config.healthBarPad,
                                                                      (config.healthBarWidth * (tmpObj.reloads[tmpObj.primaryIndex] / items.weapons[tmpObj.primaryIndex].speed)), 17 - config.healthBarPad * 2, 7);
                                                mainContext.fill();
                                            }
                                            if (tmpObj.secondaryIndex == undefined ? false : (tmpObj.reloads[tmpObj.secondaryIndex] > 0)) {
                                                // SECONDARY RELOAD BAR:
                                                mainContext.roundRect(tmpObj.x - xOffset + (config.healthBarWidth * ((items.weapons[tmpObj.secondaryIndex].speed - tmpObj.reloads[tmpObj.secondaryIndex]) / items.weapons[tmpObj.secondaryIndex].speed)),
                                                                      (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + config.healthBarPad,
                                                                      (config.healthBarWidth * (tmpObj.reloads[tmpObj.secondaryIndex] / items.weapons[tmpObj.secondaryIndex].speed)), 17 - config.healthBarPad * 2, 7);
                                                mainContext.fill();
                                            }

                                        }

                                        if (tmpObj == player) {

                                            /*
                                            // TURRET RELOAD HOLDER:
                                            mainContext.fillStyle = darkOutlineColor;
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + 13, (config.healthBarWidth * 2) +
                                                                  (config.healthBarPad * 2), 17, 8);
                                            mainContext.fill();

                                            // TURRET RELOAD BAR:
                                            mainContext.fillStyle = "#cc5151";
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                                                                  (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + 13 + config.healthBarPad,
                                                                  ((config.healthBarWidth * 2) * reloads.turret), 17 - config.healthBarPad * 2, 7);
                                            mainContext.fill();
                                            */

                                            // RENDER DIR:
                                            if (tmpObj.dir != undefined) {
                                                mainContext.fillStyle = "#fff";
                                                mainContext.globalAlpha = 0.75;
                                                renderCircle(tmpObj.x + (Math.cos(tmpObj.dir) * items.weapons[player.weapons[0]].range) - xOffset, tmpObj.y + (Math.sin(tmpObj.dir) * items.weapons[player.weapons[0]].range) - yOffset, 5, mainContext, true, false);
                                            }

                                        }

                                        // UNDER TEXT:
                                        mainContext.globalAlpha = 1;
                                        mainContext.font = "20px Hammersmith One";
                                        mainContext.fillStyle = "#fff";
                                        mainContext.strokeStyle = darkOutlineColor;
                                        mainContext.textBaseline = "middle";
                                        mainContext.textAlign = "center";
                                        mainContext.lineWidth = 8;
                                        mainContext.lineJoin = "round";
                                        let text = [];
                                        if (tmpObj == player) {
                                            /*if (getEl("visualType").value == "smp16") {
                                                text = [tmpObj.oldSkinIndex, tmpObj.skinIndex];
                                                mainContext.strokeText("[" + text.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                                mainContext.fillText("[" + text.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            }*/
                                        } else {
                                            text = [tmpObj.primaryIndex, (tmpObj.secondaryIndex || 0), UTILS.fixTo(tmpObj.damageThreat, 2)];
                                            mainContext.strokeText("[" + text.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            mainContext.fillText("[" + text.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                        }

                                        // SHAME COUNT:
                                        mainContext.globalAlpha = 1;
                                        mainContext.font = "21px Hammersmith One";
                                        mainContext.fillStyle = (tmpObj==player||(tmpObj.team&&tmpObj.team==player.team))? "#8ecc51" : "#cc5151";
                                        mainContext.strokeStyle = "#000";
                                        mainContext.textBaseline = "middle";
                                        mainContext.textAlign = "center";
                                        mainContext.lineWidth = tmpObj.nameScale ? 11 : 8;
                                        mainContext.lineJoin = "round";
                                        var tmpS = config.crownIconScale;
                                        var tmpX = tmpObj.x - xOffset - tmpS / 2 + mainContext.measureText(tmpText).width / 2 + config.crownPad + (tmpObj.iconIndex == 1 ? (tmpObj.nameScale || 30) * 2.75 : tmpObj.nameScale || 30);
                                    mainContext.strokeText(tmpObj.shameCount, tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 30 * -2.2);
                                    mainContext.fillText(tmpObj.shameCount, tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 30 * -2.2);
                                        // PLAYER TRACER:
                                        if (!tmpObj.isTeam(player)) {
                                            let center = {
                                                x: screenWidth / 2,
                                                y: screenHeight / 2,
                                            };
                                            let alpha = Math.min(1, (UTILS.getDistance(0, 0, player.x - tmpObj.x, (player.y - tmpObj.y) * (16 / 9)) * 100) / (config.maxScreenHeight / 2) / center.y);
                                            let dist = center.y * alpha;
                                            let tmpX = dist * Math.cos(UTILS.getDirect(tmpObj, player, 0, 0));
                                            let tmpY = dist * Math.sin(UTILS.getDirect(tmpObj, player, 0, 0));
                                            mainContext.save();
                                            mainContext.translate((player.x - xOffset) + tmpX, (player.y - yOffset) + tmpY);
                                            mainContext.rotate(tmpObj.aim2 + Math.PI / 2);
                                            let by = 255 - (tmpObj.sid * 2);
                                            mainContext.fillStyle = `rgb(${by}, ${by}, ${by})`;
                                            mainContext.globalAlpha = alpha;
                                            let renderTracer = function(s, ctx) {
                                                ctx = ctx || mainContext;
                                                let h = s * (Math.sqrt(3) / 2);
                                                ctx.beginPath();
                                                ctx.moveTo(0, -h / 1.5);
                                                ctx.lineTo(-s / 2, h / 2);
                                                ctx.lineTo(s / 2, h / 2);
                                                ctx.lineTo(0, -h / 1.5);
                                                ctx.fill();
                                                ctx.closePath();
                                            }
                                            renderTracer(25, mainContext);
                                            mainContext.restore();
                                        }

                                        if (getEl("predictType").value == "pre2") {
                                            mainContext.lineWidth = 3;
                                            mainContext.strokeStyle = "#cc5151";
                                            mainContext.globalAlpha = 1;
                                            mainContext.beginPath();
                                            let render = {
                                                x: tmpObj.x2 - xOffset,
                                                y: tmpObj.y2 - yOffset
                                            };
                                            mainContext.moveTo(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                            mainContext.lineTo(render.x, render.y);
                                            mainContext.stroke();
                                        } else if (getEl("predictType").value == "pre3") {
                                            mainContext.lineWidth = 3;
                                            mainContext.strokeStyle = "#cc5151";
                                            mainContext.globalAlpha = 1;
                                            mainContext.beginPath();
                                            let render = {
                                                x: tmpObj.x3 - xOffset,
                                                y: tmpObj.y3 - yOffset
                                            };
                                            mainContext.moveTo(tmpObj.x - xOffset, tmpObj.y - yOffset);
                                            mainContext.lineTo(render.x, render.y);
                                            mainContext.stroke();
                                        }

                                    }
                                }
                            }
                        }
                    }

                    if (player) {

                        // AUTOPUSH LINE:
                        if (my.autoPush) {
                            mainContext.lineWidth = 5;
                            mainContext.globalAlpha = 1;
                            mainContext.beginPath();

                            mainContext.strokeStyle = "#fffffb";
                            mainContext.moveTo(player.x - xOffset, player.y - yOffset);
                            mainContext.lineTo(my.pushData.x2 - xOffset, my.pushData.y2 - yOffset);
                            mainContext.lineTo(my.pushData.x - xOffset, my.pushData.y - yOffset);
                            mainContext.stroke();
                        }

                        // FUNNY:
                        if (petals.length && getEl("funni").checked) {

                            player.spinDir += 2.5 / 60;
                            let maxRad = 0;
                            if (clicks.left) {
                                maxRad = 100;
                            } else if (clicks.right) {
                                maxRad = 15;
                            } else {
                                maxRad = 40;
                            }
                            maxRad += player.scale;

                            petals.forEach((petal, i) => {
                                if (petal.active) {
                                    let petalRad = (Math.PI * (i / (petals.length / 2)));
                                    let pl = {
                                        x: player.x + (maxRad * Math.cos(player.spinDir + petalRad)),
                                        y: player.y + (maxRad * Math.sin(player.spinDir + petalRad))
                                    };
                                    let angle = UTILS.getDirect(pl, petal, 0, 0);
                                    let dist = UTILS.getDist(pl, petal, 0, 0);
                                    petal.x += (dist / 7) * Math.cos(angle);
                                    petal.y += (dist / 7) * Math.sin(angle);

                                    players.filter((tmp) => tmp.visible && tmp != player).forEach((tmp) => {
                                        let angle = UTILS.getDirect(petal, tmp, 0, 0);
                                        let dist = UTILS.getDist(petal, tmp, 0, 0);
                                        let sc = petal.scale + tmp.scale;
                                        if (dist <= sc) {
                                            let tD = dist - sc;
                                            let diff = -tD;
                                            petal.x += diff * Math.cos(angle);
                                            petal.y += diff * Math.sin(angle);
                                            petal.health -= 10;
                                            petal.damaged += 125;
                                            if (petal.health <= 0) {
                                                petal.active = false;
                                            }
                                        }
                                    });

                                } else {
                                    petal.time += delta;

                                    if (petal.alive) {
                                        petal.alpha -= delta / 200;
                                        petal.visScale += delta / (petal.scale * 2);
                                        if (petal.alpha <= 0) {
                                            petal.alpha = 0;
                                            petal.alive = false;
                                        }
                                    }

                                    if (petal.time >= petal.timer) {
                                        petal.time = 0;
                                        petal.active = true;
                                        petal.alive = true;
                                        petal.x = player.x;
                                        petal.y = player.y;
                                        petal.health = petal.maxHealth;
                                        petal.damaged = 0;
                                        petal.alpha = 1;
                                        petal.visScale = petal.scale;
                                    }
                                }

                                if (petal.alive) {

                                    let cD = function(r, g, b, dmg) {
                                        return "rgb(" + `${Math.min(255, r + Math.floor(dmg))}, ${Math.max(0, g - Math.floor(dmg))}, ${Math.max(0, b - Math.floor(dmg))}` + ")";
                                    }

                                    mainContext.globalAlpha = petal.alpha;
                                    mainContext.lineWidth = 3;
                                    mainContext.fillStyle = cD(255, 255, 255, petal.damaged);
                                    mainContext.strokeStyle = cD(200, 200, 200, petal.damaged);
                                    mainContext.beginPath();
                                    mainContext.arc(petal.x - xOffset, petal.y - yOffset, petal.visScale, 0, Math.PI * 2);
                                    mainContext.fill();
                                    mainContext.stroke();

                                    petal.damaged = Math.max(0, petal.damaged - (delta / 2));

                                }

                            });
                        }

                    }

                    mainContext.globalAlpha = 1;

                    // RENDER ANIM TEXTS:
                    textManager.update(delta, mainContext, xOffset, yOffset);

                    // RENDER CHAT MESSAGES:
                    for (let i = 0; i < players.length; ++i) {
                        tmpObj = players[i];
                        if (tmpObj.visible) {
                            if (tmpObj.chatCountdown > 0) {
                                tmpObj.chatCountdown -= delta;
                                if (tmpObj.chatCountdown <= 0)
                                    tmpObj.chatCountdown = 0;
                                mainContext.font = "24px Sans Serif";
                                let tmpSize = mainContext.measureText(tmpObj.chatMessage);
                                mainContext.textBaseline = "middle";
                                mainContext.textAlign = "center";
                                let tmpX = tmpObj.x - xOffset;
                                let tmpY = tmpObj.y - tmpObj.scale - yOffset - 90;
                                let tmpH = 47;
                                let tmpW = tmpSize.width + 17;
                                mainContext.fillStyle = "rgba(0,0,0,0.2)";
                                mainContext.roundRect(tmpX-tmpW/2, tmpY-tmpH/2, tmpW, tmpH, 6);
                                mainContext.fill();
                                mainContext.fillStyle = "#fff";
                                mainContext.fillText(tmpObj.chatMessage, tmpX, tmpY);
                            }
                            if (tmpObj.chat.count > 0) {
                                if (!useWasd) {
                                    tmpObj.chat.count -= delta;
                                    if (tmpObj.chat.count <= 0)
                                        tmpObj.chat.count = 0;
                                    mainContext.font = "32px Hammersmith One";
                                    let tmpSize = mainContext.measureText(tmpObj.chat.message);
                                    mainContext.textBaseline = "middle";
                                    mainContext.textAlign = "center";
                                    let tmpX = tmpObj.x - xOffset;
                                    let tmpY = tmpObj.y - tmpObj.scale - yOffset + (90 * 2);
                                    let tmpH = 47;
                                    let tmpW = tmpSize.width + 17;
                                    mainContext.fillStyle = "rgba(0,0,0,0.2)";
                                    mainContext.roundRect(tmpX-tmpW/2, tmpY-tmpH/2, tmpW, tmpH, 6);
                                    mainContext.fill();
                                    mainContext.fillStyle = "#ffffff99";
                                    mainContext.fillText(tmpObj.chat.message, tmpX, tmpY);
                                } else {
                                    tmpObj.chat.count = 0;
                                }
                            }
                        }
                    }

                    if (allChats.length) {
                        allChats.filter(ch => ch.active).forEach((ch) => {
                            if (!ch.alive) {
                                if (ch.alpha <= 1) {
                                    ch.alpha += delta / 250;
                                    if (ch.alpha >= 1) {
                                        ch.alpha = 1;
                                        ch.alive = true;
                                    }
                                }
                            } else {
                                ch.alpha -= delta / 5000;
                                if (ch.alpha <= 0) {
                                    ch.alpha = 0;
                                    ch.active = false;
                                }
                            }
                            if (ch.active) {
                                mainContext.font = "21px Ubuntu";
                                let tmpSize = mainContext.measureText(ch.chat);
                                mainContext.textBaseline = "middle";
                                mainContext.textAlign = "center";
                                let tmpX = ch.x - xOffset;
                                let tmpY = ch.y - yOffset - 90;
                                let tmpH = 40;
                                let tmpW = tmpSize.width + 15;

                                mainContext.globalAlpha = ch.alpha;

                                mainContext.fillStyle = ch.owner.isTeam(player) ? "#3877ff" : "#ff1f1f";
                                mainContext.strokeStyle = "rgb(25, 25, 25)";
                                mainContext.strokeText(ch.owner.name, tmpX, tmpY - 45);
                                mainContext.fillText(ch.owner.name, tmpX, tmpY - 45);

                                mainContext.lineWidth = 5;
                                mainContext.fillStyle = "#ccc";
                                mainContext.strokeStyle = "rgb(25, 25, 25)";

                                mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                                mainContext.stroke();
                                mainContext.fill();

                                mainContext.fillStyle = "#fff";
                                mainContext.strokeStyle = "#000";
                                mainContext.strokeText(ch.chat, tmpX, tmpY);
                                mainContext.fillText(ch.chat, tmpX, tmpY);
                                ch.y -= delta / 100;
                            }
                        });
                    }
                }

                mainContext.globalAlpha = 1;

                // RENDER MINIMAP:
                renderMinimap(delta);
            }

            // UPDATE & ANIMATE:
            window.requestAnimFrame = function() {
                return null;
            }
            window.rAF = (function() {
                return window.requestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    function(callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
            })();
            function doUpdate() {
                now = performance.now();
                delta = now - lastUpdate;
                lastUpdate = now;

                let timer = performance.now();
                let diff = timer - fpsTimer.last;
                if (diff >= 1000) {

                    fpsTimer.ltime = fpsTimer.time * (1000 / diff);

                    fpsTimer.last = timer;
                    fpsTimer.time = 0;
                }
                fpsTimer.time++;

                getEl("pingFps").innerHTML = `${window.pingTime}ms | Fps: ${UTILS.round(fpsTimer.ltime, 10)}`;
                getEl("packetStatus").innerHTML = secPacket;
                updateGame();
                rAF(doUpdate);
            }
            prepareMenuBackground();
            doUpdate();

            function toggleUseless(boolean) {
                getEl("instaType").disabled = boolean;
                getEl("antiBullType").disabled = boolean;
                getEl("predictType").disabled = boolean;
                getEl("visualType").disabled = boolean;
            }
            toggleUseless(useWasd);

            let changeDays = {};
            window.debug = function() {
                my.waitHit = 0;
                my.autoAim = false;
                instaC.isTrue = false;
                traps.inTrap = false;
                itemSprites = [];
                objSprites = [];
                gameObjectSprites = [];
            };
            window.toggleNight = function() {
                clearTimeout(changeDays);
                if (nightMode.style.animationName == "night1") {
                    nightMode.style.animationName = "night2";
                    nightMode.style.opacity = 0;
                    changeDays = setTimeout(() => {
                        nightMode.style.display = "none";
                    }, 1000 * parseFloat(nightMode.style.animationDuration));
                } else {
                    nightMode.style.animationName = "night1";
                    nightMode.style.opacity = 0.35;
                    nightMode.style.display = "block";
                }
                isNight = !isNight;
                itemSprites = [];
                objSprites = [];
                gameObjectSprites = [];
            };
            window.wasdMode = function() {
                useWasd = !useWasd;
                toggleUseless(useWasd);
            };
            window.startGrind = function() {
                if (getEl("weaponGrind").checked) {
                    for (let i = 0; i < Math.PI*2; i+= Math.PI/2) {
                        checkPlace(player.getItemType(22), i);
                    }
                }
            };
            // REMOVED!!! so they cant abuse :)
            let projects = [];
            let botIDS = 0;
            window.connectFillBots = function() {
                botSkts = [];
                botIDS = 0;
                for (let i = 0; i < projects.length; i++) {
                    let test = new WebSocket(`wss://${projects[i]}.glitch.me`);
                    test.binaryType = "arraybuffer";

                    test.onopen = function() {
                        test.ssend = function(type) {
                            let data = Array.prototype.slice.call(arguments, 1);
                            let binary = window.msgpack.encode([type, data]);
                            test.send(binary);
                        };
                        for (let i = 0; i < 4; i++) {
                            window.grecaptcha.execute("6LevKusUAAAAAAFknhlV8sPtXAk5Z5dGP5T2FYIZ", {
                                action: "homepage"
                            }).then(function (token) {
                                test.ssend("bots", WS.url.split("&")[0] + "&token=" + encodeURIComponent(token), botIDS);
                                botSkts.push([test]);
                                botIDS++;
                            });
                        }
                    };
                    test.onmessage = function(message) {
                        let data = new Uint8Array(message.data);
                        let parsed = window.msgpack.decode(data);
                        let type = parsed[0];
                        data = parsed[1];
                    };
                }
            };
            window.tryConnectBots = function() {
                for (let i = 0; i < (bots.length < 3 ? 3 : 4); i++) {
                    window.grecaptcha.execute("6LevKusUAAAAAAFknhlV8sPtXAk5Z5dGP5T2FYIZ", {
                        action: "homepage"
                    }).then(function (token) {
                        // CONNECT SOCKET:
                        botSpawn(token);
                    });
                }
            };
            window.destroyBots = function() {
                bots.forEach((botyyyyy)=>{
                    botyyyyy.closeSocket = true;
                });
                bots = [];
            };
            window.resBuild = function() {
                if (gameObjects.length) {
                    gameObjects.forEach((tmp) => {
                        tmp.breakObj = false;
                    });
                    breakObjects = [];
                }
            };
            window.toggleBotsCircle = function() {
                player.circle = !player.circle;
            };
            window.toggleVisual = function() {
                config.anotherVisual = !config.anotherVisual;
                gameObjects.forEach((tmp) => {
                    if (tmp.active) {
                        tmp.dir = tmp.lastDir;
                    }
                });
            };
            window.prepareUI = function(tmpObj) {
                resize();
                // ACTION BAR:
                UTILS.removeAllChildren(actionBar);
                for (let i = 0; i < (items.weapons.length + items.list.length); ++i) {
                    (function(i) {
                        UTILS.generateElement({
                            id: "actionBarItem" + i,
                            class: "actionBarItem",
                            style: "display:none",
                            onmouseout: function() {
                                showItemInfo();
                            },
                            parent: actionBar
                        });
                    })(i);
                }
                for (let i = 0; i < (items.list.length + items.weapons.length); ++i) {
                    (function(i) {
                        let tmpCanvas = document.createElement("canvas");
                        tmpCanvas.width = tmpCanvas.height = 66;
                        let tmpContext = tmpCanvas.getContext("2d");
                        tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                        tmpContext.imageSmoothingEnabled = false;
                        tmpContext.webkitImageSmoothingEnabled = false;
                        tmpContext.mozImageSmoothingEnabled = false;
                        if (items.weapons[i]) {
                            tmpContext.rotate((Math.PI/4)+Math.PI);
                            let tmpSprite = new Image();
                            toolSprites[items.weapons[i].src] = tmpSprite;
                            tmpSprite.onload = function() {
                                this.isLoaded = true;
                                let tmpPad = 1 / (this.height / this.width);
                                let tmpMlt = (items.weapons[i].iPad || 1);
                                tmpContext.drawImage(this, -(tmpCanvas.width*tmpMlt*config.iconPad*tmpPad)/2, -(tmpCanvas.height*tmpMlt*config.iconPad)/2,
                                                     tmpCanvas.width*tmpMlt*tmpPad*config.iconPad, tmpCanvas.height*tmpMlt*config.iconPad);
                                tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                                tmpContext.globalCompositeOperation = "source-atop";
                                tmpContext.fillRect(-tmpCanvas.width / 2, -tmpCanvas.height / 2, tmpCanvas.width, tmpCanvas.height);
                                getEl('actionBarItem' + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                            };
                            tmpSprite.src = "./../img/weapons/" + items.weapons[i].src + ".png";
                            let tmpUnit = getEl('actionBarItem' + i);
                            tmpUnit.onmouseover = UTILS.checkTrusted(function() {
                                showItemInfo(items.weapons[i], true);
                            });
                            tmpUnit.onclick = UTILS.checkTrusted(function() {
                                selectWeapon(tmpObj.weapons[items.weapons[i].type]);
                            });
                            UTILS.hookTouchEvents(tmpUnit);
                        } else {
                            let tmpSprite = getItemSprite(items.list[i-items.weapons.length], true);
                            let tmpScale = Math.min(tmpCanvas.width - config.iconPadding, tmpSprite.width);
                            tmpContext.globalAlpha = 1;
                            tmpContext.drawImage(tmpSprite, -tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                            tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                            tmpContext.globalCompositeOperation = "source-atop";
                            tmpContext.fillRect(-tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                            getEl('actionBarItem' + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                            let tmpUnit = getEl('actionBarItem' + i);
                            tmpUnit.onmouseover = UTILS.checkTrusted(function() {
                                showItemInfo(items.list[i - items.weapons.length]);
                            });
                            tmpUnit.onclick = UTILS.checkTrusted(function() {
                                selectToBuild(tmpObj.items[tmpObj.getItemType(i - items.weapons.length)]);
                            });
                            UTILS.hookTouchEvents(tmpUnit);
                        }
                    })(i);
                }
            };
            window.profineTest = function(data) {
                if (data) {
                    // SET INITIAL NAME:
                    let noname = "unknown";

                    // VALIDATE NAME:
                    let name = data + "";
                    name = name.slice(0, config.maxNameLength);
                    name = name.replace(/[^\w:\(\)\/? -]+/gmi, " ");  // USE SPACE SO WE CAN CHECK PROFANITY
                    name = name.replace(/[^\x00-\x7F]/g, " ");
                    name = name.trim();

                    let langFilter = {
                        "list": [
                            "ahole",
                            "anus",
                            "ash0le",
                            "ash0les",
                            "asholes",
                            "ass",
                            "Ass Monkey",
                            "Assface",
                            "assh0le",
                            "assh0lez",
                            "asshole",
                            "assholes",
                            "assholz",
                            "asswipe",
                            "azzhole",
                            "bassterds",
                            "bastard",
                            "bastards",
                            "bastardz",
                            "basterds",
                            "basterdz",
                            "Biatch",
                            "bitch",
                            "bitches",
                            "Blow Job",
                            "boffing",
                            "butthole",
                            "buttwipe",
                            "c0ck",
                            "c0cks",
                            "c0k",
                            "Carpet Muncher",
                            "cawk",
                            "cawks",
                            "Clit",
                            "cnts",
                            "cntz",
                            "cock",
                            "cockhead",
                            "cock-head",
                            "cocks",
                            "CockSucker",
                            "cock-sucker",
                            "crap",
                            "cum",
                            "cunt",
                            "cunts",
                            "cuntz",
                            "dick",
                            "dild0",
                            "dild0s",
                            "dildo",
                            "dildos",
                            "dilld0",
                            "dilld0s",
                            "dominatricks",
                            "dominatrics",
                            "dominatrix",
                            "dyke",
                            "enema",
                            "f u c k",
                            "f u c k e r",
                            "fag",
                            "fag1t",
                            "faget",
                            "fagg1t",
                            "faggit",
                            "faggot",
                            "fagg0t",
                            "fagit",
                            "fags",
                            "fagz",
                            "faig",
                            "faigs",
                            "fart",
                            "flipping the bird",
                            "fuck",
                            "fucker",
                            "fuckin",
                            "fucking",
                            "fucks",
                            "Fudge Packer",
                            "fuk",
                            "Fukah",
                            "Fuken",
                            "fuker",
                            "Fukin",
                            "Fukk",
                            "Fukkah",
                            "Fukken",
                            "Fukker",
                            "Fukkin",
                            "g00k",
                            "God-damned",
                            "h00r",
                            "h0ar",
                            "h0re",
                            "hells",
                            "hoar",
                            "hoor",
                            "hoore",
                            "jackoff",
                            "jap",
                            "japs",
                            "jerk-off",
                            "jisim",
                            "jiss",
                            "jizm",
                            "jizz",
                            "knob",
                            "knobs",
                            "knobz",
                            "kunt",
                            "kunts",
                            "kuntz",
                            "Lezzian",
                            "Lipshits",
                            "Lipshitz",
                            "masochist",
                            "masokist",
                            "massterbait",
                            "masstrbait",
                            "masstrbate",
                            "masterbaiter",
                            "masterbate",
                            "masterbates",
                            "Motha Fucker",
                            "Motha Fuker",
                            "Motha Fukkah",
                            "Motha Fukker",
                            "Mother Fucker",
                            "Mother Fukah",
                            "Mother Fuker",
                            "Mother Fukkah",
                            "Mother Fukker",
                            "mother-fucker",
                            "Mutha Fucker",
                            "Mutha Fukah",
                            "Mutha Fuker",
                            "Mutha Fukkah",
                            "Mutha Fukker",
                            "n1gr",
                            "nastt",
                            "nigger;",
                            "nigur;",
                            "niiger;",
                            "niigr;",
                            "orafis",
                            "orgasim;",
                            "orgasm",
                            "orgasum",
                            "oriface",
                            "orifice",
                            "orifiss",
                            "packi",
                            "packie",
                            "packy",
                            "paki",
                            "pakie",
                            "paky",
                            "pecker",
                            "peeenus",
                            "peeenusss",
                            "peenus",
                            "peinus",
                            "pen1s",
                            "penas",
                            "penis",
                            "penis-breath",
                            "penus",
                            "penuus",
                            "Phuc",
                            "Phuck",
                            "Phuk",
                            "Phuker",
                            "Phukker",
                            "polac",
                            "polack",
                            "polak",
                            "Poonani",
                            "pr1c",
                            "pr1ck",
                            "pr1k",
                            "pusse",
                            "pussee",
                            "pussy",
                            "puuke",
                            "puuker",
                            "queer",
                            "queers",
                            "queerz",
                            "qweers",
                            "qweerz",
                            "qweir",
                            "recktum",
                            "rectum",
                            "retard",
                            "sadist",
                            "scank",
                            "schlong",
                            "screwing",
                            "semen",
                            "sex",
                            "sexy",
                            "Sh!t",
                            "sh1t",
                            "sh1ter",
                            "sh1ts",
                            "sh1tter",
                            "sh1tz",
                            "shit",
                            "shits",
                            "shitter",
                            "Shitty",
                            "Shity",
                            "shitz",
                            "Shyt",
                            "Shyte",
                            "Shytty",
                            "Shyty",
                            "skanck",
                            "skank",
                            "skankee",
                            "skankey",
                            "skanks",
                            "Skanky",
                            "slag",
                            "slut",
                            "sluts",
                            "Slutty",
                            "slutz",
                            "son-of-a-bitch",
                            "tit",
                            "turd",
                            "va1jina",
                            "vag1na",
                            "vagiina",
                            "vagina",
                            "vaj1na",
                            "vajina",
                            "vullva",
                            "vulva",
                            "w0p",
                            "wh00r",
                            "wh0re",
                            "whore",
                            "xrated",
                            "xxx",
                            "b!+ch",
                            "bitch",
                            "blowjob",
                            "clit",
                            "arschloch",
                            "fuck",
                            "shit",
                            "ass",
                            "asshole",
                            "b!tch",
                            "b17ch",
                            "b1tch",
                            "bastard",
                            "bi+ch",
                            "boiolas",
                            "buceta",
                            "c0ck",
                            "cawk",
                            "chink",
                            "cipa",
                            "clits",
                            "cock",
                            "cum",
                            "cunt",
                            "dildo",
                            "dirsa",
                            "ejakulate",
                            "fatass",
                            "fcuk",
                            "fuk",
                            "fux0r",
                            "hoer",
                            "hore",
                            "jism",
                            "kawk",
                            "l3itch",
                            "l3i+ch",
                            "lesbian",
                            "masturbate",
                            "masterbat*",
                            "masterbat3",
                            "motherfucker",
                            "s.o.b.",
                            "mofo",
                            "nazi",
                            "nigga",
                            "nigger",
                            "nutsack",
                            "phuck",
                            "pimpis",
                            "pusse",
                            "pussy",
                            "scrotum",
                            "sh!t",
                            "shemale",
                            "shi+",
                            "sh!+",
                            "slut",
                            "smut",
                            "teets",
                            "tits",
                            "boobs",
                            "b00bs",
                            "teez",
                            "testical",
                            "testicle",
                            "titt",
                            "w00se",
                            "jackoff",
                            "wank",
                            "whoar",
                            "whore",
                            "*damn",
                            "*dyke",
                            "*fuck*",
                            "*shit*",
                            "@$$",
                            "amcik",
                            "andskota",
                            "arse*",
                            "assrammer",
                            "ayir",
                            "bi7ch",
                            "bitch*",
                            "bollock*",
                            "breasts",
                            "butt-pirate",
                            "cabron",
                            "cazzo",
                            "chraa",
                            "chuj",
                            "Cock*",
                            "cunt*",
                            "d4mn",
                            "daygo",
                            "dego",
                            "dick*",
                            "dike*",
                            "dupa",
                            "dziwka",
                            "ejackulate",
                            "Ekrem*",
                            "Ekto",
                            "enculer",
                            "faen",
                            "fag*",
                            "fanculo",
                            "fanny",
                            "feces",
                            "feg",
                            "Felcher",
                            "ficken",
                            "fitt*",
                            "Flikker",
                            "foreskin",
                            "Fotze",
                            "Fu(*",
                            "fuk*",
                            "futkretzn",
                            "gook",
                            "guiena",
                            "h0r",
                            "h4x0r",
                            "hell",
                            "helvete",
                            "hoer*",
                            "honkey",
                            "Huevon",
                            "hui",
                            "injun",
                            "jizz",
                            "kanker*",
                            "kike",
                            "klootzak",
                            "kraut",
                            "knulle",
                            "kuk",
                            "kuksuger",
                            "Kurac",
                            "kurwa",
                            "kusi*",
                            "kyrpa*",
                            "lesbo",
                            "mamhoon",
                            "masturbat*",
                            "merd*",
                            "mibun",
                            "monkleigh",
                            "mouliewop",
                            "muie",
                            "mulkku",
                            "muschi",
                            "nazis",
                            "nepesaurio",
                            "nigger*",
                            "orospu",
                            "paska*",
                            "perse",
                            "picka",
                            "pierdol*",
                            "pillu*",
                            "pimmel",
                            "piss*",
                            "pizda",
                            "poontsee",
                            "poop",
                            "porn",
                            "p0rn",
                            "pr0n",
                            "preteen",
                            "pula",
                            "pule",
                            "puta",
                            "puto",
                            "qahbeh",
                            "queef*",
                            "rautenberg",
                            "schaffer",
                            "scheiss*",
                            "schlampe",
                            "schmuck",
                            "screw",
                            "sh!t*",
                            "sharmuta",
                            "sharmute",
                            "shipal",
                            "shiz",
                            "skribz",
                            "skurwysyn",
                            "sphencter",
                            "spic",
                            "spierdalaj",
                            "splooge",
                            "suka",
                            "b00b*",
                            "testicle*",
                            "titt*",
                            "twat",
                            "vittu",
                            "wank*",
                            "wetback*",
                            "wichser",
                            "wop*",
                            "yed",
                            "zabourah",
                            "4r5e",
                            "5h1t",
                            "5hit",
                            "a55",
                            "anal",
                            "anus",
                            "ar5e",
                            "arrse",
                            "arse",
                            "ass",
                            "ass-fucker",
                            "asses",
                            "assfucker",
                            "assfukka",
                            "asshole",
                            "assholes",
                            "asswhole",
                            "a_s_s",
                            "b!tch",
                            "b00bs",
                            "b17ch",
                            "b1tch",
                            "ballbag",
                            "balls",
                            "ballsack",
                            "bastard",
                            "beastial",
                            "beastiality",
                            "bellend",
                            "bestial",
                            "bestiality",
                            "bi+ch",
                            "biatch",
                            "bitch",
                            "bitcher",
                            "bitchers",
                            "bitches",
                            "bitchin",
                            "bitching",
                            "bloody",
                            "blow job",
                            "blowjob",
                            "blowjobs",
                            "boiolas",
                            "bollock",
                            "bollok",
                            "boner",
                            "boob",
                            "boobs",
                            "booobs",
                            "boooobs",
                            "booooobs",
                            "booooooobs",
                            "breasts",
                            "buceta",
                            "bugger",
                            "bum",
                            "bunny fucker",
                            "butt",
                            "butthole",
                            "buttmuch",
                            "buttplug",
                            "c0ck",
                            "c0cksucker",
                            "carpet muncher",
                            "cawk",
                            "chink",
                            "cipa",
                            "cl1t",
                            "clit",
                            "clitoris",
                            "clits",
                            "cnut",
                            "cock",
                            "cock-sucker",
                            "cockface",
                            "cockhead",
                            "cockmunch",
                            "cockmuncher",
                            "cocks",
                            "cocksuck",
                            "cocksucked",
                            "cocksucker",
                            "cocksucking",
                            "cocksucks",
                            "cocksuka",
                            "cocksukka",
                            "cok",
                            "cokmuncher",
                            "coksucka",
                            "coon",
                            "cox",
                            "crap",
                            "cum",
                            "cummer",
                            "cumming",
                            "cums",
                            "cumshot",
                            "cunilingus",
                            "cunillingus",
                            "cunnilingus",
                            "cunt",
                            "cuntlick",
                            "cuntlicker",
                            "cuntlicking",
                            "cunts",
                            "cyalis",
                            "cyberfuc",
                            "cyberfuck",
                            "cyberfucked",
                            "cyberfucker",
                            "cyberfuckers",
                            "cyberfucking",
                            "d1ck",
                            "damn",
                            "dick",
                            "dickhead",
                            "dildo",
                            "dildos",
                            "dink",
                            "dinks",
                            "dirsa",
                            "dlck",
                            "dog-fucker",
                            "doggin",
                            "dogging",
                            "donkeyribber",
                            "doosh",
                            "duche",
                            "dyke",
                            "ejaculate",
                            "ejaculated",
                            "ejaculates",
                            "ejaculating",
                            "ejaculatings",
                            "ejaculation",
                            "ejakulate",
                            "f u c k",
                            "f u c k e r",
                            "f4nny",
                            "fag",
                            "fagging",
                            "faggitt",
                            "faggot",
                            "faggs",
                            "fagot",
                            "fagots",
                            "fags",
                            "fanny",
                            "fannyflaps",
                            "fannyfucker",
                            "fanyy",
                            "fatass",
                            "fcuk",
                            "fcuker",
                            "fcuking",
                            "feck",
                            "fecker",
                            "felching",
                            "fellate",
                            "fellatio",
                            "fingerfuck",
                            "fingerfucked",
                            "fingerfucker",
                            "fingerfuckers",
                            "fingerfucking",
                            "fingerfucks",
                            "fistfuck",
                            "fistfucked",
                            "fistfucker",
                            "fistfuckers",
                            "fistfucking",
                            "fistfuckings",
                            "fistfucks",
                            "flange",
                            "fook",
                            "fooker",
                            "fuck",
                            "fucka",
                            "fucked",
                            "fucker",
                            "fuckers",
                            "fuckhead",
                            "fuckheads",
                            "fuckin",
                            "fucking",
                            "fuckings",
                            "fuckingshitmotherfucker",
                            "fuckme",
                            "fucks",
                            "fuckwhit",
                            "fuckwit",
                            "fudge packer",
                            "fudgepacker",
                            "fuk",
                            "fuker",
                            "fukker",
                            "fukkin",
                            "fuks",
                            "fukwhit",
                            "fukwit",
                            "fux",
                            "fux0r",
                            "f_u_c_k",
                            "gangbang",
                            "gangbanged",
                            "gangbangs",
                            "gaylord",
                            "gaysex",
                            "goatse",
                            "God",
                            "god-dam",
                            "god-damned",
                            "goddamn",
                            "goddamned",
                            "hardcoresex",
                            "hell",
                            "heshe",
                            "hoar",
                            "hoare",
                            "hoer",
                            "homo",
                            "hore",
                            "horniest",
                            "horny",
                            "hotsex",
                            "jack-off",
                            "jackoff",
                            "jap",
                            "jerk-off",
                            "jism",
                            "jiz",
                            "jizm",
                            "jizz",
                            "kawk",
                            "knob",
                            "knobead",
                            "knobed",
                            "knobend",
                            "knobhead",
                            "knobjocky",
                            "knobjokey",
                            "kock",
                            "kondum",
                            "kondums",
                            "kum",
                            "kummer",
                            "kumming",
                            "kums",
                            "kunilingus",
                            "l3i+ch",
                            "l3itch",
                            "labia",
                            "lust",
                            "lusting",
                            "m0f0",
                            "m0fo",
                            "m45terbate",
                            "ma5terb8",
                            "ma5terbate",
                            "masochist",
                            "master-bate",
                            "masterb8",
                            "masterbat*",
                            "masterbat3",
                            "masterbate",
                            "masterbation",
                            "masterbations",
                            "masturbate",
                            "mo-fo",
                            "mof0",
                            "mofo",
                            "mothafuck",
                            "mothafucka",
                            "mothafuckas",
                            "mothafuckaz",
                            "mothafucked",
                            "mothafucker",
                            "mothafuckers",
                            "mothafuckin",
                            "mothafucking",
                            "mothafuckings",
                            "mothafucks",
                            "mother fucker",
                            "motherfuck",
                            "motherfucked",
                            "motherfucker",
                            "motherfuckers",
                            "motherfuckin",
                            "motherfucking",
                            "motherfuckings",
                            "motherfuckka",
                            "motherfucks",
                            "muff",
                            "mutha",
                            "muthafecker",
                            "muthafuckker",
                            "muther",
                            "mutherfucker",
                            "n1gga",
                            "n1gger",
                            "nazi",
                            "nigg3r",
                            "nigg4h",
                            "nigga",
                            "niggah",
                            "niggas",
                            "niggaz",
                            "nigger",
                            "niggers",
                            "nob",
                            "nob jokey",
                            "nobhead",
                            "nobjocky",
                            "nobjokey",
                            "numbnuts",
                            "nutsack",
                            "orgasim",
                            "orgasims",
                            "orgasm",
                            "orgasms",
                            "p0rn",
                            "pawn",
                            "pecker",
                            "penis",
                            "penisfucker",
                            "phonesex",
                            "phuck",
                            "phuk",
                            "phuked",
                            "phuking",
                            "phukked",
                            "phukking",
                            "phuks",
                            "phuq",
                            "pigfucker",
                            "pimpis",
                            "piss",
                            "pissed",
                            "pisser",
                            "pissers",
                            "pisses",
                            "pissflaps",
                            "pissin",
                            "pissing",
                            "pissoff",
                            "poop",
                            "porn",
                            "porno",
                            "pornography",
                            "pornos",
                            "prick",
                            "pricks",
                            "pron",
                            "pube",
                            "pusse",
                            "pussi",
                            "pussies",
                            "pussy",
                            "pussys",
                            "rectum",
                            "retard",
                            "rimjaw",
                            "rimming",
                            "s hit",
                            "s.o.b.",
                            "sadist",
                            "schlong",
                            "screwing",
                            "scroat",
                            "scrote",
                            "scrotum",
                            "semen",
                            "sex",
                            "sh!+",
                            "sh!t",
                            "sh1t",
                            "shag",
                            "shagger",
                            "shaggin",
                            "shagging",
                            "shemale",
                            "shi+",
                            "shit",
                            "shitdick",
                            "shite",
                            "shited",
                            "shitey",
                            "shitfuck",
                            "shitfull",
                            "shithead",
                            "shiting",
                            "shitings",
                            "shits",
                            "shitted",
                            "shitter",
                            "shitters",
                            "shitting",
                            "shittings",
                            "shitty",
                            "skank",
                            "slut",
                            "sluts",
                            "smegma",
                            "smut",
                            "snatch",
                            "son-of-a-bitch",
                            "spac",
                            "spunk",
                            "s_h_i_t",
                            "t1tt1e5",
                            "t1tties",
                            "teets",
                            "teez",
                            "testical",
                            "testicle",
                            "tit",
                            "titfuck",
                            "tits",
                            "titt",
                            "tittie5",
                            "tittiefucker",
                            "titties",
                            "tittyfuck",
                            "tittywank",
                            "titwank",
                            "tosser",
                            "turd",
                            "tw4t",
                            "twat",
                            "twathead",
                            "twatty",
                            "twunt",
                            "twunter",
                            "v14gra",
                            "v1gra",
                            "vagina",
                            "viagra",
                            "vulva",
                            "w00se",
                            "wang",
                            "wank",
                            "wanker",
                            "wanky",
                            "whoar",
                            "whore",
                            "willies",
                            "willy",
                            "xrated",
                            "xxx",
                            "jew",
                            "black",
                            "baby",
                            "child",
                            "white",
                            "porn",
                            "pedo",
                            "trump",
                            "clinton",
                            "hitler",
                            "nazi",
                            "gay",
                            "pride",
                            "sex",
                            "pleasure",
                            "touch",
                            "poo",
                            "kids",
                            "rape",
                            "white power",
                            "nigga",
                            "nig nog",
                            "doggy",
                            "rapist",
                            "boner",
                            "nigger",
                            "nigg",
                            "finger",
                            "nogger",
                            "nagger",
                            "nig",
                            "fag",
                            "gai",
                            "pole",
                            "stripper",
                            "penis",
                            "vagina",
                            "pussy",
                            "nazi",
                            "hitler",
                            "stalin",
                            "burn",
                            "chamber",
                            "cock",
                            "peen",
                            "dick",
                            "spick",
                            "nieger",
                            "die",
                            "satan",
                            "n|ig",
                            "nlg",
                            "cunt",
                            "c0ck",
                            "fag",
                            "lick",
                            "condom",
                            "anal",
                            "shit",
                            "phile",
                            "little",
                            "kids",
                            "free KR",
                            "tiny",
                            "sidney",
                            "ass",
                            "kill",
                            ".io",
                            "(dot)",
                            "[dot]",
                            "mini",
                            "whiore",
                            "whore",
                            "faggot",
                            "github",
                            "1337",
                            "666",
                            "satan",
                            "senpa",
                            "discord",
                            "d1scord",
                            "mistik",
                            ".io",
                            "senpa.io",
                            "sidney",
                            "sid",
                            "senpaio",
                            "vries",
                            "asa"
                        ],
                        "exclude": [],
                        "placeHolder": "*",
                        "regex": {},
                        "replaceRegex": {}
                    };

                    let isProfane = false;
                    let convertedName = name.toLowerCase().replace(/\s/g, "").replace(/1/g, "i").replace(/0/g, "o").replace(/5/g, "s");
                    for (let word of langFilter.list) {
                        if (convertedName.indexOf(word) != -1) {
                            isProfane = true;
                            break;
                        }
                    }

                    if (name.length > 0 && !isProfane) {
                        noname = name;
                    }

                    return noname;
                }
            };
            window.toggleNight();
        },
        webgl_test: () => {
            return;
            let canvas = document.createElement("canvas");
            canvas.id = "WEBGL";
            canvas.width = canvas.height = 300;
            canvas.style = `
            position: relative;
            bottom: 70%;
            left: 70%;
            pointer-events: none;
            `;

            let fat = document.createElement("div");
            fat.id = "faku";
            fat.width = fat.height = 300;
            fat.style = `
            position: relative;
            bottom: 70%;
            left: 70%;
            pointer-events: none;
            font-size: 20px;
            `;
            fat.innerHTML = "Webgl Test Rendering";

            let gl = canvas.getContext("webgl");
            if (!gl) {
                alert("urbad");
                return;
            }

            document.body.append(canvas);
            document.body.append(fat);
            log(gl);

            gl.clearColor(0, 0, 0, 0.2);
            gl.clear(gl.COLOR_BUFFER_BIT);

            let buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

            function render(vs, fs, vertice, type) {

                let vShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vShader, vs);
                gl.compileShader(vShader);
                gl.getShaderParameter(vShader, gl.COMPILE_STATUS);

                let fShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fShader, fs);
                gl.compileShader(fShader);
                gl.getShaderParameter(fShader, gl.COMPILE_STATUS);

                let program = gl.createProgram();
                gl.attachShader(program, vShader);
                gl.attachShader(program, fShader);
                gl.linkProgram(program);
                gl.getProgramParameter(program, gl.LINK_STATUS);
                gl.useProgram(program);

                let vertex = gl.getAttribLocation(program, "vertex");
                gl.enableVertexAttribArray(vertex);
                gl.vertexAttribPointer(vertex, 2, gl.FLOAT, false, 0, 0);

                let vertices = vertice.length / 2;
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertice), gl.DYNAMIC_DRAW);
                gl.drawArrays(type, 0, vertices);
            }

            function hexToRgb(hex) {
                return hex.slice(1).match(/.{1,2}/g).map(g => parseInt(g, 16));
            }

            function getRgb(r, g, b) {
                return [r / 255, g / 255, b / 255].join(", ");
            }

            let max = 50;
            for (let i = 0; i < max; i++) {
                let radian = (Math.PI * (i / (max / 2)));
                render(`
                precision mediump float;
                attribute vec2 vertex;
                void main(void) {
                    gl_Position = vec4(vertex, 0, 1);
                }
                `,`
                precision mediump float;
                void main(void) {
                    gl_FragColor = vec4(${getRgb(...hexToRgb("#cc5151"))}, 1);
                }
                `, [
                    // moveto, lineto
                    0 + (Math.cos(radian) * 0.5), 0 + (Math.sin(radian) * 0.5),
                    0, 0,
                ], gl.LINE_LOOP);
            }
        }
    };
    if (codes) {
        for (let code in codes) {
            let func = codes[code];
            typeof func === "function" && func();
        }
        window.enableHack = function() {
            if (!useHack) {
                useHack = true;
                codes.main();
            }
        };
    }
}(1);
let ae86Dir = true;
!function(e) {
    var t = {};
    function n(i) {
        if (t[i])
            return t[i].exports;
        var r = t[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return e[i].call(r.exports, r, r.exports, n),
            r.l = !0,
            r.exports
    }
    n.m = e,
        n.c = t,
        n.d = function(e, t, i) {
        n.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: i
        })
    }
        ,
        n.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
            Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
        ,
        n.t = function(e, t) {
        if (1 & t && (e = n(e)),
            8 & t)
            return e;
        if (4 & t && "object" == typeof e && e && e.__esModule)
            return e;
        var i = Object.create(null);
        if (n.r(i),
            Object.defineProperty(i, "default", {
            enumerable: !0,
            value: e
        }),
            2 & t && "string" != typeof e)
            for (var r in e)
                n.d(i, r, function(t) {
                    return e[t]
                }
                    .bind(null, r));
        return i
    }
        ,
        n.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return n.d(t, "a", t),
            t
    }
        ,
        n.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
        ,
        n.p = "",
        n(n.s = 21)
}([function(e, t, n) {
    var i = t.global = n(25)
    , r = t.hasBuffer = i && !!i.isBuffer
    , s = t.hasArrayBuffer = "undefined" != typeof ArrayBuffer
    , a = t.isArray = n(5);
    t.isArrayBuffer = s ? function(e) {
        return e instanceof ArrayBuffer || p(e)
    }
    : m;
    var o = t.isBuffer = r ? i.isBuffer : m
    , c = t.isView = s ? ArrayBuffer.isView || y("ArrayBuffer", "buffer") : m;
    t.alloc = d,
        t.concat = function(e, n) {
        n || (n = 0,
              Array.prototype.forEach.call(e, (function(e) {
            n += e.length
        }
                                              )));
        var i = this !== t && this || e[0]
        , r = d.call(i, n)
        , s = 0;
        return Array.prototype.forEach.call(e, (function(e) {
            s += f.copy.call(e, r, s)
        }
                                               )),
            r
    }
        ,
        t.from = function(e) {
        return "string" == typeof e ? function(e) {
            var t = 3 * e.length
            , n = d.call(this, t)
            , i = f.write.call(n, e);
            return t !== i && (n = f.slice.call(n, 0, i)),
                n
        }
            .call(this, e) : g(this).from(e)
    }
    ;
    var l = t.Array = n(28)
    , h = t.Buffer = n(29)
    , u = t.Uint8Array = n(30)
    , f = t.prototype = n(6);
    function d(e) {
        return g(this).alloc(e)
    }
    var p = y("ArrayBuffer");
    function g(e) {
        return o(e) ? h : c(e) ? u : a(e) ? l : r ? h : s ? u : l
    }
    function m() {
        return !1
    }
    function y(e, t) {
        return e = "[object " + e + "]",
            function(n) {
            return null != n && {}.toString.call(t ? n[t] : n) === e
        }
    }
}
   , function(e, t, n) {
       var i = n(5);
       t.createCodec = o,
           t.install = function(e) {
           for (var t in e)
               s.prototype[t] = a(s.prototype[t], e[t])
       }
           ,
           t.filter = function(e) {
           return i(e) ? function(e) {
               return e = e.slice(),
                   function(n) {
                   return e.reduce(t, n)
               }
               ;
               function t(e, t) {
                   return t(e)
               }
           }(e) : e
       }
       ;
       var r = n(0);
       function s(e) {
           if (!(this instanceof s))
               return new s(e);
           this.options = e,
               this.init()
       }
       function a(e, t) {
           return e && t ? function() {
               return e.apply(this, arguments),
                   t.apply(this, arguments)
           }
           : e || t
       }
       function o(e) {
           return new s(e)
       }
       s.prototype.init = function() {
           var e = this.options;
           return e && e.uint8array && (this.bufferish = r.Uint8Array),
               this
       }
           ,
           t.preset = o({
           preset: !0
       })
   }
   , function(e, t, n) {
       var i = n(3).ExtBuffer
       , r = n(32)
       , s = n(33)
       , a = n(1);
       function o() {
           var e = this.options;
           return this.encode = function(e) {
               var t = s.getWriteType(e);
               return function(e, n) {
                   var i = t[typeof n];
                   if (!i)
                       throw new Error('Unsupported type "' + typeof n + '": ' + n);
                   i(e, n)
               }
           }(e),
               e && e.preset && r.setExtPackers(this),
               this
       }
       a.install({
           addExtPacker: function(e, t, n) {
               n = a.filter(n);
               var r = t.name;
               r && "Object" !== r ? (this.extPackers || (this.extPackers = {}))[r] = s : (this.extEncoderList || (this.extEncoderList = [])).unshift([t, s]);
               function s(t) {
                   return n && (t = n(t)),
                       new i(t,e)
               }
           },
           getExtPacker: function(e) {
               var t = this.extPackers || (this.extPackers = {})
               , n = e.constructor
               , i = n && n.name && t[n.name];
               if (i)
                   return i;
               for (var r = this.extEncoderList || (this.extEncoderList = []), s = r.length, a = 0; a < s; a++) {
                   var o = r[a];
                   if (n === o[0])
                       return o[1]
               }
           },
           init: o
       }),
           t.preset = o.call(a.preset)
   }
   , function(e, t, n) {
       t.ExtBuffer = function e(t, n) {
           if (!(this instanceof e))
               return new e(t,n);
           this.buffer = i.from(t),
               this.type = n
       }
       ;
       var i = n(0)
       }
   , function(e, t) {
       t.read = function(e, t, n, i, r) {
           var s, a, o = 8 * r - i - 1, c = (1 << o) - 1, l = c >> 1, h = -7, u = n ? r - 1 : 0, f = n ? -1 : 1, d = e[t + u];
           for (u += f,
                s = d & (1 << -h) - 1,
                d >>= -h,
                h += o; h > 0; s = 256 * s + e[t + u],
                u += f,
                h -= 8)
               ;
           for (a = s & (1 << -h) - 1,
                s >>= -h,
                h += i; h > 0; a = 256 * a + e[t + u],
                u += f,
                h -= 8)
               ;
           if (0 === s)
               s = 1 - l;
           else {
               if (s === c)
                   return a ? NaN : 1 / 0 * (d ? -1 : 1);
               a += Math.pow(2, i),
                   s -= l
           }
           return (d ? -1 : 1) * a * Math.pow(2, s - i)
       }
           ,
           t.write = function(e, t, n, i, r, s) {
           var a, o, c, l = 8 * s - r - 1, h = (1 << l) - 1, u = h >> 1, f = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = i ? 0 : s - 1, p = i ? 1 : -1, g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
           for (t = Math.abs(t),
                isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0,
                                           a = h) : (a = Math.floor(Math.log(t) / Math.LN2),
                                                     t * (c = Math.pow(2, -a)) < 1 && (a--,
                                                                                       c *= 2),
                                                     (t += a + u >= 1 ? f / c : f * Math.pow(2, 1 - u)) * c >= 2 && (a++,
                                                                                                                     c /= 2),
                                                     a + u >= h ? (o = 0,
                                                                   a = h) : a + u >= 1 ? (o = (t * c - 1) * Math.pow(2, r),
                                                                                          a += u) : (o = t * Math.pow(2, u - 1) * Math.pow(2, r),
                                                                                                     a = 0)); r >= 8; e[n + d] = 255 & o,
                d += p,
                o /= 256,
                r -= 8)
               ;
           for (a = a << r | o,
                l += r; l > 0; e[n + d] = 255 & a,
                d += p,
                a /= 256,
                l -= 8)
               ;
           e[n + d - p] |= 128 * g
       }
   }
   , function(e, t) {
       var n = {}.toString;
       e.exports = Array.isArray || function(e) {
           return "[object Array]" == n.call(e)
       }
   }
   , function(e, t, n) {
       var i = n(31);
       t.copy = c,
           t.slice = l,
           t.toString = function(e, t, n) {
           return (!a && r.isBuffer(this) ? this.toString : i.toString).apply(this, arguments)
       }
           ,
           t.write = function(e) {
           return function() {
               return (this[e] || i[e]).apply(this, arguments)
           }
       }("write");
       var r = n(0)
       , s = r.global
       , a = r.hasBuffer && "TYPED_ARRAY_SUPPORT"in s
       , o = a && !s.TYPED_ARRAY_SUPPORT;
       function c(e, t, n, s) {
           var a = r.isBuffer(this)
           , c = r.isBuffer(e);
           if (a && c)
               return this.copy(e, t, n, s);
           if (o || a || c || !r.isView(this) || !r.isView(e))
               return i.copy.call(this, e, t, n, s);
           var h = n || null != s ? l.call(this, n, s) : this;
           return e.set(h, t),
               h.length
       }
       function l(e, t) {
           var n = this.slice || !o && this.subarray;
           if (n)
               return n.call(this, e, t);
           var i = r.alloc.call(this, t - e);
           return c.call(this, i, 0, e, t),
               i
       }
   }
   , function(e, t, n) {
       (function(e) {
           !function(t) {
               var n, i = "undefined", r = i !== typeof e && e, s = i !== typeof Uint8Array && Uint8Array, a = i !== typeof ArrayBuffer && ArrayBuffer, o = [0, 0, 0, 0, 0, 0, 0, 0], c = Array.isArray || function(e) {
                   return !!e && "[object Array]" == Object.prototype.toString.call(e)
               }
               , l = 4294967296;
               function h(e, c, h) {
                   var b = c ? 0 : 4
                   , x = c ? 4 : 0
                   , S = c ? 0 : 3
                   , T = c ? 1 : 2
                   , I = c ? 2 : 1
                   , E = c ? 3 : 0
                   , M = c ? y : v
                   , A = c ? k : w
                   , P = O.prototype
                   , B = "is" + e
                   , C = "_" + B;
                   return P.buffer = void 0,
                       P.offset = 0,
                       P[C] = !0,
                       P.toNumber = R,
                       P.toString = function(e) {
                       var t = this.buffer
                       , n = this.offset
                       , i = _(t, n + b)
                       , r = _(t, n + x)
                       , s = ""
                       , a = !h && 2147483648 & i;
                       for (a && (i = ~i,
                                  r = l - r),
                            e = e || 10; ; ) {
                           var o = i % e * l + r;
                           if (i = Math.floor(i / e),
                               r = Math.floor(o / e),
                               s = (o % e).toString(e) + s,
                               !i && !r)
                               break
                       }
                       return a && (s = "-" + s),
                           s
                   }
                       ,
                       P.toJSON = R,
                       P.toArray = u,
                       r && (P.toBuffer = f),
                       s && (P.toArrayBuffer = d),
                       O[B] = function(e) {
                       return !(!e || !e[C])
                   }
                       ,
                       t[e] = O,
                       O;
                   function O(e, t, r, c) {
                       return this instanceof O ? function(e, t, r, c, h) {
                           if (s && a && (t instanceof a && (t = new s(t)),
                                          c instanceof a && (c = new s(c))),
                               t || r || c || n) {
                               if (!p(t, r))
                                   h = r,
                                       c = t,
                                       r = 0,
                                       t = new (n || Array)(8);
                               e.buffer = t,
                                   e.offset = r |= 0,
                                   i !== typeof c && ("string" == typeof c ? function(e, t, n, i) {
                                   var r = 0
                                   , s = n.length
                                   , a = 0
                                   , o = 0;
                                   "-" === n[0] && r++;
                                   for (var c = r; r < s; ) {
                                       var h = parseInt(n[r++], i);
                                       if (!(h >= 0))
                                           break;
                                       o = o * i + h,
                                           a = a * i + Math.floor(o / l),
                                           o %= l
                                   }
                                   c && (a = ~a,
                                         o ? o = l - o : a++),
                                       j(e, t + b, a),
                                       j(e, t + x, o)
                               }(t, r, c, h || 10) : p(c, h) ? g(t, r, c, h) : "number" == typeof h ? (j(t, r + b, c),
                                                                                                       j(t, r + x, h)) : c > 0 ? M(t, r, c) : c < 0 ? A(t, r, c) : g(t, r, o, 0))
                           } else
                               e.buffer = m(o, 0)
                       }(this, e, t, r, c) : new O(e,t,r,c)
                   }
                   function R() {
                       var e = this.buffer
                       , t = this.offset
                       , n = _(e, t + b)
                       , i = _(e, t + x);
                       return h || (n |= 0),
                           n ? n * l + i : i
                   }
                   function j(e, t, n) {
                       e[t + E] = 255 & n,
                           n >>= 8,
                           e[t + I] = 255 & n,
                           n >>= 8,
                           e[t + T] = 255 & n,
                           n >>= 8,
                           e[t + S] = 255 & n
                   }
                   function _(e, t) {
                       return 16777216 * e[t + S] + (e[t + T] << 16) + (e[t + I] << 8) + e[t + E]
                   }
               }
               function u(e) {
                   var t = this.buffer
                   , i = this.offset;
                   return n = null,
                       !1 !== e && 0 === i && 8 === t.length && c(t) ? t : m(t, i)
               }
               function f(t) {
                   var i = this.buffer
                   , s = this.offset;
                   if (n = r,
                       !1 !== t && 0 === s && 8 === i.length && e.isBuffer(i))
                       return i;
                   var a = new r(8);
                   return g(a, 0, i, s),
                       a
               }
               function d(e) {
                   var t = this.buffer
                   , i = this.offset
                   , r = t.buffer;
                   if (n = s,
                       !1 !== e && 0 === i && r instanceof a && 8 === r.byteLength)
                       return r;
                   var o = new s(8);
                   return g(o, 0, t, i),
                       o.buffer
               }
               function p(e, t) {
                   var n = e && e.length;
                   return t |= 0,
                       n && t + 8 <= n && "string" != typeof e[t]
               }
               function g(e, t, n, i) {
                   t |= 0,
                       i |= 0;
                   for (var r = 0; r < 8; r++)
                       e[t++] = 255 & n[i++]
               }
               function m(e, t) {
                   return Array.prototype.slice.call(e, t, t + 8)
               }
               function y(e, t, n) {
                   for (var i = t + 8; i > t; )
                       e[--i] = 255 & n,
                           n /= 256
               }
               function k(e, t, n) {
                   var i = t + 8;
                   for (n++; i > t; )
                       e[--i] = 255 & -n ^ 255,
                           n /= 256
               }
               function v(e, t, n) {
                   for (var i = t + 8; t < i; )
                       e[t++] = 255 & n,
                           n /= 256
               }
               function w(e, t, n) {
                   var i = t + 8;
                   for (n++; t < i; )
                       e[t++] = 255 & -n ^ 255,
                           n /= 256
               }
               h("Uint64BE", !0, !0),
                   h("Int64BE", !0, !1),
                   h("Uint64LE", !1, !0),
                   h("Int64LE", !1, !1)
           }("string" != typeof t.nodeName ? t : this || {})
       }
       ).call(this, n(11).Buffer)
   }
   , function(e, t, n) {
       var i = n(3).ExtBuffer
       , r = n(35)
       , s = n(17).readUint8
       , a = n(36)
       , o = n(1);
       function c() {
           var e = this.options;
           return this.decode = function(e) {
               var t = a.getReadToken(e);
               return function(e) {
                   var n = s(e)
                   , i = t[n];
                   if (!i)
                       throw new Error("Invalid type: " + (n ? "0x" + n.toString(16) : n));
                   return i(e)
               }
           }(e),
               e && e.preset && r.setExtUnpackers(this),
               this
       }
       o.install({
           addExtUnpacker: function(e, t) {
               (this.extUnpackers || (this.extUnpackers = []))[e] = o.filter(t)
           },
           getExtUnpacker: function(e) {
               return (this.extUnpackers || (this.extUnpackers = []))[e] || function(t) {
                   return new i(t,e)
               }
           },
           init: c
       }),
           t.preset = c.call(o.preset)
   }
   , function(e, t, n) {
       t.encode = function(e, t) {
           var n = new i(t);
           return n.write(e),
               n.read()
       }
       ;
       var i = n(10).EncodeBuffer
       }
   , function(e, t, n) {
       t.EncodeBuffer = r;
       var i = n(2).preset;
       function r(e) {
           if (!(this instanceof r))
               return new r(e);
           if (e && (this.options = e,
                     e.codec)) {
               var t = this.codec = e.codec;
               t.bufferish && (this.bufferish = t.bufferish)
           }
       }
       n(14).FlexEncoder.mixin(r.prototype),
           r.prototype.codec = i,
           r.prototype.write = function(e) {
           this.codec.encode(this, e)
       }
   }
   , function(e, t, n) {
       "use strict";
       (function(e) {
           /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
           var i = n(26)
           , r = n(4)
           , s = n(27);
           function a() {
               return c.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
           }
           function o(e, t) {
               if (a() < t)
                   throw new RangeError("Invalid typed array length");
               return c.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = c.prototype : (null === e && (e = new c(t)),
                                                                                                 e.length = t),
                   e
           }
           function c(e, t, n) {
               if (!(c.TYPED_ARRAY_SUPPORT || this instanceof c))
                   return new c(e,t,n);
               if ("number" == typeof e) {
                   if ("string" == typeof t)
                       throw new Error("If encoding is specified then the first argument must be a string");
                   return u(this, e)
               }
               return l(this, e, t, n)
           }
           function l(e, t, n, i) {
               if ("number" == typeof t)
                   throw new TypeError('"value" argument must not be a number');
               return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function(e, t, n, i) {
                   if (t.byteLength,
                       n < 0 || t.byteLength < n)
                       throw new RangeError("'offset' is out of bounds");
                   if (t.byteLength < n + (i || 0))
                       throw new RangeError("'length' is out of bounds");
                   return t = void 0 === n && void 0 === i ? new Uint8Array(t) : void 0 === i ? new Uint8Array(t,n) : new Uint8Array(t,n,i),
                       c.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = c.prototype : e = f(e, t),
                       e
               }(e, t, n, i) : "string" == typeof t ? function(e, t, n) {
                   if ("string" == typeof n && "" !== n || (n = "utf8"),
                       !c.isEncoding(n))
                       throw new TypeError('"encoding" must be a valid string encoding');
                   var i = 0 | p(t, n)
                   , r = (e = o(e, i)).write(t, n);
                   return r !== i && (e = e.slice(0, r)),
                       e
               }(e, t, n) : function(e, t) {
                   if (c.isBuffer(t)) {
                       var n = 0 | d(t.length);
                       return 0 === (e = o(e, n)).length || t.copy(e, 0, 0, n),
                           e
                   }
                   if (t) {
                       if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length"in t)
                           return "number" != typeof t.length || function(e) {
                               return e != e
                           }(t.length) ? o(e, 0) : f(e, t);
                       if ("Buffer" === t.type && s(t.data))
                           return f(e, t.data)
                   }
                   throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
               }(e, t)
           }
           function h(e) {
               if ("number" != typeof e)
                   throw new TypeError('"size" argument must be a number');
               if (e < 0)
                   throw new RangeError('"size" argument must not be negative')
           }
           function u(e, t) {
               if (h(t),
                   e = o(e, t < 0 ? 0 : 0 | d(t)),
                   !c.TYPED_ARRAY_SUPPORT)
                   for (var n = 0; n < t; ++n)
                       e[n] = 0;
               return e
           }
           function f(e, t) {
               var n = t.length < 0 ? 0 : 0 | d(t.length);
               e = o(e, n);
               for (var i = 0; i < n; i += 1)
                   e[i] = 255 & t[i];
               return e
           }
           function d(e) {
               if (e >= a())
                   throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
               return 0 | e
           }
           function p(e, t) {
               if (c.isBuffer(e))
                   return e.length;
               if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer))
                   return e.byteLength;
               "string" != typeof e && (e = "" + e);
               var n = e.length;
               if (0 === n)
                   return 0;
               for (var i = !1; ; )
                   switch (t) {
                       case "ascii":
                       case "latin1":
                       case "binary":
                           return n;
                       case "utf8":
                       case "utf-8":
                       case void 0:
                           return z(e).length;
                       case "ucs2":
                       case "ucs-2":
                       case "utf16le":
                       case "utf-16le":
                           return 2 * n;
                       case "hex":
                           return n >>> 1;
                       case "base64":
                           return H(e).length;
                       default:
                           if (i)
                               return z(e).length;
                           t = ("" + t).toLowerCase(),
                               i = !0
                   }
           }
           function g(e, t, n) {
               var i = e[t];
               e[t] = e[n],
                   e[n] = i
           }
           function m(e, t, n, i, r) {
               if (0 === e.length)
                   return -1;
               if ("string" == typeof n ? (i = n,
                                           n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648),
                   n = +n,
                   isNaN(n) && (n = r ? 0 : e.length - 1),
                   n < 0 && (n = e.length + n),
                   n >= e.length) {
                   if (r)
                       return -1;
                   n = e.length - 1
               } else if (n < 0) {
                   if (!r)
                       return -1;
                   n = 0
               }
               if ("string" == typeof t && (t = c.from(t, i)),
                   c.isBuffer(t))
                   return 0 === t.length ? -1 : y(e, t, n, i, r);
               if ("number" == typeof t)
                   return t &= 255,
                       c.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? r ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : y(e, [t], n, i, r);
               throw new TypeError("val must be string, number or Buffer")
           }
           function y(e, t, n, i, r) {
               var s, a = 1, o = e.length, c = t.length;
               if (void 0 !== i && ("ucs2" === (i = String(i).toLowerCase()) || "ucs-2" === i || "utf16le" === i || "utf-16le" === i)) {
                   if (e.length < 2 || t.length < 2)
                       return -1;
                   a = 2,
                       o /= 2,
                       c /= 2,
                       n /= 2
               }
               function l(e, t) {
                   return 1 === a ? e[t] : e.readUInt16BE(t * a)
               }
               if (r) {
                   var h = -1;
                   for (s = n; s < o; s++)
                       if (l(e, s) === l(t, -1 === h ? 0 : s - h)) {
                           if (-1 === h && (h = s),
                               s - h + 1 === c)
                               return h * a
                       } else
                           -1 !== h && (s -= s - h),
                               h = -1
               } else
                   for (n + c > o && (n = o - c),
                        s = n; s >= 0; s--) {
                       for (var u = !0, f = 0; f < c; f++)
                           if (l(e, s + f) !== l(t, f)) {
                               u = !1;
                               break
                           }
                       if (u)
                           return s
                   }
               return -1
           }
           function k(e, t, n, i) {
               n = Number(n) || 0;
               var r = e.length - n;
               i ? (i = Number(i)) > r && (i = r) : i = r;
               var s = t.length;
               if (s % 2 != 0)
                   throw new TypeError("Invalid hex string");
               i > s / 2 && (i = s / 2);
               for (var a = 0; a < i; ++a) {
                   var o = parseInt(t.substr(2 * a, 2), 16);
                   if (isNaN(o))
                       return a;
                   e[n + a] = o
               }
               return a
           }
           function v(e, t, n, i) {
               return V(z(t, e.length - n), e, n, i)
           }
           function w(e, t, n, i) {
               return V(function(e) {
                   for (var t = [], n = 0; n < e.length; ++n)
                       t.push(255 & e.charCodeAt(n));
                   return t
               }(t), e, n, i)
           }
           function b(e, t, n, i) {
               return w(e, t, n, i)
           }
           function x(e, t, n, i) {
               return V(H(t), e, n, i)
           }
           function S(e, t, n, i) {
               return V(function(e, t) {
                   for (var n, i, r, s = [], a = 0; a < e.length && !((t -= 2) < 0); ++a)
                       i = (n = e.charCodeAt(a)) >> 8,
                           r = n % 256,
                           s.push(r),
                           s.push(i);
                   return s
               }(t, e.length - n), e, n, i)
           }
           function T(e, t, n) {
               return 0 === t && n === e.length ? i.fromByteArray(e) : i.fromByteArray(e.slice(t, n))
           }
           function I(e, t, n) {
               n = Math.min(e.length, n);
               for (var i = [], r = t; r < n; ) {
                   var s, a, o, c, l = e[r], h = null, u = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                   if (r + u <= n)
                       switch (u) {
                           case 1:
                               l < 128 && (h = l);
                               break;
                           case 2:
                               128 == (192 & (s = e[r + 1])) && (c = (31 & l) << 6 | 63 & s) > 127 && (h = c);
                               break;
                           case 3:
                               s = e[r + 1],
                                   a = e[r + 2],
                                   128 == (192 & s) && 128 == (192 & a) && (c = (15 & l) << 12 | (63 & s) << 6 | 63 & a) > 2047 && (c < 55296 || c > 57343) && (h = c);
                               break;
                           case 4:
                               s = e[r + 1],
                                   a = e[r + 2],
                                   o = e[r + 3],
                                   128 == (192 & s) && 128 == (192 & a) && 128 == (192 & o) && (c = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) > 65535 && c < 1114112 && (h = c)
                       }
                   null === h ? (h = 65533,
                                 u = 1) : h > 65535 && (h -= 65536,
                                                        i.push(h >>> 10 & 1023 | 55296),
                                                        h = 56320 | 1023 & h),
                       i.push(h),
                       r += u
               }
               return function(e) {
                   var t = e.length;
                   if (t <= E)
                       return String.fromCharCode.apply(String, e);
                   for (var n = "", i = 0; i < t; )
                       n += String.fromCharCode.apply(String, e.slice(i, i += E));
                   return n
               }(i)
           }
           t.Buffer = c,
               t.SlowBuffer = function(e) {
               return +e != e && (e = 0),
                   c.alloc(+e)
           }
               ,
               t.INSPECT_MAX_BYTES = 50,
               c.TYPED_ARRAY_SUPPORT = void 0 !== e.TYPED_ARRAY_SUPPORT ? e.TYPED_ARRAY_SUPPORT : function() {
               try {
                   var e = new Uint8Array(1);
                   return e.__proto__ = {
                       __proto__: Uint8Array.prototype,
                       foo: function() {
                           return 42
                       }
                   },
                       42 === e.foo() && "function" == typeof e.subarray && 0 === e.subarray(1, 1).byteLength
               } catch (e) {
                   return !1
               }
           }(),
               t.kMaxLength = a(),
               c.poolSize = 8192,
               c._augment = function(e) {
               return e.__proto__ = c.prototype,
                   e
           }
               ,
               c.from = function(e, t, n) {
               return l(null, e, t, n)
           }
               ,
               c.TYPED_ARRAY_SUPPORT && (c.prototype.__proto__ = Uint8Array.prototype,
                                         c.__proto__ = Uint8Array,
                                         "undefined" != typeof Symbol && Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, {
               value: null,
               configurable: !0
           })),
               c.alloc = function(e, t, n) {
               return function(e, t, n, i) {
                   return h(t),
                       t <= 0 ? o(e, t) : void 0 !== n ? "string" == typeof i ? o(e, t).fill(n, i) : o(e, t).fill(n) : o(e, t)
               }(null, e, t, n)
           }
               ,
               c.allocUnsafe = function(e) {
               return u(null, e)
           }
               ,
               c.allocUnsafeSlow = function(e) {
               return u(null, e)
           }
               ,
               c.isBuffer = function(e) {
               return !(null == e || !e._isBuffer)
           }
               ,
               c.compare = function(e, t) {
               if (!c.isBuffer(e) || !c.isBuffer(t))
                   throw new TypeError("Arguments must be Buffers");
               if (e === t)
                   return 0;
               for (var n = e.length, i = t.length, r = 0, s = Math.min(n, i); r < s; ++r)
                   if (e[r] !== t[r]) {
                       n = e[r],
                           i = t[r];
                       break
                   }
               return n < i ? -1 : i < n ? 1 : 0
           }
               ,
               c.isEncoding = function(e) {
               switch (String(e).toLowerCase()) {
                   case "hex":
                   case "utf8":
                   case "utf-8":
                   case "ascii":
                   case "latin1":
                   case "binary":
                   case "base64":
                   case "ucs2":
                   case "ucs-2":
                   case "utf16le":
                   case "utf-16le":
                       return !0;
                   default:
                       return !1
               }
           }
               ,
               c.concat = function(e, t) {
               if (!s(e))
                   throw new TypeError('"list" argument must be an Array of Buffers');
               if (0 === e.length)
                   return c.alloc(0);
               var n;
               if (void 0 === t)
                   for (t = 0,
                        n = 0; n < e.length; ++n)
                       t += e[n].length;
               var i = c.allocUnsafe(t)
               , r = 0;
               for (n = 0; n < e.length; ++n) {
                   var a = e[n];
                   if (!c.isBuffer(a))
                       throw new TypeError('"list" argument must be an Array of Buffers');
                   a.copy(i, r),
                       r += a.length
               }
               return i
           }
               ,
               c.byteLength = p,
               c.prototype._isBuffer = !0,
               c.prototype.swap16 = function() {
               var e = this.length;
               if (e % 2 != 0)
                   throw new RangeError("Buffer size must be a multiple of 16-bits");
               for (var t = 0; t < e; t += 2)
                   g(this, t, t + 1);
               return this
           }
               ,
               c.prototype.swap32 = function() {
               var e = this.length;
               if (e % 4 != 0)
                   throw new RangeError("Buffer size must be a multiple of 32-bits");
               for (var t = 0; t < e; t += 4)
                   g(this, t, t + 3),
                       g(this, t + 1, t + 2);
               return this
           }
               ,
               c.prototype.swap64 = function() {
               var e = this.length;
               if (e % 8 != 0)
                   throw new RangeError("Buffer size must be a multiple of 64-bits");
               for (var t = 0; t < e; t += 8)
                   g(this, t, t + 7),
                       g(this, t + 1, t + 6),
                       g(this, t + 2, t + 5),
                       g(this, t + 3, t + 4);
               return this
           }
               ,
               c.prototype.toString = function() {
               var e = 0 | this.length;
               return 0 === e ? "" : 0 === arguments.length ? I(this, 0, e) : function(e, t, n) {
                   var i = !1;
                   if ((void 0 === t || t < 0) && (t = 0),
                       t > this.length)
                       return "";
                   if ((void 0 === n || n > this.length) && (n = this.length),
                       n <= 0)
                       return "";
                   if ((n >>>= 0) <= (t >>>= 0))
                       return "";
                   for (e || (e = "utf8"); ; )
                       switch (e) {
                           case "hex":
                               return P(this, t, n);
                           case "utf8":
                           case "utf-8":
                               return I(this, t, n);
                           case "ascii":
                               return M(this, t, n);
                           case "latin1":
                           case "binary":
                               return A(this, t, n);
                           case "base64":
                               return T(this, t, n);
                           case "ucs2":
                           case "ucs-2":
                           case "utf16le":
                           case "utf-16le":
                               return B(this, t, n);
                           default:
                               if (i)
                                   throw new TypeError("Unknown encoding: " + e);
                               e = (e + "").toLowerCase(),
                                   i = !0
                       }
               }
                   .apply(this, arguments)
           }
               ,
               c.prototype.equals = function(e) {
               if (!c.isBuffer(e))
                   throw new TypeError("Argument must be a Buffer");
               return this === e || 0 === c.compare(this, e)
           }
               ,
               c.prototype.inspect = function() {
               var e = ""
               , n = t.INSPECT_MAX_BYTES;
               return this.length > 0 && (e = this.toString("hex", 0, n).match(/.{2}/g).join(" "),
                                          this.length > n && (e += " ... ")),
                   "<Buffer " + e + ">"
           }
               ,
               c.prototype.compare = function(e, t, n, i, r) {
               if (!c.isBuffer(e))
                   throw new TypeError("Argument must be a Buffer");
               if (void 0 === t && (t = 0),
                   void 0 === n && (n = e ? e.length : 0),
                   void 0 === i && (i = 0),
                   void 0 === r && (r = this.length),
                   t < 0 || n > e.length || i < 0 || r > this.length)
                   throw new RangeError("out of range index");
               if (i >= r && t >= n)
                   return 0;
               if (i >= r)
                   return -1;
               if (t >= n)
                   return 1;
               if (this === e)
                   return 0;
               for (var s = (r >>>= 0) - (i >>>= 0), a = (n >>>= 0) - (t >>>= 0), o = Math.min(s, a), l = this.slice(i, r), h = e.slice(t, n), u = 0; u < o; ++u)
                   if (l[u] !== h[u]) {
                       s = l[u],
                           a = h[u];
                       break
                   }
               return s < a ? -1 : a < s ? 1 : 0
           }
               ,
               c.prototype.includes = function(e, t, n) {
               return -1 !== this.indexOf(e, t, n)
           }
               ,
               c.prototype.indexOf = function(e, t, n) {
               return m(this, e, t, n, !0)
           }
               ,
               c.prototype.lastIndexOf = function(e, t, n) {
               return m(this, e, t, n, !1)
           }
               ,
               c.prototype.write = function(e, t, n, i) {
               if (void 0 === t)
                   i = "utf8",
                       n = this.length,
                       t = 0;
               else if (void 0 === n && "string" == typeof t)
                   i = t,
                       n = this.length,
                       t = 0;
               else {
                   if (!isFinite(t))
                       throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                   t |= 0,
                       isFinite(n) ? (n |= 0,
                                      void 0 === i && (i = "utf8")) : (i = n,
                                                                       n = void 0)
               }
               var r = this.length - t;
               if ((void 0 === n || n > r) && (n = r),
                   e.length > 0 && (n < 0 || t < 0) || t > this.length)
                   throw new RangeError("Attempt to write outside buffer bounds");
               i || (i = "utf8");
               for (var s = !1; ; )
                   switch (i) {
                       case "hex":
                           return k(this, e, t, n);
                       case "utf8":
                       case "utf-8":
                           return v(this, e, t, n);
                       case "ascii":
                           return w(this, e, t, n);
                       case "latin1":
                       case "binary":
                           return b(this, e, t, n);
                       case "base64":
                           return x(this, e, t, n);
                       case "ucs2":
                       case "ucs-2":
                       case "utf16le":
                       case "utf-16le":
                           return S(this, e, t, n);
                       default:
                           if (s)
                               throw new TypeError("Unknown encoding: " + i);
                           i = ("" + i).toLowerCase(),
                               s = !0
                   }
           }
               ,
               c.prototype.toJSON = function() {
               return {
                   type: "Buffer",
                   data: Array.prototype.slice.call(this._arr || this, 0)
               }
           }
           ;
           var E = 4096;
           function M(e, t, n) {
               var i = "";
               n = Math.min(e.length, n);
               for (var r = t; r < n; ++r)
                   i += String.fromCharCode(127 & e[r]);
               return i
           }
           function A(e, t, n) {
               var i = "";
               n = Math.min(e.length, n);
               for (var r = t; r < n; ++r)
                   i += String.fromCharCode(e[r]);
               return i
           }
           function P(e, t, n) {
               var i = e.length;
               (!t || t < 0) && (t = 0),
                   (!n || n < 0 || n > i) && (n = i);
               for (var r = "", s = t; s < n; ++s)
                   r += F(e[s]);
               return r
           }
           function B(e, t, n) {
               for (var i = e.slice(t, n), r = "", s = 0; s < i.length; s += 2)
                   r += String.fromCharCode(i[s] + 256 * i[s + 1]);
               return r
           }
           function C(e, t, n) {
               if (e % 1 != 0 || e < 0)
                   throw new RangeError("offset is not uint");
               if (e + t > n)
                   throw new RangeError("Trying to access beyond buffer length")
           }
           function O(e, t, n, i, r, s) {
               if (!c.isBuffer(e))
                   throw new TypeError('"buffer" argument must be a Buffer instance');
               if (t > r || t < s)
                   throw new RangeError('"value" argument is out of bounds');
               if (n + i > e.length)
                   throw new RangeError("Index out of range")
           }
           function R(e, t, n, i) {
               t < 0 && (t = 65535 + t + 1);
               for (var r = 0, s = Math.min(e.length - n, 2); r < s; ++r)
                   e[n + r] = (t & 255 << 8 * (i ? r : 1 - r)) >>> 8 * (i ? r : 1 - r)
           }
           function j(e, t, n, i) {
               t < 0 && (t = 4294967295 + t + 1);
               for (var r = 0, s = Math.min(e.length - n, 4); r < s; ++r)
                   e[n + r] = t >>> 8 * (i ? r : 3 - r) & 255
           }
           function _(e, t, n, i, r, s) {
               if (n + i > e.length)
                   throw new RangeError("Index out of range");
               if (n < 0)
                   throw new RangeError("Index out of range")
           }
           function U(e, t, n, i, s) {
               return s || _(e, 0, n, 4),
                   r.write(e, t, n, i, 23, 4),
                   n + 4
           }
           function D(e, t, n, i, s) {
               return s || _(e, 0, n, 8),
                   r.write(e, t, n, i, 52, 8),
                   n + 8
           }
           c.prototype.slice = function(e, t) {
               var n, i = this.length;
               if ((e = ~~e) < 0 ? (e += i) < 0 && (e = 0) : e > i && (e = i),
                   (t = void 0 === t ? i : ~~t) < 0 ? (t += i) < 0 && (t = 0) : t > i && (t = i),
                   t < e && (t = e),
                   c.TYPED_ARRAY_SUPPORT)
                   (n = this.subarray(e, t)).__proto__ = c.prototype;
               else {
                   var r = t - e;
                   n = new c(r,void 0);
                   for (var s = 0; s < r; ++s)
                       n[s] = this[s + e]
               }
               return n
           }
               ,
               c.prototype.readUIntLE = function(e, t, n) {
               e |= 0,
                   t |= 0,
                   n || C(e, t, this.length);
               for (var i = this[e], r = 1, s = 0; ++s < t && (r *= 256); )
                   i += this[e + s] * r;
               return i
           }
               ,
               c.prototype.readUIntBE = function(e, t, n) {
               e |= 0,
                   t |= 0,
                   n || C(e, t, this.length);
               for (var i = this[e + --t], r = 1; t > 0 && (r *= 256); )
                   i += this[e + --t] * r;
               return i
           }
               ,
               c.prototype.readUInt8 = function(e, t) {
               return t || C(e, 1, this.length),
                   this[e]
           }
               ,
               c.prototype.readUInt16LE = function(e, t) {
               return t || C(e, 2, this.length),
                   this[e] | this[e + 1] << 8
           }
               ,
               c.prototype.readUInt16BE = function(e, t) {
               return t || C(e, 2, this.length),
                   this[e] << 8 | this[e + 1]
           }
               ,
               c.prototype.readUInt32LE = function(e, t) {
               return t || C(e, 4, this.length),
                   (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
           }
               ,
               c.prototype.readUInt32BE = function(e, t) {
               return t || C(e, 4, this.length),
                   16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
           }
               ,
               c.prototype.readIntLE = function(e, t, n) {
               e |= 0,
                   t |= 0,
                   n || C(e, t, this.length);
               for (var i = this[e], r = 1, s = 0; ++s < t && (r *= 256); )
                   i += this[e + s] * r;
               return i >= (r *= 128) && (i -= Math.pow(2, 8 * t)),
                   i
           }
               ,
               c.prototype.readIntBE = function(e, t, n) {
               e |= 0,
                   t |= 0,
                   n || C(e, t, this.length);
               for (var i = t, r = 1, s = this[e + --i]; i > 0 && (r *= 256); )
                   s += this[e + --i] * r;
               return s >= (r *= 128) && (s -= Math.pow(2, 8 * t)),
                   s
           }
               ,
               c.prototype.readInt8 = function(e, t) {
               return t || C(e, 1, this.length),
                   128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
           }
               ,
               c.prototype.readInt16LE = function(e, t) {
               t || C(e, 2, this.length);
               var n = this[e] | this[e + 1] << 8;
               return 32768 & n ? 4294901760 | n : n
           }
               ,
               c.prototype.readInt16BE = function(e, t) {
               t || C(e, 2, this.length);
               var n = this[e + 1] | this[e] << 8;
               return 32768 & n ? 4294901760 | n : n
           }
               ,
               c.prototype.readInt32LE = function(e, t) {
               return t || C(e, 4, this.length),
                   this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
           }
               ,
               c.prototype.readInt32BE = function(e, t) {
               return t || C(e, 4, this.length),
                   this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
           }
               ,
               c.prototype.readFloatLE = function(e, t) {
               return t || C(e, 4, this.length),
                   r.read(this, e, !0, 23, 4)
           }
               ,
               c.prototype.readFloatBE = function(e, t) {
               return t || C(e, 4, this.length),
                   r.read(this, e, !1, 23, 4)
           }
               ,
               c.prototype.readDoubleLE = function(e, t) {
               return t || C(e, 8, this.length),
                   r.read(this, e, !0, 52, 8)
           }
               ,
               c.prototype.readDoubleBE = function(e, t) {
               return t || C(e, 8, this.length),
                   r.read(this, e, !1, 52, 8)
           }
               ,
               c.prototype.writeUIntLE = function(e, t, n, i) {
               e = +e,
                   t |= 0,
                   n |= 0,
                   i || O(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
               var r = 1
               , s = 0;
               for (this[t] = 255 & e; ++s < n && (r *= 256); )
                   this[t + s] = e / r & 255;
               return t + n
           }
               ,
               c.prototype.writeUIntBE = function(e, t, n, i) {
               e = +e,
                   t |= 0,
                   n |= 0,
                   i || O(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
               var r = n - 1
               , s = 1;
               for (this[t + r] = 255 & e; --r >= 0 && (s *= 256); )
                   this[t + r] = e / s & 255;
               return t + n
           }
               ,
               c.prototype.writeUInt8 = function(e, t, n) {
               return e = +e,
                   t |= 0,
                   n || O(this, e, t, 1, 255, 0),
                   c.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)),
                   this[t] = 255 & e,
                   t + 1
           }
               ,
               c.prototype.writeUInt16LE = function(e, t, n) {
               return e = +e,
                   t |= 0,
                   n || O(this, e, t, 2, 65535, 0),
                   c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
                                            this[t + 1] = e >>> 8) : R(this, e, t, !0),
                   t + 2
           }
               ,
               c.prototype.writeUInt16BE = function(e, t, n) {
               return e = +e,
                   t |= 0,
                   n || O(this, e, t, 2, 65535, 0),
                   c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8,
                                            this[t + 1] = 255 & e) : R(this, e, t, !1),
                   t + 2
           }
               ,
               c.prototype.writeUInt32LE = function(e, t, n) {
               return e = +e,
                   t |= 0,
                   n || O(this, e, t, 4, 4294967295, 0),
                   c.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24,
                                            this[t + 2] = e >>> 16,
                                            this[t + 1] = e >>> 8,
                                            this[t] = 255 & e) : j(this, e, t, !0),
                   t + 4
           }
               ,
               c.prototype.writeUInt32BE = function(e, t, n) {
               return e = +e,
                   t |= 0,
                   n || O(this, e, t, 4, 4294967295, 0),
                   c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24,
                                            this[t + 1] = e >>> 16,
                                            this[t + 2] = e >>> 8,
                                            this[t + 3] = 255 & e) : j(this, e, t, !1),
                   t + 4
           }
               ,
               c.prototype.writeIntLE = function(e, t, n, i) {
               if (e = +e,
                   t |= 0,
                   !i) {
                   var r = Math.pow(2, 8 * n - 1);
                   O(this, e, t, n, r - 1, -r)
               }
               var s = 0
               , a = 1
               , o = 0;
               for (this[t] = 255 & e; ++s < n && (a *= 256); )
                   e < 0 && 0 === o && 0 !== this[t + s - 1] && (o = 1),
                       this[t + s] = (e / a >> 0) - o & 255;
               return t + n
           }
               ,
               c.prototype.writeIntBE = function(e, t, n, i) {
               if (e = +e,
                   t |= 0,
                   !i) {
                   var r = Math.pow(2, 8 * n - 1);
                   O(this, e, t, n, r - 1, -r)
               }
               var s = n - 1
               , a = 1
               , o = 0;
               for (this[t + s] = 255 & e; --s >= 0 && (a *= 256); )
                   e < 0 && 0 === o && 0 !== this[t + s + 1] && (o = 1),
                       this[t + s] = (e / a >> 0) - o & 255;
               return t + n
           }
               ,
               c.prototype.writeInt8 = function(e, t, n) {
               return e = +e,
                   t |= 0,
                   n || O(this, e, t, 1, 127, -128),
                   c.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)),
                   e < 0 && (e = 255 + e + 1),
                   this[t] = 255 & e,
                   t + 1
           }
               ,
               c.prototype.writeInt16LE = function(e, t, n) {
               return e = +e,
                   t |= 0,
                   n || O(this, e, t, 2, 32767, -32768),
                   c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
                                            this[t + 1] = e >>> 8) : R(this, e, t, !0),
                   t + 2
           }
               ,
               c.prototype.writeInt16BE = function(e, t, n) {
               return e = +e,
                   t |= 0,
                   n || O(this, e, t, 2, 32767, -32768),
                   c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8,
                                            this[t + 1] = 255 & e) : R(this, e, t, !1),
                   t + 2
           }
               ,
               c.prototype.writeInt32LE = function(e, t, n) {
               return e = +e,
                   t |= 0,
                   n || O(this, e, t, 4, 2147483647, -2147483648),
                   c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
                                            this[t + 1] = e >>> 8,
                                            this[t + 2] = e >>> 16,
                                            this[t + 3] = e >>> 24) : j(this, e, t, !0),
                   t + 4
           }
               ,
               c.prototype.writeInt32BE = function(e, t, n) {
               return e = +e,
                   t |= 0,
                   n || O(this, e, t, 4, 2147483647, -2147483648),
                   e < 0 && (e = 4294967295 + e + 1),
                   c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24,
                                            this[t + 1] = e >>> 16,
                                            this[t + 2] = e >>> 8,
                                            this[t + 3] = 255 & e) : j(this, e, t, !1),
                   t + 4
           }
               ,
               c.prototype.writeFloatLE = function(e, t, n) {
               return U(this, e, t, !0, n)
           }
               ,
               c.prototype.writeFloatBE = function(e, t, n) {
               return U(this, e, t, !1, n)
           }
               ,
               c.prototype.writeDoubleLE = function(e, t, n) {
               return D(this, e, t, !0, n)
           }
               ,
               c.prototype.writeDoubleBE = function(e, t, n) {
               return D(this, e, t, !1, n)
           }
               ,
               c.prototype.copy = function(e, t, n, i) {
               if (n || (n = 0),
                   i || 0 === i || (i = this.length),
                   t >= e.length && (t = e.length),
                   t || (t = 0),
                   i > 0 && i < n && (i = n),
                   i === n)
                   return 0;
               if (0 === e.length || 0 === this.length)
                   return 0;
               if (t < 0)
                   throw new RangeError("targetStart out of bounds");
               if (n < 0 || n >= this.length)
                   throw new RangeError("sourceStart out of bounds");
               if (i < 0)
                   throw new RangeError("sourceEnd out of bounds");
               i > this.length && (i = this.length),
                   e.length - t < i - n && (i = e.length - t + n);
               var r, s = i - n;
               if (this === e && n < t && t < i)
                   for (r = s - 1; r >= 0; --r)
                       e[r + t] = this[r + n];
               else if (s < 1e3 || !c.TYPED_ARRAY_SUPPORT)
                   for (r = 0; r < s; ++r)
                       e[r + t] = this[r + n];
               else
                   Uint8Array.prototype.set.call(e, this.subarray(n, n + s), t);
               return s
           }
               ,
               c.prototype.fill = function(e, t, n, i) {
               if ("string" == typeof e) {
                   if ("string" == typeof t ? (i = t,
                                               t = 0,
                                               n = this.length) : "string" == typeof n && (i = n,
                                                                                           n = this.length),
                       1 === e.length) {
                       var r = e.charCodeAt(0);
                       r < 256 && (e = r)
                   }
                   if (void 0 !== i && "string" != typeof i)
                       throw new TypeError("encoding must be a string");
                   if ("string" == typeof i && !c.isEncoding(i))
                       throw new TypeError("Unknown encoding: " + i)
               } else
                   "number" == typeof e && (e &= 255);
               if (t < 0 || this.length < t || this.length < n)
                   throw new RangeError("Out of range index");
               if (n <= t)
                   return this;
               var s;
               if (t >>>= 0,
                   n = void 0 === n ? this.length : n >>> 0,
                   e || (e = 0),
                   "number" == typeof e)
                   for (s = t; s < n; ++s)
                       this[s] = e;
               else {
                   var a = c.isBuffer(e) ? e : z(new c(e,i).toString())
                   , o = a.length;
                   for (s = 0; s < n - t; ++s)
                       this[s + t] = a[s % o]
               }
               return this
           }
           ;
           var L = /[^+\/0-9A-Za-z-_]/g;
           function F(e) {
               return e < 16 ? "0" + e.toString(16) : e.toString(16)
           }
           function z(e, t) {
               var n;
               t = t || 1 / 0;
               for (var i = e.length, r = null, s = [], a = 0; a < i; ++a) {
                   if ((n = e.charCodeAt(a)) > 55295 && n < 57344) {
                       if (!r) {
                           if (n > 56319) {
                               (t -= 3) > -1 && s.push(239, 191, 189);
                               continue
                           }
                           if (a + 1 === i) {
                               (t -= 3) > -1 && s.push(239, 191, 189);
                               continue
                           }
                           r = n;
                           continue
                       }
                       if (n < 56320) {
                           (t -= 3) > -1 && s.push(239, 191, 189),
                               r = n;
                           continue
                       }
                       n = 65536 + (r - 55296 << 10 | n - 56320)
                   } else
                       r && (t -= 3) > -1 && s.push(239, 191, 189);
                   if (r = null,
                       n < 128) {
                       if ((t -= 1) < 0)
                           break;
                       s.push(n)
                   } else if (n < 2048) {
                       if ((t -= 2) < 0)
                           break;
                       s.push(n >> 6 | 192, 63 & n | 128)
                   } else if (n < 65536) {
                       if ((t -= 3) < 0)
                           break;
                       s.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                   } else {
                       if (!(n < 1114112))
                           throw new Error("Invalid code point");
                       if ((t -= 4) < 0)
                           break;
                       s.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                   }
               }
               return s
           }
           function H(e) {
               return i.toByteArray(function(e) {
                   if ((e = function(e) {
                       return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
                   }(e).replace(L, "")).length < 2)
                       return "";
                   for (; e.length % 4 != 0; )
                       e += "=";
                   return e
               }(e))
           }
           function V(e, t, n, i) {
               for (var r = 0; r < i && !(r + n >= t.length || r >= e.length); ++r)
                   t[r + n] = e[r];
               return r
           }
       }
       ).call(this, n(12))
   }
   , function(e, t) {
       var n;
       n = function() {
           return this
       }();
       try {
           n = n || new Function("return this")()
       } catch (e) {
           "object" == typeof window && (n = window)
       }
       e.exports = n
   }
   , function(e, t) {
       for (var n = t.uint8 = new Array(256), i = 0; i <= 255; i++)
           n[i] = r(i);
       function r(e) {
           return function(t) {
               var n = t.reserve(1);
               t.buffer[n] = e
           }
       }
   }
   , function(e, t, n) {
       t.FlexDecoder = s,
           t.FlexEncoder = a;
       var i = n(0)
       , r = "BUFFER_SHORTAGE";
       function s() {
           if (!(this instanceof s))
               return new s
       }
       function a() {
           if (!(this instanceof a))
               return new a
       }
       function o() {
           throw new Error("method not implemented: write()")
       }
       function c() {
           throw new Error("method not implemented: fetch()")
       }
       function l() {
           return this.buffers && this.buffers.length ? (this.flush(),
                                                         this.pull()) : this.fetch()
       }
       function h(e) {
           (this.buffers || (this.buffers = [])).push(e)
       }
       function u() {
           return (this.buffers || (this.buffers = [])).shift()
       }
       function f(e) {
           return function(t) {
               for (var n in e)
                   t[n] = e[n];
               return t
           }
       }
       s.mixin = f({
           bufferish: i,
           write: function(e) {
               var t = this.offset ? i.prototype.slice.call(this.buffer, this.offset) : this.buffer;
               this.buffer = t ? e ? this.bufferish.concat([t, e]) : t : e,
                   this.offset = 0
           },
           fetch: c,
           flush: function() {
               for (; this.offset < this.buffer.length; ) {
                   var e, t = this.offset;
                   try {
                       e = this.fetch()
                   } catch (e) {
                       if (e && e.message != r)
                           throw e;
                       this.offset = t;
                       break
                   }
                   this.push(e)
               }
           },
           push: h,
           pull: u,
           read: l,
           reserve: function(e) {
               var t = this.offset
               , n = t + e;
               if (n > this.buffer.length)
                   throw new Error(r);
               return this.offset = n,
                   t
           },
           offset: 0
       }),
           s.mixin(s.prototype),
           a.mixin = f({
           bufferish: i,
           write: o,
           fetch: function() {
               var e = this.start;
               if (e < this.offset) {
                   var t = this.start = this.offset;
                   return i.prototype.slice.call(this.buffer, e, t)
               }
           },
           flush: function() {
               for (; this.start < this.offset; ) {
                   var e = this.fetch();
                   e && this.push(e)
               }
           },
           push: h,
           pull: function() {
               var e = this.buffers || (this.buffers = [])
               , t = e.length > 1 ? this.bufferish.concat(e) : e[0];
               return e.length = 0,
                   t
           },
           read: l,
           reserve: function(e) {
               var t = 0 | e;
               if (this.buffer) {
                   var n = this.buffer.length
                   , i = 0 | this.offset
                   , r = i + t;
                   if (r < n)
                       return this.offset = r,
                           i;
                   this.flush(),
                       e = Math.max(e, Math.min(2 * n, this.maxBufferSize))
               }
               return e = Math.max(e, this.minBufferSize),
                   this.buffer = this.bufferish.alloc(e),
                   this.start = 0,
                   this.offset = t,
                   0
           },
           send: function(e) {
               var t = e.length;
               if (t > this.minBufferSize)
                   this.flush(),
                       this.push(e);
               else {
                   var n = this.reserve(t);
                   i.prototype.copy.call(e, this.buffer, n)
               }
           },
           maxBufferSize: 65536,
           minBufferSize: 2048,
           offset: 0,
           start: 0
       }),
           a.mixin(a.prototype)
   }
   , function(e, t, n) {
       t.decode = function(e, t) {
           var n = new i(t);
           return n.write(e),
               n.read()
       }
       ;
       var i = n(16).DecodeBuffer
       }
   , function(e, t, n) {
       t.DecodeBuffer = r;
       var i = n(8).preset;
       function r(e) {
           if (!(this instanceof r))
               return new r(e);
           if (e && (this.options = e,
                     e.codec)) {
               var t = this.codec = e.codec;
               t.bufferish && (this.bufferish = t.bufferish)
           }
       }
       n(14).FlexDecoder.mixin(r.prototype),
           r.prototype.codec = i,
           r.prototype.fetch = function() {
           return this.codec.decode(this)
       }
   }
   , function(e, t, n) {
       var i = n(4)
       , r = n(7)
       , s = r.Uint64BE
       , a = r.Int64BE;
       t.getReadFormat = function(e) {
           var t = o.hasArrayBuffer && e && e.binarraybuffer
           , n = e && e.int64;
           return {
               map: l && e && e.usemap ? u : h,
               array: f,
               str: d,
               bin: t ? g : p,
               ext: m,
               uint8: y,
               uint16: v,
               uint32: b,
               uint64: S(8, n ? E : T),
               int8: k,
               int16: w,
               int32: x,
               int64: S(8, n ? M : I),
               float32: S(4, A),
               float64: S(8, P)
           }
       }
           ,
           t.readUint8 = y;
       var o = n(0)
       , c = n(6)
       , l = "undefined" != typeof Map;
       function h(e, t) {
           var n, i = {}, r = new Array(t), s = new Array(t), a = e.codec.decode;
           for (n = 0; n < t; n++)
               r[n] = a(e),
                   s[n] = a(e);
           for (n = 0; n < t; n++)
               i[r[n]] = s[n];
           return i
       }
       function u(e, t) {
           var n, i = new Map, r = new Array(t), s = new Array(t), a = e.codec.decode;
           for (n = 0; n < t; n++)
               r[n] = a(e),
                   s[n] = a(e);
           for (n = 0; n < t; n++)
               i.set(r[n], s[n]);
           return i
       }
       function f(e, t) {
           for (var n = new Array(t), i = e.codec.decode, r = 0; r < t; r++)
               n[r] = i(e);
           return n
       }
       function d(e, t) {
           var n = e.reserve(t)
           , i = n + t;
           return c.toString.call(e.buffer, "utf-8", n, i)
       }
       function p(e, t) {
           var n = e.reserve(t)
           , i = n + t
           , r = c.slice.call(e.buffer, n, i);
           return o.from(r)
       }
       function g(e, t) {
           var n = e.reserve(t)
           , i = n + t
           , r = c.slice.call(e.buffer, n, i);
           return o.Uint8Array.from(r).buffer
       }
       function m(e, t) {
           var n = e.reserve(t + 1)
           , i = e.buffer[n++]
           , r = n + t
           , s = e.codec.getExtUnpacker(i);
           if (!s)
               throw new Error("Invalid ext type: " + (i ? "0x" + i.toString(16) : i));
           return s(c.slice.call(e.buffer, n, r))
       }
       function y(e) {
           var t = e.reserve(1);
           return e.buffer[t]
       }
       function k(e) {
           var t = e.reserve(1)
           , n = e.buffer[t];
           return 128 & n ? n - 256 : n
       }
       function v(e) {
           var t = e.reserve(2)
           , n = e.buffer;
           return n[t++] << 8 | n[t]
       }
       function w(e) {
           var t = e.reserve(2)
           , n = e.buffer
           , i = n[t++] << 8 | n[t];
           return 32768 & i ? i - 65536 : i
       }
       function b(e) {
           var t = e.reserve(4)
           , n = e.buffer;
           return 16777216 * n[t++] + (n[t++] << 16) + (n[t++] << 8) + n[t]
       }
       function x(e) {
           var t = e.reserve(4)
           , n = e.buffer;
           return n[t++] << 24 | n[t++] << 16 | n[t++] << 8 | n[t]
       }
       function S(e, t) {
           return function(n) {
               var i = n.reserve(e);
               return t.call(n.buffer, i, !0)
           }
       }
       function T(e) {
           return new s(this,e).toNumber()
       }
       function I(e) {
           return new a(this,e).toNumber()
       }
       function E(e) {
           return new s(this,e)
       }
       function M(e) {
           return new a(this,e)
       }
       function A(e) {
           return i.read(this, e, !1, 23, 4)
       }
       function P(e) {
           return i.read(this, e, !1, 52, 8)
       }
   }
   , function(e, t, n) {
       !function(t) {
           e.exports = t;
           var n = "listeners"
           , i = {
               on: function(e, t) {
                   return a(this, e).push(t),
                       this
               },
               once: function(e, t) {
                   var n = this;
                   return i.originalListener = t,
                       a(n, e).push(i),
                       n;
                   function i() {
                       s.call(n, e, i),
                           t.apply(this, arguments)
                   }
               },
               off: s,
               emit: function(e, t) {
                   var n = this
                   , i = a(n, e, !0);
                   if (!i)
                       return !1;
                   var r = arguments.length;
                   if (1 === r)
                       i.forEach((function(e) {
                           e.call(n)
                       }
                                 ));
                   else if (2 === r)
                       i.forEach((function(e) {
                           e.call(n, t)
                       }
                                 ));
                   else {
                       var s = Array.prototype.slice.call(arguments, 1);
                       i.forEach((function(e) {
                           e.apply(n, s)
                       }
                                 ))
                   }
                   return !!i.length
               }
           };
           function r(e) {
               for (var t in i)
                   e[t] = i[t];
               return e
           }
           function s(e, t) {
               var i;
               if (arguments.length) {
                   if (t) {
                       if (i = a(this, e, !0)) {
                           if (!(i = i.filter((function(e) {
                               return e !== t && e.originalListener !== t
                           }
                                              ))).length)
                               return s.call(this, e);
                           this[n][e] = i
                       }
                   } else if ((i = this[n]) && (delete i[e],
                                                !Object.keys(i).length))
                       return s.call(this)
               } else
                   delete this[n];
               return this
           }
           function a(e, t, i) {
               if (!i || e[n]) {
                   var r = e[n] || (e[n] = {});
                   return r[t] || (r[t] = [])
               }
           }
           r(t.prototype),
               t.mixin = r
       }((/**
 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
 *
 * @copyright Yusuke Kawasaki
 * @license MIT
 * @constructor
 * @see https://github.com/kawanet/event-lite
 * @see http://kawanet.github.io/event-lite/EventLite.html
 * @example
 * var EventLite = require("event-lite");
 *
 * function MyClass() {...}             // your class
 *
 * EventLite.mixin(MyClass.prototype);  // import event methods
 *
 * var obj = new MyClass();
 * obj.on("foo", function() {...});     // add event listener
 * obj.once("bar", function() {...});   // add one-time event listener
 * obj.emit("foo");                     // dispatch event
 * obj.emit("bar");                     // dispatch another event
 * obj.off("foo");                      // remove event listener
 */
           function e() {
               if (!(this instanceof e))
                   return new e
           }
       ))
   }
   , function(e, t, n) {
       (function(t) {
           e.exports.maxScreenWidth = 1920,
               e.exports.maxScreenHeight = 1080,
               e.exports.serverUpdateRate = 9,
               e.exports.maxPlayers = t && -1 != t.argv.indexOf("--largeserver") ? 99999 : 99999,
               e.exports.maxPlayersHard = e.exports.maxPlayers + 10,
               e.exports.collisionDepth = 6,
               e.exports.minimapRate = 3e3,
               e.exports.colGrid = 10,
               e.exports.clientSendRate = 5,
               e.exports.healthBarWidth = 50,
               e.exports.healthBarPad = 4.5,
               e.exports.iconPadding = 15,
               e.exports.iconPad = .9,
               e.exports.deathFadeout = 3e3,
               e.exports.crownIconScale = 60,
               e.exports.crownPad = 35,
               e.exports.chatCountdown = 3e3,
               e.exports.chatCooldown = 500,
               e.exports.inSandbox = t && "mm_exp" === t.env.VULTR_SCHEME,
               e.exports.maxAge = 100,
               e.exports.gatherAngle = Math.PI / 2.6,
               e.exports.gatherWiggle = 10,
               e.exports.hitReturnRatio = .25,
               e.exports.hitAngle = Math.PI / 2,
               e.exports.playerScale = 35,
               e.exports.playerSpeed = .0016,
               e.exports.playerDecel = .993,
               e.exports.nameY = 34,
               e.exports.skinColors = ["#bf8f54", "#cbb091", "#896c4b", "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3", "#8bc373"],
               e.exports.animalCount = 7,
               e.exports.aiTurnRandom = .06,
               e.exports.cowNames = ["Sid", "Steph", "Bmoe", "Romn", "Jononthecool", "Fiona", "Vince", "Nathan", "Nick", "Flappy", "Ronald", "Otis", "Pepe", "Mc Donald", "Theo", "Fabz", "Oliver", "Jeff", "Jimmy", "Helena", "Reaper", "Ben", "Alan", "Naomi", "XYZ", "Clever", "Jeremy", "Mike", "Destined", "Stallion", "Allison", "Meaty", "Sophia", "Vaja", "Joey", "Pendy", "Murdoch", "Theo", "Jared", "July", "Sonia", "Mel", "Dexter", "Quinn", "Milky"],
               e.exports.shieldAngle = Math.PI / 3,
               e.exports.weaponVariants = [{
                   id: 0,
                   src: "",
                   xp: 0,
                   val: 1
               }, {
                   id: 1,
                   src: "_g",
                   xp: 3e3,
                   val: 1.1
               }, {
                   id: 2,
                   src: "_d",
                   xp: 7e3,
                   val: 1.18
               }, {
                   id: 3,
                   src: "_r",
                   poison: !0,
                   xp: 12e3,
                   val: 1.18
               }],
               e.exports.fetchVariant = function(t) {
               for (var n = t.weaponXP[t.weaponIndex] || 0, i = e.exports.weaponVariants.length - 1; i >= 0; --i)
                   if (n >= e.exports.weaponVariants[i].xp)
                       return e.exports.weaponVariants[i]
           }
               ,
               e.exports.resourceTypes = ["wood", "food", "stone", "points"],
               e.exports.areaCount = 7,
               e.exports.treesPerArea = 9,
               e.exports.bushesPerArea = 3,
               e.exports.totalRocks = 32,
               e.exports.goldOres = 7,
               e.exports.riverWidth = 724,
               e.exports.riverPadding = 114,
               e.exports.waterCurrent = .0011,
               e.exports.waveSpeed = 1e-4,
               e.exports.waveMax = 1.3,
               e.exports.treeScales = [150, 160, 165, 175],
               e.exports.bushScales = [80, 85, 95],
               e.exports.rockScales = [80, 85, 90],
               e.exports.snowBiomeTop = 2400,
               e.exports.snowSpeed = .75,
               e.exports.maxNameLength = 15,
               e.exports.mapScale = 14400,
               e.exports.mapPingScale = 40,
               e.exports.mapPingTime = 2200
       }
       ).call(this, n(41))
   }
   , function(e, t) {
       var n = {
           utf8: {
               stringToBytes: function(e) {
                   return n.bin.stringToBytes(unescape(encodeURIComponent(e)))
               },
               bytesToString: function(e) {
                   return decodeURIComponent(escape(n.bin.bytesToString(e)))
               }
           },
           bin: {
               stringToBytes: function(e) {
                   for (var t = [], n = 0; n < e.length; n++)
                       t.push(255 & e.charCodeAt(n));
                   return t
               },
               bytesToString: function(e) {
                   for (var t = [], n = 0; n < e.length; n++)
                       t.push(String.fromCharCode(e[n]));
                   return t.join("")
               }
           }
       };
       e.exports = n
   }
   , function(e, t, n) {
       "use strict";
       window.loadedScript = !0;
       var i = "127.0.0.1" !== location.hostname && !location.hostname.startsWith("192.168.");
       n(22);
       var r = n(23)
       , s = n(42)
       , a = n(43)
       , o = n(19)
       , c = n(44)
       , l = n(45)
       , h = (n(46),
              n(47))
       , u = n(48)
       , f = n(55)
       , d = n(56)
       , p = n(57)
       , g = n(58).obj
       , m = new a.TextManager
       , y = new (n(59))("moomoo.io",3e3,o.maxPlayers,5,!1);
       y.debugLog = !1;
       var k = !1;
       function v() {
           ht && ut && (k = !0,
                        i ? window.grecaptcha.execute("6LevKusUAAAAAAFknhlV8sPtXAk5Z5dGP5T2FYIZ", {
               action: "homepage"
           }).then((function(e) {
               w(e)
           }
                   )) : w(null))
       }
       function w(e) {
           y.start((function(t, n, a) {
               var c = (i ? "wss" : "ws") + "://" + t + ":8008/?gameIndex=" + a;
               e && (c += "&token=" + encodeURIComponent(e)),
                   r.connect(c, (function(e) {
                   Bi(),
                       setInterval(()=>Bi(), 2500),
                       e ? ft(e) : (ue.onclick = s.checkTrusted((function() {
                       !function() {
                           var e = ++bt > 1
                           , t = Date.now() - wt > vt;
                           e && t ? (wt = Date.now(),
                                     xt()) : Tn()
                       }()
                   }
                                                                )),
                                    s.hookTouchEvents(ue),
                                    fe.onclick = s.checkTrusted((function() {
                       Oi("https://krunker.io/?play=SquidGame_KB")
                   }
                                                                )),
                                    s.hookTouchEvents(fe),
                                    pe.onclick = s.checkTrusted((function() {
                       setTimeout((function() {
                           !function() {
                               var e = xe.value
                               , t = prompt("party key", e);
                               t && (window.onbeforeunload = void 0,
                                     window.location.href = "/?server=" + t)
                           }()
                       }
                                  ), 10)
                   }
                                                                )),
                                    s.hookTouchEvents(pe),
                                    ge.onclick = s.checkTrusted((function() {
                       Ae.classList.contains("showing") ? (Ae.classList.remove("showing"),
                                                           me.innerText = "Settings") : (Ae.classList.add("showing"),
                                                                                         me.innerText = "Close")
                   }
                                                                )),
                                    s.hookTouchEvents(ge),
                                    ye.onclick = s.checkTrusted((function() {
                       yn(),
                           "block" != Ye.style.display ? Ut() : Ye.style.display = "none"
                   }
                                                                )),
                                    s.hookTouchEvents(ye),
                                    ke.onclick = s.checkTrusted((function() {
                       "block" != Qe.style.display ? (Qe.style.display = "block",
                                                      Ye.style.display = "none",
                                                      an(),
                                                      Gt()) : Qe.style.display = "none"
                   }
                                                                )),
                                    s.hookTouchEvents(ke),
                                    ve.onclick = s.checkTrusted((function() {
                       rn()
                   }
                                                                )),
                                    s.hookTouchEvents(ve),
                                    Ne.onclick = s.checkTrusted((function() {
                       xn()
                   }
                                                                )),
                                    s.hookTouchEvents(Ne),
                                    function() {
                       for (var e = 0; e < jn.length; ++e) {
                           var t = new Image;
                           t.onload = function() {
                               this.isLoaded = !0
                           }
                               ,
                               t.src = ".././img/icons/" + jn[e] + ".png",
                               Rn[jn[e]] = t
                       }
                   }(),
                                    Pe.style.display = "none",
                                    Me.style.display = "block",
                                    Le.value = E("moo_name") || "",
                                    function() {
                       var e = E("native_resolution");
                       Zt(e ? "true" == e : "undefined" != typeof cordova),
                           A = "true" == E("show_ping"),
                           Ie.hidden = !A,
                           E("moo_moosic"),
                           setInterval((function() {
                           window.cordova && (document.getElementById("downloadButtonContainer").classList.add("cordova"),
                                              document.getElementById("mobileDownloadButtonContainer").classList.add("cordova"))
                       }
                                       ), 1e3),
                           en(),
                           s.removeAllChildren(Ce);
                       for (var t = 0; t < l.weapons.length + l.list.length; ++t)
                           !function(e) {
                               s.generateElement({
                                   id: "actionBarItem" + e,
                                   class: "actionBarItem",
                                   style: "display:none",
                                   onmouseout: function() {
                                       Tt()
                                   },
                                   parent: Ce
                               })
                           }(t);
                       for (t = 0; t < l.list.length + l.weapons.length; ++t)
                           !function(e) {
                               var t = document.createElement("canvas");
                               t.width = t.height = 66;
                               var n = t.getContext("2d");
                               if (n.translate(t.width / 2, t.height / 2),
                                   n.imageSmoothingEnabled = !1,
                                   n.webkitImageSmoothingEnabled = !1,
                                   n.mozImageSmoothingEnabled = !1,
                                   l.weapons[e]) {
                                   n.rotate(Math.PI / 4 + Math.PI);
                                   var i = new Image;
                                   Zn[l.weapons[e].src] = i,
                                       i.onload = function() {
                                       this.isLoaded = !0;
                                       var i = 1 / (this.height / this.width)
                                       , r = l.weapons[e].iPad || 1;
                                       n.drawImage(this, -t.width * r * o.iconPad * i / 2, -t.height * r * o.iconPad / 2, t.width * r * i * o.iconPad, t.height * r * o.iconPad),
                                           n.fillStyle = "rgba(0, 0, 70, 0.1)",
                                           n.globalCompositeOperation = "source-atop",
                                           n.fillRect(-t.width / 2, -t.height / 2, t.width, t.height),
                                           document.getElementById("actionBarItem" + e).style.backgroundImage = "url(" + t.toDataURL() + ")"
                                   }
                                       ,
                                       i.src = ".././img/weapons/" + l.weapons[e].src + ".png",
                                       (r = document.getElementById("actionBarItem" + e)).onmouseover = s.checkTrusted((function() {
                                       Tt(l.weapons[e], !0)
                                   }
                                                                                                                       )),
                                       r.onclick = s.checkTrusted((function() {
                                       Sn(e, !0)
                                   }
                                                                  )),
                                       s.hookTouchEvents(r)
                               } else {
                                   i = ri(l.list[e - l.weapons.length], !0);
                                   var r, a = Math.min(t.width - o.iconPadding, i.width);
                                   n.globalAlpha = 1,
                                       n.drawImage(i, -a / 2, -a / 2, a, a),
                                       n.fillStyle = "rgba(0, 0, 70, 0.1)",
                                       n.globalCompositeOperation = "source-atop",
                                       n.fillRect(-a / 2, -a / 2, a, a),
                                       document.getElementById("actionBarItem" + e).style.backgroundImage = "url(" + t.toDataURL() + ")",
                                       (r = document.getElementById("actionBarItem" + e)).onmouseover = s.checkTrusted((function() {
                                       Tt(l.list[e - l.weapons.length])
                                   }
                                                                                                                       )),
                                       r.onclick = s.checkTrusted((function() {
                                       Sn(e - l.weapons.length)
                                   }
                                                                  )),
                                       s.hookTouchEvents(r)
                               }
                           }(t);
                       Le.ontouchstart = s.checkTrusted((function(e) {
                           e.preventDefault();
                           var t = prompt("enter name", e.currentTarget.value);
                           e.currentTarget.value = t.slice(0, 15)
                       }
                                                        )),
                           Se.checked = M,
                           Se.onchange = s.checkTrusted((function(e) {
                           Zt(e.target.checked)
                       }
                                                        )),
                           Te.checked = A,
                           Te.onchange = s.checkTrusted((function(e) {
                           A = Te.checked,
                               Ie.hidden = !A,
                               I("show_ping", A ? "true" : "false")
                       }
                                                        ))
                   }())
               }
                                ), {
                   id: st,
                   d: ft,
                   1: En,
                   2: vi,
                   4: wi,
                   33: Ti,
                   5: Ln,
                   6: li,
                   a: gi,
                   aa: pi,
                   7: Wn,
                   8: hi,
                   sp: ui,
                   9: xi,
                   h: Si,
                   11: Pn,
                   12: Cn,
                   13: Bn,
                   14: bi,
                   15: Dn,
                   16: Un,
                   17: $t,
                   18: fi,
                   19: di,
                   20: Ci,
                   ac: Ot,
                   ad: _t,
                   an: Bt,
                   st: Rt,
                   sa: jt,
                   us: Nt,
                   ch: hn,
                   mm: Wt,
                   t: Mn,
                   p: Yt,
                   pp: Pi
               }),
                   pt(),
                   setTimeout(()=>gt(), 3e3)
           }
                   ), (function(e) {
               console.error("Vultr error:", e),
                   alert("Error:\n" + e),
                   ft("disconnected")
           }
                      ))
       }
       var b, x = new g(o,s), S = Math.PI, T = 2 * S;
       function I(e, t) {
           b && localStorage.setItem(e, t)
       }
       function E(e) {
           return b ? localStorage.getItem(e) : null
       }
       Math.lerpAngle = function(e, t, n) {
           Math.abs(t - e) > S && (e > t ? t += T : e += T);
           var i = t + (e - t) * n;
           return i >= 0 && i <= T ? i : i % T
       }
           ,
           CanvasRenderingContext2D.prototype.roundRect = function(e, t, n, i, r) {
           return n < 2 * r && (r = n / 2),
               i < 2 * r && (r = i / 2),
               r < 0 && (r = 0),
               this.beginPath(),
               this.moveTo(e + r, t),
               this.arcTo(e + n, t, e + n, t + i, r),
               this.arcTo(e + n, t + i, e, t + i, r),
               this.arcTo(e, t + i, e, t, r),
               this.arcTo(e, t, e + n, t, r),
               this.closePath(),
               this
       }
           ,
           "undefined" != typeof Storage && (b = !0),
           E("consent") || (consentBlock.style.display = "block"),
           window.checkTerms = function(e) {
           e ? (consentBlock.style.display = "none",
                I("consent", 1)) : $("#consentShake").effect("shake")
       }
       ;
       var M, A, P, B, C, O, R, j, _, U, D, L, F, z, H = E("moofoll"), V = 1, q = Date.now(), Y = [], W = [], X = [], N = [], G = [], J = new p(d,G,W,Y,nt,l,o,s), K = n(70), Q = n(71), Z = new K(Y,Q,W,l,null,o,s), ee = 1, te = 0, ne = 0, ie = 0, re = {
           id: -1,
           startX: 0,
           startY: 0,
           currentX: 0,
           currentY: 0
       }, se = {
           id: -1,
           startX: 0,
           startY: 0,
           currentX: 0,
           currentY: 0
       }, ae = 0, oe = o.maxScreenWidth, ce = o.maxScreenHeight, le = !1, he = (document.getElementById("ad-container"),
                                                                                document.getElementById("mainMenu")), ue = document.getElementById("enterGame"), fe = document.getElementById("promoImg"), de = document.getElementById("partyButton"), pe = document.getElementById("joinPartyButton"), ge = document.getElementById("settingsButton"), me = ge.getElementsByTagName("span")[0], ye = document.getElementById("allianceButton"), ke = document.getElementById("storeButton"), ve = document.getElementById("chatButton"), we = document.getElementById("gameCanvas"), be = we.getContext("2d"), xe = document.getElementById("serverBrowser"), Se = document.getElementById("nativeResolution"), Te = document.getElementById("showPing"), Ie = (document.getElementById("playMusic"),
    document.getElementById("pingDisplay")), Ee = document.getElementById("shutdownDisplay"), Me = document.getElementById("menuCardHolder"), Ae = document.getElementById("guideCard"), Pe = document.getElementById("loadingText"), Be = document.getElementById("gameUI"), Ce = document.getElementById("actionBar"), Oe = document.getElementById("scoreDisplay"), Re = document.getElementById("foodDisplay"), je = document.getElementById("woodDisplay"), _e = document.getElementById("stoneDisplay"), Ue = document.getElementById("killCounter"), De = document.getElementById("leaderboardData"), Le = document.getElementById("nameInput"), Fe = document.getElementById("itemInfoHolder"), ze = document.getElementById("ageText"), He = document.getElementById("ageBarBody"), Ve = document.getElementById("upgradeHolder"), qe = document.getElementById("upgradeCounter"), Ye = document.getElementById("allianceMenu"), We = document.getElementById("allianceHolder"), Xe = document.getElementById("allianceManager"), Ne = document.getElementById("mapDisplay"), Ge = document.getElementById("diedText"), Je = document.getElementById("skinColorHolder"), Ke = Ne.getContext("2d");
       Ne.width = 300,
           Ne.height = 300;
       var Qe = document.getElementById("storeMenu")
       , $e = document.getElementById("storeHolder")
       , Ze = document.getElementById("noticationDisplay")
       , et = f.hats
       , tt = f.accessories
       , nt = new h(c,N,s,o)
       , it = "#525252"
       , rt = "#3d3f42";
       function st(e) {
           X = e.teams
       }
       var at = document.getElementById("featuredYoutube")
       , ot = [{
           name: "Corrupt X",
           link: "https://www.youtube.com/channel/UC0UH2LfQvBSeH24bmtbmITw"
       }, {
           name: "Tweak Big",
           link: "https://www.youtube.com/channel/UCbwvzJ38AndDTkoX8sD9YOw"
       }, {
           name: "Arena Closer",
           link: "https://www.youtube.com/channel/UCazucVSJqW-kiHMIhQhD-QQ"
       }, {
           name: "Godenot",
           link: "https://www.youtube.com/user/SirGodenot"
       }, {
           name: "RajNoobTV",
           link: "https://www.youtube.com/channel/UCVLo9brXBWrCttMaGzvm0-Q"
       }, {
           name: "TomNotTom",
           link: "https://www.youtube.com/channel/UC7z97RgHFJRcv2niXgArBDw"
       }, {
           name: "Nation",
           link: "https://www.youtube.com/channel/UCSl-MBn3qzjrIvLNESQRk-g"
       }, {
           name: "Pidyohago",
           link: "https://www.youtube.com/channel/UC04p8Mg8nDaDx04A9is2B8Q"
       }, {
           name: "Enigma",
           link: "https://www.youtube.com/channel/UC5HhLbs3sReHo8Bb9NDdFrg"
       }, {
           name: "Bauer",
           link: "https://www.youtube.com/channel/UCwU2TbJx3xTSlPqg-Ix3R1g"
       }, {
           name: "iStealth",
           link: "https://www.youtube.com/channel/UCGrvlEOsQFViZbyFDE6t69A"
       }, {
           name: "SICKmania",
           link: "https://www.youtube.com/channel/UCvVI98ezn4TpX5wDMZjMa3g"
       }, {
           name: "LightThief",
           link: "https://www.youtube.com/channel/UCj6C_tiDeATiKd3GX127XoQ"
       }, {
           name: "Fortish",
           link: "https://www.youtube.com/channel/UCou6CLU-szZA3Tb340TB9_Q"
       }, {
           name: "Ã¥Â·Â§Ã¥â€¦â€¹Ã¥Å â€º",
           link: "https://www.youtube.com/channel/UCgL6J6oL8F69vm-GcPScmwg"
       }, {
           name: "i Febag",
           link: "https://www.youtube.com/channel/UCiU6WZwiKbsnt5xmwr0OFbg"
       }, {
           name: "GoneGaming",
           link: "https://www.youtube.com/channel/UCOcQthRanYcwYY0XVyVeK0g"
       }]
       , ct = ot[s.randInt(0, ot.length - 1)];
       at.innerHTML = "<a target='_blank' class='ytLink' href='" + ct.link + "'><i class='material-icons' style='vertical-align: top;'>&#xE064;</i> " + ct.name + "</a>";
       var lt = !0
       , ht = !1
       , ut = !1;
       function ft(e) {
           r.close(),
               dt(e)
       }
       function dt(e) {
           he.style.display = "block",
               Be.style.display = "none",
               Me.style.display = "none",
               Ge.style.display = "none",
               Pe.style.display = "block",
               Pe.innerHTML = e + "<a href='javascript:window.location.href=window.location.href' class='ytLink'>reload</a>"
       }
       window.onblur = function() {
           lt = !1
       }
           ,
           window.onfocus = function() {
           lt = !0,
               R && R.alive && yn()
       }
           ,
           window.onload = function() {
           ht = !0,
               v(),
               setTimeout((function() {
               k || (alert("Captcha failed to load"),
                     window.location.reload())
           }
                          ), 2e4)
       }
           ,
           window.captchaCallback = function() {
           ut = !0,
               v()
       }
           ,
           we.oncontextmenu = function() {
           return !1
       }
       ;
       function pt() {
           var e, t, n = "", i = 0;
           for (var r in y.servers) {
               for (var s = y.servers[r], a = 0, c = 0; c < s.length; c++)
                   for (var l = 0; l < s[c].games.length; l++)
                       a += s[c].games[l].playerCount;
               i += a;
               var h = y.regionInfo[r].name;
               n += "<option disabled>" + h + " - " + a + " players</option>";
               for (var u = 0; u < s.length; u++)
                   for (var f = s[u], d = 0; d < f.games.length; d++) {
                       var p = f.games[d]
                       , g = 1 * f.index + d + 1
                       , m = y.server && y.server.region === f.region && y.server.index === f.index && y.gameIndex == d
                       , k = h + " " + g + " [" + Math.min(p.playerCount, o.maxPlayers) + "/" + o.maxPlayers + "]";
                       let e = y.stripRegion(r) + ":" + u + ":" + d;
                       m && (de.getElementsByTagName("span")[0].innerText = e),
                           n += "<option value='" + e + "' " + (m ? "selected" : "") + ">" + k + "</option>"
                   }
               n += "<option disabled></option>"
           }
           n += "<option disabled>All Servers - " + i + " players</option>",
               xe.innerHTML = n,
               "sandbox.moomoo.io" == location.hostname ? (e = "Back to MooMoo",
                                                           t = "//moomoo.io/") : (e = "Try the sandbox",
                                                                                  t = "//sandbox.moomoo.io/"),
               document.getElementById("altServer").innerHTML = "<a href='" + t + "'>" + e + "<i class='material-icons' style='font-size:10px;vertical-align:middle'>arrow_forward_ios</i></a>"
       }
       function gt() {
           var e = new XMLHttpRequest;
           e.onreadystatechange = function() {
               4 == this.readyState && (200 == this.status ? (window.vultr = JSON.parse(this.responseText),
                                                              y.processServers(vultr.servers),
                                                              pt()) : console.error("Failed to load server data with status code:", this.status))
           }
               ,
               e.open("GET", "/serverData", !0),
               e.send()
       }
       xe.addEventListener("change", s.checkTrusted((function() {
           let e = xe.value.split(":");
           y.switchServer(e[0], e[1], e[2])
       }
                                                    )));
       var mt = document.getElementById("pre-content-container")
       , yt = null
       , kt = null;
       window.cpmstarAPI((function(e) {
           e.game.setTarget(mt),
               kt = e
       }
                         ));
       var vt = 3e5
       , wt = 0
       , bt = 0;
       function xt() {
           if (!cpmstarAPI || !kt)
               return console.log("Failed to load video ad API", !!cpmstarAPI, !!kt),
                   void Tn();
           (yt = new kt.game.RewardedVideoView("rewardedvideo")).addEventListener("ad_closed", (function(e) {
               console.log("Video ad closed"),
                   St()
           }
                                                                                               )),
               yt.addEventListener("loaded", (function(e) {
               console.log("Video ad loaded"),
                   yt.show()
           }
                                             )),
               yt.addEventListener("load_failed", (function(e) {
               console.log("Video ad load failed", e),
                   St()
           }
                                                  )),
               yt.load(),
               mt.style.display = "block"
       }
       function St() {
           mt.style.display = "none",
               Tn()
       }
       function Tt(e, t, n) {
           if (R && e)
               if (s.removeAllChildren(Fe),
                   Fe.classList.add("visible"),
                   s.generateElement({
                   id: "itemInfoName",
                   text: s.capitalizeFirst(e.name),
                   parent: Fe
               }),
                   s.generateElement({
                   id: "itemInfoDesc",
                   text: e.desc,
                   parent: Fe
               }),
                   n)
                   ;
               else if (t)
                   s.generateElement({
                       class: "itemInfoReq",
                       text: e.type ? "secondary" : "primary",
                       parent: Fe
                   });
               else {
                   for (var i = 0; i < e.req.length; i += 2)
                       s.generateElement({
                           class: "itemInfoReq",
                           html: e.req[i] + "<span class='itemInfoReqVal'> x" + e.req[i + 1] + "</span>",
                           parent: Fe
                       });
                   e.group.limit && s.generateElement({
                       class: "itemInfoLmt",
                       text: (R.itemCounts[e.group.id] || 0) + "/" + e.group.limit,
                       parent: Fe
                   })
               }
           else
               Fe.classList.remove("visible")
       }
       window.showPreAd = xt;
       var It, Et, Mt, At = [], Pt = [];
       function Bt(e, t) {
           At.push({
               sid: e,
               name: t
           }),
               Ct()
       }
       function Ct() {
           if (At[0]) {
               var e = At[0];
               s.removeAllChildren(Ze),
                   Ze.style.display = "block",
                   s.generateElement({
                   class: "notificationText",
                   text: e.name,
                   parent: Ze
               }),
                   s.generateElement({
                   class: "notifButton",
                   html: "<i class='material-icons' style='font-size:28px;color:#cc5151;'>&#xE14C;</i>",
                   parent: Ze,
                   onclick: function() {
                       Dt(0)
                   },
                   hookTouch: !0
               }),
                   s.generateElement({
                   class: "notifButton",
                   html: "<i class='material-icons' style='font-size:28px;color:#8ecc51;'>&#xE876;</i>",
                   parent: Ze,
                   onclick: function() {
                       Dt(1)
                   },
                   hookTouch: !0
               })
           } else
               Ze.style.display = "none"
       }
       function Ot(e) {
           X.push(e),
               "block" == Ye.style.display && Ut()
       }
       function Rt(e, t) {
           R && (R.team = e,
                 R.isOwner = t,
                 "block" == Ye.style.display && Ut())
       }
       function jt(e) {
           Pt = e,
               "block" == Ye.style.display && Ut()
       }
       function _t(e) {
           for (var t = X.length - 1; t >= 0; t--)
               X[t].sid == e && X.splice(t, 1);
           "block" == Ye.style.display && Ut()
       }
       function Ut() {
           if (R && R.alive) {
               if (an(),
                   Qe.style.display = "none",
                   Ye.style.display = "block",
                   s.removeAllChildren(We),
                   R.team)
                   for (var e = 0; e < Pt.length; e += 2)
                       !function(e) {
                           var t = s.generateElement({
                               class: "allianceItem",
                               style: "color:" + (Pt[e] == R.sid ? "#fff" : "rgba(255,255,255,0.6)"),
                               text: Pt[e + 1],
                               parent: We
                           });
                           R.isOwner && Pt[e] != R.sid && s.generateElement({
                               class: "joinAlBtn",
                               text: "Kick",
                               onclick: function() {
                                   Lt(Pt[e])
                               },
                               hookTouch: !0,
                               parent: t
                           })
                       }(e);
               else if (X.length)
                   for (e = 0; e < X.length; ++e)
                       !function(e) {
                           var t = s.generateElement({
                               class: "allianceItem",
                               style: "color:" + (X[e].sid == R.team ? "#fff" : "rgba(255,255,255,0.6)"),
                               text: X[e].sid,
                               parent: We
                           });
                           s.generateElement({
                               class: "joinAlBtn",
                               text: "Join",
                               onclick: function() {
                                   Ft(e)
                               },
                               hookTouch: !0,
                               parent: t
                           })
                       }(e);
               else
                   s.generateElement({
                       class: "allianceItem",
                       text: "No Tribes Yet",
                       parent: We
                   });
               s.removeAllChildren(Xe),
                   R.team ? s.generateElement({
                   class: "allianceButtonM",
                   style: "width: 360px",
                   text: R.isOwner ? "Delete Tribe" : "Leave Tribe",
                   onclick: function() {
                       Ht()
                   },
                   hookTouch: !0,
                   parent: Xe
               }) : (s.generateElement({
                   tag: "input",
                   type: "text",
                   id: "allianceInput",
                   maxLength: 7,
                   placeholder: "unique name",
                   ontouchstart: function(e) {
                       e.preventDefault();
                       var t = prompt("unique name", e.currentTarget.value);
                       e.currentTarget.value = t.slice(0, 7)
                   },
                   parent: Xe
               }),
                     s.generateElement({
                   tag: "div",
                   class: "allianceButtonM",
                   style: "width: 140px;",
                   text: "Create",
                   onclick: function() {
                       zt()
                   },
                   hookTouch: !0,
                   parent: Xe
               }))
           }
       }
       function Dt(e) {
           r.send("11", At[0].sid, e),
               At.splice(0, 1),
               Ct()
       }
       function Lt(e) {
           r.send("12", e)
       }
       function Ft(e) {
           r.send("10", X[e].sid)
       }
       function zt() {
           r.send("8", document.getElementById("allianceInput").value)
       }
       function Ht() {
           At = [],
               Ct(),
               r.send("9")
       }
       var Vt, qt = [];
       function Yt(e, t) {
           for (var n = 0; n < qt.length; ++n)
               if (!qt[n].active) {
                   Vt = qt[n];
                   break
               }
           Vt || (Vt = new function() {
               this.init = function(e, t) {
                   this.scale = 0,
                       this.x = e,
                       this.y = t,
                       this.active = !0
               }
                   ,
                   this.update = function(e, t) {
                   this.active && (this.scale += .05 * t,
                                   this.scale >= o.mapPingScale ? this.active = !1 : (e.globalAlpha = 1 - Math.max(0, this.scale / o.mapPingScale),
                                                                                      e.beginPath(),
                                                                                      e.arc(this.x / o.mapScale * Ne.width, this.y / o.mapScale * Ne.width, this.scale, 0, 2 * Math.PI),
                                                                                      e.stroke()))
               }
           }
                  ,
                  qt.push(Vt)),
               Vt.init(e, t)
       }
       function Wt(e) {
           Et = e
       }
       var Xt = 0;
       function Nt(e, t, n) {
           n ? e ? R.tailIndex = t : R.tails[t] = 1 : e ? R.skinIndex = t : R.skins[t] = 1,
               "block" == Qe.style.display && Gt()
       }
       function Gt() {
           if (R) {
               s.removeAllChildren($e);
               for (var e = Xt, t = e ? tt : et, n = 0; n < t.length; ++n)
                   t[n].dontSell || function(n) {
                       var i = s.generateElement({
                           id: "storeDisplay" + n,
                           class: "storeItem",
                           onmouseout: function() {
                               Tt()
                           },
                           onmouseover: function() {
                               Tt(t[n], !1, !0)
                           },
                           parent: $e
                       });
                       s.hookTouchEvents(i, !0),
                           s.generateElement({
                           tag: "img",
                           class: "hatPreview",
                           src: "../img/" + (e ? "accessories/access_" : "hats/hat_") + t[n].id + (t[n].topSprite ? "_p" : "") + ".png",
                           parent: i
                       }),
                           s.generateElement({
                           tag: "span",
                           text: t[n].name,
                           parent: i
                       }),
                           (e ? R.tails[t[n].id] : R.skins[t[n].id]) ? (e ? R.tailIndex : R.skinIndex) == t[n].id ? s.generateElement({
                           class: "joinAlBtn",
                           style: "margin-top: 5px",
                           text: "Unequip",
                           onclick: function() {
                               Jt(0, e)
                           },
                           hookTouch: !0,
                           parent: i
                       }) : s.generateElement({
                           class: "joinAlBtn",
                           style: "margin-top: 5px",
                           text: "Equip",
                           onclick: function() {
                               Jt(t[n].id, e)
                           },
                           hookTouch: !0,
                           parent: i
                       }) : (s.generateElement({
                           class: "joinAlBtn",
                           style: "margin-top: 5px",
                           text: "Buy",
                           onclick: function() {
                               Kt(t[n].id, e)
                           },
                           hookTouch: !0,
                           parent: i
                       }),
                             s.generateElement({
                           tag: "span",
                           class: "itemPrice",
                           text: t[n].price,
                           parent: i
                       }))
                   }(n)
           }
       }
       function Jt(e, t) {
           r.send("13c", 0, e, t)
       }
       function Kt(e, t) {
           r.send("13c", 1, e, t)
       }
       function Qt() {
           Qe.style.display = "none",
               Ye.style.display = "none",
               an()
       }
       function $t(e, t) {
           e && (t ? R.weapons = e : R.items = e);
           for (var n = 0; n < l.list.length; ++n) {
               var i = l.weapons.length + n;
               document.getElementById("actionBarItem" + i).style.display = R.items.indexOf(l.list[n].id) >= 0 ? "inline-block" : "none"
           }
           for (n = 0; n < l.weapons.length; ++n)
               document.getElementById("actionBarItem" + n).style.display = R.weapons[l.weapons[n].type] == l.weapons[n].id ? "inline-block" : "none"
       }
       function Zt(e) {
           M = e,
               V = e && window.devicePixelRatio || 1,
               Se.checked = e,
               I("native_resolution", e.toString()),
               un()
       }
       function en() {
           for (var e = "", t = 0; t < o.skinColors.length; ++t)
               e += t == ae ? "<div class='skinColorItem activeSkin' style='background-color:" + o.skinColors[t] + "' onclick='selectSkinColor(" + t + ")'></div>" : "<div class='skinColorItem' style='background-color:" + o.skinColors[t] + "' onclick='selectSkinColor(" + t + ")'></div>";
           Je.innerHTML = e
       }
       var tn = document.getElementById("chatBox")
       , nn = document.getElementById("chatHolder");
       var chatHistory = ["~", "~Chat Log~"], turretlock = 0, serverfreeze = false, aimer = false, autb = false, autby = false, blink = false, blinker = 0, musketLock = 0, wh = 0, ah = 0, sh = 0, dh = 0, cSp = false, spin = false, canspin = 0, botMode = false, atplcr = false, commandPrefix = "/", showCommand = false, ignoreList = [], commands = [], camX = 0, camY = 0, lol, HT = 0, TY = 0, TX = 0, instaID = 0, atpcr = false, thtC = 0, camDir, dn = false, HIT = 0, camID, TA, HTE = false, tH = 0, nPoint, nEyT = 0, Mil = 0, nEyY, nEyX, AB = false, freeCam = false, clickerID, hitterID, chatHistoryDisplay = document.createElement('div')
       var em = 0, lastX, lastY;
       function rn() {
           on ? setTimeout((function() {
               var e = prompt("chat message");
               e && sn(e)
           }
                           ), 1) : "block" == nn.style.display ? (tn.value && sn(tn.value),
                                                                  an()) : (Qe.style.display = "none",
                                                                           Ye.style.display = "none",
                                                                           nn.style.display = "block",
                                                                           tn.focus(),
                                                                           yn()),
               tn.value = ""
       }
       function sn(e) {
           r.send("ch", e.slice(0, 30))
       }
       function an() {
           tn.value = "",
               nn.style.display = "none"
       }
       var on, cn, ln = ["cunt", "whore", "fuck", "shit", "faggot", "nigger", "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex", "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune", "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard"];
       function hn(e, t) {
           var n = Ii(e);
           n && (n.chatMessage = function(e) {
               for (var t, n = 0; n < ln.length; ++n)
                   if (e.indexOf(ln[n]) > -1) {
                       t = "";
                       for (var i = 0; i < ln[n].length; ++i)
                           t += t.length ? "o" : "M";
                       var r = new RegExp(ln[n],"g");
                       e = e.replace(r, t)
                   }
               return e
           }(t),
                 n.chatCountdown = o.chatCountdown)
       }
       function un() {
           F = window.innerWidth,
               z = window.innerHeight;
           var e = Math.max(F / oe, z / ce) * V;
           we.width = F * V,
               we.height = z * V,
               we.style.width = F + "px",
               we.style.height = z + "px",
               be.setTransform(e, 0, 0, e, (F * V - oe * e) / 2, (z * V - ce * e) / 2)
       }
       function fn(e) {
           (on = e) ? Ae.classList.add("touch") : Ae.classList.remove("touch")
       }
       function dn(e) {
           e.preventDefault(),
               e.stopPropagation(),
               fn(!0);
           for (var t = 0; t < e.changedTouches.length; t++) {
               var n = e.changedTouches[t];
               n.identifier == re.id ? (re.id = -1,
                                        bn()) : n.identifier == se.id && (se.id = -1,
                                                                          R.buildIndex >= 0 && (O = 1,
                                                                                                vn()),
                                                                          O = 0,
                                                                          vn())
           }
       }
       function pn() {
           return R ? (-1 != se.id ? cn = Math.atan2(se.currentY - se.startY, se.currentX - se.startX) : R.lockDir || on || (cn = Math.atan2(ie - z / 2, ne - F / 2)),
                       s.fixTo(cn || 0, 2)) : 0
       }
       window.addEventListener("resize", s.checkTrusted(un)),
           un(),
           fn(!1),
           window.setUsingTouch = fn,
           we.addEventListener("touchmove", s.checkTrusted((function(e) {
           e.preventDefault(),
               e.stopPropagation(),
               fn(!0);
           for (var t = 0; t < e.changedTouches.length; t++) {
               var n = e.changedTouches[t];
               n.identifier == re.id ? (re.currentX = n.pageX,
                                        re.currentY = n.pageY,
                                        bn()) : n.identifier == se.id && (se.currentX = n.pageX,
                                                                          se.currentY = n.pageY,
                                                                          O = 1)
           }
       }
                                                           )), !1),
           we.addEventListener("touchstart", s.checkTrusted((function(e) {
           e.preventDefault(),
               e.stopPropagation(),
               fn(!0);
           for (var t = 0; t < e.changedTouches.length; t++) {
               var n = e.changedTouches[t];
               n.pageX < document.body.scrollWidth / 2 && -1 == re.id ? (re.id = n.identifier,
                                                                         re.startX = re.currentX = n.pageX,
                                                                         re.startY = re.currentY = n.pageY,
                                                                         bn()) : n.pageX > document.body.scrollWidth / 2 && -1 == se.id && (se.id = n.identifier,
                                                                                                                                            se.startX = se.currentX = n.pageX,
                                                                                                                                            se.startY = se.currentY = n.pageY,
                                                                                                                                            R.buildIndex < 0 && (O = 1,
            vn()))
           }
       }
                                                            )), !1),
           we.addEventListener("touchend", s.checkTrusted(dn), !1),
           we.addEventListener("touchcancel", s.checkTrusted(dn), !1),
           we.addEventListener("touchleave", s.checkTrusted(dn), !1),
           we.addEventListener("mousemove", (function(e) {
           e.preventDefault(),
               e.stopPropagation(),
               fn(!1),
               ne = e.clientX,
               ie = e.clientY
       }
                                            ), !1),
           we.addEventListener("mousedown", (function(e) {
           fn(!1),
               1 != O && (O = 1,
                          vn())
       }
                                            ), !1),
           we.addEventListener("mouseup", (function(e) {
           fn(!1),
               0 != O && (O = 0,
                          vn())
       }
                                          ), !1);
       var gn = {}
       , mn = {
           87: [0, -1],
           38: [0, -1],
           83: [0, 1],
           40: [0, 1],
           65: [-1, 0],
           37: [-1, 0],
           68: [1, 0],
           39: [1, 0]
       };
       function yn() {
           gn = {},
               r.send("rmd")
       }
       function kn() {
           return "block" != Ye.style.display && "block" != nn.style.display
       }
       function vn() {
           R && R.alive && r.send("c", O, R.buildIndex >= 0 ? pn() : null)
       }
       window.addEventListener("keydown", s.checkTrusted((function(e) {
           var t = e.which || e.keyCode || 0;
           27 == t ? Qt() : R && R.alive && kn() && (gn[t] || (gn[t] = 1,
                                                               69 == t ? r.send("7", 1) : 67 == t ? (Mt || (Mt = {}),
                                                                                                     Mt.x = R.x,
                                                                                                     Mt.y = R.y) : 88 == t ? (R.lockDir = R.lockDir ? 0 : 1,
                                                                                                                              r.send("7", 0)) : null != R.weapons[t - 49] ? Sn(R.weapons[t - 49], !0) : null != R.items[t - 49 - R.weapons.length] ? Sn(R.items[t - 49 - R.weapons.length]) : 81 == t ? Sn(R.items[0]) : 82 == t ? xn() : mn[t] ? bn() : 32 == t && (O = 1,
        vn())))
       }
                                                         ))),
           window.addEventListener("keyup", s.checkTrusted((function(e) {
           if (R && R.alive) {
               var t = e.which || e.keyCode || 0;
               13 == t ? rn() : kn() && gn[t] && (gn[t] = 0,
                                                  mn[t] ? bn() : 32 == t && (O = 0,
                                                                             vn()))
           }
       }
                                                           )));
       var wn = void 0;
       function bn() {
           var e = function() {
               var e = 0
               , t = 0;
               if (-1 != re.id)
                   e += re.currentX - re.startX,
                       t += re.currentY - re.startY;
               else
                   for (var n in mn) {
                       var i = mn[n];
                       e += !!gn[n] * i[0],
                           t += !!gn[n] * i[1]
                   }
               return 0 == e && 0 == t ? void 0 : s.fixTo(Math.atan2(t, e), 2)
           }();
           (null == wn || null == e || Math.abs(e - wn) > .3) && (r.send("33", e),
                                                                  wn = e)
       }
       function xn() {
           r.send("14", 1)
       }
       function Sn(e, t) {
           r.send("5", e, t)
       }
       function Tn() {
           I("moo_name", Le.value),
               !le && r.connected && (le = !0,
                                      x.stop("menu"),
                                      dt("Loading..."),
                                      r.send("sp", {
               name: Le.value,
               moofoll: H,
               skin: ae
           }))
       }
       var In = !0;
       function En(e) {
           Pe.style.display = "none",
               Me.style.display = "block",
               he.style.display = "none",
               gn = {},
               j = e,
               O = 0,
               le = !0,
               In && (In = !1,
                      N.length = 0)
       }
       function Mn(e, t, n, i) {
           m.showText(e, t, 50, .18, 500, Math.abs(n), n >= 0 ? "#fff" : "#8ecc51")
       }
       var An = 99999;
       function Pn() {
           le = !1;
           try {
               factorem.refreshAds([2], !0)
           } catch (e) {}
           Be.style.display = "none",
               Qt(),
               It = {
               x: R.x,
               y: R.y
           },
               Pe.style.display = "none",
               Ge.style.display = "block",
               Ge.style.fontSize = "0px",
               An = 0,
               setTimeout((function() {
               Me.style.display = "block",
                   he.style.display = "block",
                   Ge.style.display = "none"
           }
                          ), o.deathFadeout),
               gt()
       }
       function Bn(e) {
           R && nt.removeAllItems(e)
       }
       function Cn(e) {
           nt.disableBySid(e)
       }
       function On() {
           Oe.innerText = R.points,
               Re.innerText = R.food,
               je.innerText = R.wood,
               _e.innerText = R.stone,
               Ue.innerText = R.kills
       }
       var Rn = {}
       , jn = ["crown", "skull"]
       , _n = [];
       function Un(e, t) {
           if (R.upgradePoints = e,
               R.upgrAge = t,
               e > 0) {
               _n.length = 0,
                   s.removeAllChildren(Ve);
               for (var n = 0; n < l.weapons.length; ++n)
                   l.weapons[n].age == t && (null == l.weapons[n].pre || R.weapons.indexOf(l.weapons[n].pre) >= 0) && (s.generateElement({
                       id: "upgradeItem" + n,
                       class: "actionBarItem",
                       onmouseout: function() {
                           Tt()
                       },
                       parent: Ve
                   }).style.backgroundImage = document.getElementById("actionBarItem" + n).style.backgroundImage,
                                                                                                                       _n.push(n));
               for (n = 0; n < l.list.length; ++n)
                   if (l.list[n].age == t && (null == l.list[n].pre || R.items.indexOf(l.list[n].pre) >= 0)) {
                       var i = l.weapons.length + n;
                       s.generateElement({
                           id: "upgradeItem" + i,
                           class: "actionBarItem",
                           onmouseout: function() {
                               Tt()
                           },
                           parent: Ve
                       }).style.backgroundImage = document.getElementById("actionBarItem" + i).style.backgroundImage,
                           _n.push(i)
                   }
               for (n = 0; n < _n.length; n++)
                   !function(e) {
                       var t = document.getElementById("upgradeItem" + e);
                       t.onmouseover = function() {
                           l.weapons[e] ? Tt(l.weapons[e], !0) : Tt(l.list[e - l.weapons.length])
                       }
                           ,
                           t.onclick = s.checkTrusted((function() {
                           r.send("6", e)
                       }
                                                      )),
                           s.hookTouchEvents(t)
                   }(_n[n]);
               _n.length ? (Ve.style.display = "block",
                            qe.style.display = "block",
                            qe.innerHTML = "SELECT ITEMS (" + e + ")") : (Ve.style.display = "none",
                                                                          qe.style.display = "none",
                                                                          Tt())
           } else
               Ve.style.display = "none",
                   qe.style.display = "none",
                   Tt()
       }
       function Dn(e, t, n) {
           null != e && (R.XP = e),
               null != t && (R.maxXP = t),
               null != n && (R.age = n),
               n == o.maxAge ? (ze.innerHTML = "MAX AGE",
                                He.style.width = "100%") : (ze.innerHTML = "AGE " + R.age,
                                                            He.style.width = R.XP / R.maxXP * 100 + "%")
       }
       function Ln(e) {
           s.removeAllChildren(De);
           for (var t = 1, n = 0; n < e.length; n += 3)
               !function(n) {
                   s.generateElement({
                       class: "leaderHolder",
                       parent: De,
                       children: [s.generateElement({
                           class: "leaderboardItem",
                           style: "color:" + (e[n] == j ? "#fff" : "rgba(255,255,255,0.6)"),
                           text: t + ". " + ("" != e[n + 1] ? e[n + 1] : "unknown")
                       }), s.generateElement({
                           class: "leaderScore",
                           text: s.kFormat(e[n + 2]) || "0"
                       })]
                   })
               }(n),
                   t++
       }
       function Fn(e, t, n, i) {
           be.save(),
               be.setTransform(1, 0, 0, 1, 0, 0),
               be.scale(V, V);
           var r = 50;
           be.beginPath(),
               be.arc(e, t, r, 0, 2 * Math.PI, !1),
               be.closePath(),
               be.fillStyle = "rgba(255, 255, 255, 0.3)",
               be.fill(),
               r = 50;
           var s = n - e
           , a = i - t
           , o = Math.sqrt(Math.pow(s, 2) + Math.pow(a, 2))
           , c = o > r ? o / r : 1;
           s /= c,
               a /= c,
               be.beginPath(),
               be.arc(e + s, t + a, .5 * r, 0, 2 * Math.PI, !1),
               be.closePath(),
               be.fillStyle = "white",
               be.fill(),
               be.restore()
       }
       function zn(e, t, n) {
           for (var i = 0; i < G.length; ++i)
               (_ = G[i]).active && _.layer == e && (_.update(P),
                                                     _.active && ki(_.x - t, _.y - n, _.scale) && (be.save(),
                                                                                                   be.translate(_.x - t, _.y - n),
                                                                                                   be.rotate(_.dir),
                                                                                                   Vn(0, 0, _, be, 1),
                                                                                                   be.restore()))
       }
       var Hn = {};
       function Vn(e, t, n, i, r) {
           if (n.src) {
               var s = l.projectiles[n.indx].src
               , a = Hn[s];
               a || ((a = new Image).onload = function() {
                   this.isLoaded = !0
               }
                     ,
                     a.src = ".././img/weapons/" + s + ".png",
                     Hn[s] = a),
                   a.isLoaded && i.drawImage(a, e - n.scale / 2, t - n.scale / 2, n.scale, n.scale)
           } else
               1 == n.indx && (i.fillStyle = "#939393",
                               si(e, t, n.scale, i))
       }
       function qn(e, t, n, i) {
           var r = o.riverWidth + i
           , s = o.mapScale / 2 - t - r / 2;
           s < ce && s + r > 0 && n.fillRect(0, s, oe, r)
       }
       function Yn(e, t, n) {
           for (var i, r, s, a = 0; a < N.length; ++a)
               (_ = N[a]).active && (r = _.x + _.xWiggle - t,
                                     s = _.y + _.yWiggle - n,
                                     0 == e && _.update(P),
                                     _.layer == e && ki(r, s, _.scale + (_.blocker || 0)) && (be.globalAlpha = _.hideFromEnemy ? .6 : 1,
                                                                                              _.isItem ? (i = ri(_),
                                                                                                          be.save(),
                                                                                                          be.translate(r, s),
                                                                                                          be.rotate(_.dir),
                                                                                                          be.drawImage(i, -i.width / 2, -i.height / 2),
                                                                                                          _.blocker && (be.strokeStyle = "#db6e6e",
                                                                                                                        be.globalAlpha = .3,
                                                                                                                        be.lineWidth = 6,
                                                                                                                        si(0, 0, _.blocker, be, !1, !0)),
                                                                                                          be.restore()) : (i = ni(_),
                                                                                                                           be.drawImage(i, r - i.width / 2, s - i.height / 2))))
       }
       function Wn(e, t, n) {
           (_ = Ii(e)) && _.startAnim(t, n)
       }
       function Xn(e, t, n) {
           be.globalAlpha = 1;
           for (var i = 0; i < W.length; ++i)
               (_ = W[i]).zIndex == n && (_.animate(P),
                                          _.visible && (_.skinRot += .002 * P,
                                                        L = (_ == R ? (ae86Dir) ? R.dir : AA ? nEA : LT ? TD : pn() : _.dir) + _.dirPlus,
                                                        be.save(),
                                                        be.translate(_.x - e, _.y - t),
                                                        be.rotate(L),
                                                        Nn(_, be),
                                                        be.restore()))
       }
       function Nn(e, t) {
           (t = t || be).lineWidth = 5.5,
               t.lineJoin = "miter";
           var n = Math.PI / 4 * (l.weapons[e.weaponIndex].armS || 1)
           , i = e.buildIndex < 0 && l.weapons[e.weaponIndex].hndS || 1
           , r = e.buildIndex < 0 && l.weapons[e.weaponIndex].hndD || 1;
           if (e.tailIndex > 0 && function(e, t, n) {
               if (!(Gn = Qn[e])) {
                   var i = new Image;
                   i.onload = function() {
                       this.isLoaded = !0,
                           this.onload = null
                   }
                       ,
                       i.src = ".././img/accessories/access_" + e + ".png",
                       Qn[e] = i,
                       Gn = i
               }
               var r = $n[e];
               if (!r) {
                   for (var s = 0; s < tt.length; ++s)
                       if (tt[s].id == e) {
                           r = tt[s];
                           break
                       }
                   $n[e] = r
               }
               Gn.isLoaded && (t.save(),
                               t.translate(-20 - (r.xOff || 0), 0),
                               r.spin && t.rotate(n.skinRot),
                               t.drawImage(Gn, -r.scale / 2, -r.scale / 2, r.scale, r.scale),
                               t.restore())
           }(e.tailIndex, t, e),
               e.buildIndex < 0 && !l.weapons[e.weaponIndex].aboveHand && (ei(l.weapons[e.weaponIndex], o.weaponVariants[e.weaponVariant].src, e.scale, 0, t),
                                                                           null == l.weapons[e.weaponIndex].projectile || l.weapons[e.weaponIndex].hideProjectile || Vn(e.scale, 0, l.projectiles[l.weapons[e.weaponIndex].projectile], be)),
               t.fillStyle = o.skinColors[e.skinColor],
               si(e.scale * Math.cos(n), e.scale * Math.sin(n), 14),
               si(e.scale * r * Math.cos(-n * i), e.scale * r * Math.sin(-n * i), 14),
               e.buildIndex < 0 && l.weapons[e.weaponIndex].aboveHand && (ei(l.weapons[e.weaponIndex], o.weaponVariants[e.weaponVariant].src, e.scale, 0, t),
                                                                          null == l.weapons[e.weaponIndex].projectile || l.weapons[e.weaponIndex].hideProjectile || Vn(e.scale, 0, l.projectiles[l.weapons[e.weaponIndex].projectile], be)),
               e.buildIndex >= 0) {
               var s = ri(l.list[e.buildIndex]);
               t.drawImage(s, e.scale - l.list[e.buildIndex].holdOffset, -s.width / 2)
           }
           si(0, 0, e.scale, t),
               e.skinIndex > 0 && (t.rotate(Math.PI / 2),
                                   function e(t, n, i, r) {
               if (!(Gn = Jn[t])) {
                   var s = new Image;
                   s.onload = function() {
                       this.isLoaded = !0,
                           this.onload = null
                   }
                       ,
                       s.src = ".././img/hats/hat_" + t + ".png",
                       Jn[t] = s,
                       Gn = s
               }
               var a = i || Kn[t];
               if (!a) {
                   for (var o = 0; o < et.length; ++o)
                       if (et[o].id == t) {
                           a = et[o];
                           break
                       }
                   Kn[t] = a
               }
               Gn.isLoaded && n.drawImage(Gn, -a.scale / 2, -a.scale / 2, a.scale, a.scale),
                   !i && a.topSprite && (n.save(),
                                         n.rotate(r.skinRot),
                                         e(t + "_top", n, a, r),
                                         n.restore())
           }(e.skinIndex, t, null, e))
       }
       var Gn, Jn = {}, Kn = {}, Qn = {}, $n = {}, Zn = {};
       function ei(e, t, n, i, r) {
           var s = e.src + (t || "")
           , a = Zn[s];
           a || ((a = new Image).onload = function() {
               this.isLoaded = !0
           }
                 ,
                 a.src = ".././img/weapons/" + s + ".png",
                 Zn[s] = a),
               a.isLoaded && r.drawImage(a, n + e.xOff - e.length / 2, i + e.yOff - e.width / 2, e.length, e.width)
       }
       var ti = {};
       function ni(e) {
           var t = e.y >= o.mapScale - o.snowBiomeTop ? 2 : e.y <= o.snowBiomeTop ? 1 : 0
           , n = e.type + "_" + e.scale + "_" + t
           , i = ti[n];
           if (!i) {
               var r = document.createElement("canvas");
               r.width = r.height = 2.1 * e.scale + 5.5;
               var a = r.getContext("2d");
               if (a.translate(r.width / 2, r.height / 2),
                   a.rotate(s.randFloat(0, Math.PI)),
                   a.strokeStyle = it,
                   a.lineWidth = 5.5,
                   0 == e.type)
                   for (var c, l = 0; l < 2; ++l)
                       ai(a, 7, c = _.scale * (l ? .5 : 1), .7 * c),
                           a.fillStyle = t ? l ? "#fff" : "#e3f1f4" : l ? "#b4db62" : "#9ebf57",
                           a.fill(),
                           l || a.stroke();
               else if (1 == e.type)
                   if (2 == t)
                       a.fillStyle = "#606060",
                           ai(a, 6, .3 * e.scale, .71 * e.scale),
                           a.fill(),
                           a.stroke(),
                           a.fillStyle = "#89a54c",
                           si(0, 0, .55 * e.scale, a),
                           a.fillStyle = "#a5c65b",
                           si(0, 0, .3 * e.scale, a, !0);
                   else {
                       var h;
                       !function(e, t, n, i) {
                           var r, a = Math.PI / 2 * 3, o = Math.PI / 6;
                           e.beginPath(),
                               e.moveTo(0, -i);
                           for (var c = 0; c < 6; c++)
                               r = s.randInt(n + .9, 1.2 * n),
                                   e.quadraticCurveTo(Math.cos(a + o) * r, Math.sin(a + o) * r, Math.cos(a + 2 * o) * i, Math.sin(a + 2 * o) * i),
                                   a += 2 * o;
                           e.lineTo(0, -i),
                               e.closePath()
                       }(a, 0, _.scale, .7 * _.scale),
                           a.fillStyle = t ? "#e3f1f4" : "#89a54c",
                           a.fill(),
                           a.stroke(),
                           a.fillStyle = t ? "#6a64af" : "#c15555";
                       var u = T / 4;
                       for (l = 0; l < 4; ++l)
                           si((h = s.randInt(_.scale / 3.5, _.scale / 2.3)) * Math.cos(u * l), h * Math.sin(u * l), s.randInt(10, 12), a)
                   }
               else
                   2 != e.type && 3 != e.type || (a.fillStyle = 2 == e.type ? 2 == t ? "#938d77" : "#939393" : "#e0c655",
                                                  ai(a, 3, e.scale, e.scale),
                                                  a.fill(),
                                                  a.stroke(),
                                                  a.fillStyle = 2 == e.type ? 2 == t ? "#b2ab90" : "#bcbcbc" : "#ebdca3",
                                                  ai(a, 3, .55 * e.scale, .65 * e.scale),
                                                  a.fill());
               i = r,
                   ti[n] = i
           }
           return i
       }
       var ii = [];
       function ri(e, t) {
           var n = ii[e.id];
           if (!n || t) {
               var i = document.createElement("canvas");
               i.width = i.height = 2.5 * e.scale + 5.5 + (l.list[e.id].spritePadding || 0);
               var r = i.getContext("2d");
               if (r.translate(i.width / 2, i.height / 2),
                   r.rotate(t ? 0 : Math.PI / 2),
                   r.strokeStyle = it,
                   r.lineWidth = 5.5 * (t ? i.width / 81 : 1),
                   "apple" == e.name) {
                   r.fillStyle = "#c15555",
                       si(0, 0, e.scale, r),
                       r.fillStyle = "#89a54c";
                   var a = -Math.PI / 2;
                   !function(e, t, n, i, r) {
                       var s = e + 25 * Math.cos(i)
                       , a = t + 25 * Math.sin(i);
                       r.moveTo(e, t),
                           r.beginPath(),
                           r.quadraticCurveTo((e + s) / 2 + 10 * Math.cos(i + Math.PI / 2), (t + a) / 2 + 10 * Math.sin(i + Math.PI / 2), s, a),
                           r.quadraticCurveTo((e + s) / 2 - 10 * Math.cos(i + Math.PI / 2), (t + a) / 2 - 10 * Math.sin(i + Math.PI / 2), e, t),
                           r.closePath(),
                           r.fill(),
                           r.stroke()
                   }(e.scale * Math.cos(a), e.scale * Math.sin(a), 0, a + Math.PI / 2, r)
               } else if ("cookie" == e.name) {
                   r.fillStyle = "#cca861",
                       si(0, 0, e.scale, r),
                       r.fillStyle = "#937c4b";
                   for (var o = T / (h = 4), c = 0; c < h; ++c)
                       si((u = s.randInt(e.scale / 2.5, e.scale / 1.7)) * Math.cos(o * c), u * Math.sin(o * c), s.randInt(4, 5), r, !0)
               } else if ("cheese" == e.name) {
                   var h, u;
                   for (r.fillStyle = "#f4f3ac",
                        si(0, 0, e.scale, r),
                        r.fillStyle = "#c3c28b",
                        o = T / (h = 4),
                        c = 0; c < h; ++c)
                       si((u = s.randInt(e.scale / 2.5, e.scale / 1.7)) * Math.cos(o * c), u * Math.sin(o * c), s.randInt(4, 5), r, !0)
               } else if ("wood wall" == e.name || "stone wall" == e.name || "castle wall" == e.name) {
                   r.fillStyle = "castle wall" == e.name ? "#83898e" : "wood wall" == e.name ? "#a5974c" : "#939393";
                   var f = "castle wall" == e.name ? 4 : 3;
                   ai(r, f, 1.1 * e.scale, 1.1 * e.scale),
                       r.fill(),
                       r.stroke(),
                       r.fillStyle = "castle wall" == e.name ? "#9da4aa" : "wood wall" == e.name ? "#c9b758" : "#bcbcbc",
                       ai(r, f, .65 * e.scale, .65 * e.scale),
                       r.fill()
               } else if ("spikes" == e.name || "greater spikes" == e.name || "poison spikes" == e.name || "spinning spikes" == e.name) {
                   r.fillStyle = "poison spikes" == e.name ? "#7b935d" : "#939393";
                   var d = .6 * e.scale;
                   ai(r, "spikes" == e.name ? 5 : 6, e.scale, d),
                       r.fill(),
                       r.stroke(),
                       r.fillStyle = "#a5974c",
                       si(0, 0, d, r),
                       r.fillStyle = "#c9b758",
                       si(0, 0, d / 2, r, !0)
               } else if ("windmill" == e.name || "faster windmill" == e.name || "power mill" == e.name)
                   r.fillStyle = "#a5974c",
                       si(0, 0, e.scale, r),
                       r.fillStyle = "#c9b758",
                       ci(0, 0, 1.5 * e.scale, 29, 4, r),
                       r.fillStyle = "#a5974c",
                       si(0, 0, .5 * e.scale, r);
               else if ("mine" == e.name)
                   r.fillStyle = "#939393",
                       ai(r, 3, e.scale, e.scale),
                       r.fill(),
                       r.stroke(),
                       r.fillStyle = "#bcbcbc",
                       ai(r, 3, .55 * e.scale, .65 * e.scale),
                       r.fill();
               else if ("sapling" == e.name)
                   for (c = 0; c < 2; ++c)
                       ai(r, 7, d = e.scale * (c ? .5 : 1), .7 * d),
                           r.fillStyle = c ? "#b4db62" : "#9ebf57",
                           r.fill(),
                           c || r.stroke();
               else if ("pit trap" == e.name)
                   r.fillStyle = "#a5974c",
                       ai(r, 3, 1.1 * e.scale, 1.1 * e.scale),
                       r.fill(),
                       r.stroke(),
                       r.fillStyle = it,
                       ai(r, 3, .65 * e.scale, .65 * e.scale),
                       r.fill();
               else if ("boost pad" == e.name)
                   r.fillStyle = "#7e7f82",
                       oi(0, 0, 2 * e.scale, 2 * e.scale, r),
                       r.fill(),
                       r.stroke(),
                       r.fillStyle = "#dbd97d",
                       function(e, t) {
                       t = t || be;
                       var n = e * (Math.sqrt(3) / 2);
                       t.beginPath(),
                           t.moveTo(0, -n / 2),
                           t.lineTo(-e / 2, n / 2),
                           t.lineTo(e / 2, n / 2),
                           t.lineTo(0, -n / 2),
                           t.fill(),
                           t.closePath()
                   }(1 * e.scale, r);
               else if ("turret" == e.name)
                   r.fillStyle = "#a5974c",
                       si(0, 0, e.scale, r),
                       r.fill(),
                       r.stroke(),
                       r.fillStyle = "#939393",
                       oi(0, -25, .9 * e.scale, 50, r),
                       si(0, 0, .6 * e.scale, r),
                       r.fill(),
                       r.stroke();
               else if ("platform" == e.name) {
                   r.fillStyle = "#cebd5f";
                   var p = 2 * e.scale
                   , g = p / 4
                   , m = -e.scale / 2;
                   for (c = 0; c < 4; ++c)
                       oi(m - g / 2, 0, g, 2 * e.scale, r),
                           r.fill(),
                           r.stroke(),
                           m += p / 4
               } else
                   "healing pad" == e.name ? (r.fillStyle = "#7e7f82",
                                              oi(0, 0, 2 * e.scale, 2 * e.scale, r),
                                              r.fill(),
                                              r.stroke(),
                                              r.fillStyle = "#db6e6e",
                                              ci(0, 0, .65 * e.scale, 20, 4, r, !0)) : "spawn pad" == e.name ? (r.fillStyle = "#7e7f82",
                                                                                                                oi(0, 0, 2 * e.scale, 2 * e.scale, r),
                                                                                                                r.fill(),
                                                                                                                r.stroke(),
                                                                                                                r.fillStyle = "#71aad6",
                                                                                                                si(0, 0, .6 * e.scale, r)) : "blocker" == e.name ? (r.fillStyle = "#7e7f82",
                si(0, 0, e.scale, r),
                r.fill(),
                r.stroke(),
                r.rotate(Math.PI / 4),
                r.fillStyle = "#db6e6e",
                ci(0, 0, .65 * e.scale, 20, 4, r, !0)) : "teleporter" == e.name && (r.fillStyle = "#7e7f82",
                                                                                    si(0, 0, e.scale, r),
                                                                                    r.fill(),
                                                                                    r.stroke(),
                                                                                    r.rotate(Math.PI / 4),
                                                                                    r.fillStyle = "#d76edb",
                                                                                    si(0, 0, .5 * e.scale, r, !0));
               n = i,
                   t || (ii[e.id] = n)
           }
           return n
       }
       function si(e, t, n, i, r, s) {
           (i = i || be).beginPath(),
               i.arc(e, t, n, 0, 2 * Math.PI),
               s || i.fill(),
               r || i.stroke()
       }
       function ai(e, t, n, i) {
           var r, s, a = Math.PI / 2 * 3, o = Math.PI / t;
           e.beginPath(),
               e.moveTo(0, -n);
           for (var c = 0; c < t; c++)
               r = Math.cos(a) * n,
                   s = Math.sin(a) * n,
                   e.lineTo(r, s),
                   a += o,
                   r = Math.cos(a) * i,
                   s = Math.sin(a) * i,
                   e.lineTo(r, s),
                   a += o;
           e.lineTo(0, -n),
               e.closePath()
       }
       function oi(e, t, n, i, r, s) {
           r.fillRect(e - n / 2, t - i / 2, n, i),
               s || r.strokeRect(e - n / 2, t - i / 2, n, i)
       }
       function ci(e, t, n, i, r, s, a) {
           s.save(),
               s.translate(e, t),
               r = Math.ceil(r / 2);
           for (var o = 0; o < r; o++)
               oi(0, 0, 2 * n, i, s, a),
                   s.rotate(Math.PI / r);
           s.restore()
       }
       function li(e) {
           for (var t = 0; t < e.length; )
               nt.add(e[t], e[t + 1], e[t + 2], e[t + 3], e[t + 4], e[t + 5], l.list[e[t + 6]], !0, e[t + 7] >= 0 ? {
                   sid: e[t + 7]
               } : null),
                   t += 8
       }
       function hi(e, t) {
           (_ = Mi(t)) && (_.xWiggle += o.gatherWiggle * Math.cos(e),
                           _.yWiggle += o.gatherWiggle * Math.sin(e))
       }
       function ui(e, t) {
           (_ = Mi(e)) && (_.dir = t,
                           _.xWiggle += o.gatherWiggle * Math.cos(t + Math.PI),
                           _.yWiggle += o.gatherWiggle * Math.sin(t + Math.PI))
       }
       function fi(e, t, n, i, r, s, a, o) {
           lt && (J.addProjectile(e, t, n, i, r, s, null, null, a).sid = o)
       }
       function di(e, t) {
           for (var n = 0; n < G.length; ++n)
               G[n].sid == e && (G[n].range = t)
       }
       function pi(e) {
           (_ = Ei(e)) && _.startAnim()
       }
       function gi(e) {
           for (var t = 0; t < Y.length; ++t)
               Y[t].forcePos = !Y[t].visible,
                   Y[t].visible = !1;
           if (e) {
               var n = Date.now();
               for (t = 0; t < e.length; )
                   (_ = Ei(e[t])) ? (_.index = e[t + 1],
                                     _.t1 = void 0 === _.t2 ? n : _.t2,
                                     _.t2 = n,
                                     _.x1 = _.x,
                                     _.y1 = _.y,
                                     _.x2 = e[t + 2],
                                     _.y2 = e[t + 3],
                                     _.d1 = void 0 === _.d2 ? e[t + 4] : _.d2,
                                     _.d2 = e[t + 4],
                                     _.health = e[t + 5],
                                     _.dt = 0,
                                     _.visible = !0) : ((_ = Z.spawn(e[t + 2], e[t + 3], e[t + 4], e[t + 1])).x2 = _.x,
                                                        _.y2 = _.y,
                                                        _.d2 = _.dir,
                                                        _.health = e[t + 5],
                                                        Z.aiTypes[e[t + 1]].name || (_.name = o.cowNames[e[t + 6]]),
                                                        _.forcePos = !0,
                                                        _.sid = e[t],
                                                        _.visible = !0),
                       t += 7
           }
       }
       var mi = {};
       function yi(e, t) {
           var n = e.index
           , i = mi[n];
           if (!i) {
               var r = new Image;
               r.onload = function() {
                   this.isLoaded = !0,
                       this.onload = null
               }
                   ,
                   r.src = ".././img/animals/" + e.src + ".png",
                   i = r,
                   mi[n] = i
           }
           if (i.isLoaded) {
               var s = 1.2 * e.scale * (e.spriteMlt || 1);
               t.drawImage(i, -s, -s, 2 * s, 2 * s)
           }
       }
       function ki(e, t, n) {
           return e + n >= 0 && e - n <= oe && t + n >= 0 && t - n <= ce
       }
       function vi(e, t) {
           var n = function(e) {
               for (var t = 0; t < W.length; ++t)
                   if (W[t].id == e)
                       return W[t];
               return null
           }(e[0]);
           n || (n = new u(e[0],e[1],o,s,J,nt,W,Y,l,et,tt),
                 W.push(n)),
               n.spawn(t ? H : null),
               n.visible = !1,
               n.x2 = void 0,
               n.y2 = void 0,
               n.setData(e),
               t && (U = (R = n).x,
                     D = R.y,
                     $t(),
                     On(),
                     Dn(),
                     Un(0),
                     Be.style.display = "block")
       }
       function wi(e) {
           for (var t = 0; t < W.length; t++)
               if (W[t].id == e) {
                   W.splice(t, 1);
                   break
               }
       }
       function bi(e, t) {
           R && (R.itemCounts[e] = t)
       }
       function xi(e, t, n) {
           R && (R[e] = t,
                 n && On())
       }
       function Si(e, t) {
           (_ = Ii(e)) && (_.health = t)
       }
       function Ti(e) {
           for (var t = Date.now(), n = 0; n < W.length; ++n)
               W[n].forcePos = !W[n].visible,
                   W[n].visible = !1;
           for (n = 0; n < e.length; )
               (_ = Ii(e[n])) && (_.t1 = void 0 === _.t2 ? t : _.t2,
                                  _.t2 = t,
                                  _.x1 = _.x,
                                  _.y1 = _.y,
                                  _.x2 = e[n + 1],
                                  _.y2 = e[n + 2],
                                  _.d1 = void 0 === _.d2 ? e[n + 3] : _.d2,
                                  _.d2 = e[n + 3],
                                  _.dt = 0,
                                  _.buildIndex = e[n + 4],
                                  _.weaponIndex = e[n + 5],
                                  _.weaponVariant = e[n + 6],
                                  _.team = e[n + 7],
                                  _.isLeader = e[n + 8],
                                  _.skinIndex = e[n + 9],
                                  _.tailIndex = e[n + 10],
                                  _.iconIndex = e[n + 11],
                                  _.zIndex = e[n + 12],
                                  _.visible = !0),
                   n += 13
       }
       function Ii(e) {
           for (var t = 0; t < W.length; ++t)
               if (W[t].sid == e)
                   return W[t];
           return null
       }
       function Ei(e) {
           for (var t = 0; t < Y.length; ++t)
               if (Y[t].sid == e)
                   return Y[t];
           return null
       }
       function Mi(e) {
           for (var t = 0; t < N.length; ++t)
               if (N[t].sid == e)
                   return N[t];
           return null
       }
       var Ai = -1;
       function Pi() {
           var e = Date.now() - Ai;
           window.pingTime = e,
               Ie.innerText = "Ping: " + e + "Ã‚ ms"
       }
       function Bi() {
           Ai = Date.now(),
               r.send("pp")
       }
       function Ci(e) {
           if (!(e < 0)) {
               var t = Math.floor(e / 60)
               , n = e % 60;
               n = ("0" + n).slice(-2),
                   Ee.innerText = "Server restarting in " + t + ":" + n,
                   Ee.hidden = !1
           }
       }
       function Oi(e) {
           window.open(e, "_blank")
       }
       window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(e) {
           window.setTimeout(e, 1e3 / 60)
       }
           ,
           function() {
           var e = o.mapScale / 2;
           nt.add(0, e, e + 200, 0, o.treeScales[3], 0),
               nt.add(1, e, e - 480, 0, o.treeScales[3], 0),
               nt.add(2, e + 300, e + 450, 0, o.treeScales[3], 0),
               nt.add(3, e - 950, e - 130, 0, o.treeScales[2], 0),
               nt.add(4, e - 750, e - 400, 0, o.treeScales[3], 0),
               nt.add(5, e - 700, e + 400, 0, o.treeScales[2], 0),
               nt.add(6, e + 800, e - 200, 0, o.treeScales[3], 0),
               nt.add(7, e - 260, e + 340, 0, o.bushScales[3], 1),
               nt.add(8, e + 760, e + 310, 0, o.bushScales[3], 1),
               nt.add(9, e - 800, e + 100, 0, o.bushScales[3], 1),
               nt.add(10, e - 800, e + 300, 0, l.list[4].scale, l.list[4].id, l.list[10]),
               nt.add(11, e + 650, e - 390, 0, l.list[4].scale, l.list[4].id, l.list[10]),
               nt.add(12, e - 400, e - 450, 0, o.rockScales[2], 2)
       }(),
           function e() {
           B = Date.now(),
               P = B - q,
               q = B,
               function() {
               if (R && (!C || B - C >= 1e3 / o.clientSendRate) && (C = B,
                                                                    r.send("2", pn())),
                   An < 120 && (An += .1 * P,
                                Ge.style.fontSize = Math.min(Math.round(An), 120) + "px"),
                   R) {
                   var e = s.getDistance(U, D, R.x, R.y)
                   , t = s.getDirection(R.x, R.y, U, D)
                   , n = Math.min(.01 * e * P, e);
                   e > .05 ? (U += n * Math.cos(t),
                              D += n * Math.sin(t)) : (U = R.x,
                                                       D = R.y)
               } else
                   U = o.mapScale / 2,
                       D = o.mapScale / 2;
               for (var i = B - 1e3 / o.serverUpdateRate, a = 0; a < W.length + Y.length; ++a)
                   if ((_ = W[a] || Y[a - W.length]) && _.visible)
                       if (_.forcePos)
                           _.x = _.x2,
                               _.y = _.y2,
                               _.dir = _.d2;
                       else {
                           var c = _.t2 - _.t1
                           , l = (i - _.t1) / c;
                           _.dt += P;
                           var h = Math.min(1.7, _.dt / 170)
                           , u = _.x2 - _.x1;
                           _.x = _.x1 + u * h,
                               u = _.y2 - _.y1,
                               _.y = _.y1 + u * h,
                               _.dir = Math.lerpAngle(_.d2, _.d1, Math.min(1.2, l))
                       }
               var f = U - oe / 2
               , d = D - ce / 2;
               o.snowBiomeTop - d <= 0 && o.mapScale - o.snowBiomeTop - d >= ce ? (be.fillStyle = "#b6db66",
                                                                                   be.fillRect(0, 0, oe, ce)) : o.mapScale - o.snowBiomeTop - d <= 0 ? (be.fillStyle = "#dbc666",
            be.fillRect(0, 0, oe, ce)) : o.snowBiomeTop - d >= ce ? (be.fillStyle = "#fff",
                                                                     be.fillRect(0, 0, oe, ce)) : o.snowBiomeTop - d >= 0 ? (be.fillStyle = "#fff",
                                                                                                                             be.fillRect(0, 0, oe, o.snowBiomeTop - d),
                                                                                                                             be.fillStyle = "#b6db66",
                                                                                                                             be.fillRect(0, o.snowBiomeTop - d, oe, ce - (o.snowBiomeTop - d))) : (be.fillStyle = "#b6db66",
            be.fillRect(0, 0, oe, o.mapScale - o.snowBiomeTop - d),
            be.fillStyle = "#dbc666",
            be.fillRect(0, o.mapScale - o.snowBiomeTop - d, oe, ce - (o.mapScale - o.snowBiomeTop - d))),
                   In || ((ee += te * o.waveSpeed * P) >= o.waveMax ? (ee = o.waveMax,
                                                                       te = -1) : ee <= 1 && (ee = te = 1),
                          be.globalAlpha = 1,
                          be.fillStyle = "#dbc666",
                          qn(f, d, be, o.riverPadding),
                          be.fillStyle = "#91b2db",
                          qn(f, d, be, 250 * (ee - 1))),
                   be.lineWidth = 4,
                   be.strokeStyle = "#000",
                   be.globalAlpha = .06,
                   be.beginPath();
               for (var p = -U; p < oe; p += ce / 18)
                   p > 0 && (be.moveTo(p, 0),
                             be.lineTo(p, ce));
               for (var g = -D; g < ce; g += ce / 18)
                   p > 0 && (be.moveTo(0, g),
                             be.lineTo(oe, g));
               for (be.stroke(),
                    be.globalAlpha = 1,
                    be.strokeStyle = it,
                    Yn(-1, f, d),
                    be.globalAlpha = 1,
                    be.lineWidth = 5.5,
                    zn(0, f, d),
                    Xn(f, d, 0),
                    be.globalAlpha = 1,
                    a = 0; a < Y.length; ++a)
                   (_ = Y[a]).active && _.visible && (_.animate(P),
                                                      be.save(),
                                                      be.translate(_.x - f, _.y - d),
                                                      be.rotate(_.dir + _.dirPlus - Math.PI / 2),
                                                      yi(_, be),
                                                      be.restore());
               if (Yn(0, f, d),
                   zn(1, f, d),
                   Yn(1, f, d),
                   Xn(f, d, 1),
                   Yn(2, f, d),
                   Yn(3, f, d),
                   be.fillStyle = "#000",
                   be.globalAlpha = .09,
                   f <= 0 && be.fillRect(0, 0, -f, ce),
                   o.mapScale - f <= oe) {
                   var y = Math.max(0, -d);
                   be.fillRect(o.mapScale - f, y, oe - (o.mapScale - f), ce - y)
               }
               if (d <= 0 && be.fillRect(-f, 0, oe + f, -d),
                   o.mapScale - d <= ce) {
                   var k = Math.max(0, -f)
                   , v = 0;
                   o.mapScale - f <= oe && (v = oe - (o.mapScale - f)),
                       be.fillRect(k, o.mapScale - d, oe - k - v, ce - (o.mapScale - d))
               }
               for (be.globalAlpha = 1,
                    be.fillStyle = "rgba(0, 0, 70, 0.35)",
                    be.fillRect(0, 0, oe, ce),
                    be.strokeStyle = rt,
                    a = 0; a < W.length + Y.length; ++a)
                   if ((_ = W[a] || Y[a - W.length]).visible && (10 != _.skinIndex || _ == R || _.team && _.team == R.team)) {
                       var w = (_.team ? "[" + _.team + "] " : "") + (_.name || "");
                       if ("" != w) {
                           if (be.font = (_.nameScale || 30) + "px Hammersmith One",
                               be.fillStyle = "#fff",
                               be.textBaseline = "middle",
                               be.textAlign = "center",
                               be.lineWidth = _.nameScale ? 11 : 8,
                               be.lineJoin = "round",
                               be.strokeText(w, _.x - f, _.y - d - _.scale - o.nameY),
                               be.fillText(w, _.x - f, _.y - d - _.scale - o.nameY),
                               _.isLeader && Rn.crown.isLoaded) {
                               var b = o.crownIconScale;
                               k = _.x - f - b / 2 - be.measureText(w).width / 2 - o.crownPad,
                                   be.drawImage(Rn.crown, k, _.y - d - _.scale - o.nameY - b / 2 - 5, b, b)
                           }
                           1 == _.iconIndex && Rn.skull.isLoaded && (b = o.crownIconScale,
                                                                     k = _.x - f - b / 2 + be.measureText(w).width / 2 + o.crownPad,
                                                                     be.drawImage(Rn.skull, k, _.y - d - _.scale - o.nameY - b / 2 - 5, b, b))
                       }
                       _.health > 0 && (o.healthBarWidth,
                                        be.fillStyle = rt,
                                        be.roundRect(_.x - f - o.healthBarWidth - o.healthBarPad, _.y - d + _.scale + o.nameY, 2 * o.healthBarWidth + 2 * o.healthBarPad, 17, 8),
                                        be.fill(),
                                        be.fillStyle = _ == R || _.team && _.team == R.team ? "#8ecc51" : "#cc5151",
                                        be.roundRect(_.x - f - o.healthBarWidth, _.y - d + _.scale + o.nameY + o.healthBarPad, 2 * o.healthBarWidth * (_.health / _.maxHealth), 17 - 2 * o.healthBarPad, 7),
                                        be.fill())
                   }
               for (m.update(P, be, f, d),
                    a = 0; a < W.length; ++a)
                   if ((_ = W[a]).visible && _.chatCountdown > 0) {
                       _.chatCountdown -= P,
                           _.chatCountdown <= 0 && (_.chatCountdown = 0),
                           be.font = "32px Hammersmith One";
                       var x = be.measureText(_.chatMessage);
                       be.textBaseline = "middle",
                           be.textAlign = "center",
                           k = _.x - f,
                           y = _.y - _.scale - d - 90;
                       var S = x.width + 17;
                       be.fillStyle = "rgba(0,0,0,0.2)",
                           be.roundRect(k - S / 2, y - 23.5, S, 47, 6),
                           be.fill(),
                           be.fillStyle = "#fff",
                           be.fillText(_.chatMessage, k, y)
                   }
               !function(e) {
                   if (R && R.alive) {
                       Ke.clearRect(0, 0, Ne.width, Ne.height),
                           Ke.strokeStyle = "#fff",
                           Ke.lineWidth = 4;
                       for (var t = 0; t < qt.length; ++t)
                           (Vt = qt[t]).update(Ke, e);
                       if (Ke.globalAlpha = 1,
                           Ke.fillStyle = "#fff",
                           si(R.x / o.mapScale * Ne.width, R.y / o.mapScale * Ne.height, 7, Ke, !0),
                           Ke.fillStyle = "rgba(255,255,255,0.35)",
                           R.team && Et)
                           for (t = 0; t < Et.length; )
                               si(Et[t] / o.mapScale * Ne.width, Et[t + 1] / o.mapScale * Ne.height, 7, Ke, !0),
                                   t += 2;
                       It && (Ke.fillStyle = "#fc5553",
                              Ke.font = "34px Hammersmith One",
                              Ke.textBaseline = "middle",
                              Ke.textAlign = "center",
                              Ke.fillText("x", It.x / o.mapScale * Ne.width, It.y / o.mapScale * Ne.height)),
                           Mt && (Ke.fillStyle = "#fff",
                                  Ke.font = "34px Hammersmith One",
                                  Ke.textBaseline = "middle",
                                  Ke.textAlign = "center",
                                  Ke.fillText("x", Mt.x / o.mapScale * Ne.width, Mt.y / o.mapScale * Ne.height))
                   }
               }(P),
                   -1 !== re.id && Fn(re.startX, re.startY, re.currentX, re.currentY),
                   -1 !== se.id && Fn(se.startX, se.startY, se.currentX, se.currentY)
           }(),
               requestAnimFrame(e)
       }(),
           window.openLink = Oi,
           window.aJoinReq = Dt,
           window.follmoo = function() {
           H || (H = !0,
                 I("moofoll", 1))
       }
           ,
           window.kickFromClan = Lt,
           window.sendJoin = Ft,
           window.leaveAlliance = Ht,
           window.createAlliance = zt,
           window.storeBuy = Kt,
           window.storeEquip = Jt,
           window.showItemInfo = Tt,
           window.selectSkinColor = function(e) {
           ae = e,
               en()
       }
           ,
           window.changeStoreIndex = function(e) {
           Xt != e && (Xt = e,
                       Gt())
       }
           ,
           window.config = o
   }
   , function(e, t) {
       !function(e, t, n) {
           function i(e, t) {
               return typeof e === t
           }
           var r = []
           , s = []
           , a = {
               _version: "3.5.0",
               _config: {
                   classPrefix: "",
                   enableClasses: !0,
                   enableJSClass: !0,
                   usePrefixes: !0
               },
               _q: [],
               on: function(e, t) {
                   var n = this;
                   setTimeout((function() {
                       t(n[e])
                   }
                              ), 0)
               },
               addTest: function(e, t, n) {
                   s.push({
                       name: e,
                       fn: t,
                       options: n
                   })
               },
               addAsyncTest: function(e) {
                   s.push({
                       name: null,
                       fn: e
                   })
               }
           }
           , o = function() {};
           o.prototype = a,
               o = new o;
           var c = t.documentElement
           , l = "svg" === c.nodeName.toLowerCase();
           o.addTest("passiveeventlisteners", (function() {
               var t = !1;
               try {
                   var n = Object.defineProperty({}, "passive", {
                       get: function() {
                           t = !0
                       }
                   });
                   e.addEventListener("test", null, n)
               } catch (e) {}
               return t
           }
                                              )),
               function() {
               var e, t, n, a, c, l;
               for (var h in s)
                   if (s.hasOwnProperty(h)) {
                       if (e = [],
                           (t = s[h]).name && (e.push(t.name.toLowerCase()),
                                               t.options && t.options.aliases && t.options.aliases.length))
                           for (n = 0; n < t.options.aliases.length; n++)
                               e.push(t.options.aliases[n].toLowerCase());
                       for (a = i(t.fn, "function") ? t.fn() : t.fn,
                            c = 0; c < e.length; c++)
                           1 === (l = e[c].split(".")).length ? o[l[0]] = a : (!o[l[0]] || o[l[0]]instanceof Boolean || (o[l[0]] = new Boolean(o[l[0]])),
                                                                               o[l[0]][l[1]] = a),
                               r.push((a ? "" : "no-") + l.join("-"))
                   }
           }(),
               function(e) {
               var t = c.className
               , n = o._config.classPrefix || "";
               if (l && (t = t.baseVal),
                   o._config.enableJSClass) {
                   var i = new RegExp("(^|\\s)" + n + "no-js(\\s|$)");
                   t = t.replace(i, "$1" + n + "js$2")
               }
               o._config.enableClasses && (t += " " + n + e.join(" " + n),
                                           l ? c.className.baseVal = t : c.className = t)
           }(r),
               delete a.addTest,
               delete a.addAsyncTest;
           for (var h = 0; h < o._q.length; h++)
               o._q[h]();
           e.Modernizr = o
       }(window, document)
   }
   , function(e, t, n) {
       var i = n(24);
       n(19),
           e.exports = {
           socket: null,
           connected: !1,
           socketId: -1,
           connect: function(e, t, n) {
               if (!this.socket) {
                   var r = this;
                   try {
                       var s = !1
                       , a = e;
                       this.socket = new WebSocket(a),
                           this.socket.binaryType = "arraybuffer",
                           this.socket.onmessage = function(e) {
                           var t = new Uint8Array(e.data)
                           , s = i.decode(t)
                           , a = s[0];
                           t = s[1],
                               "io-init" == a ? r.socketId = t[0] : n[a].apply(void 0, t)
                       }
                           ,
                           this.socket.onopen = function() {
                           r.connected = !0,
                               t()
                       }
                           ,
                           this.socket.onclose = function(e) {
                           r.connected = !1,
                               4001 == e.code ? t("Invalid Connection") : s || t("disconnected")
                       }
                           ,
                           this.socket.onerror = function(e) {
                           this.socket && this.socket.readyState != WebSocket.OPEN && (s = !0,
                                                                                       console.error("Socket error", arguments),
                                                                                       t("Socket error"))
                       }
                   } catch (e) {
                       console.warn("Socket connection error:", e),
                           t(e)
                   }
               }
           },
           send: function(e) {
               var t = Array.prototype.slice.call(arguments, 1)
               , n = i.encode([e, t]);
               this.socket.send(n)
           },
           socketReady: function() {
               return this.socket && this.connected
           },
           close: function() {
               this.socket && this.socket.close()
           }
       }
   }
   , function(e, t, n) {
       t.encode = n(9).encode,
           t.decode = n(15).decode,
           t.Encoder = n(37).Encoder,
           t.Decoder = n(38).Decoder,
           t.createCodec = n(39).createCodec,
           t.codec = n(40).codec
   }
   , function(e, t, n) {
       (function(t) {
           function n(e) {
               return e && e.isBuffer && e
           }
           e.exports = n(void 0 !== t && t) || n(this.Buffer) || n("undefined" != typeof window && window.Buffer) || this.Buffer
       }
       ).call(this, n(11).Buffer)
   }
   , function(e, t, n) {
       "use strict";
       t.byteLength = function(e) {
           var t = l(e)
           , n = t[0]
           , i = t[1];
           return 3 * (n + i) / 4 - i
       }
           ,
           t.toByteArray = function(e) {
           var t, n, i = l(e), a = i[0], o = i[1], c = new s(function(e, t, n) {
               return 3 * (t + n) / 4 - n
           }(0, a, o)), h = 0, u = o > 0 ? a - 4 : a;
           for (n = 0; n < u; n += 4)
               t = r[e.charCodeAt(n)] << 18 | r[e.charCodeAt(n + 1)] << 12 | r[e.charCodeAt(n + 2)] << 6 | r[e.charCodeAt(n + 3)],
                   c[h++] = t >> 16 & 255,
                   c[h++] = t >> 8 & 255,
                   c[h++] = 255 & t;
           return 2 === o && (t = r[e.charCodeAt(n)] << 2 | r[e.charCodeAt(n + 1)] >> 4,
                              c[h++] = 255 & t),
               1 === o && (t = r[e.charCodeAt(n)] << 10 | r[e.charCodeAt(n + 1)] << 4 | r[e.charCodeAt(n + 2)] >> 2,
                           c[h++] = t >> 8 & 255,
                           c[h++] = 255 & t),
               c
       }
           ,
           t.fromByteArray = function(e) {
           for (var t, n = e.length, r = n % 3, s = [], a = 0, o = n - r; a < o; a += 16383)
               s.push(u(e, a, a + 16383 > o ? o : a + 16383));
           return 1 === r ? (t = e[n - 1],
                             s.push(i[t >> 2] + i[t << 4 & 63] + "==")) : 2 === r && (t = (e[n - 2] << 8) + e[n - 1],
                                                                                      s.push(i[t >> 10] + i[t >> 4 & 63] + i[t << 2 & 63] + "=")),
               s.join("")
       }
       ;
       for (var i = [], r = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, c = a.length; o < c; ++o)
           i[o] = a[o],
               r[a.charCodeAt(o)] = o;
       function l(e) {
           var t = e.length;
           if (t % 4 > 0)
               throw new Error("Invalid string. Length must be a multiple of 4");
           var n = e.indexOf("=");
           return -1 === n && (n = t),
               [n, n === t ? 0 : 4 - n % 4]
       }
       function h(e) {
           return i[e >> 18 & 63] + i[e >> 12 & 63] + i[e >> 6 & 63] + i[63 & e]
       }
       function u(e, t, n) {
           for (var i, r = [], s = t; s < n; s += 3)
               i = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (255 & e[s + 2]),
                   r.push(h(i));
           return r.join("")
       }
       r["-".charCodeAt(0)] = 62,
           r["_".charCodeAt(0)] = 63
   }
   , function(e, t) {
       var n = {}.toString;
       e.exports = Array.isArray || function(e) {
           return "[object Array]" == n.call(e)
       }
   }
   , function(e, t, n) {
       var i = n(0);
       function r(e) {
           return new Array(e)
       }
       (t = e.exports = r(0)).alloc = r,
           t.concat = i.concat,
           t.from = function(e) {
           if (!i.isBuffer(e) && i.isView(e))
               e = i.Uint8Array.from(e);
           else if (i.isArrayBuffer(e))
               e = new Uint8Array(e);
           else {
               if ("string" == typeof e)
                   return i.from.call(t, e);
               if ("number" == typeof e)
                   throw new TypeError('"value" argument must not be a number')
           }
           return Array.prototype.slice.call(e)
       }
   }
   , function(e, t, n) {
       var i = n(0)
       , r = i.global;
       function s(e) {
           return new r(e)
       }
       (t = e.exports = i.hasBuffer ? s(0) : []).alloc = i.hasBuffer && r.alloc || s,
           t.concat = i.concat,
           t.from = function(e) {
           if (!i.isBuffer(e) && i.isView(e))
               e = i.Uint8Array.from(e);
           else if (i.isArrayBuffer(e))
               e = new Uint8Array(e);
           else {
               if ("string" == typeof e)
                   return i.from.call(t, e);
               if ("number" == typeof e)
                   throw new TypeError('"value" argument must not be a number')
           }
           return r.from && 1 !== r.from.length ? r.from(e) : new r(e)
       }
   }
   , function(e, t, n) {
       var i = n(0);
       function r(e) {
           return new Uint8Array(e)
       }
       (t = e.exports = i.hasArrayBuffer ? r(0) : []).alloc = r,
           t.concat = i.concat,
           t.from = function(e) {
           if (i.isView(e)) {
               var n = e.byteOffset
               , r = e.byteLength;
               (e = e.buffer).byteLength !== r && (e.slice ? e = e.slice(n, n + r) : (e = new Uint8Array(e)).byteLength !== r && (e = Array.prototype.slice.call(e, n, n + r)))
           } else {
               if ("string" == typeof e)
                   return i.from.call(t, e);
               if ("number" == typeof e)
                   throw new TypeError('"value" argument must not be a number')
           }
           return new Uint8Array(e)
       }
   }
   , function(e, t) {
       t.copy = function(e, t, n, i) {
           var r;
           n || (n = 0),
               i || 0 === i || (i = this.length),
               t || (t = 0);
           var s = i - n;
           if (e === this && n < t && t < i)
               for (r = s - 1; r >= 0; r--)
                   e[r + t] = this[r + n];
           else
               for (r = 0; r < s; r++)
                   e[r + t] = this[r + n];
           return s
       }
           ,
           t.toString = function(e, t, n) {
           var i = 0 | t;
           n || (n = this.length);
           for (var r = "", s = 0; i < n; )
               (s = this[i++]) < 128 ? r += String.fromCharCode(s) : (192 == (224 & s) ? s = (31 & s) << 6 | 63 & this[i++] : 224 == (240 & s) ? s = (15 & s) << 12 | (63 & this[i++]) << 6 | 63 & this[i++] : 240 == (248 & s) && (s = (7 & s) << 18 | (63 & this[i++]) << 12 | (63 & this[i++]) << 6 | 63 & this[i++]),
                                                                      s >= 65536 ? (s -= 65536,
                                                                                    r += String.fromCharCode(55296 + (s >>> 10), 56320 + (1023 & s))) : r += String.fromCharCode(s));
           return r
       }
           ,
           t.write = function(e, t) {
           for (var n = t || (t |= 0), i = e.length, r = 0, s = 0; s < i; )
               (r = e.charCodeAt(s++)) < 128 ? this[n++] = r : r < 2048 ? (this[n++] = 192 | r >>> 6,
                                                                           this[n++] = 128 | 63 & r) : r < 55296 || r > 57343 ? (this[n++] = 224 | r >>> 12,
                                                                                                                                 this[n++] = 128 | r >>> 6 & 63,
                                                                                                                                 this[n++] = 128 | 63 & r) : (r = 65536 + (r - 55296 << 10 | e.charCodeAt(s++) - 56320),
            this[n++] = 240 | r >>> 18,
            this[n++] = 128 | r >>> 12 & 63,
            this[n++] = 128 | r >>> 6 & 63,
            this[n++] = 128 | 63 & r);
           return n - t
       }
   }
   , function(e, t, n) {
       t.setExtPackers = function(e) {
           e.addExtPacker(14, Error, [u, c]),
               e.addExtPacker(1, EvalError, [u, c]),
               e.addExtPacker(2, RangeError, [u, c]),
               e.addExtPacker(3, ReferenceError, [u, c]),
               e.addExtPacker(4, SyntaxError, [u, c]),
               e.addExtPacker(5, TypeError, [u, c]),
               e.addExtPacker(6, URIError, [u, c]),
               e.addExtPacker(10, RegExp, [h, c]),
               e.addExtPacker(11, Boolean, [l, c]),
               e.addExtPacker(12, String, [l, c]),
               e.addExtPacker(13, Date, [Number, c]),
               e.addExtPacker(15, Number, [l, c]),
               "undefined" != typeof Uint8Array && (e.addExtPacker(17, Int8Array, a),
                                                    e.addExtPacker(18, Uint8Array, a),
                                                    e.addExtPacker(19, Int16Array, a),
                                                    e.addExtPacker(20, Uint16Array, a),
                                                    e.addExtPacker(21, Int32Array, a),
                                                    e.addExtPacker(22, Uint32Array, a),
                                                    e.addExtPacker(23, Float32Array, a),
                                                    "undefined" != typeof Float64Array && e.addExtPacker(24, Float64Array, a),
                                                    "undefined" != typeof Uint8ClampedArray && e.addExtPacker(25, Uint8ClampedArray, a),
                                                    e.addExtPacker(26, ArrayBuffer, a),
                                                    e.addExtPacker(29, DataView, a)),
               r.hasBuffer && e.addExtPacker(27, s, r.from)
       }
       ;
       var i, r = n(0), s = r.global, a = r.Uint8Array.from, o = {
           name: 1,
           message: 1,
           stack: 1,
           columnNumber: 1,
           fileName: 1,
           lineNumber: 1
       };
       function c(e) {
           return i || (i = n(9).encode),
               i(e)
       }
       function l(e) {
           return e.valueOf()
       }
       function h(e) {
           (e = RegExp.prototype.toString.call(e).split("/")).shift();
           var t = [e.pop()];
           return t.unshift(e.join("/")),
               t
       }
       function u(e) {
           var t = {};
           for (var n in o)
               t[n] = e[n];
           return t
       }
   }
   , function(e, t, n) {
       var i = n(5)
       , r = n(7)
       , s = r.Uint64BE
       , a = r.Int64BE
       , o = n(0)
       , c = n(6)
       , l = n(34)
       , h = n(13).uint8
       , u = n(3).ExtBuffer
       , f = "undefined" != typeof Uint8Array
       , d = "undefined" != typeof Map
       , p = [];
       p[1] = 212,
           p[2] = 213,
           p[4] = 214,
           p[8] = 215,
           p[16] = 216,
           t.getWriteType = function(e) {
           var t = l.getWriteToken(e)
           , n = e && e.useraw
           , r = f && e && e.binarraybuffer
           , g = r ? o.isArrayBuffer : o.isBuffer
           , m = r ? function(e, t) {
               w(e, new Uint8Array(t))
           }
           : w
           , y = d && e && e.usemap ? function(e, n) {
               if (!(n instanceof Map))
                   return b(e, n);
               var i = n.size;
               t[i < 16 ? 128 + i : i <= 65535 ? 222 : 223](e, i);
               var r = e.codec.encode;
               n.forEach((function(t, n, i) {
                   r(e, n),
                       r(e, t)
               }
                         ))
           }
           : b;
           return {
               boolean: function(e, n) {
                   t[n ? 195 : 194](e, n)
               },
               function: v,
               number: function(e, n) {
                   var i = 0 | n;
                   n === i ? t[-32 <= i && i <= 127 ? 255 & i : 0 <= i ? i <= 255 ? 204 : i <= 65535 ? 205 : 206 : -128 <= i ? 208 : -32768 <= i ? 209 : 210](e, i) : t[203](e, n)
               },
               object: n ? function(e, n) {
                   if (g(n))
                       return function(e, n) {
                           var i = n.length;
                           t[i < 32 ? 160 + i : i <= 65535 ? 218 : 219](e, i),
                               e.send(n)
                       }(e, n);
                   k(e, n)
               }
               : k,
               string: function(e) {
                   return function(n, i) {
                       var r = i.length
                       , s = 5 + 3 * r;
                       n.offset = n.reserve(s);
                       var a = n.buffer
                       , o = e(r)
                       , l = n.offset + o;
                       r = c.write.call(a, i, l);
                       var h = e(r);
                       if (o !== h) {
                           var u = l + h - o
                           , f = l + r;
                           c.copy.call(a, a, u, l, f)
                       }
                       t[1 === h ? 160 + r : h <= 3 ? 215 + h : 219](n, r),
                           n.offset += r
                   }
               }(n ? function(e) {
                   return e < 32 ? 1 : e <= 65535 ? 3 : 5
               }
                 : function(e) {
                   return e < 32 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5
               }
                ),
               symbol: v,
               undefined: v
           };
           function k(e, n) {
               if (null === n)
                   return v(e, n);
               if (g(n))
                   return m(e, n);
               if (i(n))
                   return function(e, n) {
                       var i = n.length;
                       t[i < 16 ? 144 + i : i <= 65535 ? 220 : 221](e, i);
                       for (var r = e.codec.encode, s = 0; s < i; s++)
                           r(e, n[s])
                   }(e, n);
               if (s.isUint64BE(n))
                   return function(e, n) {
                       t[207](e, n.toArray())
                   }(e, n);
               if (a.isInt64BE(n))
                   return function(e, n) {
                       t[211](e, n.toArray())
                   }(e, n);
               var r = e.codec.getExtPacker(n);
               if (r && (n = r(n)),
                   n instanceof u)
                   return function(e, n) {
                       var i = n.buffer
                       , r = i.length
                       , s = p[r] || (r < 255 ? 199 : r <= 65535 ? 200 : 201);
                       t[s](e, r),
                           h[n.type](e),
                           e.send(i)
                   }(e, n);
               y(e, n)
           }
           function v(e, n) {
               t[192](e, n)
           }
           function w(e, n) {
               var i = n.length;
               t[i < 255 ? 196 : i <= 65535 ? 197 : 198](e, i),
                   e.send(n)
           }
           function b(e, n) {
               var i = Object.keys(n)
               , r = i.length;
               t[r < 16 ? 128 + r : r <= 65535 ? 222 : 223](e, r);
               var s = e.codec.encode;
               i.forEach((function(t) {
                   s(e, t),
                       s(e, n[t])
               }
                         ))
           }
       }
   }
   , function(e, t, n) {
       var i = n(4)
       , r = n(7)
       , s = r.Uint64BE
       , a = r.Int64BE
       , o = n(13).uint8
       , c = n(0)
       , l = c.global
       , h = c.hasBuffer && "TYPED_ARRAY_SUPPORT"in l && !l.TYPED_ARRAY_SUPPORT
       , u = c.hasBuffer && l.prototype || {};
       function f() {
           var e = o.slice();
           return e[196] = d(196),
               e[197] = p(197),
               e[198] = g(198),
               e[199] = d(199),
               e[200] = p(200),
               e[201] = g(201),
               e[202] = m(202, 4, u.writeFloatBE || v, !0),
               e[203] = m(203, 8, u.writeDoubleBE || w, !0),
               e[204] = d(204),
               e[205] = p(205),
               e[206] = g(206),
               e[207] = m(207, 8, y),
               e[208] = d(208),
               e[209] = p(209),
               e[210] = g(210),
               e[211] = m(211, 8, k),
               e[217] = d(217),
               e[218] = p(218),
               e[219] = g(219),
               e[220] = p(220),
               e[221] = g(221),
               e[222] = p(222),
               e[223] = g(223),
               e
       }
       function d(e) {
           return function(t, n) {
               var i = t.reserve(2)
               , r = t.buffer;
               r[i++] = e,
                   r[i] = n
           }
       }
       function p(e) {
           return function(t, n) {
               var i = t.reserve(3)
               , r = t.buffer;
               r[i++] = e,
                   r[i++] = n >>> 8,
                   r[i] = n
           }
       }
       function g(e) {
           return function(t, n) {
               var i = t.reserve(5)
               , r = t.buffer;
               r[i++] = e,
                   r[i++] = n >>> 24,
                   r[i++] = n >>> 16,
                   r[i++] = n >>> 8,
                   r[i] = n
           }
       }
       function m(e, t, n, i) {
           return function(r, s) {
               var a = r.reserve(t + 1);
               r.buffer[a++] = e,
                   n.call(r.buffer, s, a, i)
           }
       }
       function y(e, t) {
           new s(this,t,e)
       }
       function k(e, t) {
           new a(this,t,e)
       }
       function v(e, t) {
           i.write(this, e, t, !1, 23, 4)
       }
       function w(e, t) {
           i.write(this, e, t, !1, 52, 8)
       }
       t.getWriteToken = function(e) {
           return e && e.uint8array ? function() {
               var e = f();
               return e[202] = m(202, 4, v),
                   e[203] = m(203, 8, w),
                   e
           }() : h || c.hasBuffer && e && e.safe ? function() {
               var e = o.slice();
               return e[196] = m(196, 1, l.prototype.writeUInt8),
                   e[197] = m(197, 2, l.prototype.writeUInt16BE),
                   e[198] = m(198, 4, l.prototype.writeUInt32BE),
                   e[199] = m(199, 1, l.prototype.writeUInt8),
                   e[200] = m(200, 2, l.prototype.writeUInt16BE),
                   e[201] = m(201, 4, l.prototype.writeUInt32BE),
                   e[202] = m(202, 4, l.prototype.writeFloatBE),
                   e[203] = m(203, 8, l.prototype.writeDoubleBE),
                   e[204] = m(204, 1, l.prototype.writeUInt8),
                   e[205] = m(205, 2, l.prototype.writeUInt16BE),
                   e[206] = m(206, 4, l.prototype.writeUInt32BE),
                   e[207] = m(207, 8, y),
                   e[208] = m(208, 1, l.prototype.writeInt8),
                   e[209] = m(209, 2, l.prototype.writeInt16BE),
                   e[210] = m(210, 4, l.prototype.writeInt32BE),
                   e[211] = m(211, 8, k),
                   e[217] = m(217, 1, l.prototype.writeUInt8),
                   e[218] = m(218, 2, l.prototype.writeUInt16BE),
                   e[219] = m(219, 4, l.prototype.writeUInt32BE),
                   e[220] = m(220, 2, l.prototype.writeUInt16BE),
                   e[221] = m(221, 4, l.prototype.writeUInt32BE),
                   e[222] = m(222, 2, l.prototype.writeUInt16BE),
                   e[223] = m(223, 4, l.prototype.writeUInt32BE),
                   e
           }() : f()
       }
   }
   , function(e, t, n) {
       t.setExtUnpackers = function(e) {
           e.addExtUnpacker(14, [o, l(Error)]),
               e.addExtUnpacker(1, [o, l(EvalError)]),
               e.addExtUnpacker(2, [o, l(RangeError)]),
               e.addExtUnpacker(3, [o, l(ReferenceError)]),
               e.addExtUnpacker(4, [o, l(SyntaxError)]),
               e.addExtUnpacker(5, [o, l(TypeError)]),
               e.addExtUnpacker(6, [o, l(URIError)]),
               e.addExtUnpacker(10, [o, c]),
               e.addExtUnpacker(11, [o, h(Boolean)]),
               e.addExtUnpacker(12, [o, h(String)]),
               e.addExtUnpacker(13, [o, h(Date)]),
               e.addExtUnpacker(15, [o, h(Number)]),
               "undefined" != typeof Uint8Array && (e.addExtUnpacker(17, h(Int8Array)),
                                                    e.addExtUnpacker(18, h(Uint8Array)),
                                                    e.addExtUnpacker(19, [u, h(Int16Array)]),
                                                    e.addExtUnpacker(20, [u, h(Uint16Array)]),
                                                    e.addExtUnpacker(21, [u, h(Int32Array)]),
                                                    e.addExtUnpacker(22, [u, h(Uint32Array)]),
                                                    e.addExtUnpacker(23, [u, h(Float32Array)]),
                                                    "undefined" != typeof Float64Array && e.addExtUnpacker(24, [u, h(Float64Array)]),
                                                    "undefined" != typeof Uint8ClampedArray && e.addExtUnpacker(25, h(Uint8ClampedArray)),
                                                    e.addExtUnpacker(26, u),
                                                    e.addExtUnpacker(29, [u, h(DataView)])),
               r.hasBuffer && e.addExtUnpacker(27, h(s))
       }
       ;
       var i, r = n(0), s = r.global, a = {
           name: 1,
           message: 1,
           stack: 1,
           columnNumber: 1,
           fileName: 1,
           lineNumber: 1
       };
       function o(e) {
           return i || (i = n(15).decode),
               i(e)
       }
       function c(e) {
           return RegExp.apply(null, e)
       }
       function l(e) {
           return function(t) {
               var n = new e;
               for (var i in a)
                   n[i] = t[i];
               return n
           }
       }
       function h(e) {
           return function(t) {
               return new e(t)
           }
       }
       function u(e) {
           return new Uint8Array(e).buffer
       }
   }
   , function(e, t, n) {
       var i = n(17);
       function r(e) {
           var t, n = new Array(256);
           for (t = 0; t <= 127; t++)
               n[t] = s(t);
           for (t = 128; t <= 143; t++)
               n[t] = o(t - 128, e.map);
           for (t = 144; t <= 159; t++)
               n[t] = o(t - 144, e.array);
           for (t = 160; t <= 191; t++)
               n[t] = o(t - 160, e.str);
           for (n[192] = s(null),
                n[193] = null,
                n[194] = s(!1),
                n[195] = s(!0),
                n[196] = a(e.uint8, e.bin),
                n[197] = a(e.uint16, e.bin),
                n[198] = a(e.uint32, e.bin),
                n[199] = a(e.uint8, e.ext),
                n[200] = a(e.uint16, e.ext),
                n[201] = a(e.uint32, e.ext),
                n[202] = e.float32,
                n[203] = e.float64,
                n[204] = e.uint8,
                n[205] = e.uint16,
                n[206] = e.uint32,
                n[207] = e.uint64,
                n[208] = e.int8,
                n[209] = e.int16,
                n[210] = e.int32,
                n[211] = e.int64,
                n[212] = o(1, e.ext),
                n[213] = o(2, e.ext),
                n[214] = o(4, e.ext),
                n[215] = o(8, e.ext),
                n[216] = o(16, e.ext),
                n[217] = a(e.uint8, e.str),
                n[218] = a(e.uint16, e.str),
                n[219] = a(e.uint32, e.str),
                n[220] = a(e.uint16, e.array),
                n[221] = a(e.uint32, e.array),
                n[222] = a(e.uint16, e.map),
                n[223] = a(e.uint32, e.map),
                t = 224; t <= 255; t++)
               n[t] = s(t - 256);
           return n
       }
       function s(e) {
           return function() {
               return e
           }
       }
       function a(e, t) {
           return function(n) {
               var i = e(n);
               return t(n, i)
           }
       }
       function o(e, t) {
           return function(n) {
               return t(n, e)
           }
       }
       t.getReadToken = function(e) {
           var t = i.getReadFormat(e);
           return e && e.useraw ? function(e) {
               var t, n = r(e).slice();
               for (n[217] = n[196],
                    n[218] = n[197],
                    n[219] = n[198],
                    t = 160; t <= 191; t++)
                   n[t] = o(t - 160, e.bin);
               return n
           }(t) : r(t)
       }
   }
   , function(e, t, n) {
       t.Encoder = s;
       var i = n(18)
       , r = n(10).EncodeBuffer;
       function s(e) {
           if (!(this instanceof s))
               return new s(e);
           r.call(this, e)
       }
       s.prototype = new r,
           i.mixin(s.prototype),
           s.prototype.encode = function(e) {
           this.write(e),
               this.emit("data", this.read())
       }
           ,
           s.prototype.end = function(e) {
           arguments.length && this.encode(e),
               this.flush(),
               this.emit("end")
       }
   }
   , function(e, t, n) {
       t.Decoder = s;
       var i = n(18)
       , r = n(16).DecodeBuffer;
       function s(e) {
           if (!(this instanceof s))
               return new s(e);
           r.call(this, e)
       }
       s.prototype = new r,
           i.mixin(s.prototype),
           s.prototype.decode = function(e) {
           arguments.length && this.write(e),
               this.flush()
       }
           ,
           s.prototype.push = function(e) {
           this.emit("data", e)
       }
           ,
           s.prototype.end = function(e) {
           this.decode(e),
               this.emit("end")
       }
   }
   , function(e, t, n) {
       n(8),
           n(2),
           t.createCodec = n(1).createCodec
   }
   , function(e, t, n) {
       n(8),
           n(2),
           t.codec = {
           preset: n(1).preset
       }
   }
   , function(e, t) {
       var n, i, r = e.exports = {};
       function s() {
           throw new Error("setTimeout has not been defined")
       }
       function a() {
           throw new Error("clearTimeout has not been defined")
       }
       function o(e) {
           if (n === setTimeout)
               return setTimeout(e, 0);
           if ((n === s || !n) && setTimeout)
               return n = setTimeout,
                   setTimeout(e, 0);
           try {
               return n(e, 0)
           } catch (t) {
               try {
                   return n.call(null, e, 0)
               } catch (t) {
                   return n.call(this, e, 0)
               }
           }
       }
       !function() {
           try {
               n = "function" == typeof setTimeout ? setTimeout : s
           } catch (e) {
               n = s
           }
           try {
               i = "function" == typeof clearTimeout ? clearTimeout : a
           } catch (e) {
               i = a
           }
       }();
       var c, l = [], h = !1, u = -1;
       function f() {
           h && c && (h = !1,
                      c.length ? l = c.concat(l) : u = -1,
                      l.length && d())
       }
       function d() {
           if (!h) {
               var e = o(f);
               h = !0;
               for (var t = l.length; t; ) {
                   for (c = l,
                        l = []; ++u < t; )
                       c && c[u].run();
                   u = -1,
                       t = l.length
               }
               c = null,
                   h = !1,
                   function(e) {
                   if (i === clearTimeout)
                       return clearTimeout(e);
                   if ((i === a || !i) && clearTimeout)
                       return i = clearTimeout,
                           clearTimeout(e);
                   try {
                       i(e)
                   } catch (t) {
                       try {
                           return i.call(null, e)
                       } catch (t) {
                           return i.call(this, e)
                       }
                   }
               }(e)
           }
       }
       function p(e, t) {
           this.fun = e,
               this.array = t
       }
       function g() {}
       r.nextTick = function(e) {
           var t = new Array(arguments.length - 1);
           if (arguments.length > 1)
               for (var n = 1; n < arguments.length; n++)
                   t[n - 1] = arguments[n];
           l.push(new p(e,t)),
               1 !== l.length || h || o(d)
       }
           ,
           p.prototype.run = function() {
           this.fun.apply(null, this.array)
       }
           ,
           r.title = "browser",
           r.browser = !0,
           r.env = {},
           r.argv = [],
           r.version = "",
           r.versions = {},
           r.on = g,
           r.addListener = g,
           r.once = g,
           r.off = g,
           r.removeListener = g,
           r.removeAllListeners = g,
           r.emit = g,
           r.prependListener = g,
           r.prependOnceListener = g,
           r.listeners = function(e) {
           return []
       }
           ,
           r.binding = function(e) {
           throw new Error("process.binding is not supported")
       }
           ,
           r.cwd = function() {
           return "/"
       }
           ,
           r.chdir = function(e) {
           throw new Error("process.chdir is not supported")
       }
           ,
           r.umask = function() {
           return 0
       }
   }
   , function(e, t) {
       var n = Math.abs
       , i = (Math.cos,
              Math.sin,
              Math.pow,
              Math.sqrt)
       , r = (n = Math.abs,
              Math.atan2)
       , s = Math.PI;
       e.exports.randInt = function(e, t) {
           return Math.floor(Math.random() * (t - e + 1)) + e
       }
           ,
           e.exports.randFloat = function(e, t) {
           return Math.random() * (t - e + 1) + e
       }
           ,
           e.exports.lerp = function(e, t, n) {
           return e + (t - e) * n
       }
           ,
           e.exports.decel = function(e, t) {
           return e > 0 ? e = Math.max(0, e - t) : e < 0 && (e = Math.min(0, e + t)),
               e
       }
           ,
           e.exports.getDistance = function(e, t, n, r) {
           return i((n -= e) * n + (r -= t) * r)
       }
           ,
           e.exports.getDirection = function(e, t, n, i) {
           return r(t - i, e - n)
       }
           ,
           e.exports.getAngleDist = function(e, t) {
           var i = n(t - e) % (2 * s);
           return i > s ? 2 * s - i : i
       }
           ,
           e.exports.isNumber = function(e) {
           return "number" == typeof e && !isNaN(e) && isFinite(e)
       }
           ,
           e.exports.isString = function(e) {
           return e && "string" == typeof e
       }
           ,
           e.exports.kFormat = function(e) {
           return e > 999 ? (e / 1e3).toFixed(1) + "k" : e
       }
           ,
           e.exports.capitalizeFirst = function(e) {
           return e.charAt(0).toUpperCase() + e.slice(1)
       }
           ,
           e.exports.fixTo = function(e, t) {
           return parseFloat(e.toFixed(t))
       }
           ,
           e.exports.sortByPoints = function(e, t) {
           return parseFloat(t.points) - parseFloat(e.points)
       }
           ,
           e.exports.lineInRect = function(e, t, n, i, r, s, a, o) {
           var c = r
           , l = a;
           if (r > a && (c = a,
                         l = r),
               l > n && (l = n),
               c < e && (c = e),
               c > l)
               return !1;
           var h = s
           , u = o
           , f = a - r;
           if (Math.abs(f) > 1e-7) {
               var d = (o - s) / f
               , p = s - d * r;
               h = d * c + p,
                   u = d * l + p
           }
           if (h > u) {
               var g = u;
               u = h,
                   h = g
           }
           return u > i && (u = i),
               h < t && (h = t),
               !(h > u)
       }
           ,
           e.exports.containsPoint = function(e, t, n) {
           var i = e.getBoundingClientRect()
           , r = i.left + window.scrollX
           , s = i.top + window.scrollY
           , a = i.width
           , o = i.height;
           return t > r && t < r + a && n > s && n < s + o
       }
           ,
           e.exports.mousifyTouchEvent = function(e) {
           var t = e.changedTouches[0];
           e.screenX = t.screenX,
               e.screenY = t.screenY,
               e.clientX = t.clientX,
               e.clientY = t.clientY,
               e.pageX = t.pageX,
               e.pageY = t.pageY
       }
           ,
           e.exports.hookTouchEvents = function(t, n) {
           var i = !n
           , r = !1;
           function s(n) {
               e.exports.mousifyTouchEvent(n),
                   window.setUsingTouch(!0),
                   i && (n.preventDefault(),
                         n.stopPropagation()),
                   r && (t.onclick && t.onclick(n),
                         t.onmouseout && t.onmouseout(n),
                         r = !1)
           }
           t.addEventListener("touchstart", e.exports.checkTrusted((function(n) {
               e.exports.mousifyTouchEvent(n),
                   window.setUsingTouch(!0),
                   i && (n.preventDefault(),
                         n.stopPropagation()),
                   t.onmouseover && t.onmouseover(n),
                   r = !0
           }
                                                                   )), !1),
               t.addEventListener("touchmove", e.exports.checkTrusted((function(n) {
               e.exports.mousifyTouchEvent(n),
                   window.setUsingTouch(!0),
                   i && (n.preventDefault(),
                         n.stopPropagation()),
                   e.exports.containsPoint(t, n.pageX, n.pageY) ? r || (t.onmouseover && t.onmouseover(n),
                                                                        r = !0) : r && (t.onmouseout && t.onmouseout(n),
                                                                                        r = !1)
           }
                                                                      )), !1),
               t.addEventListener("touchend", e.exports.checkTrusted(s), !1),
               t.addEventListener("touchcancel", e.exports.checkTrusted(s), !1),
               t.addEventListener("touchleave", e.exports.checkTrusted(s), !1)
       }
           ,
           e.exports.removeAllChildren = function(e) {
           for (; e.hasChildNodes(); )
               e.removeChild(e.lastChild)
       }
           ,
           e.exports.generateElement = function(t) {
           var n = document.createElement(t.tag || "div");
           function i(e, i) {
               t[e] && (n[i] = t[e])
           }
           for (var r in i("text", "textContent"),
                i("html", "innerHTML"),
                i("class", "className"),
                t) {
               switch (r) {
                   case "tag":
                   case "text":
                   case "html":
                   case "class":
                   case "style":
                   case "hookTouch":
                   case "parent":
                   case "children":
                       continue
               }
               n[r] = t[r]
           }
           if (n.onclick && (n.onclick = e.exports.checkTrusted(n.onclick)),
               n.onmouseover && (n.onmouseover = e.exports.checkTrusted(n.onmouseover)),
               n.onmouseout && (n.onmouseout = e.exports.checkTrusted(n.onmouseout)),
               t.style && (n.style.cssText = t.style),
               t.hookTouch && e.exports.hookTouchEvents(n),
               t.parent && t.parent.appendChild(n),
               t.children)
               for (var s = 0; s < t.children.length; s++)
                   n.appendChild(t.children[s]);
           return n
       }
           ,
           e.exports.eventIsTrusted = function(e) {
           return !e || "boolean" != typeof e.isTrusted || e.isTrusted
       }
           ,
           e.exports.checkTrusted = function(t) {
           return function(n) {
               n && n instanceof Event && e.exports.eventIsTrusted(n) && t(n)
           }
       }
           ,
           e.exports.randomString = function(e) {
           for (var t = "", n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", i = 0; i < e; i++)
               t += n.charAt(Math.floor(Math.random() * n.length));
           return t
       }
           ,
           e.exports.countInArray = function(e, t) {
           for (var n = 0, i = 0; i < e.length; i++)
               e[i] === t && n++;
           return n
       }
   }
   , function(e, t) {
       e.exports.AnimText = function() {
           this.init = function(e, t, n, i, r, s, a) {
               this.x = e,
                   this.y = t,
                   this.color = a,
                   this.scale = n,
                   this.startScale = this.scale,
                   this.maxScale = 1.5 * n,
                   this.scaleSpeed = .7,
                   this.speed = i,
                   this.life = r,
                   this.text = s
           }
               ,
               this.update = function(e) {
               this.life && (this.life -= e,
                             this.y -= this.speed * e,
                             this.scale += this.scaleSpeed * e,
                             this.scale >= this.maxScale ? (this.scale = this.maxScale,
                                                            this.scaleSpeed *= -1) : this.scale <= this.startScale && (this.scale = this.startScale,
                                                                                                                       this.scaleSpeed = 0),
                             this.life <= 0 && (this.life = 0))
           }
               ,
               this.render = function(e, t, n) {
               e.fillStyle = this.color,
                   e.font = this.scale + "px Hammersmith One",
                   e.fillText(this.text, this.x - t, this.y - n)
           }
       }
           ,
           e.exports.TextManager = function() {
           this.texts = [],
               this.update = function(e, t, n, i) {
               t.textBaseline = "middle",
                   t.textAlign = "center";
               for (var r = 0; r < this.texts.length; ++r)
                   this.texts[r].life && (this.texts[r].update(e),
                                          this.texts[r].render(t, n, i))
           }
               ,
               this.showText = function(t, n, i, r, s, a, o) {
               for (var c, l = 0; l < this.texts.length; ++l)
                   if (!this.texts[l].life) {
                       c = this.texts[l];
                       break
                   }
               c || (c = new e.exports.AnimText,
                     this.texts.push(c)),
                   c.init(t, n, i, r, s, a, o)
           }
       }
   }
   , function(e, t) {
       e.exports = function(e) {
           this.sid = e,
               this.init = function(e, t, n, i, r, s, a) {
               s = s || {},
                   this.sentTo = {},
                   this.gridLocations = [],
                   this.active = !0,
                   this.doUpdate = s.doUpdate,
                   this.x = e,
                   this.y = t,
                   this.dir = n,
                   this.xWiggle = 0,
                   this.yWiggle = 0,
                   this.scale = i,
                   this.type = r,
                   this.id = s.id,
                   this.owner = a,
                   this.name = s.name,
                   this.isItem = null != this.id,
                   this.group = s.group,
                   this.health = s.health,
                   this.layer = 2,
                   null != this.group ? this.layer = this.group.layer : 0 == this.type ? this.layer = 3 : 2 == this.type ? this.layer = 0 : 4 == this.type && (this.layer = -1),
                   this.colDiv = s.colDiv || 1,
                   this.blocker = s.blocker,
                   this.ignoreCollision = s.ignoreCollision,
                   this.dontGather = s.dontGather,
                   this.hideFromEnemy = s.hideFromEnemy,
                   this.friction = s.friction,
                   this.projDmg = s.projDmg,
                   this.dmg = s.dmg,
                   this.pDmg = s.pDmg,
                   this.pps = s.pps,
                   this.zIndex = s.zIndex || 0,
                   this.turnSpeed = s.turnSpeed,
                   this.req = s.req,
                   this.trap = s.trap,
                   this.healCol = s.healCol,
                   this.teleport = s.teleport,
                   this.boostSpeed = s.boostSpeed,
                   this.projectile = s.projectile,
                   this.shootRange = s.shootRange,
                   this.shootRate = s.shootRate,
                   this.shootCount = this.shootRate,
                   this.spawnPoint = s.spawnPoint
           }
               ,
               this.changeHealth = function(e, t) {
               return this.health += e,
                   this.health <= 0
           }
               ,
               this.getScale = function(e, t) {
               return e = e || 1,
                   this.scale * (this.isItem || 2 == this.type || 3 == this.type || 4 == this.type ? 1 : .6 * e) * (t ? 1 : this.colDiv)
           }
               ,
               this.visibleToPlayer = function(e) {
               return !this.hideFromEnemy || this.owner && (this.owner == e || this.owner.team && e.team == this.owner.team)
           }
               ,
               this.update = function(e) {
               this.active && (this.xWiggle && (this.xWiggle *= Math.pow(.99, e)),
                               this.yWiggle && (this.yWiggle *= Math.pow(.99, e)),
                               this.turnSpeed && (this.dir += this.turnSpeed * e))
           }
       }
   }
   , function(e, t) {
       e.exports.groups = [{
           id: 0,
           name: "food",
           layer: 0
       }, {
           id: 1,
           name: "walls",
           place: !0,
           limit: 30,
           layer: 0
       }, {
           id: 2,
           name: "spikes",
           place: !0,
           limit: 15,
           layer: 0
       }, {
           id: 3,
           name: "mill",
           place: !0,
           limit: 7,
           layer: 1
       }, {
           id: 4,
           name: "mine",
           place: !0,
           limit: 1,
           layer: 0
       }, {
           id: 5,
           name: "trap",
           place: !0,
           limit: 6,
           layer: -1
       }, {
           id: 6,
           name: "booster",
           place: !0,
           limit: 12,
           layer: -1
       }, {
           id: 7,
           name: "turret",
           place: !0,
           limit: 2,
           layer: 1
       }, {
           id: 8,
           name: "watchtower",
           place: !0,
           limit: 12,
           layer: 1
       }, {
           id: 9,
           name: "buff",
           place: !0,
           limit: 4,
           layer: -1
       }, {
           id: 10,
           name: "spawn",
           place: !0,
           limit: 1,
           layer: -1
       }, {
           id: 11,
           name: "sapling",
           place: !0,
           limit: 2,
           layer: 0
       }, {
           id: 12,
           name: "blocker",
           place: !0,
           limit: 3,
           layer: -1
       }, {
           id: 13,
           name: "teleporter",
           place: !0,
           limit: 2,
           layer: -1
       }],
           t.projectiles = [{
               indx: 0,
               layer: 0,
               src: "arrow_1",
               dmg: 25,
               speed: 1.6,
               scale: 103,
               range: 1e3
           }, {
               indx: 1,
               layer: 1,
               dmg: 25,
               scale: 20
           }, {
               indx: 0,
               layer: 0,
               src: "arrow_1",
               dmg: 35,
               speed: 2.5,
               scale: 103,
               range: 1200
           }, {
               indx: 0,
               layer: 0,
               src: "arrow_1",
               dmg: 30,
               speed: 2,
               scale: 103,
               range: 1200
           }, {
               indx: 1,
               layer: 1,
               dmg: 16,
               scale: 20
           }, {
               indx: 0,
               layer: 0,
               src: "bullet_1",
               dmg: 50,
               speed: 3.6,
               scale: 160,
               range: 1400
           }],
           t.weapons = [{
               id: 0,
               type: 0,
               name: "tool hammer",
               desc: "tool for gathering all resources",
               src: "hammer_1",
               length: 140,
               width: 140,
               xOff: -3,
               yOff: 18,
               dmg: 25,
               range: 65,
               gather: 1,
               speed: 300
           }, {
               id: 1,
               type: 0,
               age: 2,
               name: "hand axe",
               desc: "gathers resources at a higher rate",
               src: "axe_1",
               length: 140,
               width: 140,
               xOff: 3,
               yOff: 24,
               dmg: 30,
               spdMult: 1,
               range: 70,
               gather: 2,
               speed: 400
           }, {
               id: 2,
               type: 0,
               age: 8,
               pre: 1,
               name: "great axe",
               desc: "deal more damage and gather more resources",
               src: "great_axe_1",
               length: 140,
               width: 140,
               xOff: -8,
               yOff: 25,
               dmg: 35,
               spdMult: 1,
               range: 75,
               gather: 4,
               speed: 400
           }, {
               id: 3,
               type: 0,
               age: 2,
               name: "short sword",
               desc: "increased attack power but slower move speed",
               src: "sword_1",
               iPad: 1.3,
               length: 130,
               width: 210,
               xOff: -8,
               yOff: 46,
               dmg: 35,
               spdMult: .85,
               range: 110,
               gather: 1,
               speed: 300
           }, {
               id: 4,
               type: 0,
               age: 8,
               pre: 3,
               name: "katana",
               desc: "greater range and damage",
               src: "samurai_1",
               iPad: 1.3,
               length: 130,
               width: 210,
               xOff: -8,
               yOff: 59,
               dmg: 40,
               spdMult: .8,
               range: 118,
               gather: 1,
               speed: 300
           }, {
               id: 5,
               type: 0,
               age: 2,
               name: "polearm",
               desc: "long range melee weapon",
               src: "spear_1",
               iPad: 1.3,
               length: 130,
               width: 210,
               xOff: -8,
               yOff: 53,
               dmg: 45,
               knock: .2,
               spdMult: .82,
               range: 142,
               gather: 1,
               speed: 700
           }, {
               id: 6,
               type: 0,
               age: 2,
               name: "bat",
               desc: "fast long range melee weapon",
               src: "bat_1",
               iPad: 1.3,
               length: 110,
               width: 180,
               xOff: -8,
               yOff: 53,
               dmg: 20,
               knock: .7,
               range: 110,
               gather: 1,
               speed: 300
           }, {
               id: 7,
               type: 0,
               age: 2,
               name: "daggers",
               desc: "really fast short range weapon",
               src: "dagger_1",
               iPad: .8,
               length: 110,
               width: 110,
               xOff: 18,
               yOff: 0,
               dmg: 20,
               knock: .1,
               range: 65,
               gather: 1,
               hitSlow: .1,
               spdMult: 1.13,
               speed: 100
           }, {
               id: 8,
               type: 0,
               age: 2,
               name: "stick",
               desc: "great for gathering but very weak",
               src: "stick_1",
               length: 140,
               width: 140,
               xOff: 3,
               yOff: 24,
               dmg: 1,
               spdMult: 1,
               range: 70,
               gather: 7,
               speed: 400
           }, {
               id: 9,
               type: 1,
               age: 6,
               name: "hunting bow",
               desc: "bow used for ranged combat and hunting",
               src: "bow_1",
               req: ["wood", 4],
               length: 120,
               width: 120,
               xOff: -6,
               yOff: 0,
               projectile: 0,
               spdMult: .75,
               speed: 600
           }, {
               id: 10,
               type: 1,
               age: 6,
               name: "great hammer",
               desc: "hammer used for destroying structures",
               src: "great_hammer_1",
               length: 140,
               width: 140,
               xOff: -9,
               yOff: 25,
               dmg: 10,
               spdMult: .88,
               range: 75,
               sDmg: 7.5,
               gather: 1,
               speed: 400
           }, {
               id: 11,
               type: 1,
               age: 6,
               name: "wooden shield",
               desc: "blocks projectiles and reduces melee damage",
               src: "shield_1",
               length: 120,
               width: 120,
               shield: .2,
               xOff: 6,
               yOff: 0,
               spdMult: .7
           }, {
               id: 12,
               type: 1,
               age: 8,
               pre: 9,
               name: "crossbow",
               desc: "deals more damage and has greater range",
               src: "crossbow_1",
               req: ["wood", 5],
               aboveHand: !0,
               armS: .75,
               length: 120,
               width: 120,
               xOff: -4,
               yOff: 0,
               projectile: 2,
               spdMult: .7,
               speed: 700
           }, {
               id: 13,
               type: 1,
               age: 9,
               pre: 12,
               name: "repeater crossbow",
               desc: "high firerate crossbow with reduced damage",
               src: "crossbow_2",
               req: ["wood", 10],
               aboveHand: !0,
               armS: .75,
               length: 120,
               width: 120,
               xOff: -4,
               yOff: 0,
               projectile: 3,
               spdMult: .7,
               speed: 230
           }, {
               id: 14,
               type: 1,
               age: 6,
               name: "mc grabby",
               desc: "steals resources from enemies",
               src: "grab_1",
               length: 130,
               width: 210,
               xOff: -8,
               yOff: 53,
               dmg: 0,
               steal: 250,
               knock: .2,
               spdMult: 1.05,
               range: 125,
               gather: 0,
               speed: 700
           }, {
               id: 15,
               type: 1,
               age: 9,
               pre: 12,
               name: "musket",
               desc: "slow firerate but high damage and range",
               src: "musket_1",
               req: ["stone", 10],
               aboveHand: !0,
               rec: .35,
               armS: .6,
               hndS: .3,
               hndD: 1.6,
               length: 205,
               width: 205,
               xOff: 25,
               yOff: 0,
               projectile: 5,
               hideProjectile: !0,
               spdMult: .6,
               speed: 1500
           }],
           e.exports.list = [{
               group: e.exports.groups[0],
               name: "apple",
               desc: "restores 20 health when consumed",
               req: ["food", 10],
               consume: function(e) {
                   return e.changeHealth(20, e)
               },
               scale: 22,
               holdOffset: 15
           }, {
               age: 3,
               group: e.exports.groups[0],
               name: "cookie",
               desc: "restores 40 health when consumed",
               req: ["food", 15],
               consume: function(e) {
                   return e.changeHealth(40, e)
               },
               scale: 27,
               holdOffset: 15
           }, {
               age: 7,
               group: e.exports.groups[0],
               name: "cheese",
               desc: "restores 30 health and another 50 over 5 seconds",
               req: ["food", 25],
               consume: function(e) {
                   return !!(e.changeHealth(30, e) || e.health < 100) && (e.dmgOverTime.dmg = -10,
                                                                          e.dmgOverTime.doer = e,
                                                                          e.dmgOverTime.time = 5,
                                                                          !0)
               },
               scale: 27,
               holdOffset: 15
           }, {
               group: e.exports.groups[1],
               name: "wood wall",
               desc: "provides protection for your village",
               req: ["wood", 10],
               projDmg: !0,
               health: 380,
               scale: 50,
               holdOffset: 20,
               placeOffset: -5
           }, {
               age: 3,
               group: e.exports.groups[1],
               name: "stone wall",
               desc: "provides improved protection for your village",
               req: ["stone", 25],
               health: 900,
               scale: 50,
               holdOffset: 20,
               placeOffset: -5
           }, {
               age: 7,
               pre: 1,
               group: e.exports.groups[1],
               name: "castle wall",
               desc: "provides powerful protection for your village",
               req: ["stone", 35],
               health: 1500,
               scale: 52,
               holdOffset: 20,
               placeOffset: -5
           }, {
               group: e.exports.groups[2],
               name: "spikes",
               desc: "damages enemies when they touch them",
               req: ["wood", 20, "stone", 5],
               health: 400,
               dmg: 20,
               scale: 49,
               spritePadding: -23,
               holdOffset: 8,
               placeOffset: -5
           }, {
               age: 5,
               group: e.exports.groups[2],
               name: "greater spikes",
               desc: "damages enemies when they touch them",
               req: ["wood", 30, "stone", 10],
               health: 500,
               dmg: 35,
               scale: 52,
               spritePadding: -23,
               holdOffset: 8,
               placeOffset: -5
           }, {
               age: 9,
               pre: 1,
               group: e.exports.groups[2],
               name: "poison spikes",
               desc: "poisons enemies when they touch them",
               req: ["wood", 35, "stone", 15],
               health: 600,
               dmg: 30,
               pDmg: 5,
               scale: 52,
               spritePadding: -23,
               holdOffset: 8,
               placeOffset: -5
           }, {
               age: 9,
               pre: 2,
               group: e.exports.groups[2],
               name: "spinning spikes",
               desc: "damages enemies when they touch them",
               req: ["wood", 30, "stone", 20],
               health: 500,
               dmg: 45,
               turnSpeed: .003,
               scale: 52,
               spritePadding: -23,
               holdOffset: 8,
               placeOffset: -5
           }, {
               group: e.exports.groups[3],
               name: "windmill",
               desc: "generates gold over time",
               req: ["wood", 50, "stone", 10],
               health: 400,
               pps: 1,
               turnSpeed: .0016,
               spritePadding: 25,
               iconLineMult: 12,
               scale: 45,
               holdOffset: 20,
               placeOffset: 5
           }, {
               age: 5,
               pre: 1,
               group: e.exports.groups[3],
               name: "faster windmill",
               desc: "generates more gold over time",
               req: ["wood", 60, "stone", 20],
               health: 500,
               pps: 1.5,
               turnSpeed: .0025,
               spritePadding: 25,
               iconLineMult: 12,
               scale: 47,
               holdOffset: 20,
               placeOffset: 5
           }, {
               age: 8,
               pre: 1,
               group: e.exports.groups[3],
               name: "power mill",
               desc: "generates more gold over time",
               req: ["wood", 100, "stone", 50],
               health: 800,
               pps: 2,
               turnSpeed: .005,
               spritePadding: 25,
               iconLineMult: 12,
               scale: 47,
               holdOffset: 20,
               placeOffset: 5
           }, {
               age: 5,
               group: e.exports.groups[4],
               type: 2,
               name: "mine",
               desc: "allows you to mine stone",
               req: ["wood", 20, "stone", 100],
               iconLineMult: 12,
               scale: 65,
               holdOffset: 20,
               placeOffset: 0
           }, {
               age: 5,
               group: e.exports.groups[11],
               type: 0,
               name: "sapling",
               desc: "allows you to farm wood",
               req: ["wood", 150],
               iconLineMult: 12,
               colDiv: .5,
               scale: 110,
               holdOffset: 50,
               placeOffset: -15
           }, {
               age: 4,
               group: e.exports.groups[5],
               name: "pit trap",
               desc: "pit that traps enemies if they walk over it",
               req: ["wood", 30, "stone", 30],
               trap: !0,
               ignoreCollision: !0,
               hideFromEnemy: !0,
               health: 500,
               colDiv: .2,
               scale: 50,
               holdOffset: 20,
               placeOffset: -5
           }, {
               age: 4,
               group: e.exports.groups[6],
               name: "boost pad",
               desc: "provides boost when stepped on",
               req: ["stone", 20, "wood", 5],
               ignoreCollision: !0,
               boostSpeed: 1.5,
               health: 150,
               colDiv: .7,
               scale: 45,
               holdOffset: 20,
               placeOffset: -5
           }, {
               age: 7,
               group: e.exports.groups[7],
               doUpdate: !0,
               name: "turret",
               desc: "defensive structure that shoots at enemies",
               req: ["wood", 200, "stone", 150],
               health: 800,
               projectile: 1,
               shootRange: 700,
               shootRate: 2200,
               scale: 43,
               holdOffset: 20,
               placeOffset: -5
           }, {
               age: 7,
               group: e.exports.groups[8],
               name: "platform",
               desc: "platform to shoot over walls and cross over water",
               req: ["wood", 20],
               ignoreCollision: !0,
               zIndex: 1,
               health: 300,
               scale: 43,
               holdOffset: 20,
               placeOffset: -5
           }, {
               age: 7,
               group: e.exports.groups[9],
               name: "healing pad",
               desc: "standing on it will slowly heal you",
               req: ["wood", 30, "food", 10],
               ignoreCollision: !0,
               healCol: 15,
               health: 400,
               colDiv: .7,
               scale: 45,
               holdOffset: 20,
               placeOffset: -5
           }, {
               age: 9,
               group: e.exports.groups[10],
               name: "spawn pad",
               desc: "you will spawn here when you die but it will dissapear",
               req: ["wood", 100, "stone", 100],
               health: 400,
               ignoreCollision: !0,
               spawnPoint: !0,
               scale: 45,
               holdOffset: 20,
               placeOffset: -5
           }, {
               age: 7,
               group: e.exports.groups[12],
               name: "blocker",
               desc: "blocks building in radius",
               req: ["wood", 30, "stone", 25],
               ignoreCollision: !0,
               blocker: 300,
               health: 400,
               colDiv: .7,
               scale: 45,
               holdOffset: 20,
               placeOffset: -5
           }, {
               age: 7,
               group: e.exports.groups[13],
               name: "teleporter",
               desc: "teleports you to a random point on the map",
               req: ["wood", 60, "stone", 60],
               ignoreCollision: !0,
               teleport: !0,
               health: 200,
               colDiv: .7,
               scale: 45,
               holdOffset: 20,
               placeOffset: -5
           }];
       for (var n = 0; n < e.exports.list.length; ++n)
           e.exports.list[n].id = n,
               e.exports.list[n].pre && (e.exports.list[n].pre = n - e.exports.list[n].pre)
   }
   , function(e, t) {
       e.exports = {}
   }
   , function(e, t) {
       var n = Math.floor
       , i = Math.abs
       , r = Math.cos
       , s = Math.sin
       , a = (Math.pow,
              Math.sqrt);
       e.exports = function(e, t, o, c, l, h) {
           var u, f;
           this.objects = t,
               this.grids = {},
               this.updateObjects = [];
           var d = c.mapScale / c.colGrid;
           this.setObjectGrids = function(e) {
               for (var t = Math.min(c.mapScale, Math.max(0, e.x)), n = Math.min(c.mapScale, Math.max(0, e.y)), i = 0; i < c.colGrid; ++i) {
                   u = i * d;
                   for (var r = 0; r < c.colGrid; ++r)
                       f = r * d,
                           t + e.scale >= u && t - e.scale <= u + d && n + e.scale >= f && n - e.scale <= f + d && (this.grids[i + "_" + r] || (this.grids[i + "_" + r] = []),
                                                                                                                    this.grids[i + "_" + r].push(e),
                                                                                                                    e.gridLocations.push(i + "_" + r))
               }
           }
               ,
               this.removeObjGrid = function(e) {
               for (var t, n = 0; n < e.gridLocations.length; ++n)
                   (t = this.grids[e.gridLocations[n]].indexOf(e)) >= 0 && this.grids[e.gridLocations[n]].splice(t, 1)
           }
               ,
               this.disableObj = function(e) {
               if (e.active = !1,
                   h) {
                   e.owner && e.pps && (e.owner.pps -= e.pps),
                       this.removeObjGrid(e);
                   var t = this.updateObjects.indexOf(e);
                   t >= 0 && this.updateObjects.splice(t, 1)
               }
           }
               ,
               this.hitObj = function(e, t) {
               for (var n = 0; n < l.length; ++n)
                   l[n].active && (e.sentTo[l[n].id] && (e.active ? l[n].canSee(e) && h.send(l[n].id, "8", o.fixTo(t, 1), e.sid) : h.send(l[n].id, "12", e.sid)),
                                   e.active || e.owner != l[n] || l[n].changeItemCount(e.group.id, -1))
           }
           ;
           var p, g, m = [];
           this.getGridArrays = function(e, t, i) {
               u = n(e / d),
                   f = n(t / d),
                   m.length = 0;
               try {
                   this.grids[u + "_" + f] && m.push(this.grids[u + "_" + f]),
                       e + i >= (u + 1) * d && ((p = this.grids[u + 1 + "_" + f]) && m.push(p),
                                                f && t - i <= f * d ? (p = this.grids[u + 1 + "_" + (f - 1)]) && m.push(p) : t + i >= (f + 1) * d && (p = this.grids[u + 1 + "_" + (f + 1)]) && m.push(p)),
                       u && e - i <= u * d && ((p = this.grids[u - 1 + "_" + f]) && m.push(p),
                                               f && t - i <= f * d ? (p = this.grids[u - 1 + "_" + (f - 1)]) && m.push(p) : t + i >= (f + 1) * d && (p = this.grids[u - 1 + "_" + (f + 1)]) && m.push(p)),
                       t + i >= (f + 1) * d && (p = this.grids[u + "_" + (f + 1)]) && m.push(p),
                       f && t - i <= f * d && (p = this.grids[u + "_" + (f - 1)]) && m.push(p)
               } catch (e) {}
               return m
           }
               ,
               this.add = function(n, i, r, s, a, o, c, l, u) {
               g = null;
               for (var f = 0; f < t.length; ++f)
                   if (t[f].sid == n) {
                       g = t[f];
                       break
                   }
               if (!g)
                   for (f = 0; f < t.length; ++f)
                       if (!t[f].active) {
                           g = t[f];
                           break
                       }
               g || (g = new e(n),
                     t.push(g)),
                   l && (g.sid = n),
                   g.init(i, r, s, a, o, c, u),
                   h && (this.setObjectGrids(g),
                         g.doUpdate && this.updateObjects.push(g))
           }
               ,
               this.disableBySid = function(e) {
               for (var n = 0; n < t.length; ++n)
                   if (t[n].sid == e) {
                       this.disableObj(t[n]);
                       break
                   }
           }
               ,
               this.removeAllItems = function(e, n) {
               for (var i = 0; i < t.length; ++i)
                   t[i].active && t[i].owner && t[i].owner.sid == e && this.disableObj(t[i]);
               n && n.broadcast("13", e)
           }
               ,
               this.fetchSpawnObj = function(e) {
               for (var n = null, i = 0; i < t.length; ++i)
                   if ((g = t[i]).active && g.owner && g.owner.sid == e && g.spawnPoint) {
                       n = [g.x, g.y],
                           this.disableObj(g),
                           h.broadcast("12", g.sid),
                           g.owner && g.owner.changeItemCount(g.group.id, -1);
                       break
                   }
               return n
           }
               ,
               this.checkItemLocation = function(e, n, i, r, s, a, l) {
               for (var h = 0; h < t.length; ++h) {
                   var u = t[h].blocker ? t[h].blocker : t[h].getScale(r, t[h].isItem);
                   if (t[h].active && o.getDistance(e, n, t[h].x, t[h].y) < i + u)
                       return !1
               }
               return !(!a && 18 != s && n >= c.mapScale / 2 - c.riverWidth / 2 && n <= c.mapScale / 2 + c.riverWidth / 2)
           }
               ,
               this.addProjectile = function(e, t, n, i, r) {
               for (var s, a = items.projectiles[r], c = 0; c < projectiles.length; ++c)
                   if (!projectiles[c].active) {
                       s = projectiles[c];
                       break
                   }
               s || (s = new Projectile(l,o),
                     projectiles.push(s)),
                   s.init(r, e, t, n, a.speed, i, a.scale)
           }
               ,
               this.checkCollision = function(e, t, n) {
               n = n || 1;
               var l = e.x - t.x
               , h = e.y - t.y
               , u = e.scale + t.scale;
               if (i(l) <= u || i(h) <= u) {
                   u = e.scale + (t.getScale ? t.getScale() : t.scale);
                   var f = a(l * l + h * h) - u;
                   if (f <= 0) {
                       if (t.ignoreCollision)
                           !t.trap || e.noTrap || t.owner == e || t.owner && t.owner.team && t.owner.team == e.team ? t.boostSpeed ? (e.xVel += n * t.boostSpeed * (t.weightM || 1) * r(t.dir),
                                                                                                                                      e.yVel += n * t.boostSpeed * (t.weightM || 1) * s(t.dir)) : t.healCol ? e.healCol = t.healCol : t.teleport && (e.x = o.randInt(0, c.mapScale),
                        e.y = o.randInt(0, c.mapScale)) : (e.lockMove = !0,
                                                           t.hideFromEnemy = !1);
                       else {
                           var d = o.getDirection(e.x, e.y, t.x, t.y);
                           if (o.getDistance(e.x, e.y, t.x, t.y),
                               t.isPlayer ? (f = -1 * f / 2,
                                             e.x += f * r(d),
                                             e.y += f * s(d),
                                             t.x -= f * r(d),
                                             t.y -= f * s(d)) : (e.x = t.x + u * r(d),
                                                                 e.y = t.y + u * s(d),
                                                                 e.xVel *= .75,
                                                                 e.yVel *= .75),
                               t.dmg && t.owner != e && (!t.owner || !t.owner.team || t.owner.team != e.team)) {
                               e.changeHealth(-t.dmg, t.owner, t);
                               var p = 1.5 * (t.weightM || 1);
                               e.xVel += p * r(d),
                                   e.yVel += p * s(d),
                                   !t.pDmg || e.skin && e.skin.poisonRes || (e.dmgOverTime.dmg = t.pDmg,
                                                                             e.dmgOverTime.time = 5,
                                                                             e.dmgOverTime.doer = t.owner),
                                   e.colDmg && t.health && (t.changeHealth(-e.colDmg) && this.disableObj(t),
                                                            this.hitObj(t, o.getDirection(e.x, e.y, t.x, t.y)))
                           }
                       }
                       return t.zIndex > e.zIndex && (e.zIndex = t.zIndex),
                           !0
                   }
               }
               return !1
           }
       }
   }
   , function(e, t, n) {
       var i = new (n(49));
       i.addWords("jew", "black", "baby", "child", "white", "porn", "pedo", "trump", "clinton", "hitler", "nazi", "gay", "pride", "sex", "pleasure", "touch", "poo", "kids", "rape", "white power", "nigga", "nig nog", "doggy", "rapist", "boner", "nigger", "nigg", "finger", "nogger", "nagger", "nig", "fag", "gai", "pole", "stripper", "penis", "vagina", "pussy", "nazi", "hitler", "stalin", "burn", "chamber", "cock", "peen", "dick", "spick", "nieger", "die", "satan", "n|ig", "nlg", "cunt", "c0ck", "fag", "lick", "condom", "anal", "shit", "phile", "little", "kids", "free KR", "tiny", "sidney", "ass", "kill", ".io", "(dot)", "[dot]", "mini", "whiore", "whore", "faggot", "github", "1337", "666", "satan", "senpa", "discord", "d1scord", "mistik", ".io", "senpa.io", "sidney", "sid", "senpaio", "vries", "asa");
       var r = Math.abs
       , s = Math.cos
       , a = Math.sin
       , o = Math.pow
       , c = Math.sqrt;
       e.exports = function(e, t, n, l, h, u, f, d, p, g, m, y, k, v) {
           this.id = e,
               this.sid = t,
               this.tmpScore = 0,
               this.team = null,
               this.skinIndex = 0,
               this.tailIndex = 0,
               this.hitTime = 0,
               this.tails = {};
           for (var w = 0; w < m.length; ++w)
               m[w].price <= 0 && (this.tails[m[w].id] = 1);
           for (this.skins = {},
                w = 0; w < g.length; ++w)
               g[w].price <= 0 && (this.skins[g[w].id] = 1);
           this.points = 0,
               this.dt = 0,
               this.hidden = !1,
               this.itemCounts = {},
               this.isPlayer = !0,
               this.pps = 0,
               this.moveDir = void 0,
               this.skinRot = 0,
               this.lastPing = 0,
               this.iconIndex = 0,
               this.skinColor = 0,
               this.spawn = function(e) {
               this.active = !0,
                   this.alive = !0,
                   this.lockMove = !1,
                   this.lockDir = !1,
                   this.minimapCounter = 0,
                   this.chatCountdown = 0,
                   this.shameCount = 0,
                   this.shameTimer = 0,
                   this.sentTo = {},
                   this.gathering = 0,
                   this.autoGather = 0,
                   this.animTime = 0,
                   this.animSpeed = 0,
                   this.mouseState = 0,
                   this.buildIndex = -1,
                   this.weaponIndex = 0,
                   this.dmgOverTime = {},
                   this.noMovTimer = 0,
                   this.maxXP = 300,
                   this.XP = 0,
                   this.age = 1,
                   this.kills = 0,
                   this.upgrAge = 2,
                   this.upgradePoints = 0,
                   this.x = 0,
                   this.y = 0,
                   this.zIndex = 0,
                   this.xVel = 0,
                   this.yVel = 0,
                   this.slowMult = 1,
                   this.dir = 0,
                   this.dirPlus = 0,
                   this.targetDir = 0,
                   this.targetAngle = 0,
                   this.maxHealth = 100,
                   this.health = this.maxHealth,
                   this.scale = n.playerScale,
                   this.speed = n.playerSpeed,
                   this.resetMoveDir(),
                   this.resetResources(e),
                   this.items = [0, 3, 6, 10],
                   this.weapons = [0],
                   this.shootCount = 0,
                   this.weaponXP = [],
                   this.reloads = {}
           }
               ,
               this.resetMoveDir = function() {
               this.moveDir = void 0
           }
               ,
               this.resetResources = function(e) {
               for (var t = 0; t < n.resourceTypes.length; ++t)
                   this[n.resourceTypes[t]] = e ? 100 : 0
           }
               ,
               this.addItem = function(e) {
               var t = p.list[e];
               if (t) {
                   for (var n = 0; n < this.items.length; ++n)
                       if (p.list[this.items[n]].group == t.group)
                           return this.buildIndex == this.items[n] && (this.buildIndex = e),
                               this.items[n] = e,
                               !0;
                   return this.items.push(e),
                       !0
               }
               return !1
           }
               ,
               this.setUserData = function(e) {
               if (e) {
                   this.name = "unknown";
                   var t = e.name + ""
                   , r = !1
                   , s = (t = (t = (t = (t = t.slice(0, n.maxNameLength)).replace(/[^\w:\(\)\/? -]+/gim, " ")).replace(/[^\x00-\x7F]/g, " ")).trim()).toLowerCase().replace(/\s/g, "").replace(/1/g, "i").replace(/0/g, "o").replace(/5/g, "s");
                   for (var a of i.list)
                       if (-1 != s.indexOf(a)) {
                           r = !0;
                           break
                       }
                   t.length > 0 && !r && (this.name = t),
                       this.skinColor = 0,
                       n.skinColors[e.skin] && (this.skinColor = e.skin)
               }
           }
               ,
               this.getData = function() {
               return [this.id, this.sid, this.name, l.fixTo(this.x, 2), l.fixTo(this.y, 2), l.fixTo(this.dir, 3), this.health, this.maxHealth, this.scale, this.skinColor]
           }
               ,
               this.setData = function(e) {
               this.id = e[0],
                   this.sid = e[1],
                   this.name = e[2],
                   this.x = e[3],
                   this.y = e[4],
                   this.dir = e[5],
                   this.health = e[6],
                   this.maxHealth = e[7],
                   this.scale = e[8],
                   this.skinColor = e[9]
           }
           ;
           var b = 0;
           this.update = function(e) {
               if (this.alive) {
                   if (this.shameTimer > 0 && (this.shameTimer -= e,
                                               this.shameTimer <= 0 && (this.shameTimer = 0,
                                                                        this.shameCount = 0)),
                       (b -= e) <= 0) {
                       var t = (this.skin && this.skin.healthRegen ? this.skin.healthRegen : 0) + (this.tail && this.tail.healthRegen ? this.tail.healthRegen : 0);
                       t && this.changeHealth(t, this),
                           this.dmgOverTime.dmg && (this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer),
                                                    this.dmgOverTime.time -= 1,
                                                    this.dmgOverTime.time <= 0 && (this.dmgOverTime.dmg = 0)),
                           this.healCol && this.changeHealth(this.healCol, this),
                           b = 1e3
                   }
                   if (this.alive) {
                       if (this.slowMult < 1 && (this.slowMult += 8e-4 * e,
                                                 this.slowMult > 1 && (this.slowMult = 1)),
                           this.noMovTimer += e,
                           (this.xVel || this.yVel) && (this.noMovTimer = 0),
                           this.lockMove)
                           this.xVel = 0,
                               this.yVel = 0;
                       else {
                           var i = (this.buildIndex >= 0 ? .5 : 1) * (p.weapons[this.weaponIndex].spdMult || 1) * (this.skin && this.skin.spdMult || 1) * (this.tail && this.tail.spdMult || 1) * (this.y <= n.snowBiomeTop ? this.skin && this.skin.coldM ? 1 : n.snowSpeed : 1) * this.slowMult;
                           !this.zIndex && this.y >= n.mapScale / 2 - n.riverWidth / 2 && this.y <= n.mapScale / 2 + n.riverWidth / 2 && (this.skin && this.skin.watrImm ? (i *= .75,
                        this.xVel += .4 * n.waterCurrent * e) : (i *= .33,
                                                                 this.xVel += n.waterCurrent * e));
                           var r = null != this.moveDir ? s(this.moveDir) : 0
                           , d = null != this.moveDir ? a(this.moveDir) : 0
                           , g = c(r * r + d * d);
                           0 != g && (r /= g,
                                      d /= g),
                               r && (this.xVel += r * this.speed * i * e),
                               d && (this.yVel += d * this.speed * i * e)
                       }
                       var m;
                       this.zIndex = 0,
                           this.lockMove = !1,
                           this.healCol = 0;
                       for (var y = l.getDistance(0, 0, this.xVel * e, this.yVel * e), k = Math.min(4, Math.max(1, Math.round(y / 40))), v = 1 / k, w = 0; w < k; ++w) {
                           this.xVel && (this.x += this.xVel * e * v),
                               this.yVel && (this.y += this.yVel * e * v),
                               m = u.getGridArrays(this.x, this.y, this.scale);
                           for (var x = 0; x < m.length; ++x)
                               for (var S = 0; S < m[x].length; ++S)
                                   m[x][S].active && u.checkCollision(this, m[x][S], v)
                       }
                       for (w = (I = f.indexOf(this)) + 1; w < f.length; ++w)
                           f[w] != this && f[w].alive && u.checkCollision(this, f[w]);
                       if (this.xVel && (this.xVel *= o(n.playerDecel, e),
                                         this.xVel <= .01 && this.xVel >= -.01 && (this.xVel = 0)),
                           this.yVel && (this.yVel *= o(n.playerDecel, e),
                                         this.yVel <= .01 && this.yVel >= -.01 && (this.yVel = 0)),
                           this.x - this.scale < 0 ? this.x = this.scale : this.x + this.scale > n.mapScale && (this.x = n.mapScale - this.scale),
                           this.y - this.scale < 0 ? this.y = this.scale : this.y + this.scale > n.mapScale && (this.y = n.mapScale - this.scale),
                           this.buildIndex < 0)
                           if (this.reloads[this.weaponIndex] > 0)
                               this.reloads[this.weaponIndex] -= e,
                                   this.gathering = this.mouseState;
                           else if (this.gathering || this.autoGather) {
                               var T = !0;
                               if (null != p.weapons[this.weaponIndex].gather)
                                   this.gather(f);
                               else if (null != p.weapons[this.weaponIndex].projectile && this.hasRes(p.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0)) {
                                   this.useRes(p.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0),
                                       this.noMovTimer = 0;
                                   var I = p.weapons[this.weaponIndex].projectile
                                   , E = 2 * this.scale
                                   , M = this.skin && this.skin.aMlt ? this.skin.aMlt : 1;
                                   p.weapons[this.weaponIndex].rec && (this.xVel -= p.weapons[this.weaponIndex].rec * s(this.dir),
                                                                       this.yVel -= p.weapons[this.weaponIndex].rec * a(this.dir)),
                                       h.addProjectile(this.x + E * s(this.dir), this.y + E * a(this.dir), this.dir, p.projectiles[I].range * M, p.projectiles[I].speed * M, I, this, null, this.zIndex)
                               } else
                                   T = !1;
                               this.gathering = this.mouseState,
                                   T && (this.reloads[this.weaponIndex] = p.weapons[this.weaponIndex].speed * (this.skin && this.skin.atkSpd || 1))
                           }
                   }
               }
           }
               ,
               this.addWeaponXP = function(e) {
               this.weaponXP[this.weaponIndex] || (this.weaponXP[this.weaponIndex] = 0),
                   this.weaponXP[this.weaponIndex] += e
           }
               ,
               this.earnXP = function(e) {
               this.age < n.maxAge && (this.XP += e,
                                       this.XP >= this.maxXP ? (this.age < n.maxAge ? (this.age++,
                                                                                       this.XP = 0,
                                                                                       this.maxXP *= 1.2) : this.XP = this.maxXP,
                                                                this.upgradePoints++,
                                                                y.send(this.id, "16", this.upgradePoints, this.upgrAge),
                                                                y.send(this.id, "15", this.XP, l.fixTo(this.maxXP, 1), this.age)) : y.send(this.id, "15", this.XP))
           }
               ,
               this.changeHealth = function(e, t) {
               if (e > 0 && this.health >= this.maxHealth)
                   return !1;
               e < 0 && this.skin && (e *= this.skin.dmgMult || 1),
                   e < 0 && this.tail && (e *= this.tail.dmgMult || 1),
                   e < 0 && (this.hitTime = Date.now()),
                   this.health += e,
                   this.health > this.maxHealth && (e -= this.health - this.maxHealth,
                                                    this.health = this.maxHealth),
                   this.health <= 0 && this.kill(t);
               for (var n = 0; n < f.length; ++n)
                   this.sentTo[f[n].id] && y.send(f[n].id, "h", this.sid, Math.round(this.health));
               return !t || !t.canSee(this) || t == this && e < 0 || y.send(t.id, "t", Math.round(this.x), Math.round(this.y), Math.round(-e), 1),
                   !0
           }
               ,
               this.kill = function(e) {
               e && e.alive && (e.kills++,
                                e.skin && e.skin.goldSteal ? k(e, Math.round(this.points / 2)) : k(e, Math.round(100 * this.age * (e.skin && e.skin.kScrM ? e.skin.kScrM : 1))),
                                y.send(e.id, "9", "kills", e.kills, 1)),
                   this.alive = !1,
                   y.send(this.id, "11"),
                   v()
           }
               ,
               this.addResource = function(e, t, i) {
               !i && t > 0 && this.addWeaponXP(t),
                   3 == e ? k(this, t, !0) : (this[n.resourceTypes[e]] += t,
                                              y.send(this.id, "9", n.resourceTypes[e], this[n.resourceTypes[e]], 1))
           }
               ,
               this.changeItemCount = function(e, t) {
               this.itemCounts[e] = this.itemCounts[e] || 0,
                   this.itemCounts[e] += t,
                   y.send(this.id, "14", e, this.itemCounts[e])
           }
               ,
               this.buildItem = function(e) {
               var t = this.scale + e.scale + (e.placeOffset || 0)
               , n = this.x + t * s(this.dir)
               , i = this.y + t * a(this.dir);
               if (this.canBuild(e) && !(e.consume && this.skin && this.skin.noEat) && (e.consume || u.checkItemLocation(n, i, e.scale, .6, e.id, !1, this))) {
                   var r = !1;
                   if (e.consume) {
                       if (this.hitTime) {
                           var o = Date.now() - this.hitTime;
                           this.hitTime = 0,
                               o <= 120 ? (this.shameCount++,
                                           this.shameCount >= 8 && (this.shameTimer = 3e4,
                                                                    this.shameCount = 0)) : (this.shameCount -= 2,
                                                                                             this.shameCount <= 0 && (this.shameCount = 0))
                       }
                       this.shameTimer <= 0 && (r = e.consume(this))
                   } else
                       r = !0,
                           e.group.limit && this.changeItemCount(e.group.id, 1),
                           e.pps && (this.pps += e.pps),
                           u.add(u.objects.length, n, i, this.dir, e.scale, e.type, e, !1, this);
                   r && (this.useRes(e),
                         this.buildIndex = -1)
               }
           }
               ,
               this.hasRes = function(e, t) {
               for (var n = 0; n < e.req.length; ) {
                   if (this[e.req[n]] < Math.round(e.req[n + 1] * (t || 1)))
                       return !1;
                   n += 2
               }
               return !0
           }
               ,
               this.useRes = function(e, t) {
               if (!n.inSandbox)
                   for (var i = 0; i < e.req.length; )
                       this.addResource(n.resourceTypes.indexOf(e.req[i]), -Math.round(e.req[i + 1] * (t || 1))),
                           i += 2
           }
               ,
               this.canBuild = function(e) {
               return !!n.inSandbox || !(e.group.limit && this.itemCounts[e.group.id] >= e.group.limit) && this.hasRes(e)
           }
               ,
               this.gather = function() {
               this.noMovTimer = 0,
                   this.slowMult -= p.weapons[this.weaponIndex].hitSlow || .3,
                   this.slowMult < 0 && (this.slowMult = 0);
               for (var e, t, i, r = n.fetchVariant(this), o = r.poison, c = r.val, h = {}, g = u.getGridArrays(this.x, this.y, p.weapons[this.weaponIndex].range), m = 0; m < g.length; ++m)
                   for (var y = 0; y < g[m].length; ++y)
                       if ((t = g[m][y]).active && !t.dontGather && !h[t.sid] && t.visibleToPlayer(this) && l.getDistance(this.x, this.y, t.x, t.y) - t.scale <= p.weapons[this.weaponIndex].range && (e = l.getDirection(t.x, t.y, this.x, this.y),
                    l.getAngleDist(e, this.dir) <= n.gatherAngle)) {
                           if (h[t.sid] = 1,
                               t.health) {
                               if (t.changeHealth(-p.weapons[this.weaponIndex].dmg * c * (p.weapons[this.weaponIndex].sDmg || 1) * (this.skin && this.skin.bDmg ? this.skin.bDmg : 1), this)) {
                                   for (var k = 0; k < t.req.length; )
                                       this.addResource(n.resourceTypes.indexOf(t.req[k]), t.req[k + 1]),
                                           k += 2;
                                   u.disableObj(t)
                               }
                           } else {
                               this.earnXP(4 * p.weapons[this.weaponIndex].gather);
                               var v = p.weapons[this.weaponIndex].gather + (3 == t.type ? 4 : 0);
                               this.skin && this.skin.extraGold && this.addResource(3, 1),
                                   this.addResource(t.type, v)
                           }
                           i = !0,
                               u.hitObj(t, e)
                       }
               for (y = 0; y < f.length + d.length; ++y)
                   if ((t = f[y] || d[y - f.length]) != this && t.alive && (!t.team || t.team != this.team) && l.getDistance(this.x, this.y, t.x, t.y) - 1.8 * t.scale <= p.weapons[this.weaponIndex].range && (e = l.getDirection(t.x, t.y, this.x, this.y),
                l.getAngleDist(e, this.dir) <= n.gatherAngle)) {
                       var w = p.weapons[this.weaponIndex].steal;
                       w && t.addResource && (w = Math.min(t.points || 0, w),
                                              this.addResource(3, w),
                                              t.addResource(3, -w));
                       var b = c;
                       null != t.weaponIndex && p.weapons[t.weaponIndex].shield && l.getAngleDist(e + Math.PI, t.dir) <= n.shieldAngle && (b = p.weapons[t.weaponIndex].shield);
                       var x = p.weapons[this.weaponIndex].dmg * (this.skin && this.skin.dmgMultO ? this.skin.dmgMultO : 1) * (this.tail && this.tail.dmgMultO ? this.tail.dmgMultO : 1)
                       , S = .3 * (t.weightM || 1) + (p.weapons[this.weaponIndex].knock || 0);
                       t.xVel += S * s(e),
                           t.yVel += S * a(e),
                           this.skin && this.skin.healD && this.changeHealth(x * b * this.skin.healD, this),
                           this.tail && this.tail.healD && this.changeHealth(x * b * this.tail.healD, this),
                           t.skin && t.skin.dmg && 1 == b && this.changeHealth(-x * t.skin.dmg, t),
                           t.tail && t.tail.dmg && 1 == b && this.changeHealth(-x * t.tail.dmg, t),
                           !(t.dmgOverTime && this.skin && this.skin.poisonDmg) || t.skin && t.skin.poisonRes || (t.dmgOverTime.dmg = this.skin.poisonDmg,
                                                                                                                  t.dmgOverTime.time = this.skin.poisonTime || 1,
                                                                                                                  t.dmgOverTime.doer = this),
                           !t.dmgOverTime || !o || t.skin && t.skin.poisonRes || (t.dmgOverTime.dmg = 5,
                                                                                  t.dmgOverTime.time = 5,
                                                                                  t.dmgOverTime.doer = this),
                           t.skin && t.skin.dmgK && (this.xVel -= t.skin.dmgK * s(e),
                                                     this.yVel -= t.skin.dmgK * a(e)),
                           t.changeHealth(-x * b, this, this)
                   }
               this.sendAnimation(i ? 1 : 0)
           }
               ,
               this.sendAnimation = function(e) {
               for (var t = 0; t < f.length; ++t)
                   this.sentTo[f[t].id] && this.canSee(f[t]) && y.send(f[t].id, "7", this.sid, e ? 1 : 0, this.weaponIndex)
           }
           ;
           var x = 0
           , S = 0;
           this.animate = function(e) {
               this.animTime > 0 && (this.animTime -= e,
                                     this.animTime <= 0 ? (this.animTime = 0,
                                                           this.dirPlus = 0,
                                                           x = 0,
                                                           S = 0) : 0 == S ? (x += e / (this.animSpeed * n.hitReturnRatio),
                                                                              this.dirPlus = l.lerp(0, this.targetAngle, Math.min(1, x)),
                                                                              x >= 1 && (x = 1,
                                                                                         S = 1)) : (x -= e / (this.animSpeed * (1 - n.hitReturnRatio)),
                                                                                                    this.dirPlus = l.lerp(0, this.targetAngle, Math.max(0, x))))
           }
               ,
               this.startAnim = function(e, t) {
               this.animTime = this.animSpeed = p.weapons[t].speed,
                   this.targetAngle = e ? -n.hitAngle : -Math.PI,
                   x = 0,
                   S = 0
           }
               ,
               this.canSee = function(e) {
               if (!e)
                   return !1;
               if (e.skin && e.skin.invisTimer && e.noMovTimer >= e.skin.invisTimer)
                   return !1;
               var t = r(e.x - this.x) - e.scale
               , i = r(e.y - this.y) - e.scale;
               return t <= n.maxScreenWidth / 2 * 1.3 && i <= n.maxScreenHeight / 2 * 1.3
           }
       }
   }
   , function(e, t, n) {
       const i = n(50).words
       , r = n(51).array;
       e.exports = class {
           constructor(e={}) {
               Object.assign(this, {
                   list: e.emptyList && [] || Array.prototype.concat.apply(i, [r, e.list || []]),
                   exclude: e.exclude || [],
                   placeHolder: e.placeHolder || "*",
                   regex: e.regex || /[^a-zA-Z0-9|\$|\@]|\^/g,
                   replaceRegex: e.replaceRegex || /\w/g
               })
           }
           isProfane(e) {
               return this.list.filter(t=>{
                   const n = new RegExp(`\\b${t.replace(/(\W)/g, "\\$1")}\\b`,"gi");
                   return !this.exclude.includes(t.toLowerCase()) && n.test(e)
               }
                                      ).length > 0 || !1
           }
           replaceWord(e) {
               return e.replace(this.regex, "").replace(this.replaceRegex, this.placeHolder)
           }
           clean(e) {
               return e.split(/\b/).map(e=>this.isProfane(e) ? this.replaceWord(e) : e).join("")
           }
           addWords() {
               let e = Array.from(arguments);
               this.list.push(...e),
                   e.map(e=>e.toLowerCase()).forEach(e=>{
                   this.exclude.includes(e) && this.exclude.splice(this.exclude.indexOf(e), 1)
               }
                                                    )
           }
           removeWords() {
               this.exclude.push(...Array.from(arguments).map(e=>e.toLowerCase()))
           }
       }
   }
   , function(e) {
       e.exports = {
           words: ["ahole", "anus", "ash0le", "ash0les", "asholes", "ass", "Ass Monkey", "Assface", "assh0le", "assh0lez", "asshole", "assholes", "assholz", "asswipe", "azzhole", "bassterds", "bastard", "bastards", "bastardz", "basterds", "basterdz", "Biatch", "bitch", "bitches", "Blow Job", "boffing", "butthole", "buttwipe", "c0ck", "c0cks", "c0k", "Carpet Muncher", "cawk", "cawks", "Clit", "cnts", "cntz", "cock", "cockhead", "cock-head", "cocks", "CockSucker", "cock-sucker", "crap", "cum", "cunt", "cunts", "cuntz", "dick", "dild0", "dild0s", "dildo", "dildos", "dilld0", "dilld0s", "dominatricks", "dominatrics", "dominatrix", "dyke", "enema", "f u c k", "f u c k e r", "fag", "fag1t", "faget", "fagg1t", "faggit", "faggot", "fagg0t", "fagit", "fags", "fagz", "faig", "faigs", "fart", "flipping the bird", "fuck", "fucker", "fuckin", "fucking", "fucks", "Fudge Packer", "fuk", "Fukah", "Fuken", "fuker", "Fukin", "Fukk", "Fukkah", "Fukken", "Fukker", "Fukkin", "g00k", "God-damned", "h00r", "h0ar", "h0re", "hells", "hoar", "hoor", "hoore", "jackoff", "jap", "japs", "jerk-off", "jisim", "jiss", "jizm", "jizz", "knob", "knobs", "knobz", "kunt", "kunts", "kuntz", "Lezzian", "Lipshits", "Lipshitz", "masochist", "masokist", "massterbait", "masstrbait", "masstrbate", "masterbaiter", "masterbate", "masterbates", "Motha Fucker", "Motha Fuker", "Motha Fukkah", "Motha Fukker", "Mother Fucker", "Mother Fukah", "Mother Fuker", "Mother Fukkah", "Mother Fukker", "mother-fucker", "Mutha Fucker", "Mutha Fukah", "Mutha Fuker", "Mutha Fukkah", "Mutha Fukker", "n1gr", "nastt", "nigger;", "nigur;", "niiger;", "niigr;", "orafis", "orgasim;", "orgasm", "orgasum", "oriface", "orifice", "orifiss", "packi", "packie", "packy", "paki", "pakie", "paky", "pecker", "peeenus", "peeenusss", "peenus", "peinus", "pen1s", "penas", "penis", "penis-breath", "penus", "penuus", "Phuc", "Phuck", "Phuk", "Phuker", "Phukker", "polac", "polack", "polak", "Poonani", "pr1c", "pr1ck", "pr1k", "pusse", "pussee", "pussy", "puuke", "puuker", "queer", "queers", "queerz", "qweers", "qweerz", "qweir", "recktum", "rectum", "retard", "sadist", "scank", "schlong", "screwing", "semen", "sex", "sexy", "Sh!t", "sh1t", "sh1ter", "sh1ts", "sh1tter", "sh1tz", "shit", "shits", "shitter", "Shitty", "Shity", "shitz", "Shyt", "Shyte", "Shytty", "Shyty", "skanck", "skank", "skankee", "skankey", "skanks", "Skanky", "slag", "slut", "sluts", "Slutty", "slutz", "son-of-a-bitch", "tit", "turd", "va1jina", "vag1na", "vagiina", "vagina", "vaj1na", "vajina", "vullva", "vulva", "w0p", "wh00r", "wh0re", "whore", "xrated", "xxx", "b!+ch", "bitch", "blowjob", "clit", "arschloch", "fuck", "shit", "ass", "asshole", "b!tch", "b17ch", "b1tch", "bastard", "bi+ch", "boiolas", "buceta", "c0ck", "cawk", "chink", "cipa", "clits", "cock", "cum", "cunt", "dildo", "dirsa", "ejakulate", "fatass", "fcuk", "fuk", "fux0r", "hoer", "hore", "jism", "kawk", "l3itch", "l3i+ch", "lesbian", "masturbate", "masterbat*", "masterbat3", "motherfucker", "s.o.b.", "mofo", "nazi", "nigga", "nigger", "nutsack", "phuck", "pimpis", "pusse", "pussy", "scrotum", "sh!t", "shemale", "shi+", "sh!+", "slut", "smut", "teets", "tits", "boobs", "b00bs", "teez", "testical", "testicle", "titt", "w00se", "jackoff", "wank", "whoar", "whore", "*damn", "*dyke", "*fuck*", "*shit*", "@$$", "amcik", "andskota", "arse*", "assrammer", "ayir", "bi7ch", "bitch*", "bollock*", "breasts", "butt-pirate", "cabron", "cazzo", "chraa", "chuj", "Cock*", "cunt*", "d4mn", "daygo", "dego", "dick*", "dike*", "dupa", "dziwka", "ejackulate", "Ekrem*", "Ekto", "enculer", "faen", "fag*", "fanculo", "fanny", "feces", "feg", "Felcher", "ficken", "fitt*", "Flikker", "foreskin", "Fotze", "Fu(*", "fuk*", "futkretzn", "gook", "guiena", "h0r", "h4x0r", "hell", "helvete", "hoer*", "honkey", "Huevon", "hui", "injun", "jizz", "kanker*", "kike", "klootzak", "kraut", "knulle", "kuk", "kuksuger", "Kurac", "kurwa", "kusi*", "kyrpa*", "lesbo", "mamhoon", "masturbat*", "merd*", "mibun", "monkleigh", "mouliewop", "muie", "mulkku", "muschi", "nazis", "nepesaurio", "nigger*", "orospu", "paska*", "perse", "picka", "pierdol*", "pillu*", "pimmel", "piss*", "pizda", "poontsee", "poop", "porn", "p0rn", "pr0n", "preteen", "pula", "pule", "puta", "puto", "qahbeh", "queef*", "rautenberg", "schaffer", "scheiss*", "schlampe", "schmuck", "screw", "sh!t*", "sharmuta", "sharmute", "shipal", "shiz", "skribz", "skurwysyn", "sphencter", "spic", "spierdalaj", "splooge", "suka", "b00b*", "testicle*", "titt*", "twat", "vittu", "wank*", "wetback*", "wichser", "wop*", "yed", "zabourah"]
       }
   }
   , function(e, t, n) {
       e.exports = {
           object: n(52),
           array: n(53),
           regex: n(54)
       }
   }
   , function(e, t) {
       e.exports = {
           "4r5e": 1,
           "5h1t": 1,
           "5hit": 1,
           a55: 1,
           anal: 1,
           anus: 1,
           ar5e: 1,
           arrse: 1,
           arse: 1,
           ass: 1,
           "ass-fucker": 1,
           asses: 1,
           assfucker: 1,
           assfukka: 1,
           asshole: 1,
           assholes: 1,
           asswhole: 1,
           a_s_s: 1,
           "b!tch": 1,
           b00bs: 1,
           b17ch: 1,
           b1tch: 1,
           ballbag: 1,
           balls: 1,
           ballsack: 1,
           bastard: 1,
           beastial: 1,
           beastiality: 1,
           bellend: 1,
           bestial: 1,
           bestiality: 1,
           "bi+ch": 1,
           biatch: 1,
           bitch: 1,
           bitcher: 1,
           bitchers: 1,
           bitches: 1,
           bitchin: 1,
           bitching: 1,
           bloody: 1,
           "blow job": 1,
           blowjob: 1,
           blowjobs: 1,
           boiolas: 1,
           bollock: 1,
           bollok: 1,
           boner: 1,
           boob: 1,
           boobs: 1,
           booobs: 1,
           boooobs: 1,
           booooobs: 1,
           booooooobs: 1,
           breasts: 1,
           buceta: 1,
           bugger: 1,
           bum: 1,
           "bunny fucker": 1,
           butt: 1,
           butthole: 1,
           buttmuch: 1,
           buttplug: 1,
           c0ck: 1,
           c0cksucker: 1,
           "carpet muncher": 1,
           cawk: 1,
           chink: 1,
           cipa: 1,
           cl1t: 1,
           clit: 1,
           clitoris: 1,
           clits: 1,
           cnut: 1,
           cock: 1,
           "cock-sucker": 1,
           cockface: 1,
           cockhead: 1,
           cockmunch: 1,
           cockmuncher: 1,
           cocks: 1,
           cocksuck: 1,
           cocksucked: 1,
           cocksucker: 1,
           cocksucking: 1,
           cocksucks: 1,
           cocksuka: 1,
           cocksukka: 1,
           cok: 1,
           cokmuncher: 1,
           coksucka: 1,
           coon: 1,
           cox: 1,
           crap: 1,
           cum: 1,
           cummer: 1,
           cumming: 1,
           cums: 1,
           cumshot: 1,
           cunilingus: 1,
           cunillingus: 1,
           cunnilingus: 1,
           cunt: 1,
           cuntlick: 1,
           cuntlicker: 1,
           cuntlicking: 1,
           cunts: 1,
           cyalis: 1,
           cyberfuc: 1,
           cyberfuck: 1,
           cyberfucked: 1,
           cyberfucker: 1,
           cyberfuckers: 1,
           cyberfucking: 1,
           d1ck: 1,
           damn: 1,
           dick: 1,
           dickhead: 1,
           dildo: 1,
           dildos: 1,
           dink: 1,
           dinks: 1,
           dirsa: 1,
           dlck: 1,
           "dog-fucker": 1,
           doggin: 1,
           dogging: 1,
           donkeyribber: 1,
           doosh: 1,
           duche: 1,
           dyke: 1,
           ejaculate: 1,
           ejaculated: 1,
           ejaculates: 1,
           ejaculating: 1,
           ejaculatings: 1,
           ejaculation: 1,
           ejakulate: 1,
           "f u c k": 1,
           "f u c k e r": 1,
           f4nny: 1,
           fag: 1,
           fagging: 1,
           faggitt: 1,
           faggot: 1,
           faggs: 1,
           fagot: 1,
           fagots: 1,
           fags: 1,
           fanny: 1,
           fannyflaps: 1,
           fannyfucker: 1,
           fanyy: 1,
           fatass: 1,
           fcuk: 1,
           fcuker: 1,
           fcuking: 1,
           feck: 1,
           fecker: 1,
           felching: 1,
           fellate: 1,
           fellatio: 1,
           fingerfuck: 1,
           fingerfucked: 1,
           fingerfucker: 1,
           fingerfuckers: 1,
           fingerfucking: 1,
           fingerfucks: 1,
           fistfuck: 1,
           fistfucked: 1,
           fistfucker: 1,
           fistfuckers: 1,
           fistfucking: 1,
           fistfuckings: 1,
           fistfucks: 1,
           flange: 1,
           fook: 1,
           fooker: 1,
           fuck: 1,
           fucka: 1,
           fucked: 1,
           fucker: 1,
           fuckers: 1,
           fuckhead: 1,
           fuckheads: 1,
           fuckin: 1,
           fucking: 1,
           fuckings: 1,
           fuckingshitmotherfucker: 1,
           fuckme: 1,
           fucks: 1,
           fuckwhit: 1,
           fuckwit: 1,
           "fudge packer": 1,
           fudgepacker: 1,
           fuk: 1,
           fuker: 1,
           fukker: 1,
           fukkin: 1,
           fuks: 1,
           fukwhit: 1,
           fukwit: 1,
           fux: 1,
           fux0r: 1,
           f_u_c_k: 1,
           gangbang: 1,
           gangbanged: 1,
           gangbangs: 1,
           gaylord: 1,
           gaysex: 1,
           goatse: 1,
           God: 1,
           "god-dam": 1,
           "god-damned": 1,
           goddamn: 1,
           goddamned: 1,
           hardcoresex: 1,
           hell: 1,
           heshe: 1,
           hoar: 1,
           hoare: 1,
           hoer: 1,
           homo: 1,
           hore: 1,
           horniest: 1,
           horny: 1,
           hotsex: 1,
           "jack-off": 1,
           jackoff: 1,
           jap: 1,
           "jerk-off": 1,
           jism: 1,
           jiz: 1,
           jizm: 1,
           jizz: 1,
           kawk: 1,
           knob: 1,
           knobead: 1,
           knobed: 1,
           knobend: 1,
           knobhead: 1,
           knobjocky: 1,
           knobjokey: 1,
           kock: 1,
           kondum: 1,
           kondums: 1,
           kum: 1,
           kummer: 1,
           kumming: 1,
           kums: 1,
           kunilingus: 1,
           "l3i+ch": 1,
           l3itch: 1,
           labia: 1,
           lust: 1,
           lusting: 1,
           m0f0: 1,
           m0fo: 1,
           m45terbate: 1,
           ma5terb8: 1,
           ma5terbate: 1,
           masochist: 1,
           "master-bate": 1,
           masterb8: 1,
           "masterbat*": 1,
           masterbat3: 1,
           masterbate: 1,
           masterbation: 1,
           masterbations: 1,
           masturbate: 1,
           "mo-fo": 1,
           mof0: 1,
           mofo: 1,
           mothafuck: 1,
           mothafucka: 1,
           mothafuckas: 1,
           mothafuckaz: 1,
           mothafucked: 1,
           mothafucker: 1,
           mothafuckers: 1,
           mothafuckin: 1,
           mothafucking: 1,
           mothafuckings: 1,
           mothafucks: 1,
           "mother fucker": 1,
           motherfuck: 1,
           motherfucked: 1,
           motherfucker: 1,
           motherfuckers: 1,
           motherfuckin: 1,
           motherfucking: 1,
           motherfuckings: 1,
           motherfuckka: 1,
           motherfucks: 1,
           muff: 1,
           mutha: 1,
           muthafecker: 1,
           muthafuckker: 1,
           muther: 1,
           mutherfucker: 1,
           n1gga: 1,
           n1gger: 1,
           nazi: 1,
           nigg3r: 1,
           nigg4h: 1,
           nigga: 1,
           niggah: 1,
           niggas: 1,
           niggaz: 1,
           nigger: 1,
           niggers: 1,
           nob: 1,
           "nob jokey": 1,
           nobhead: 1,
           nobjocky: 1,
           nobjokey: 1,
           numbnuts: 1,
           nutsack: 1,
           orgasim: 1,
           orgasims: 1,
           orgasm: 1,
           orgasms: 1,
           p0rn: 1,
           pawn: 1,
           pecker: 1,
           penis: 1,
           penisfucker: 1,
           phonesex: 1,
           phuck: 1,
           phuk: 1,
           phuked: 1,
           phuking: 1,
           phukked: 1,
           phukking: 1,
           phuks: 1,
           phuq: 1,
           pigfucker: 1,
           pimpis: 1,
           piss: 1,
           pissed: 1,
           pisser: 1,
           pissers: 1,
           pisses: 1,
           pissflaps: 1,
           pissin: 1,
           pissing: 1,
           pissoff: 1,
           poop: 1,
           porn: 1,
           porno: 1,
           pornography: 1,
           pornos: 1,
           prick: 1,
           pricks: 1,
           pron: 1,
           pube: 1,
           pusse: 1,
           pussi: 1,
           pussies: 1,
           pussy: 1,
           pussys: 1,
           rectum: 1,
           retard: 1,
           rimjaw: 1,
           rimming: 1,
           "s hit": 1,
           "s.o.b.": 1,
           sadist: 1,
           schlong: 1,
           screwing: 1,
           scroat: 1,
           scrote: 1,
           scrotum: 1,
           semen: 1,
           sex: 1,
           "sh!+": 1,
           "sh!t": 1,
           sh1t: 1,
           shag: 1,
           shagger: 1,
           shaggin: 1,
           shagging: 1,
           shemale: 1,
           "shi+": 1,
           shit: 1,
           shitdick: 1,
           shite: 1,
           shited: 1,
           shitey: 1,
           shitfuck: 1,
           shitfull: 1,
           shithead: 1,
           shiting: 1,
           shitings: 1,
           shits: 1,
           shitted: 1,
           shitter: 1,
           shitters: 1,
           shitting: 1,
           shittings: 1,
           shitty: 1,
           skank: 1,
           slut: 1,
           sluts: 1,
           smegma: 1,
           smut: 1,
           snatch: 1,
           "son-of-a-bitch": 1,
           spac: 1,
           spunk: 1,
           s_h_i_t: 1,
           t1tt1e5: 1,
           t1tties: 1,
           teets: 1,
           teez: 1,
           testical: 1,
           testicle: 1,
           tit: 1,
           titfuck: 1,
           tits: 1,
           titt: 1,
           tittie5: 1,
           tittiefucker: 1,
           titties: 1,
           tittyfuck: 1,
           tittywank: 1,
           titwank: 1,
           tosser: 1,
           turd: 1,
           tw4t: 1,
           twat: 1,
           twathead: 1,
           twatty: 1,
           twunt: 1,
           twunter: 1,
           v14gra: 1,
           v1gra: 1,
           vagina: 1,
           viagra: 1,
           vulva: 1,
           w00se: 1,
           wang: 1,
           wank: 1,
           wanker: 1,
           wanky: 1,
           whoar: 1,
           whore: 1,
           willies: 1,
           willy: 1,
           xrated: 1,
           xxx: 1
       }
   }
   , function(e, t) {
       e.exports = ["4r5e", "5h1t", "5hit", "a55", "anal", "anus", "ar5e", "arrse", "arse", "ass", "ass-fucker", "asses", "assfucker", "assfukka", "asshole", "assholes", "asswhole", "a_s_s", "b!tch", "b00bs", "b17ch", "b1tch", "ballbag", "balls", "ballsack", "bastard", "beastial", "beastiality", "bellend", "bestial", "bestiality", "bi+ch", "biatch", "bitch", "bitcher", "bitchers", "bitches", "bitchin", "bitching", "bloody", "blow job", "blowjob", "blowjobs", "boiolas", "bollock", "bollok", "boner", "boob", "boobs", "booobs", "boooobs", "booooobs", "booooooobs", "breasts", "buceta", "bugger", "bum", "bunny fucker", "butt", "butthole", "buttmuch", "buttplug", "c0ck", "c0cksucker", "carpet muncher", "cawk", "chink", "cipa", "cl1t", "clit", "clitoris", "clits", "cnut", "cock", "cock-sucker", "cockface", "cockhead", "cockmunch", "cockmuncher", "cocks", "cocksuck", "cocksucked", "cocksucker", "cocksucking", "cocksucks", "cocksuka", "cocksukka", "cok", "cokmuncher", "coksucka", "coon", "cox", "crap", "cum", "cummer", "cumming", "cums", "cumshot", "cunilingus", "cunillingus", "cunnilingus", "cunt", "cuntlick", "cuntlicker", "cuntlicking", "cunts", "cyalis", "cyberfuc", "cyberfuck", "cyberfucked", "cyberfucker", "cyberfuckers", "cyberfucking", "d1ck", "damn", "dick", "dickhead", "dildo", "dildos", "dink", "dinks", "dirsa", "dlck", "dog-fucker", "doggin", "dogging", "donkeyribber", "doosh", "duche", "dyke", "ejaculate", "ejaculated", "ejaculates", "ejaculating", "ejaculatings", "ejaculation", "ejakulate", "f u c k", "f u c k e r", "f4nny", "fag", "fagging", "faggitt", "faggot", "faggs", "fagot", "fagots", "fags", "fanny", "fannyflaps", "fannyfucker", "fanyy", "fatass", "fcuk", "fcuker", "fcuking", "feck", "fecker", "felching", "fellate", "fellatio", "fingerfuck", "fingerfucked", "fingerfucker", "fingerfuckers", "fingerfucking", "fingerfucks", "fistfuck", "fistfucked", "fistfucker", "fistfuckers", "fistfucking", "fistfuckings", "fistfucks", "flange", "fook", "fooker", "fuck", "fucka", "fucked", "fucker", "fuckers", "fuckhead", "fuckheads", "fuckin", "fucking", "fuckings", "fuckingshitmotherfucker", "fuckme", "fucks", "fuckwhit", "fuckwit", "fudge packer", "fudgepacker", "fuk", "fuker", "fukker", "fukkin", "fuks", "fukwhit", "fukwit", "fux", "fux0r", "f_u_c_k", "gangbang", "gangbanged", "gangbangs", "gaylord", "gaysex", "goatse", "God", "god-dam", "god-damned", "goddamn", "goddamned", "hardcoresex", "hell", "heshe", "hoar", "hoare", "hoer", "homo", "hore", "horniest", "horny", "hotsex", "jack-off", "jackoff", "jap", "jerk-off", "jism", "jiz", "jizm", "jizz", "kawk", "knob", "knobead", "knobed", "knobend", "knobhead", "knobjocky", "knobjokey", "kock", "kondum", "kondums", "kum", "kummer", "kumming", "kums", "kunilingus", "l3i+ch", "l3itch", "labia", "lust", "lusting", "m0f0", "m0fo", "m45terbate", "ma5terb8", "ma5terbate", "masochist", "master-bate", "masterb8", "masterbat*", "masterbat3", "masterbate", "masterbation", "masterbations", "masturbate", "mo-fo", "mof0", "mofo", "mothafuck", "mothafucka", "mothafuckas", "mothafuckaz", "mothafucked", "mothafucker", "mothafuckers", "mothafuckin", "mothafucking", "mothafuckings", "mothafucks", "mother fucker", "motherfuck", "motherfucked", "motherfucker", "motherfuckers", "motherfuckin", "motherfucking", "motherfuckings", "motherfuckka", "motherfucks", "muff", "mutha", "muthafecker", "muthafuckker", "muther", "mutherfucker", "n1gga", "n1gger", "nazi", "nigg3r", "nigg4h", "nigga", "niggah", "niggas", "niggaz", "nigger", "niggers", "nob", "nob jokey", "nobhead", "nobjocky", "nobjokey", "numbnuts", "nutsack", "orgasim", "orgasims", "orgasm", "orgasms", "p0rn", "pawn", "pecker", "penis", "penisfucker", "phonesex", "phuck", "phuk", "phuked", "phuking", "phukked", "phukking", "phuks", "phuq", "pigfucker", "pimpis", "piss", "pissed", "pisser", "pissers", "pisses", "pissflaps", "pissin", "pissing", "pissoff", "poop", "porn", "porno", "pornography", "pornos", "prick", "pricks", "pron", "pube", "pusse", "pussi", "pussies", "pussy", "pussys", "rectum", "retard", "rimjaw", "rimming", "s hit", "s.o.b.", "sadist", "schlong", "screwing", "scroat", "scrote", "scrotum", "semen", "sex", "sh!+", "sh!t", "sh1t", "shag", "shagger", "shaggin", "shagging", "shemale", "shi+", "shit", "shitdick", "shite", "shited", "shitey", "shitfuck", "shitfull", "shithead", "shiting", "shitings", "shits", "shitted", "shitter", "shitters", "shitting", "shittings", "shitty", "skank", "slut", "sluts", "smegma", "smut", "snatch", "son-of-a-bitch", "spac", "spunk", "s_h_i_t", "t1tt1e5", "t1tties", "teets", "teez", "testical", "testicle", "tit", "titfuck", "tits", "titt", "tittie5", "tittiefucker", "titties", "tittyfuck", "tittywank", "titwank", "tosser", "turd", "tw4t", "twat", "twathead", "twatty", "twunt", "twunter", "v14gra", "v1gra", "vagina", "viagra", "vulva", "w00se", "wang", "wank", "wanker", "wanky", "whoar", "whore", "willies", "willy", "xrated", "xxx"]
   }
   , function(e, t) {
       e.exports = /\b(4r5e|5h1t|5hit|a55|anal|anus|ar5e|arrse|arse|ass|ass-fucker|asses|assfucker|assfukka|asshole|assholes|asswhole|a_s_s|b!tch|b00bs|b17ch|b1tch|ballbag|balls|ballsack|bastard|beastial|beastiality|bellend|bestial|bestiality|bi\+ch|biatch|bitch|bitcher|bitchers|bitches|bitchin|bitching|bloody|blow job|blowjob|blowjobs|boiolas|bollock|bollok|boner|boob|boobs|booobs|boooobs|booooobs|booooooobs|breasts|buceta|bugger|bum|bunny fucker|butt|butthole|buttmuch|buttplug|c0ck|c0cksucker|carpet muncher|cawk|chink|cipa|cl1t|clit|clitoris|clits|cnut|cock|cock-sucker|cockface|cockhead|cockmunch|cockmuncher|cocks|cocksuck|cocksucked|cocksucker|cocksucking|cocksucks|cocksuka|cocksukka|cok|cokmuncher|coksucka|coon|cox|crap|cum|cummer|cumming|cums|cumshot|cunilingus|cunillingus|cunnilingus|cunt|cuntlick|cuntlicker|cuntlicking|cunts|cyalis|cyberfuc|cyberfuck|cyberfucked|cyberfucker|cyberfuckers|cyberfucking|d1ck|damn|dick|dickhead|dildo|dildos|dink|dinks|dirsa|dlck|dog-fucker|doggin|dogging|donkeyribber|doosh|duche|dyke|ejaculate|ejaculated|ejaculates|ejaculating|ejaculatings|ejaculation|ejakulate|f u c k|f u c k e r|f4nny|fag|fagging|faggitt|faggot|faggs|fagot|fagots|fags|fanny|fannyflaps|fannyfucker|fanyy|fatass|fcuk|fcuker|fcuking|feck|fecker|felching|fellate|fellatio|fingerfuck|fingerfucked|fingerfucker|fingerfuckers|fingerfucking|fingerfucks|fistfuck|fistfucked|fistfucker|fistfuckers|fistfucking|fistfuckings|fistfucks|flange|fook|fooker|fuck|fucka|fucked|fucker|fuckers|fuckhead|fuckheads|fuckin|fucking|fuckings|fuckingshitmotherfucker|fuckme|fucks|fuckwhit|fuckwit|fudge packer|fudgepacker|fuk|fuker|fukker|fukkin|fuks|fukwhit|fukwit|fux|fux0r|f_u_c_k|gangbang|gangbanged|gangbangs|gaylord|gaysex|goatse|God|god-dam|god-damned|goddamn|goddamned|hardcoresex|hell|heshe|hoar|hoare|hoer|homo|hore|horniest|horny|hotsex|jack-off|jackoff|jap|jerk-off|jism|jiz|jizm|jizz|kawk|knob|knobead|knobed|knobend|knobhead|knobjocky|knobjokey|kock|kondum|kondums|kum|kummer|kumming|kums|kunilingus|l3i\+ch|l3itch|labia|lust|lusting|m0f0|m0fo|m45terbate|ma5terb8|ma5terbate|masochist|master-bate|masterb8|masterbat*|masterbat3|masterbate|masterbation|masterbations|masturbate|mo-fo|mof0|mofo|mothafuck|mothafucka|mothafuckas|mothafuckaz|mothafucked|mothafucker|mothafuckers|mothafuckin|mothafucking|mothafuckings|mothafucks|mother fucker|motherfuck|motherfucked|motherfucker|motherfuckers|motherfuckin|motherfucking|motherfuckings|motherfuckka|motherfucks|muff|mutha|muthafecker|muthafuckker|muther|mutherfucker|n1gga|n1gger|nazi|nigg3r|nigg4h|nigga|niggah|niggas|niggaz|nigger|niggers|nob|nob jokey|nobhead|nobjocky|nobjokey|numbnuts|nutsack|orgasim|orgasims|orgasm|orgasms|p0rn|pawn|pecker|penis|penisfucker|phonesex|phuck|phuk|phuked|phuking|phukked|phukking|phuks|phuq|pigfucker|pimpis|piss|pissed|pisser|pissers|pisses|pissflaps|pissin|pissing|pissoff|poop|porn|porno|pornography|pornos|prick|pricks|pron|pube|pusse|pussi|pussies|pussy|pussys|rectum|retard|rimjaw|rimming|s hit|s.o.b.|sadist|schlong|screwing|scroat|scrote|scrotum|semen|sex|sh!\+|sh!t|sh1t|shag|shagger|shaggin|shagging|shemale|shi\+|shit|shitdick|shite|shited|shitey|shitfuck|shitfull|shithead|shiting|shitings|shits|shitted|shitter|shitters|shitting|shittings|shitty|skank|slut|sluts|smegma|smut|snatch|son-of-a-bitch|spac|spunk|s_h_i_t|t1tt1e5|t1tties|teets|teez|testical|testicle|tit|titfuck|tits|titt|tittie5|tittiefucker|titties|tittyfuck|tittywank|titwank|tosser|turd|tw4t|twat|twathead|twatty|twunt|twunter|v14gra|v1gra|vagina|viagra|vulva|w00se|wang|wank|wanker|wanky|whoar|whore|willies|willy|xrated|xxx)\b/gi
   }
   , function(e, t) {
       e.exports.hats = [{
           id: 45,
           name: "Shame!",
           dontSell: !0,
           price: 0,
           scale: 120,
           desc: "hacks are for losers"
       }, {
           id: 51,
           name: "Moo Cap",
           price: 0,
           scale: 120,
           desc: "coolest mooer around"
       }, {
           id: 50,
           name: "Apple Cap",
           price: 0,
           scale: 120,
           desc: "apple farms remembers"
       }, {
           id: 28,
           name: "Moo Head",
           price: 0,
           scale: 120,
           desc: "no effect"
       }, {
           id: 29,
           name: "Pig Head",
           price: 0,
           scale: 120,
           desc: "no effect"
       }, {
           id: 30,
           name: "Fluff Head",
           price: 0,
           scale: 120,
           desc: "no effect"
       }, {
           id: 36,
           name: "Pandou Head",
           price: 0,
           scale: 120,
           desc: "no effect"
       }, {
           id: 37,
           name: "Bear Head",
           price: 0,
           scale: 120,
           desc: "no effect"
       }, {
           id: 38,
           name: "Monkey Head",
           price: 0,
           scale: 120,
           desc: "no effect"
       }, {
           id: 44,
           name: "Polar Head",
           price: 0,
           scale: 120,
           desc: "no effect"
       }, {
           id: 35,
           name: "Fez Hat",
           price: 0,
           scale: 120,
           desc: "no effect"
       }, {
           id: 42,
           name: "Enigma Hat",
           price: 0,
           scale: 120,
           desc: "join the enigma army"
       }, {
           id: 43,
           name: "Blitz Hat",
           price: 0,
           scale: 120,
           desc: "hey everybody i'm blitz"
       }, {
           id: 49,
           name: "Bob XIII Hat",
           price: 0,
           scale: 120,
           desc: "like and subscribe"
       }, {
           id: 57,
           name: "Pumpkin",
           price: 50,
           scale: 120,
           desc: "Spooooky"
       }, {
           id: 8,
           name: "Bummle Hat",
           price: 100,
           scale: 120,
           desc: "no effect"
       }, {
           id: 2,
           name: "Straw Hat",
           price: 500,
           scale: 120,
           desc: "no effect"
       }, {
           id: 15,
           name: "Winter Cap",
           price: 600,
           scale: 120,
           desc: "allows you to move at normal speed in snow",
           coldM: 1
       }, {
           id: 5,
           name: "Cowboy Hat",
           price: 1e3,
           scale: 120,
           desc: "no effect"
       }, {
           id: 4,
           name: "Ranger Hat",
           price: 2e3,
           scale: 120,
           desc: "no effect"
       }, {
           id: 18,
           name: "Explorer Hat",
           price: 2e3,
           scale: 120,
           desc: "no effect"
       }, {
           id: 31,
           name: "Flipper Hat",
           price: 2500,
           scale: 120,
           desc: "have more control while in water",
           watrImm: !0
       }, {
           id: 1,
           name: "Marksman Cap",
           price: 3e3,
           scale: 120,
           desc: "increases arrow speed and range",
           aMlt: 1.3
       }, {
           id: 10,
           name: "Bush Gear",
           price: 3e3,
           scale: 160,
           desc: "allows you to disguise yourself as a bush"
       }, {
           id: 48,
           name: "Halo",
           price: 3e3,
           scale: 120,
           desc: "no effect"
       }, {
           id: 6,
           name: "Soldier Helmet",
           price: 4e3,
           scale: 120,
           desc: "reduces damage taken but slows movement",
           spdMult: .94,
           dmgMult: .75
       }, {
           id: 23,
           name: "Anti Venom Gear",
           price: 4e3,
           scale: 120,
           desc: "makes you immune to poison",
           poisonRes: 1
       }, {
           id: 13,
           name: "Medic Gear",
           price: 5e3,
           scale: 110,
           desc: "slowly regenerates health over time",
           healthRegen: 3
       }, {
           id: 9,
           name: "Miners Helmet",
           price: 5e3,
           scale: 120,
           desc: "earn 1 extra gold per resource",
           extraGold: 1
       }, {
           id: 32,
           name: "Musketeer Hat",
           price: 5e3,
           scale: 120,
           desc: "reduces cost of projectiles",
           projCost: .5
       }, {
           id: 7,
           name: "Bull Helmet",
           price: 6e3,
           scale: 120,
           desc: "increases damage done but drains health",
           healthRegen: -5,
           dmgMultO: 1.5,
           spdMult: .96
       }, {
           id: 22,
           name: "Emp Helmet",
           price: 6e3,
           scale: 120,
           desc: "turrets won't attack but you move slower",
           antiTurret: 1,
           spdMult: .7
       }, {
           id: 12,
           name: "Booster Hat",
           price: 6e3,
           scale: 120,
           desc: "increases your movement speed",
           spdMult: 1.16
       }, {
           id: 26,
           name: "Barbarian Armor",
           price: 8e3,
           scale: 120,
           desc: "knocks back enemies that attack you",
           dmgK: .6
       }, {
           id: 21,
           name: "Plague Mask",
           price: 1e4,
           scale: 120,
           desc: "melee attacks deal poison damage",
           poisonDmg: 5,
           poisonTime: 6
       }, {
           id: 46,
           name: "Bull Mask",
           price: 1e4,
           scale: 120,
           desc: "bulls won't target you unless you attack them",
           bullRepel: 1
       }, {
           id: 14,
           name: "Windmill Hat",
           topSprite: !0,
           price: 1e4,
           scale: 120,
           desc: "generates points while worn",
           pps: 1.5
       }, {
           id: 11,
           name: "Spike Gear",
           topSprite: !0,
           price: 1e4,
           scale: 120,
           desc: "deal damage to players that damage you",
           dmg: .45
       }, {
           id: 53,
           name: "Turret Gear",
           topSprite: !0,
           price: 1e4,
           scale: 120,
           desc: "you become a walking turret",
           turret: {
               proj: 1,
               range: 700,
               rate: 2500
           },
           spdMult: .7
       }, {
           id: 20,
           name: "Samurai Armor",
           price: 12e3,
           scale: 120,
           desc: "increased attack speed and fire rate",
           atkSpd: .78
       }, {
           id: 58,
           name: "Dark Knight",
           price: 12e3,
           scale: 120,
           desc: "restores health when you deal damage",
           healD: .4
       }, {
           id: 27,
           name: "Scavenger Gear",
           price: 15e3,
           scale: 120,
           desc: "earn double points for each kill",
           kScrM: 2
       }, {
           id: 40,
           name: "Tank Gear",
           price: 15e3,
           scale: 120,
           desc: "increased damage to buildings but slower movement",
           spdMult: .3,
           bDmg: 3.3
       }, {
           id: 52,
           name: "Thief Gear",
           price: 15e3,
           scale: 120,
           desc: "steal half of a players gold when you kill them",
           goldSteal: .5
       }, {
           id: 55,
           name: "Bloodthirster",
           price: 2e4,
           scale: 120,
           desc: "Restore Health when dealing damage. And increased damage",
           healD: .25,
           dmgMultO: 1.2
       }, {
           id: 56,
           name: "Assassin Gear",
           price: 2e4,
           scale: 120,
           desc: "Go invisible when not moving. Can't eat. Increased speed",
           noEat: !0,
           spdMult: 1.1,
           invisTimer: 1e3
       }],
           e.exports.accessories = [{
               id: 12,
               name: "Snowball",
               price: 1e3,
               scale: 105,
               xOff: 18,
               desc: "no effect"
           }, {
               id: 9,
               name: "Tree Cape",
               price: 1e3,
               scale: 90,
               desc: "no effect"
           }, {
               id: 10,
               name: "Stone Cape",
               price: 1e3,
               scale: 90,
               desc: "no effect"
           }, {
               id: 3,
               name: "Cookie Cape",
               price: 1500,
               scale: 90,
               desc: "no effect"
           }, {
               id: 8,
               name: "Cow Cape",
               price: 2e3,
               scale: 90,
               desc: "no effect"
           }, {
               id: 11,
               name: "Monkey Tail",
               price: 2e3,
               scale: 97,
               xOff: 25,
               desc: "Super speed but reduced damage",
               spdMult: 1.35,
               dmgMultO: .2
           }, {
               id: 17,
               name: "Apple Basket",
               price: 3e3,
               scale: 80,
               xOff: 12,
               desc: "slowly regenerates health over time",
               healthRegen: 1
           }, {
               id: 6,
               name: "Winter Cape",
               price: 3e3,
               scale: 90,
               desc: "no effect"
           }, {
               id: 4,
               name: "Skull Cape",
               price: 4e3,
               scale: 90,
               desc: "no effect"
           }, {
               id: 5,
               name: "Dash Cape",
               price: 5e3,
               scale: 90,
               desc: "no effect"
           }, {
               id: 2,
               name: "Dragon Cape",
               price: 6e3,
               scale: 90,
               desc: "no effect"
           }, {
               id: 1,
               name: "Super Cape",
               price: 8e3,
               scale: 90,
               desc: "no effect"
           }, {
               id: 7,
               name: "Troll Cape",
               price: 8e3,
               scale: 90,
               desc: "no effect"
           }, {
               id: 14,
               name: "Thorns",
               price: 1e4,
               scale: 115,
               xOff: 20,
               desc: "no effect"
           }, {
               id: 15,
               name: "Blockades",
               price: 1e4,
               scale: 95,
               xOff: 15,
               desc: "no effect"
           }, {
               id: 20,
               name: "Devils Tail",
               price: 1e4,
               scale: 95,
               xOff: 20,
               desc: "no effect"
           }, {
               id: 16,
               name: "Sawblade",
               price: 12e3,
               scale: 90,
               spin: !0,
               xOff: 0,
               desc: "deal damage to players that damage you",
               dmg: .15
           }, {
               id: 13,
               name: "Angel Wings",
               price: 15e3,
               scale: 138,
               xOff: 22,
               desc: "slowly regenerates health over time",
               healthRegen: 3
           }, {
               id: 19,
               name: "Shadow Wings",
               price: 15e3,
               scale: 138,
               xOff: 22,
               desc: "increased movement speed",
               spdMult: 1.1
           }, {
               id: 18,
               name: "Blood Wings",
               price: 2e4,
               scale: 178,
               xOff: 26,
               desc: "restores health when you deal damage",
               healD: .2
           }, {
               id: 21,
               name: "Corrupt X Wings",
               price: 2e4,
               scale: 178,
               xOff: 26,
               desc: "deal damage to players that damage you",
               dmg: .25
           }]
   }
   , function(e, t) {
       e.exports = function(e, t, n, i, r, s, a) {
           this.init = function(e, t, n, i, r, s, o, c, l) {
               this.active = !0,
                   this.indx = e,
                   this.x = t,
                   this.y = n,
                   this.dir = i,
                   this.skipMov = !0,
                   this.speed = r,
                   this.dmg = s,
                   this.scale = c,
                   this.range = o,
                   this.owner = l,
                   a && (this.sentTo = {})
           }
           ;
           var o, c = [];
           this.update = function(l) {
               if (this.active) {
                   var h, u = this.speed * l;
                   if (this.skipMov ? this.skipMov = !1 : (this.x += u * Math.cos(this.dir),
                                                           this.y += u * Math.sin(this.dir),
                                                           this.range -= u,
                                                           this.range <= 0 && (this.x += this.range * Math.cos(this.dir),
                                                                               this.y += this.range * Math.sin(this.dir),
                                                                               u = 1,
                                                                               this.range = 0,
                                                                               this.active = !1)),
                       a) {
                       for (var f = 0; f < e.length; ++f)
                           !this.sentTo[e[f].id] && e[f].canSee(this) && (this.sentTo[e[f].id] = 1,
                                                                          a.send(e[f].id, "18", s.fixTo(this.x, 1), s.fixTo(this.y, 1), s.fixTo(this.dir, 2), s.fixTo(this.range, 1), this.speed, this.indx, this.layer, this.sid));
                       for (c.length = 0,
                            f = 0; f < e.length + t.length; ++f)
                           !(o = e[f] || t[f - e.length]).alive || o == this.owner || this.owner.team && o.team == this.owner.team || s.lineInRect(o.x - o.scale, o.y - o.scale, o.x + o.scale, o.y + o.scale, this.x, this.y, this.x + u * Math.cos(this.dir), this.y + u * Math.sin(this.dir)) && c.push(o);
                       for (var d = n.getGridArrays(this.x, this.y, this.scale), p = 0; p < d.length; ++p)
                           for (var g = 0; g < d[p].length; ++g)
                               h = (o = d[p][g]).getScale(),
                                   o.active && this.ignoreObj != o.sid && this.layer <= o.layer && c.indexOf(o) < 0 && !o.ignoreCollision && s.lineInRect(o.x - h, o.y - h, o.x + h, o.y + h, this.x, this.y, this.x + u * Math.cos(this.dir), this.y + u * Math.sin(this.dir)) && c.push(o);
                       if (c.length > 0) {
                           var m = null
                           , y = null
                           , k = null;
                           for (f = 0; f < c.length; ++f)
                               k = s.getDistance(this.x, this.y, c[f].x, c[f].y),
                                   (null == y || k < y) && (y = k,
                                                            m = c[f]);
                           if (m.isPlayer || m.isAI) {
                               var v = .3 * (m.weightM || 1);
                               m.xVel += v * Math.cos(this.dir),
                                   m.yVel += v * Math.sin(this.dir),
                                   null != m.weaponIndex && i.weapons[m.weaponIndex].shield && s.getAngleDist(this.dir + Math.PI, m.dir) <= r.shieldAngle || m.changeHealth(-this.dmg, this.owner, this.owner)
                           } else
                               for (m.projDmg && m.health && m.changeHealth(-this.dmg) && n.disableObj(m),
                                    f = 0; f < e.length; ++f)
                                   e[f].active && (m.sentTo[e[f].id] && (m.active ? e[f].canSee(m) && a.send(e[f].id, "8", s.fixTo(this.dir, 2), m.sid) : a.send(e[f].id, "12", m.sid)),
                                                   m.active || m.owner != e[f] || e[f].changeItemCount(m.group.id, -1));
                           for (this.active = !1,
                                f = 0; f < e.length; ++f)
                               this.sentTo[e[f].id] && a.send(e[f].id, "19", this.sid, s.fixTo(y, 1))
                       }
                   }
               }
           }
       }
   }
   , function(e, t) {
       e.exports = function(e, t, n, i, r, s, a, o, c) {
           this.addProjectile = function(l, h, u, f, d, p, g, m, y) {
               for (var k, v = s.projectiles[p], w = 0; w < t.length; ++w)
                   if (!t[w].active) {
                       k = t[w];
                       break
                   }
               return k || ((k = new e(n,i,r,s,a,o,c)).sid = t.length,
                            t.push(k)),
                   k.init(p, l, h, u, d, v.dmg, f, v.scale, g),
                   k.ignoreObj = m,
                   k.layer = y || v.layer,
                   k.src = v.src,
                   k
           }
       }
   }
   , function(e, t) {
       e.exports.obj = function(e, t) {
           var n;
           this.sounds = [],
               this.active = !0,
               this.play = function(t, i, r) {
               i && this.active && ((n = this.sounds[t]) || (n = new Howl({
                   src: ".././sound/" + t + ".mp3"
               }),
                                                             this.sounds[t] = n),
                                    r && n.isPlaying || (n.isPlaying = !0,
                                                         n.play(),
                                                         n.volume((i || 1) * e.volumeMult),
                                                         n.loop(r)))
           }
               ,
               this.toggleMute = function(e, t) {
               (n = this.sounds[e]) && n.mute(t)
           }
               ,
               this.stop = function(e) {
               (n = this.sounds[e]) && (n.stop(),
                                        n.isPlaying = !1)
           }
       }
   }
   , function(e, t, n) {
       var i = n(60)
       , r = n(67);
       function s(e, t, n, i, r) {
           "localhost" == location.hostname && (window.location.hostname = "127.0.0.1"),
               this.debugLog = !1,
               this.baseUrl = e,
               this.lobbySize = n,
               this.devPort = t,
               this.lobbySpread = i,
               this.rawIPs = !!r,
               this.server = void 0,
               this.gameIndex = void 0,
               this.callback = void 0,
               this.errorCallback = void 0,
               this.processServers(vultr.servers)
       }
       s.prototype.regionInfo = {
           0: {
               name: "Local",
               latitude: 0,
               longitude: 0
           },
           "vultr:1": {
               name: "New Jersey",
               latitude: 40.1393329,
               longitude: -75.8521818
           },
           "vultr:2": {
               name: "Chicago",
               latitude: 41.8339037,
               longitude: -87.872238
           },
           "vultr:3": {
               name: "Dallas",
               latitude: 32.8208751,
               longitude: -96.8714229
           },
           "vultr:4": {
               name: "Seattle",
               latitude: 47.6149942,
               longitude: -122.4759879
           },
           "vultr:5": {
               name: "Los Angeles",
               latitude: 34.0207504,
               longitude: -118.691914
           },
           "vultr:6": {
               name: "Atlanta",
               latitude: 33.7676334,
               longitude: -84.5610332
           },
           "vultr:7": {
               name: "Amsterdam",
               latitude: 52.3745287,
               longitude: 4.7581878
           },
           "vultr:8": {
               name: "London",
               latitude: 51.5283063,
               longitude: -.382486
           },
           "vultr:9": {
               name: "Frankfurt",
               latitude: 50.1211273,
               longitude: 8.496137
           },
           "vultr:12": {
               name: "Silicon Valley",
               latitude: 37.4024714,
               longitude: -122.3219752
           },
           "vultr:19": {
               name: "Sydney",
               latitude: -33.8479715,
               longitude: 150.651084
           },
           "vultr:24": {
               name: "Paris",
               latitude: 48.8588376,
               longitude: 2.2773454
           },
           "vultr:25": {
               name: "Tokyo",
               latitude: 35.6732615,
               longitude: 139.569959
           },
           "vultr:39": {
               name: "Miami",
               latitude: 25.7823071,
               longitude: -80.3012156
           },
           "vultr:40": {
               name: "Singapore",
               latitude: 1.3147268,
               longitude: 103.7065876
           }
       },
           s.prototype.start = function(e, t) {
           this.callback = e,
               this.errorCallback = t;
           var n = this.parseServerQuery();
           n ? (this.log("Found server in query."),
                this.password = n[3],
                this.connect(n[0], n[1], n[2])) : (this.log("Pinging servers..."),
                                                   this.pingServers())
       }
           ,
           s.prototype.parseServerQuery = function() {
           var e = i.parse(location.href, !0)
           , t = e.query.server;
           if ("string" == typeof t) {
               var n = t.split(":");
               if (3 == n.length) {
                   var r = n[0]
                   , s = parseInt(n[1])
                   , a = parseInt(n[2]);
                   return "0" == r || r.startsWith("vultr:") || (r = "vultr:" + r),
                       [r, s, a, e.query.password]
               }
               this.errorCallback("Invalid number of server parameters in " + t)
           }
       }
           ,
           s.prototype.findServer = function(e, t) {
           var n = this.servers[e];
           if (Array.isArray(n)) {
               for (var i = 0; i < n.length; i++) {
                   var r = n[i];
                   if (r.index == t)
                       return r
               }
               console.warn("Could not find server in region " + e + " with index " + t + ".")
           } else
               this.errorCallback("No server list for region " + e)
       }
           ,
           s.prototype.pingServers = function() {
           var e = this
           , t = [];
           for (var n in this.servers)
               if (this.servers.hasOwnProperty(n)) {
                   var i = this.servers[n]
                   , r = i[Math.floor(Math.random() * i.length)];
                   null != r ? function(i, r) {
                       var s = new XMLHttpRequest;
                       s.onreadystatechange = function(i) {
                           var s = i.target;
                           if (4 == s.readyState)
                               if (200 == s.status) {
                                   for (var a = 0; a < t.length; a++)
                                       t[a].abort();
                                   e.log("Connecting to region", r.region);
                                   var o = e.seekServer(r.region);
                                   e.connect(o[0], o[1], o[2])
                               } else
                                   console.warn("Error pinging " + r.ip + " in region " + n)
                       }
                       ;
                       var a = "//" + e.serverAddress(r.ip, !0) + ":" + e.serverPort(r) + "/ping";
                       s.open("GET", a, !0),
                           s.send(null),
                           e.log("Pinging", a),
                           t.push(s)
                   }(0, r) : console.log("No target server for region " + n)
               }
       }
           ,
           s.prototype.seekServer = function(e, t, n) {
           null == n && (n = "random"),
               null == t && (t = !1);
           const i = ["random"];
           var r = this.lobbySize
           , s = this.lobbySpread
           , a = this.servers[e].flatMap((function(e) {
               var t = 0;
               return e.games.map((function(n) {
                   var i = t++;
                   return {
                       region: e.region,
                       index: e.index * e.games.length + i,
                       gameIndex: i,
                       gameCount: e.games.length,
                       playerCount: n.playerCount,
                       isPrivate: n.isPrivate
                   }
               }
                                  ))
           }
                                         )).filter((function(e) {
               return !e.isPrivate
           }
                                                   )).filter((function(e) {
               return !t || 0 == e.playerCount && e.gameIndex >= e.gameCount / 2
           }
                                                             )).filter((function(e) {
               return "random" == n || i[e.index % i.length].key == n
           }
                                                                       )).sort((function(e, t) {
               return t.playerCount - e.playerCount
           }
                                                                               )).filter((function(e) {
               return e.playerCount < r
           }
                                                                                         ));
           if (t && a.reverse(),
               0 != a.length) {
               var o = Math.min(s, a.length)
               , c = Math.floor(Math.random() * o)
               , l = a[c = Math.min(c, a.length - 1)]
               , h = l.region
               , u = (c = Math.floor(l.index / l.gameCount),
                      l.index % l.gameCount);
               return this.log("Found server."),
                   [h, c, u]
           }
           this.errorCallback("No open servers.")
       }
           ,
           s.prototype.connect = function(e, t, n) {
           if (!this.connected) {
               var i = this.findServer(e, t);
               null != i ? (this.log("Connecting to server", i, "with game index", n),
                            i.games[n].playerCount >= this.lobbySize ? this.errorCallback("Server is already full.") : (window.history.replaceState(document.title, document.title, this.generateHref(e, t, n, this.password)),
                                                                                                                        this.server = i,
                                                                                                                        this.gameIndex = n,
                                                                                                                        this.log("Calling callback with address", this.serverAddress(i.ip), "on port", this.serverPort(i), "with game index", n),
                                                                                                                        this.callback(this.serverAddress(i.ip), this.serverPort(i), n))) : this.errorCallback("Failed to find server for region " + e + " and index " + t)
           }
       }
           ,
           s.prototype.switchServer = function(e, t, n, i) {
           this.switchingServers = !0,
               window.location.href = this.generateHref(e, t, n, i)
       }
           ,
           s.prototype.generateHref = function(e, t, n, i) {
           var r = "/?server=" + (e = this.stripRegion(e)) + ":" + t + ":" + n;
           return i && (r += "&password=" + encodeURIComponent(i)),
               r
       }
           ,
           s.prototype.serverAddress = function(e, t) {
           return "127.0.0.1" == e || "7f000001" == e || "903d62ef5d1c2fecdcaeb5e7dd485eff" == e ? window.location.hostname : this.rawIPs ? t ? "ip_" + this.hashIP(e) + "." + this.baseUrl : e : "ip_" + e + "." + this.baseUrl
       }
           ,
           s.prototype.serverPort = function(e) {
           return 0 == e.region ? this.devPort : location.protocol.startsWith("https") ? 443 : 80
       }
           ,
           s.prototype.processServers = function(e) {
           for (var t = {}, n = 0; n < e.length; n++) {
               var i = e[n]
               , r = t[i.region];
               null == r && (r = [],
                             t[i.region] = r),
                   r.push(i)
           }
           for (var s in t)
               t[s] = t[s].sort((function(e, t) {
                   return e.index - t.index
               }
                                ));
           this.servers = t
       }
           ,
           s.prototype.ipToHex = function(e) {
           return e.split(".").map(e=>("00" + parseInt(e).toString(16)).substr(-2)).join("").toLowerCase()
       }
           ,
           s.prototype.hashIP = function(e) {
           return r(this.ipToHex(e))
       }
           ,
           s.prototype.log = function() {
           return this.debugLog ? console.log.apply(void 0, arguments) : console.verbose ? console.verbose.apply(void 0, arguments) : void 0
       }
           ,
           s.prototype.stripRegion = function(e) {
           return e.startsWith("vultr:") ? e = e.slice(6) : e.startsWith("do:") && (e = e.slice(3)),
               e
       }
           ,
           window.testVultrClient = function() {
           var e = 1;
           function t(t, n) {
               (t = "" + t) == (n = "" + n) ? console.log(`Assert ${e} passed.`) : console.warn(`Assert ${e} failed. Expected ${n}, got ${t}.`),
                   e++
           }
           var n = new s("test.io",-1,5,1,!1);
           n.errorCallback = function(e) {}
               ,
               n.processServers(function(e) {
               var t = [];
               for (var n in e)
                   for (var i = e[n], r = 0; r < i.length; r++)
                       t.push({
                           ip: n + ":" + r,
                           scheme: "testing",
                           region: n,
                           index: r,
                           games: i[r].map(e=>({
                               playerCount: e,
                               isPrivate: !1
                           }))
                       });
               return t
           }({
               1: [[0, 0, 0, 0], [0, 0, 0, 0]],
               2: [[5, 1, 0, 0], [0, 0, 0, 0]],
               3: [[5, 0, 1, 5], [0, 0, 0, 0]],
               4: [[5, 1, 1, 5], [1, 0, 0, 0]],
               5: [[5, 1, 1, 5], [1, 0, 4, 0]],
               6: [[5, 5, 5, 5], [2, 3, 1, 4]],
               7: [[5, 5, 5, 5], [5, 5, 5, 5]]
           })),
               t(n.seekServer(1, !1), [1, 0, 0]),
               t(n.seekServer(1, !0), [1, 1, 3]),
               t(n.seekServer(2, !1), [2, 0, 1]),
               t(n.seekServer(2, !0), [2, 1, 3]),
               t(n.seekServer(3, !1), [3, 0, 2]),
               t(n.seekServer(3, !0), [3, 1, 3]),
               t(n.seekServer(4, !1), [4, 0, 1]),
               t(n.seekServer(4, !0), [4, 1, 3]),
               t(n.seekServer(5, !1), [5, 1, 2]),
               t(n.seekServer(5, !0), [5, 1, 3]),
               t(n.seekServer(6, !1), [6, 1, 3]),
               t(n.seekServer(6, !0), void 0),
               t(n.seekServer(7, !1), void 0),
               t(n.seekServer(7, !0), void 0),
               console.log("Tests passed.")
       }
       ;
       var a = function(e, t) {
           return e.concat(t)
       };
       Array.prototype.flatMap = function(e) {
           return function(e, t) {
               return t.map(e).reduce(a, [])
           }(e, this)
       }
           ,
           e.exports = s
   }
   , function(e, t, n) {
       "use strict";
       var i = n(61)
       , r = n(63);
       function s() {
           this.protocol = null,
               this.slashes = null,
               this.auth = null,
               this.host = null,
               this.port = null,
               this.hostname = null,
               this.hash = null,
               this.search = null,
               this.query = null,
               this.pathname = null,
               this.path = null,
               this.href = null
       }
       t.parse = v,
           t.resolve = function(e, t) {
           return v(e, !1, !0).resolve(t)
       }
           ,
           t.resolveObject = function(e, t) {
           return e ? v(e, !1, !0).resolveObject(t) : t
       }
           ,
           t.format = function(e) {
           return r.isString(e) && (e = v(e)),
               e instanceof s ? e.format() : s.prototype.format.call(e)
       }
           ,
           t.Url = s;
       var a = /^([a-z0-9.+-]+:)/i
       , o = /:[0-9]*$/
       , c = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/
       , l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"])
       , h = ["'"].concat(l)
       , u = ["%", "/", "?", ";", "#"].concat(h)
       , f = ["/", "?", "#"]
       , d = /^[+a-z0-9A-Z_-]{0,63}$/
       , p = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
       , g = {
           javascript: !0,
           "javascript:": !0
       }
       , m = {
           javascript: !0,
           "javascript:": !0
       }
       , y = {
           http: !0,
           https: !0,
           ftp: !0,
           gopher: !0,
           file: !0,
           "http:": !0,
           "https:": !0,
           "ftp:": !0,
           "gopher:": !0,
           "file:": !0
       }
       , k = n(64);
       function v(e, t, n) {
           if (e && r.isObject(e) && e instanceof s)
               return e;
           var i = new s;
           return i.parse(e, t, n),
               i
       }
       s.prototype.parse = function(e, t, n) {
           if (!r.isString(e))
               throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
           var s = e.indexOf("?")
           , o = -1 !== s && s < e.indexOf("#") ? "?" : "#"
           , l = e.split(o);
           l[0] = l[0].replace(/\\/g, "/");
           var v = e = l.join(o);
           if (v = v.trim(),
               !n && 1 === e.split("#").length) {
               var w = c.exec(v);
               if (w)
                   return this.path = v,
                       this.href = v,
                       this.pathname = w[1],
                       w[2] ? (this.search = w[2],
                               this.query = t ? k.parse(this.search.substr(1)) : this.search.substr(1)) : t && (this.search = "",
                                                                                                                this.query = {}),
                       this
           }
           var b = a.exec(v);
           if (b) {
               var x = (b = b[0]).toLowerCase();
               this.protocol = x,
                   v = v.substr(b.length)
           }
           if (n || b || v.match(/^\/\/[^@\/]+@[^@\/]+/)) {
               var S = "//" === v.substr(0, 2);
               !S || b && m[b] || (v = v.substr(2),
                                   this.slashes = !0)
           }
           if (!m[b] && (S || b && !y[b])) {
               for (var T, I, E = -1, M = 0; M < f.length; M++)
                   -1 !== (A = v.indexOf(f[M])) && (-1 === E || A < E) && (E = A);
               for (-1 !== (I = -1 === E ? v.lastIndexOf("@") : v.lastIndexOf("@", E)) && (T = v.slice(0, I),
                                                                                           v = v.slice(I + 1),
                                                                                           this.auth = decodeURIComponent(T)),
                    E = -1,
                    M = 0; M < u.length; M++) {
                   var A;
                   -1 !== (A = v.indexOf(u[M])) && (-1 === E || A < E) && (E = A)
               }
               -1 === E && (E = v.length),
                   this.host = v.slice(0, E),
                   v = v.slice(E),
                   this.parseHost(),
                   this.hostname = this.hostname || "";
               var P = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
               if (!P)
                   for (var B = this.hostname.split(/\./), C = (M = 0,
                                                                B.length); M < C; M++) {
                       var O = B[M];
                       if (O && !O.match(d)) {
                           for (var R = "", j = 0, _ = O.length; j < _; j++)
                               O.charCodeAt(j) > 127 ? R += "x" : R += O[j];
                           if (!R.match(d)) {
                               var U = B.slice(0, M)
                               , D = B.slice(M + 1)
                               , L = O.match(p);
                               L && (U.push(L[1]),
                                     D.unshift(L[2])),
                                   D.length && (v = "/" + D.join(".") + v),
                                   this.hostname = U.join(".");
                               break
                           }
                       }
                   }
               this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(),
                   P || (this.hostname = i.toASCII(this.hostname));
               var F = this.port ? ":" + this.port : ""
               , z = this.hostname || "";
               this.host = z + F,
                   this.href += this.host,
                   P && (this.hostname = this.hostname.substr(1, this.hostname.length - 2),
                         "/" !== v[0] && (v = "/" + v))
           }
           if (!g[x])
               for (M = 0,
                    C = h.length; M < C; M++) {
                   var H = h[M];
                   if (-1 !== v.indexOf(H)) {
                       var V = encodeURIComponent(H);
                       V === H && (V = escape(H)),
                           v = v.split(H).join(V)
                   }
               }
           var q = v.indexOf("#");
           -1 !== q && (this.hash = v.substr(q),
                        v = v.slice(0, q));
           var Y = v.indexOf("?");
           if (-1 !== Y ? (this.search = v.substr(Y),
                           this.query = v.substr(Y + 1),
                           t && (this.query = k.parse(this.query)),
                           v = v.slice(0, Y)) : t && (this.search = "",
                                                      this.query = {}),
               v && (this.pathname = v),
               y[x] && this.hostname && !this.pathname && (this.pathname = "/"),
               this.pathname || this.search) {
               F = this.pathname || "";
               var W = this.search || "";
               this.path = F + W
           }
           return this.href = this.format(),
               this
       }
           ,
           s.prototype.format = function() {
           var e = this.auth || "";
           e && (e = (e = encodeURIComponent(e)).replace(/%3A/i, ":"),
                 e += "@");
           var t = this.protocol || ""
           , n = this.pathname || ""
           , i = this.hash || ""
           , s = !1
           , a = "";
           this.host ? s = e + this.host : this.hostname && (s = e + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"),
                                                             this.port && (s += ":" + this.port)),
               this.query && r.isObject(this.query) && Object.keys(this.query).length && (a = k.stringify(this.query));
           var o = this.search || a && "?" + a || "";
           return t && ":" !== t.substr(-1) && (t += ":"),
               this.slashes || (!t || y[t]) && !1 !== s ? (s = "//" + (s || ""),
                                                           n && "/" !== n.charAt(0) && (n = "/" + n)) : s || (s = ""),
               i && "#" !== i.charAt(0) && (i = "#" + i),
               o && "?" !== o.charAt(0) && (o = "?" + o),
               t + s + (n = n.replace(/[?#]/g, (function(e) {
               return encodeURIComponent(e)
           }
                                               ))) + (o = o.replace("#", "%23")) + i
       }
           ,
           s.prototype.resolve = function(e) {
           return this.resolveObject(v(e, !1, !0)).format()
       }
           ,
           s.prototype.resolveObject = function(e) {
           if (r.isString(e)) {
               var t = new s;
               t.parse(e, !1, !0),
                   e = t
           }
           for (var n = new s, i = Object.keys(this), a = 0; a < i.length; a++) {
               var o = i[a];
               n[o] = this[o]
           }
           if (n.hash = e.hash,
               "" === e.href)
               return n.href = n.format(),
                   n;
           if (e.slashes && !e.protocol) {
               for (var c = Object.keys(e), l = 0; l < c.length; l++) {
                   var h = c[l];
                   "protocol" !== h && (n[h] = e[h])
               }
               return y[n.protocol] && n.hostname && !n.pathname && (n.path = n.pathname = "/"),
                   n.href = n.format(),
                   n
           }
           if (e.protocol && e.protocol !== n.protocol) {
               if (!y[e.protocol]) {
                   for (var u = Object.keys(e), f = 0; f < u.length; f++) {
                       var d = u[f];
                       n[d] = e[d]
                   }
                   return n.href = n.format(),
                       n
               }
               if (n.protocol = e.protocol,
                   e.host || m[e.protocol])
                   n.pathname = e.pathname;
               else {
                   for (var p = (e.pathname || "").split("/"); p.length && !(e.host = p.shift()); )
                       ;
                   e.host || (e.host = ""),
                       e.hostname || (e.hostname = ""),
                       "" !== p[0] && p.unshift(""),
                       p.length < 2 && p.unshift(""),
                       n.pathname = p.join("/")
               }
               if (n.search = e.search,
                   n.query = e.query,
                   n.host = e.host || "",
                   n.auth = e.auth,
                   n.hostname = e.hostname || e.host,
                   n.port = e.port,
                   n.pathname || n.search) {
                   var g = n.pathname || ""
                   , k = n.search || "";
                   n.path = g + k
               }
               return n.slashes = n.slashes || e.slashes,
                   n.href = n.format(),
                   n
           }
           var v = n.pathname && "/" === n.pathname.charAt(0)
           , w = e.host || e.pathname && "/" === e.pathname.charAt(0)
           , b = w || v || n.host && e.pathname
           , x = b
           , S = n.pathname && n.pathname.split("/") || []
           , T = (p = e.pathname && e.pathname.split("/") || [],
                  n.protocol && !y[n.protocol]);
           if (T && (n.hostname = "",
                     n.port = null,
                     n.host && ("" === S[0] ? S[0] = n.host : S.unshift(n.host)),
                     n.host = "",
                     e.protocol && (e.hostname = null,
                                    e.port = null,
                                    e.host && ("" === p[0] ? p[0] = e.host : p.unshift(e.host)),
                                    e.host = null),
                     b = b && ("" === p[0] || "" === S[0])),
               w)
               n.host = e.host || "" === e.host ? e.host : n.host,
                   n.hostname = e.hostname || "" === e.hostname ? e.hostname : n.hostname,
                   n.search = e.search,
                   n.query = e.query,
                   S = p;
           else if (p.length)
               S || (S = []),
                   S.pop(),
                   S = S.concat(p),
                   n.search = e.search,
                   n.query = e.query;
           else if (!r.isNullOrUndefined(e.search))
               return T && (n.hostname = n.host = S.shift(),
                            (P = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && (n.auth = P.shift(),
                                                                                                 n.host = n.hostname = P.shift())),
                   n.search = e.search,
                   n.query = e.query,
                   r.isNull(n.pathname) && r.isNull(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
                   n.href = n.format(),
                   n;
           if (!S.length)
               return n.pathname = null,
                   n.search ? n.path = "/" + n.search : n.path = null,
                   n.href = n.format(),
                   n;
           for (var I = S.slice(-1)[0], E = (n.host || e.host || S.length > 1) && ("." === I || ".." === I) || "" === I, M = 0, A = S.length; A >= 0; A--)
               "." === (I = S[A]) ? S.splice(A, 1) : ".." === I ? (S.splice(A, 1),
                                                                   M++) : M && (S.splice(A, 1),
                                                                                M--);
           if (!b && !x)
               for (; M--; M)
                   S.unshift("..");
           !b || "" === S[0] || S[0] && "/" === S[0].charAt(0) || S.unshift(""),
               E && "/" !== S.join("/").substr(-1) && S.push("");
           var P, B = "" === S[0] || S[0] && "/" === S[0].charAt(0);
           return T && (n.hostname = n.host = B ? "" : S.length ? S.shift() : "",
                        (P = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && (n.auth = P.shift(),
                                                                                             n.host = n.hostname = P.shift())),
               (b = b || n.host && S.length) && !B && S.unshift(""),
               S.length ? n.pathname = S.join("/") : (n.pathname = null,
                                                      n.path = null),
               r.isNull(n.pathname) && r.isNull(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
               n.auth = e.auth || n.auth,
               n.slashes = n.slashes || e.slashes,
               n.href = n.format(),
               n
       }
           ,
           s.prototype.parseHost = function() {
           var e = this.host
           , t = o.exec(e);
           t && (":" !== (t = t[0]) && (this.port = t.substr(1)),
                 e = e.substr(0, e.length - t.length)),
               e && (this.hostname = e)
       }
   }
   , function(e, t, n) {
       (function(e, i) {
           var r;
           /*! https://mths.be/punycode v1.4.1 by @mathias */
           !function(s) {
               t && t.nodeType,
                   e && e.nodeType;
               var a = "object" == typeof i && i;
               a.global !== a && a.window !== a && a.self;
               var o, c = 2147483647, l = 36, h = /^xn--/, u = /[^\x20-\x7E]/, f = /[\x2E\u3002\uFF0E\uFF61]/g, d = {
                   overflow: "Overflow: input needs wider integers to process",
                   "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                   "invalid-input": "Invalid input"
               }, p = Math.floor, g = String.fromCharCode;
               function m(e) {
                   throw new RangeError(d[e])
               }
               function y(e, t) {
                   for (var n = e.length, i = []; n--; )
                       i[n] = t(e[n]);
                   return i
               }
               function k(e, t) {
                   var n = e.split("@")
                   , i = "";
                   return n.length > 1 && (i = n[0] + "@",
                                           e = n[1]),
                       i + y((e = e.replace(f, ".")).split("."), t).join(".")
               }
               function v(e) {
                   for (var t, n, i = [], r = 0, s = e.length; r < s; )
                       (t = e.charCodeAt(r++)) >= 55296 && t <= 56319 && r < s ? 56320 == (64512 & (n = e.charCodeAt(r++))) ? i.push(((1023 & t) << 10) + (1023 & n) + 65536) : (i.push(t),
                    r--) : i.push(t);
                   return i
               }
               function w(e) {
                   return y(e, (function(e) {
                       var t = "";
                       return e > 65535 && (t += g((e -= 65536) >>> 10 & 1023 | 55296),
                                            e = 56320 | 1023 & e),
                           t + g(e)
                   }
                               )).join("")
               }
               function b(e) {
                   return e - 48 < 10 ? e - 22 : e - 65 < 26 ? e - 65 : e - 97 < 26 ? e - 97 : l
               }
               function x(e, t) {
                   return e + 22 + 75 * (e < 26) - ((0 != t) << 5)
               }
               function S(e, t, n) {
                   var i = 0;
                   for (e = n ? p(e / 700) : e >> 1,
                        e += p(e / t); e > 455; i += l)
                       e = p(e / 35);
                   return p(i + 36 * e / (e + 38))
               }
               function T(e) {
                   var t, n, i, r, s, a, o, h, u, f, d = [], g = e.length, y = 0, k = 128, v = 72;
                   for ((n = e.lastIndexOf("-")) < 0 && (n = 0),
                        i = 0; i < n; ++i)
                       e.charCodeAt(i) >= 128 && m("not-basic"),
                           d.push(e.charCodeAt(i));
                   for (r = n > 0 ? n + 1 : 0; r < g; ) {
                       for (s = y,
                            a = 1,
                            o = l; r >= g && m("invalid-input"),
                            ((h = b(e.charCodeAt(r++))) >= l || h > p((c - y) / a)) && m("overflow"),
                            y += h * a,
                            !(h < (u = o <= v ? 1 : o >= v + 26 ? 26 : o - v)); o += l)
                           a > p(c / (f = l - u)) && m("overflow"),
                               a *= f;
                       v = S(y - s, t = d.length + 1, 0 == s),
                           p(y / t) > c - k && m("overflow"),
                           k += p(y / t),
                           y %= t,
                           d.splice(y++, 0, k)
                   }
                   return w(d)
               }
               function I(e) {
                   var t, n, i, r, s, a, o, h, u, f, d, y, k, w, b, T = [];
                   for (y = (e = v(e)).length,
                        t = 128,
                        n = 0,
                        s = 72,
                        a = 0; a < y; ++a)
                       (d = e[a]) < 128 && T.push(g(d));
                   for (i = r = T.length,
                        r && T.push("-"); i < y; ) {
                       for (o = c,
                            a = 0; a < y; ++a)
                           (d = e[a]) >= t && d < o && (o = d);
                       for (o - t > p((c - n) / (k = i + 1)) && m("overflow"),
                            n += (o - t) * k,
                            t = o,
                            a = 0; a < y; ++a)
                           if ((d = e[a]) < t && ++n > c && m("overflow"),
                               d == t) {
                               for (h = n,
                                    u = l; !(h < (f = u <= s ? 1 : u >= s + 26 ? 26 : u - s)); u += l)
                                   b = h - f,
                                       w = l - f,
                                       T.push(g(x(f + b % w, 0))),
                                       h = p(b / w);
                               T.push(g(x(h, 0))),
                                   s = S(n, k, i == r),
                                   n = 0,
                                   ++i
                           }
                       ++n,
                           ++t
                   }
                   return T.join("")
               }
               o = {
                   version: "1.4.1",
                   ucs2: {
                       decode: v,
                       encode: w
                   },
                   decode: T,
                   encode: I,
                   toASCII: function(e) {
                       return k(e, (function(e) {
                           return u.test(e) ? "xn--" + I(e) : e
                       }
                                   ))
                   },
                   toUnicode: function(e) {
                       return k(e, (function(e) {
                           return h.test(e) ? T(e.slice(4).toLowerCase()) : e
                       }
                                   ))
                   }
               },
                   void 0 === (r = function() {
                   return o
               }
                               .call(t, n, t, e)) || (e.exports = r)
           }()
       }
       ).call(this, n(62)(e), n(12))
   }
   , function(e, t) {
       e.exports = function(e) {
           return e.webpackPolyfill || (e.deprecate = function() {}
                                        ,
                                        e.paths = [],
                                        e.children || (e.children = []),
                                        Object.defineProperty(e, "loaded", {
               enumerable: !0,
               get: function() {
                   return e.l
               }
           }),
                                        Object.defineProperty(e, "id", {
               enumerable: !0,
               get: function() {
                   return e.i
               }
           }),
                                        e.webpackPolyfill = 1),
               e
       }
   }
   , function(e, t, n) {
       "use strict";
       e.exports = {
           isString: function(e) {
               return "string" == typeof e
           },
           isObject: function(e) {
               return "object" == typeof e && null !== e
           },
           isNull: function(e) {
               return null === e
           },
           isNullOrUndefined: function(e) {
               return null == e
           }
       }
   }
   , function(e, t, n) {
       "use strict";
       t.decode = t.parse = n(65),
           t.encode = t.stringify = n(66)
   }
   , function(e, t, n) {
       "use strict";
       function i(e, t) {
           return Object.prototype.hasOwnProperty.call(e, t)
       }
       e.exports = function(e, t, n, s) {
           t = t || "&",
               n = n || "=";
           var a = {};
           if ("string" != typeof e || 0 === e.length)
               return a;
           var o = /\+/g;
           e = e.split(t);
           var c = 1e3;
           s && "number" == typeof s.maxKeys && (c = s.maxKeys);
           var l = e.length;
           c > 0 && l > c && (l = c);
           for (var h = 0; h < l; ++h) {
               var u, f, d, p, g = e[h].replace(o, "%20"), m = g.indexOf(n);
               m >= 0 ? (u = g.substr(0, m),
                         f = g.substr(m + 1)) : (u = g,
                                                 f = ""),
                   d = decodeURIComponent(u),
                   p = decodeURIComponent(f),
                   i(a, d) ? r(a[d]) ? a[d].push(p) : a[d] = [a[d], p] : a[d] = p
           }
           return a
       }
       ;
       var r = Array.isArray || function(e) {
           return "[object Array]" === Object.prototype.toString.call(e)
       }
       }
   , function(e, t, n) {
       "use strict";
       var i = function(e) {
           switch (typeof e) {
               case "string":
                   return e;
               case "boolean":
                   return e ? "true" : "false";
               case "number":
                   return isFinite(e) ? e : "";
               default:
                   return ""
           }
       };
       e.exports = function(e, t, n, o) {
           return t = t || "&",
               n = n || "=",
               null === e && (e = void 0),
               "object" == typeof e ? s(a(e), (function(a) {
               var o = encodeURIComponent(i(a)) + n;
               return r(e[a]) ? s(e[a], (function(e) {
                   return o + encodeURIComponent(i(e))
               }
                                        )).join(t) : o + encodeURIComponent(i(e[a]))
           }
                                              )).join(t) : o ? encodeURIComponent(i(o)) + n + encodeURIComponent(i(e)) : ""
       }
       ;
       var r = Array.isArray || function(e) {
           return "[object Array]" === Object.prototype.toString.call(e)
       }
       ;
       function s(e, t) {
           if (e.map)
               return e.map(t);
           for (var n = [], i = 0; i < e.length; i++)
               n.push(t(e[i], i));
           return n
       }
       var a = Object.keys || function(e) {
           var t = [];
           for (var n in e)
               Object.prototype.hasOwnProperty.call(e, n) && t.push(n);
           return t
       }
       }
   , function(e, t, n) {
       !function() {
           var t = n(68)
           , i = n(20).utf8
           , r = n(69)
           , s = n(20).bin
           , a = function(e, n) {
               e.constructor == String ? e = n && "binary" === n.encoding ? s.stringToBytes(e) : i.stringToBytes(e) : r(e) ? e = Array.prototype.slice.call(e, 0) : Array.isArray(e) || (e = e.toString());
               for (var o = t.bytesToWords(e), c = 8 * e.length, l = 1732584193, h = -271733879, u = -1732584194, f = 271733878, d = 0; d < o.length; d++)
                   o[d] = 16711935 & (o[d] << 8 | o[d] >>> 24) | 4278255360 & (o[d] << 24 | o[d] >>> 8);
               o[c >>> 5] |= 128 << c % 32,
                   o[14 + (c + 64 >>> 9 << 4)] = c;
               var p = a._ff
               , g = a._gg
               , m = a._hh
               , y = a._ii;
               for (d = 0; d < o.length; d += 16) {
                   var k = l
                   , v = h
                   , w = u
                   , b = f;
                   h = y(h = y(h = y(h = y(h = m(h = m(h = m(h = m(h = g(h = g(h = g(h = g(h = p(h = p(h = p(h = p(h, u = p(u, f = p(f, l = p(l, h, u, f, o[d + 0], 7, -680876936), h, u, o[d + 1], 12, -389564586), l, h, o[d + 2], 17, 606105819), f, l, o[d + 3], 22, -1044525330), u = p(u, f = p(f, l = p(l, h, u, f, o[d + 4], 7, -176418897), h, u, o[d + 5], 12, 1200080426), l, h, o[d + 6], 17, -1473231341), f, l, o[d + 7], 22, -45705983), u = p(u, f = p(f, l = p(l, h, u, f, o[d + 8], 7, 1770035416), h, u, o[d + 9], 12, -1958414417), l, h, o[d + 10], 17, -42063), f, l, o[d + 11], 22, -1990404162), u = p(u, f = p(f, l = p(l, h, u, f, o[d + 12], 7, 1804603682), h, u, o[d + 13], 12, -40341101), l, h, o[d + 14], 17, -1502002290), f, l, o[d + 15], 22, 1236535329), u = g(u, f = g(f, l = g(l, h, u, f, o[d + 1], 5, -165796510), h, u, o[d + 6], 9, -1069501632), l, h, o[d + 11], 14, 643717713), f, l, o[d + 0], 20, -373897302), u = g(u, f = g(f, l = g(l, h, u, f, o[d + 5], 5, -701558691), h, u, o[d + 10], 9, 38016083), l, h, o[d + 15], 14, -660478335), f, l, o[d + 4], 20, -405537848), u = g(u, f = g(f, l = g(l, h, u, f, o[d + 9], 5, 568446438), h, u, o[d + 14], 9, -1019803690), l, h, o[d + 3], 14, -187363961), f, l, o[d + 8], 20, 1163531501), u = g(u, f = g(f, l = g(l, h, u, f, o[d + 13], 5, -1444681467), h, u, o[d + 2], 9, -51403784), l, h, o[d + 7], 14, 1735328473), f, l, o[d + 12], 20, -1926607734), u = m(u, f = m(f, l = m(l, h, u, f, o[d + 5], 4, -378558), h, u, o[d + 8], 11, -2022574463), l, h, o[d + 11], 16, 1839030562), f, l, o[d + 14], 23, -35309556), u = m(u, f = m(f, l = m(l, h, u, f, o[d + 1], 4, -1530992060), h, u, o[d + 4], 11, 1272893353), l, h, o[d + 7], 16, -155497632), f, l, o[d + 10], 23, -1094730640), u = m(u, f = m(f, l = m(l, h, u, f, o[d + 13], 4, 681279174), h, u, o[d + 0], 11, -358537222), l, h, o[d + 3], 16, -722521979), f, l, o[d + 6], 23, 76029189), u = m(u, f = m(f, l = m(l, h, u, f, o[d + 9], 4, -640364487), h, u, o[d + 12], 11, -421815835), l, h, o[d + 15], 16, 530742520), f, l, o[d + 2], 23, -995338651), u = y(u, f = y(f, l = y(l, h, u, f, o[d + 0], 6, -198630844), h, u, o[d + 7], 10, 1126891415), l, h, o[d + 14], 15, -1416354905), f, l, o[d + 5], 21, -57434055), u = y(u, f = y(f, l = y(l, h, u, f, o[d + 12], 6, 1700485571), h, u, o[d + 3], 10, -1894986606), l, h, o[d + 10], 15, -1051523), f, l, o[d + 1], 21, -2054922799), u = y(u, f = y(f, l = y(l, h, u, f, o[d + 8], 6, 1873313359), h, u, o[d + 15], 10, -30611744), l, h, o[d + 6], 15, -1560198380), f, l, o[d + 13], 21, 1309151649), u = y(u, f = y(f, l = y(l, h, u, f, o[d + 4], 6, -145523070), h, u, o[d + 11], 10, -1120210379), l, h, o[d + 2], 15, 718787259), f, l, o[d + 9], 21, -343485551),
                       l = l + k >>> 0,
                       h = h + v >>> 0,
                       u = u + w >>> 0,
                       f = f + b >>> 0
               }
               return t.endian([l, h, u, f])
           };
           a._ff = function(e, t, n, i, r, s, a) {
               var o = e + (t & n | ~t & i) + (r >>> 0) + a;
               return (o << s | o >>> 32 - s) + t
           }
               ,
               a._gg = function(e, t, n, i, r, s, a) {
               var o = e + (t & i | n & ~i) + (r >>> 0) + a;
               return (o << s | o >>> 32 - s) + t
           }
               ,
               a._hh = function(e, t, n, i, r, s, a) {
               var o = e + (t ^ n ^ i) + (r >>> 0) + a;
               return (o << s | o >>> 32 - s) + t
           }
               ,
               a._ii = function(e, t, n, i, r, s, a) {
               var o = e + (n ^ (t | ~i)) + (r >>> 0) + a;
               return (o << s | o >>> 32 - s) + t
           }
               ,
               a._blocksize = 16,
               a._digestsize = 16,
               e.exports = function(e, n) {
               if (null == e)
                   throw new Error("Illegal argument " + e);
               var i = t.wordsToBytes(a(e, n));
               return n && n.asBytes ? i : n && n.asString ? s.bytesToString(i) : t.bytesToHex(i)
           }
       }()
   }
   , function(e, t) {
       !function() {
           var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
           , n = {
               rotl: function(e, t) {
                   return e << t | e >>> 32 - t
               },
               rotr: function(e, t) {
                   return e << 32 - t | e >>> t
               },
               endian: function(e) {
                   if (e.constructor == Number)
                       return 16711935 & n.rotl(e, 8) | 4278255360 & n.rotl(e, 24);
                   for (var t = 0; t < e.length; t++)
                       e[t] = n.endian(e[t]);
                   return e
               },
               randomBytes: function(e) {
                   for (var t = []; e > 0; e--)
                       t.push(Math.floor(256 * Math.random()));
                   return t
               },
               bytesToWords: function(e) {
                   for (var t = [], n = 0, i = 0; n < e.length; n++,
                        i += 8)
                       t[i >>> 5] |= e[n] << 24 - i % 32;
                   return t
               },
               wordsToBytes: function(e) {
                   for (var t = [], n = 0; n < 32 * e.length; n += 8)
                       t.push(e[n >>> 5] >>> 24 - n % 32 & 255);
                   return t
               },
               bytesToHex: function(e) {
                   for (var t = [], n = 0; n < e.length; n++)
                       t.push((e[n] >>> 4).toString(16)),
                           t.push((15 & e[n]).toString(16));
                   return t.join("")
               },
               hexToBytes: function(e) {
                   for (var t = [], n = 0; n < e.length; n += 2)
                       t.push(parseInt(e.substr(n, 2), 16));
                   return t
               },
               bytesToBase64: function(e) {
                   for (var n = [], i = 0; i < e.length; i += 3)
                       for (var r = e[i] << 16 | e[i + 1] << 8 | e[i + 2], s = 0; s < 4; s++)
                           8 * i + 6 * s <= 8 * e.length ? n.push(t.charAt(r >>> 6 * (3 - s) & 63)) : n.push("=");
                   return n.join("")
               },
               base64ToBytes: function(e) {
                   e = e.replace(/[^A-Z0-9+\/]/gi, "");
                   for (var n = [], i = 0, r = 0; i < e.length; r = ++i % 4)
                       0 != r && n.push((t.indexOf(e.charAt(i - 1)) & Math.pow(2, -2 * r + 8) - 1) << 2 * r | t.indexOf(e.charAt(i)) >>> 6 - 2 * r);
                   return n
               }
           };
           e.exports = n
       }()
   }
   , function(e, t) {
       function n(e) {
           return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
       }
       /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
       e.exports = function(e) {
           return null != e && (n(e) || function(e) {
               return "function" == typeof e.readFloatLE && "function" == typeof e.slice && n(e.slice(0, 0))
           }(e) || !!e._isBuffer)
       }
   }
   , function(e, t) {
       e.exports = function(e, t, n, i, r, s, a, o, c) {
           this.aiTypes = [{
               id: 0,
               src: "cow_1",
               killScore: 150,
               health: 500,
               weightM: .8,
               speed: 95e-5,
               turnSpeed: .001,
               scale: 72,
               drop: ["food", 50]
           }, {
               id: 1,
               src: "pig_1",
               killScore: 200,
               health: 800,
               weightM: .6,
               speed: 85e-5,
               turnSpeed: .001,
               scale: 72,
               drop: ["food", 80]
           }, {
               id: 2,
               name: "Bull",
               src: "bull_2",
               hostile: !0,
               dmg: 20,
               killScore: 1e3,
               health: 1800,
               weightM: .5,
               speed: 94e-5,
               turnSpeed: 74e-5,
               scale: 78,
               viewRange: 800,
               chargePlayer: !0,
               drop: ["food", 100]
           }, {
               id: 3,
               name: "Bully",
               src: "bull_1",
               hostile: !0,
               dmg: 20,
               killScore: 2e3,
               health: 2800,
               weightM: .45,
               speed: .001,
               turnSpeed: 8e-4,
               scale: 90,
               viewRange: 900,
               chargePlayer: !0,
               drop: ["food", 400]
           }, {
               id: 4,
               name: "Wolf",
               src: "wolf_1",
               hostile: !0,
               dmg: 8,
               killScore: 500,
               health: 300,
               weightM: .45,
               speed: .001,
               turnSpeed: .002,
               scale: 84,
               viewRange: 800,
               chargePlayer: !0,
               drop: ["food", 200]
           }, {
               id: 5,
               name: "Quack",
               src: "chicken_1",
               dmg: 8,
               killScore: 2e3,
               noTrap: !0,
               health: 300,
               weightM: .2,
               speed: .0018,
               turnSpeed: .006,
               scale: 70,
               drop: ["food", 100]
           }, {
               id: 6,
               name: "MOOSTAFA",
               nameScale: 50,
               src: "enemy",
               hostile: !0,
               dontRun: !0,
               fixedSpawn: !0,
               spawnDelay: 6e4,
               noTrap: !0,
               colDmg: 100,
               dmg: 40,
               killScore: 8e3,
               health: 18e3,
               weightM: .4,
               speed: 7e-4,
               turnSpeed: .01,
               scale: 80,
               spriteMlt: 1.8,
               leapForce: .9,
               viewRange: 1e3,
               hitRange: 210,
               hitDelay: 1e3,
               chargePlayer: !0,
               drop: ["food", 100]
           }, {
               id: 7,
               name: "Treasure",
               hostile: !0,
               nameScale: 35,
               src: "crate_1",
               fixedSpawn: !0,
               spawnDelay: 12e4,
               colDmg: 200,
               killScore: 5e3,
               health: 2e4,
               weightM: .1,
               speed: 0,
               turnSpeed: 0,
               scale: 70,
               spriteMlt: 1
           }, {
               id: 8,
               name: "MOOFIE",
               src: "wolf_2",
               hostile: !0,
               fixedSpawn: !0,
               dontRun: !0,
               hitScare: 4,
               spawnDelay: 3e4,
               noTrap: !0,
               nameScale: 35,
               dmg: 10,
               colDmg: 100,
               killScore: 3e3,
               health: 7e3,
               weightM: .45,
               speed: .0015,
               turnSpeed: .002,
               scale: 90,
               viewRange: 800,
               chargePlayer: !0,
               drop: ["food", 1e3]
           }],
               this.spawn = function(l, h, u, f) {
               for (var d, p = 0; p < e.length; ++p)
                   if (!e[p].active) {
                       d = e[p];
                       break
                   }
               return d || (d = new t(e.length,r,n,i,a,s,o,c),
                            e.push(d)),
                   d.init(l, h, u, f, this.aiTypes[f]),
                   d
           }
       }
   }
   , function(e, t) {
       var n = 2 * Math.PI;
       e.exports = function(e, t, i, r, s, a, o, c) {
           this.sid = e,
               this.isAI = !0,
               this.nameIndex = s.randInt(0, a.cowNames.length - 1),
               this.init = function(e, t, n, i, r) {
               this.x = e,
                   this.y = t,
                   this.startX = r.fixedSpawn ? e : null,
                   this.startY = r.fixedSpawn ? t : null,
                   this.xVel = 0,
                   this.yVel = 0,
                   this.zIndex = 0,
                   this.dir = n,
                   this.dirPlus = 0,
                   this.index = i,
                   this.src = r.src,
                   r.name && (this.name = r.name),
                   this.weightM = r.weightM,
                   this.speed = r.speed,
                   this.killScore = r.killScore,
                   this.turnSpeed = r.turnSpeed,
                   this.scale = r.scale,
                   this.maxHealth = r.health,
                   this.leapForce = r.leapForce,
                   this.health = this.maxHealth,
                   this.chargePlayer = r.chargePlayer,
                   this.viewRange = r.viewRange,
                   this.drop = r.drop,
                   this.dmg = r.dmg,
                   this.hostile = r.hostile,
                   this.dontRun = r.dontRun,
                   this.hitRange = r.hitRange,
                   this.hitDelay = r.hitDelay,
                   this.hitScare = r.hitScare,
                   this.spriteMlt = r.spriteMlt,
                   this.nameScale = r.nameScale,
                   this.colDmg = r.colDmg,
                   this.noTrap = r.noTrap,
                   this.spawnDelay = r.spawnDelay,
                   this.hitWait = 0,
                   this.waitCount = 1e3,
                   this.moveCount = 0,
                   this.targetDir = 0,
                   this.active = !0,
                   this.alive = !0,
                   this.runFrom = null,
                   this.chargeTarget = null,
                   this.dmgOverTime = {}
           }
           ;
           var l = 0;
           this.update = function(e) {
               if (this.active) {
                   if (this.spawnCounter)
                       return this.spawnCounter -= e,
                           void (this.spawnCounter <= 0 && (this.spawnCounter = 0,
                                                            this.x = this.startX || s.randInt(0, a.mapScale),
                                                            this.y = this.startY || s.randInt(0, a.mapScale)));
                   (l -= e) <= 0 && (this.dmgOverTime.dmg && (this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer),
                                                              this.dmgOverTime.time -= 1,
                                                              this.dmgOverTime.time <= 0 && (this.dmgOverTime.dmg = 0)),
                                     l = 1e3);
                   var r = !1
                   , o = 1;
                   if (!this.zIndex && !this.lockMove && this.y >= a.mapScale / 2 - a.riverWidth / 2 && this.y <= a.mapScale / 2 + a.riverWidth / 2 && (o = .33,
                this.xVel += a.waterCurrent * e),
                       this.lockMove)
                       this.xVel = 0,
                           this.yVel = 0;
                   else if (this.waitCount > 0) {
                       if (this.waitCount -= e,
                           this.waitCount <= 0)
                           if (this.chargePlayer) {
                               for (var h, u, f, d = 0; d < i.length; ++d)
                                   !i[d].alive || i[d].skin && i[d].skin.bullRepel || (f = s.getDistance(this.x, this.y, i[d].x, i[d].y)) <= this.viewRange && (!h || f < u) && (u = f,
                                h = i[d]);
                               h ? (this.chargeTarget = h,
                                    this.moveCount = s.randInt(8e3, 12e3)) : (this.moveCount = s.randInt(1e3, 2e3),
                                                                              this.targetDir = s.randFloat(-Math.PI, Math.PI))
                           } else
                               this.moveCount = s.randInt(4e3, 1e4),
                                   this.targetDir = s.randFloat(-Math.PI, Math.PI)
                   } else if (this.moveCount > 0) {
                       var p = this.speed * o;
                       if (this.runFrom && this.runFrom.active && (!this.runFrom.isPlayer || this.runFrom.alive) ? (this.targetDir = s.getDirection(this.x, this.y, this.runFrom.x, this.runFrom.y),
                                                                                                                    p *= 1.42) : this.chargeTarget && this.chargeTarget.alive && (this.targetDir = s.getDirection(this.chargeTarget.x, this.chargeTarget.y, this.x, this.y),
                    p *= 1.75,
                    r = !0),
                           this.hitWait && (p *= .3),
                           this.dir != this.targetDir) {
                           this.dir %= n;
                           var g = (this.dir - this.targetDir + n) % n
                           , m = Math.min(Math.abs(g - n), g, this.turnSpeed * e)
                           , y = g - Math.PI >= 0 ? 1 : -1;
                           this.dir += y * m + n
                       }
                       this.dir %= n,
                           this.xVel += p * e * Math.cos(this.dir),
                           this.yVel += p * e * Math.sin(this.dir),
                           this.moveCount -= e,
                           this.moveCount <= 0 && (this.runFrom = null,
                                                   this.chargeTarget = null,
                                                   this.waitCount = this.hostile ? 1500 : s.randInt(1500, 6e3))
                   }
                   this.zIndex = 0,
                       this.lockMove = !1;
                   var k = s.getDistance(0, 0, this.xVel * e, this.yVel * e)
                   , v = Math.min(4, Math.max(1, Math.round(k / 40)))
                   , w = 1 / v;
                   for (d = 0; d < v; ++d) {
                       this.xVel && (this.x += this.xVel * e * w),
                           this.yVel && (this.y += this.yVel * e * w),
                           M = t.getGridArrays(this.x, this.y, this.scale);
                       for (var b = 0; b < M.length; ++b)
                           for (var x = 0; x < M[b].length; ++x)
                               M[b][x].active && t.checkCollision(this, M[b][x], w)
                   }
                   var S, T, I, E = !1;
                   if (this.hitWait > 0 && (this.hitWait -= e,
                                            this.hitWait <= 0)) {
                       E = !0,
                           this.hitWait = 0,
                           this.leapForce && !s.randInt(0, 2) && (this.xVel += this.leapForce * Math.cos(this.dir),
                                                                  this.yVel += this.leapForce * Math.sin(this.dir));
                       for (var M = t.getGridArrays(this.x, this.y, this.hitRange), A = 0; A < M.length; ++A)
                           for (b = 0; b < M[A].length; ++b)
                               (S = M[A][b]).health && (T = s.getDistance(this.x, this.y, S.x, S.y)) < S.scale + this.hitRange && (S.changeHealth(5 * -this.dmg) && t.disableObj(S),
                                                                                                                                   t.hitObj(S, s.getDirection(this.x, this.y, S.x, S.y)));
                       for (b = 0; b < i.length; ++b)
                           i[b].canSee(this) && c.send(i[b].id, "aa", this.sid)
                   }
                   if (r || E)
                       for (d = 0; d < i.length; ++d)
                           (S = i[d]) && S.alive && (T = s.getDistance(this.x, this.y, S.x, S.y),
                                                     this.hitRange ? !this.hitWait && T <= this.hitRange + S.scale && (E ? (I = s.getDirection(S.x, S.y, this.x, this.y),
                                                                                                                            S.changeHealth(-this.dmg),
                                                                                                                            S.xVel += .6 * Math.cos(I),
                                                                                                                            S.yVel += .6 * Math.sin(I),
                                                                                                                            this.runFrom = null,
                                                                                                                            this.chargeTarget = null,
                                                                                                                            this.waitCount = 3e3,
                                                                                                                            this.hitWait = s.randInt(0, 2) ? 0 : 600) : this.hitWait = this.hitDelay) : T <= this.scale + S.scale && (I = s.getDirection(S.x, S.y, this.x, this.y),
                        S.changeHealth(-this.dmg),
                        S.xVel += .55 * Math.cos(I),
                        S.yVel += .55 * Math.sin(I)));
                   this.xVel && (this.xVel *= Math.pow(a.playerDecel, e)),
                       this.yVel && (this.yVel *= Math.pow(a.playerDecel, e));
                   var P = this.scale;
                   this.x - P < 0 ? (this.x = P,
                                     this.xVel = 0) : this.x + P > a.mapScale && (this.x = a.mapScale - P,
                                                                                  this.xVel = 0),
                       this.y - P < 0 ? (this.y = P,
                                         this.yVel = 0) : this.y + P > a.mapScale && (this.y = a.mapScale - P,
                                                                                      this.yVel = 0)
               }
           }
               ,
               this.canSee = function(e) {
               if (!e)
                   return !1;
               if (e.skin && e.skin.invisTimer && e.noMovTimer >= e.skin.invisTimer)
                   return !1;
               var t = Math.abs(e.x - this.x) - e.scale
               , n = Math.abs(e.y - this.y) - e.scale;
               return t <= a.maxScreenWidth / 2 * 1.3 && n <= a.maxScreenHeight / 2 * 1.3
           }
           ;
           var h = 0
           , u = 0;
           this.animate = function(e) {
               this.animTime > 0 && (this.animTime -= e,
                                     this.animTime <= 0 ? (this.animTime = 0,
                                                           this.dirPlus = 0,
                                                           h = 0,
                                                           u = 0) : 0 == u ? (h += e / (this.animSpeed * a.hitReturnRatio),
                                                                              this.dirPlus = s.lerp(0, this.targetAngle, Math.min(1, h)),
                                                                              h >= 1 && (h = 1,
                                                                                         u = 1)) : (h -= e / (this.animSpeed * (1 - a.hitReturnRatio)),
                                                                                                    this.dirPlus = s.lerp(0, this.targetAngle, Math.max(0, h))))
           }
               ,
               this.startAnim = function() {
               this.animTime = this.animSpeed = 600,
                   this.targetAngle = .8 * Math.PI,
                   h = 0,
                   u = 0
           }
               ,
               this.changeHealth = function(e, t, n) {
               if (this.active && (this.health += e,
                                   n && (this.hitScare && !s.randInt(0, this.hitScare) ? (this.runFrom = n,
                                                                                          this.waitCount = 0,
                                                                                          this.moveCount = 2e3) : this.hostile && this.chargePlayer && n.isPlayer ? (this.chargeTarget = n,
            this.waitCount = 0,
            this.moveCount = 8e3) : this.dontRun || (this.runFrom = n,
                                                     this.waitCount = 0,
                                                     this.moveCount = 2e3)),
                                   e < 0 && this.hitRange && s.randInt(0, 1) && (this.hitWait = 500),
                                   t && t.canSee(this) && e < 0 && c.send(t.id, "t", Math.round(this.x), Math.round(this.y), Math.round(-e), 1),
                                   this.health <= 0 && (this.spawnDelay ? (this.spawnCounter = this.spawnDelay,
                                                                           this.x = -1e6,
                                                                           this.y = -1e6) : (this.x = this.startX || s.randInt(0, a.mapScale),
                                                                                             this.y = this.startY || s.randInt(0, a.mapScale)),
                                                        this.health = this.maxHealth,
                                                        this.runFrom = null,
                                                        t && (o(t, this.killScore),
                                                              this.drop))))
                   for (var i = 0; i < this.drop.length; )
                       t.addResource(a.resourceTypes.indexOf(this.drop[i]), this.drop[i + 1]),
                           i += 2
           }
       }
   }
  ]);
//# sourceMappingURL=bundle.js.map
var ws;
var msgpack5 = msgpack;
let myPlayer = {
    id: null,
    x: null,
    y: null,
    dir: null,
    object: null,
    weapon: null,
    clan: null,
    isLeader: null,
    hat: null,
    accessory: null,
    isSkull: null
};
document.msgpack = msgpack;

function websocket(ws, actions) {
    window.WEBSOCKET = ws;
    ws.addEventListener("message", (message) => {
        let data = window.msgpack.decode(message.data);
        if(actions[data[0]]) {
            actions[data[0]].apply(null, data[1]);
        }
    });
}
var client = null;
function send(type) {
    var data = Array.prototype.slice.call(arguments, 1);
    var binary = window.msgpack.encode([type, data]);
    window.WEBSOCKET.send(binary);
}
var mySid = null;
var players = {}, player = {
    weapons: [0],
    items: [0, 3, 6, 10],
    health: 100,
};
function heal(damage) {
    let heal = player.items[0] == 0 ? 20 : player.items[0] == 1 ? 40 : 30;
    let amount = damage / heal;
    for(let i = 0; i < amount; i++) {
        if(player.skinIndex != 45) {
            send("5", player.items[0]);
            send("c", 1);
            send("c", 0);
            send("5", player.weaponIndex, true);
        }
    }
}
WebSocket.prototype.oldSend = WebSocket.prototype.send;
WebSocket.prototype.send = function (m) {
    if (!client) {
        client = new websocket(this, {
            "1": function(sid) {
                mySid = sid;
                player.sid = sid;
            },
            "2": function(data, you) {
                //nothing for now
            },
            "17": function(data, wpn) {
                if (data) {
                    if (wpn) player.weapons = data;
                    else player.items = data;
                }
            },
            "33": function(data) {
                for (var i = 0; i < data.length;) {
                    if (data[i] == mySid) {
                        player.x2 = data[i + 1];
                        player.y2 = data[i + 2];
                        player.d2 = data[i + 3];
                        player.buildIndex = data[i + 4];
                        player.weaponIndex = data[i + 5];
                        player.weaponVariant = data[i + 6];
                        player.team = data[i + 7];
                        player.isLeader = data[i + 8];
                        player.skinIndex = data[i + 9];
                        player.tailIndex = data[i + 10];
                        player.iconIndex = data[i + 11];
                        player.zIndex = data[i + 12];
                    }
                    i+=13;
                }
            },
            "h": function(sid, value) {
                if(mySid == sid) {
                    let damage = value - player.health;
                    if(AHH == true) {
                        if(damage < 0) {
                            damage = Math.abs(damage);
                            setTimeout(() => {
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                            }, 40);
                            setTimeout(() => {
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                            }, 40);
                            setTimeout(() => {
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                            }, 40);
                            setTimeout(() => {
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                            }, 40);
                            setTimeout(() => {
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                                heal(damage);
                            }, 30);
                        }
                        player.health = value;
                    }
                }
            }
        });
    }
    this.oldSend(m);
};
function Test(sender){
    ws.send(new Uint8Array(Array.from(msgpack5.encode(sender))));
}
$("#enterGame").click( () => {
    setTimeout(() => {
        Test(["ch", ["freak ya"]]);
    },250);
});
var menuChange = document.createElement("div");
menuChange.className = "menuCard";
menuChange.id = "mainSettings";
menuChange.style.display = "none"; // Initially hide the menu
menuChange.innerHTML = `
        <div id="simpleModal" class="modal">
            <div class="modal-content x-ray">
                <div class="modal-header">
                    <span class="closeBtn" id="closeBtn">&times;</span>
                    <h2 style="font-size: 50px;">The End The Server</h2>
                </div>
                <div class="modal-body" style="font-size: 15px;">
                    <div class="flexControl">
                        <h2 style="font-size: 30px;">Menu</h2>
                        <label class="container">Autoheal (fast!)<input type="checkbox" id="AHH">
                            <span class="checkmark"></span>
                        </label>
                        <!-- Add more labels here -->
                    </div>
                </div>
            </div>
        </div>
    `;

// Add CSS styles for the x-ray effect and more styles for the menu
var style = document.createElement("style");
style.textContent = `
    .x-ray {
        background-color: rgba(0, 255, 0, 0.1); /* X-ray green color with opacity */
        border: 2px solid #00FF00; /* Green border */
        box-shadow: 0px 0px 20px rgba(0, 255, 0, 0.5); /* Green shadow */
    }

    /* Additional styles for the menu */
    .modal {
        position: fixed;
        top: 0; /* Position at the top */
        left: 0; /* Position at the left */
        background-color: #d4af37;
        color: #fff;
        padding: 20px;
        border-radius: 10px;
        max-width: 600px;
        width: 90%;
        z-index: 1000;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .modal-header h2 {
        margin: 0;
    }

    .container {
        display: block;
        position: relative;
        padding-left: 35px;
        margin-bottom: 12px;
        cursor: pointer;
        font-size: 16px;
    }

    /* Customize other styles as needed */
`;

document.head.appendChild(style);

// Append the menuChange element to the document body
document.body.appendChild(menuChange);

// Event listener to toggle the menu on "Esc" key press
document.addEventListener("keydown", function (event) {
    if (event.key === "Home") {
        var menu = document.getElementById("mainSettings");
        if (menu.style.display === "none" || menu.style.display === "") {
            menu.style.display = "block";
        } else {
            menu.style.display = "none";
        }
    }
});

// Event listener to close the menu when clicking the close button
document.getElementById("closeBtn").addEventListener("click", function () {
    var menu = document.getElementById("mainSettings");
    menu.style.display = "none";
});
var AHH = document.querySelector("#AHH")

AHH.addEventListener('change', function() {
    if (this.checked) {
        AHH = true;
    } else {
        AHH = false;
    }
})

(function() {
    const { msgpack } = window

    function AntiKick() {
        this.resetDelay = 500
        this.packetsLimit = 40

        this.ignoreTypes = [ "pp", "rmd" ]
        this.ignoreQueuePackets = [ "5", "c", "33", "2", "7", "13c" ]

        this.packetsStorage = new Map()
        this.tmpPackets = []
        this.packetsQueue = []

        this.lastSent = Date.now()

        this.onSend = function(data) {
            const binary = new Uint8Array(data)
            const parsed = msgpack.decode(binary)

            if (Date.now() - this.lastSent > this.resetDelay) {
                this.tmpPackets = []

                this.lastSent = Date.now()
            }

            if (!this.ignoreTypes.includes(parsed[0])) {
                if (this.packetsStorage.has(parsed[0])) {
                    const oldPacket = this.packetsStorage.get(parsed[0])

                    switch (parsed[0]) {
                        case "2":
                        case "33":
                            if (oldPacket[0] == parsed[1][0]) return true
                            break
                    }
                }

                if (this.tmpPackets.length > this.packetsLimit) {
                    if (!this.ignoreQueuePackets.includes(parsed[0])) {
                        this.packetsQueue.push(data)
                    }

                    return true
                }

                this.tmpPackets.push({
                    type: parsed[0],
                    data: parsed[1]
                })

                this.packetsStorage.set(parsed[0], parsed[1])
            }

            return false
        }
    }

    const antiKick = new AntiKick()

    let firstSend = false

    window.WebSocket.prototype.send = new Proxy(window.WebSocket.prototype.send, {
        apply: function(target, _this) {
            if (!firstSend) {
                _this.addEventListener("message", (event) => {
                    if (!antiKick.packetsQueue.length) return

                    const binary = new Uint8Array(event.data)
                    const parsed = msgpack.decode(binary)

                    if (parsed[0] === "33") {
                        _this.send(antiKick.packetsQueue[0])

                        antiKick.packetsQueue.shift()
                    }
                })

                firstSend = true
            }

            if (antiKick.onSend(arguments[2][0])) return

            return Reflect.apply(...arguments)
        }
    })
})()
class Antikick {

    constructor( max, max2 ) {

        this.maxRequests = max; // max request in 1 minute default = 3000
        this.maxRequests_ = max2; // max requests in 1 second default = 47

        this.requests = [];
        this.util = {
            hat: 0,
            accessory: 0,
            weapon: 0,
            equipped: 0,
            lastHit: 0,
            oldWeapon: 0,
            lastAngle: 0,
            lastHitAngle: 0,
            isHitting: 0,
            chatted: 0,
            boughtHat: [],
            boughtAcc: [],
            consommable: [0, 1, 2]
        }

        this.totalRequests = 0;
        this.maxAttempted = 0; // when max request per 1 minute reached


        if ( !window.msgpack ) this.loadMsgPack(); // load msgpack if its not loaded already
        this.hookSend(); // start antikick by hooking
    }

    async loadMsgPack() {

    }
    getDistance() {
        return Math.sqrt( (arguments[0] - arguments[1])**2 )
    }

    checkRequest() { // check packet sent ( preventing spamming packet and getting freeze )

        let packetData = msgpack.decode(new Uint8Array(arguments[0]));
        let data = packetData[1]

        switch ( packetData[0] ) {

            case '2': {

                let angle = data[0]
                if ( this.getDistance(this.util.lastAngle,angle ) < 0.01 ) return 0;
                this.util.lastAngle = angle;

            } break;

            case 'c': {

                let hitting = data[0];
                let angle = data[1] ?? this.util.lastAngle

                if ( hitting && +new Date - this.util.lastHit < 200 && this.getDistance(this.util.lastHitAngle, angle) < 0.05 && !this.util.consommable.includes(this.util.weapon) ) return 0;
                if ( !hitting && !this.util.isHitting ) return 0;
                if ( hitting && this.util.isHitting ) return 0;
                if ( hitting ) (this.util.lastHit = +new Date, this.util.lastHitAngle = angle, this.util.isHitting = true);
                if ( !hitting ) this.util.isHitting = false;

            } break;

            case '13c': {

                let buy = data[0];
                let item = data[1];
                let acc = data[2];

                if ( acc && buy && this.util.boughtAcc.includes(item) ) return 0;
                if ( acc && buy ) this.util.boughtAcc.push(item);
                if ( !acc && buy && this.util.boughtHat.includes(item) ) return 0;
                if ( !acc && buy ) this.util.boughtHat.push(item);

                if ( acc && !buy && this.util.accessory == item ) return 0;
                if ( acc && !buy ) this.util.accessory = item;
                if ( !acc && !buy && this.util.hat == item ) return 0;
                if ( !acc && !buy ) this.util.hat = item;

            } break;

            case '5': {

                let item = data[0];

                this.util.weapon = item;

            } break;

            case 'ch': {

                if ( +new Date - this.util.chatted < 1000 ) return 0;
                this.util.chatted = +new Date

            } break;

        }

        return 1;
    }

    hookSend() {

        window.WebSocket.prototype.send = new Proxy(window.WebSocket.prototype.send, {
            apply: function() {
                if ( !PeaAntiKick.checkRequest(arguments[2][0]) ) return;
                if ( !PeaAntiKick.Antikick(arguments[2][0]) ) return;

                PeaAntiKick.totalRequests++
                PeaAntiKick.requests.push([ +new Date, msgpack.decode(new Uint8Array(arguments[2][0])) ])

                return Reflect.apply(...arguments)
            }
        })

    }

    Antikick() { // preventing getting kicked

        let packetData = msgpack.decode(new Uint8Array(arguments[0]));

        if ( this.totalRequests >= this.maxRequests - 60 && !this.maxAttempted ) this.maxAttempted = +new Date;
        if ( packetData[0] == 'pp' ) return 1;
        if ( this.requests[0] && +new Date - this.requests[0][0] > 1000 ) ( this.requests = [], this.util.boughtAcc = [], this.util.boughtHat = [] )
        if ( +new Date - this.maxAttempted > 1000*31 && this.totalRequests >= this.maxRequests-60 ) ( this.totalRequests = 0, this.maxAttempted = 0 );
        if ( this.totalRequests >= this.maxRequests-60 || this.requests.length > this.maxRequests_-2 ) {return 0};

        return 1
    }

}

let PeaAntiKick = new Antikick(3000 , 50)

var primary;
var secondary;
var nearestEnemy;
var nearestEnemyAngle;
var isEnemyNear;
var node = void 0;
var autoaim = false;
var enemiesNear;
var normalAcc;
var normalHat;
var foodType;
let mouseX;
let mouseY;
let width;
let height;
let myPlayers = {
    id: null,
    x: null,
    y: null,
    dir: null,
    object: null,
    weapon: null,
    clan: null,
    isLeader: null,
    hat: null,
    accessory: null,
    isSkull: null
};

document.msgpack = msgpack;
function n(){
    this.buffer = new Uint8Array([0]);
    this.buffer.__proto__ = new Uint8Array;
    this.type = 0;
}

WebSocket.prototype.oldSend = WebSocket.prototype.send;
WebSocket.prototype.send = function(m){
    if (!ws){
        document.ws = this;

        ws = this;
        socketFound(this);
    }
    this.oldSend(m);
};


function socketFound(socket){
    socket.addEventListener('message', function(message){
        handleMessage(message);
    });
}

function handleMessage(m){
    let temp = msgpack5.decode(new Uint8Array(m.data));
    let data;
    if(temp.length > 1) {
        data = [temp[0], ...temp[1]];
        if (data[1] instanceof Array){
            data = data;
        }
    } else {
        data = temp;
    }
    let item = data[0];
    if(!data) {return};

    if(item === "io-init") {
        let cvs = document.getElementById("gameCanvas");
        width = cvs.clientWidth;
        height = cvs.clientHeight;
        $(window).resize(function() {
            width = cvs.clientWidth;
            height = cvs.clientHeight;
        });
        cvs.addEventListener("mousemove", e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
    }

    if (item == "1" && myPlayers.id == null){
        myPlayers.id = data[1];
    }

    if (item == "33") {
        enemiesNear = [];
        for(let i = 0; i < data[1].length / 13; i++) {
            let playerInfo = data[1].slice(13*i, 13*i+13);
            if(playerInfo[0] == myPlayers.id) {
                myPlayers.x = playerInfo[1];
                myPlayers.y = playerInfo[2];
                myPlayers.dir = playerInfo[3];
                myPlayers.object = playerInfo[4];
                myPlayers.weapon = playerInfo[5];
                myPlayers.clan = playerInfo[7];
                myPlayers.isLeader = playerInfo[8];
                myPlayers.hat = playerInfo[9];
                myPlayers.accessory = playerInfo[10];
                myPlayers.isSkull = playerInfo[11];
            } else if(playerInfo[7] != myPlayers.clan || playerInfo[7] === null) {
                enemiesNear.push(playerInfo);
            }
        }
    }

    isEnemyNear = false;
    if(enemiesNear) {
        nearestEnemy = enemiesNear.sort((a,b) => dist(a, myPlayers) - dist(b, myPlayers))[0];
    }

    if(nearestEnemy) {
        nearestEnemyAngle = Math.atan2(nearestEnemy[2]-myPlayers.y, nearestEnemy[1]-myPlayers.x);
        if(Math.sqrt(Math.pow((myPlayers.y-nearestEnemy[2]), 2) + Math.pow((myPlayers.x-nearestEnemy[1]), 2)) < 0) {
            isEnemyNear = true;
            if(autoaim == false && myPlayers.hat != 7 && myPlayers.hat != 53) {
                normalHat = 6;
                if(primary != 8) {
                    normalAcc = 19
                }
            };
        }
    }
    if(isEnemyNear == false && autoaim == false) {
        normalAcc = 11;
        if (myPlayers.y < 2400){
            normalHat = 15;
        } else if (myPlayers.y > 6850 && myPlayers.y < 7550){
            normalHat = 31;
        } else {
            normalHat = 12;
        }
    }
    if (!nearestEnemy) {
        nearestEnemyAngle = myPlayers.dir;
    }

    if(item == "h" && data[1] == myPlayers.id) {
        if(data[2] < 100 && data[2] > 0) {
            setTimeout( () => {
                place(foodType, null);
                place(foodType, null);
                place(foodType, null);
                place(foodType, null);
            }, 20);
            setTimeout( () => {
                place(foodType, null);
                place(foodType, null);
                place(foodType, null);
                chat("");
                Senders(["5", [primary, true]]);
                Senders(["5", [primary, true]]);
            }, 20);

        }
    }
    update();
}
setInterval(() => {
    if(autoaim == true) {
        Senders(["2", [nearestEnemyAngle]]);
    }
}, 20);
function Senders(sender) {
    ws.send(new Uint8Array(Array.from(msgpack5.encode(sender))));
}
function dist(a, b){
    return Math.sqrt( Math.pow((b.y-a[2]), 2) + Math.pow((b.x-a[1]), 2) );
}
function isElementVisible(e) {
    return (e.offsetParent !== null);
}

function chat(sender) {
    Senders(["ch", [sender]]);
}

function place(id, angle = Math.atan2(mouseY - height / 2, mouseX - width / 2)) {
    Senders(["5", [id, null]]);
    Senders(["c", [1, angle]]);
    Senders(["c", [0, angle]]);
    Senders(["5", [myPlayers.weapon, true]]);
}
function update() {
    for (let i=0;i<9;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            primary = i;
        }
    }

    for (let i=9;i<16;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            secondary = i;
        }
    }
    for (let i=16;i<19;i++){
        if (isElementVisible(document.getElementById("actionBarItem" + i.toString()))){
            foodType = i - 16;
        }
    }
}
// ==UserScript==
// @name         ae86
// @author       Alpine A110
// @description  idk random shit + its skidded as fukc
// @version      0
// @match        *://*.moomoo.io/*
// @require      https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js
// @run-at       document-end
// @grant        none
// ==/UserScript==

Math.florr = Math.floor;

function setLoop(action, loop) {
    for (let i = 0; i < loop; i++) {
        action();
    }
}
//press l for song
const song1 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1055142773948428348/Zack_Merci_X_CRVN_-_Nobody_NCS_Release.mp3");
const song2 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1055516288249757797/ae86.mp3");
 selected: true;
const song3 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1069192210932826182/dontstandsoclose.mp3");
const song4 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1083793134162546799/Jonth_Tom_Wilson_Facading_MAGNUS_Jagsy_Vosai_RudeLies__Domastic_-_Heartless_NCS10_Release_-_from_YouTube.mp3");
const song5 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1086876186887594076/boobmoo.mp3");
const song6 = new Audio("https://cdn.discordapp.com/attachments/1053956635032289280/1110020974180573264/ooooaadhahaha.mp3");
const song7 = new Audio("https://cdn.discordapp.com/attachments/1119237651392901120/1123243595164561498/VIZEofficial_x_Alan_Walker_Space_Melody_Edward_Artemyev_feat._Leony_Official_Music_Video.mp3");


function getEl(id) {
    return document.getElementById(id);
}
let firstConfig = [];
let streamerMode = false;
const HTML = {
    newLine: function(amount) {
        let text = ``;
        for (let i = 0; i < amount; i++) {
            text += `<br>`;
        }
        return text;
    },
    line: function() {
        return `<hr>`;
    },
    text: function(id, value, size, length) {
        return `<input type = "text" id = ${id} size = ${size} value = ${value} maxlength = ${length}>`;
    },
    checkBox: function(id, name, checked, rl) {
        return `${rl ? name + ` ` : ``}<input type = "checkbox" ${checked ? `checked` : ``} id = ${id}>${rl ? `` : ` ` + name}`;
    },
    button: function(id, name, onclick, classs) {
        return `<button class = ${classs} id = ${id} onclick = ${onclick}>${name}</button>`;
    },
    select: function(id, selects) {
        let text = `<select id = ${id}>`;
        selects.forEach((e,i)=>{
            text += `<option value = ${e.value} ${e.selected ? ` selected` : ``}>${e.name}</option>`;
            if (i == selects.length - 1) {
                text += `</select>`;
            }
        }
                       );
        return text;
    },
    modChange: function(id, selects) {
        console.log("test");
    },
    mod: function(id, selects) {
        let text = `<select id = ${id}>`;
        selects.forEach((e,i)=>{
            text += `<option value = ${e.value + "C"}>${e.name}</option>`;
            if (i == selects.length - 1) {
                text += `</select> `;
            }
            if (i == 0) {
                firstConfig.push(e.value + "C");
            }
        }
                       );
        selects.forEach((e,i)=>{
            text += `<input type = "checkbox"  ${e.checked ? `checked` : ``} id = ${e.value} style = "${i == 0 ? "display: inline-block;" : "display: none;"}">`;
        }
                       );
        return text;
    },
    hotkey: function(id, value, size, length) {
        return `<input type = "text" id = ${id} size = ${size} value = ${value} maxlength = ${length}><input type = "checkbox" checked id = ${id + "k"}>`;
    },
};

function getTabId(el) {
    return el.id == "tHome" ? "homeTab" : el.id == "t1" ? "miscTab" : el.id == "t2" ? "configTab" : el.id == "t3" ? "combatTab" : "homeTab";
}

function changer() {
    getEl("homeTab").style.display = "none";
    getEl("miscTab").style.display = "none";
    getEl("configTab").style.display = "none";
    getEl("combatTab").style.display = "none";
    getEl("tHome").style.border = "2px solid transparent";
    getEl("tHome").style.color = "#fff";
    getEl("tHome").style.backgroundColor = "#000";
    for (let i = 1; i <= 3; i++) {
        getEl("t" + i).style.border = "2px solid transparent";
        getEl("t" + i).style.color = "#fff";
        getEl("t" + i).style.backgroundColor = "#000";
    }
}

function changeDisp(el) {
    changer();
    getEl(el.id).style.color = "#000";
    getEl(el.id).style.backgroundColor = "#fff";
    getEl(el.id).style.border = "2px solid #000";
    getEl(getTabId(el)).style.display = "block";
}
let updateLogs = `
Toggle:${HTML.newLine(1)}
${HTML.checkBox("ranName", "randomName", false)}${HTML.newLine(1)}
`;
let Wut = "Select";
// menu html
let modMenus = document.createElement("div");
modMenus.id = "modMenus";
document.body.append(modMenus);
modMenus.style = `
display: none;
padding: 10px;
background-color: rgba(0, 0, 0, 0.75);
border-radius: 4px;
position: absolute;
left: 20px;
right: 20px;
width: 400px;
height: 800;
transition: 1s;
`;
let canmove = true;

function updateInnerHTML() {
    modMenus.innerHTML = `
    <style>
    .tabchange {
    color: #ADD8E6;
    background-color: #000;
    border: 2px solid transparent;
    border-radius: 5px;
    text-align: center;
    height: 25px;
    }
    .menuTabs {
    padding-left: 5px;
    padding-top: 5px;
    padding-bottom: 5px;
    }
    .holder {
    padding-left: 1em;
    }
    .nothing {
    }
    </style>
    <script>
    function test() {
    console.log("call");
    }
    </script>
    <div id = "headline" style = "font-size: 30px; color: rgb(255, 255, 255);">
    <div class = "menuTabs">
    ${HTML.button("tHome", "H1", "", "tabchange")}
    ${HTML.button("t1", "m1", "", "tabchange")}
    ${HTML.button("t2", "m2", "", "tabchange")}
    ${HTML.button("t3", "m3", "", "tabchange")}
    </div>
    <div style = "font-size: 12px; overflow-y: scroll; max-height: 150px;" max-width: 150px;>
    <div id = "homeTab" style = "display: block">
    <div id = "priXP">Primary XP: 0 / not found</div>
    <div id = "secXP">Seconadry XP: 0 / not found</div>
    <div id = "healer">Healer: High Ping</div>
    </div>
    <div id = "miscTab" style = "display: none">
    Create clan: ${HTML.text("ccv", ".", "20", "7")}${HTML.newLine(1)}
    ${HTML.button("ccf", "Create clan", `document.createAlliance(document.getElementById("ccv").value)`, "nothing")}${HTML.newLine(1)}
    ${HTML.select("autoupgrade", [{
        name: "Autoupgrade to DH",
        value: "dh",
    }, {
        name: "Autoupgrade to KH",
        value: "kh",
    }, {
        name: "Autoupgrade to SM",
        value: "sm",
    }, ])}${HTML.newLine(1)}
    7-Slot: ${HTML.select("7slot", [{
        name: "Teleporter",
        value: "38",
    }, {
        name: "Turret",
        value: "33",
    }, ])}${HTML.newLine(1)}
    </div>
     ~Ae86~
    ${HTML.text("aaauaua", "", false)}${HTML.newLine(1)}
    </div>
    <div id = "configTab" style = "display: none">
    ${HTML.mod("configs", [{
        name: "AddAdditionalRangeOnLag",
        value: "addictdist",
        checked: true
    }, {
        name: "AntiKick",
        value: "ak",
        checked: true
    }, {
        name: "Texture",
        value: "kmtexture",
        checked: true
    }, {
        name: "AutoBullTick",
        value: "bulltick",
    }, {
        name: "AutoQsync",
        value: "antisync",
        checked: true
    }, {
        name: "HighPingHeal",
        value: "autoq",
        checked: true
    }, {
        name: "AntiInsta",
        value: "simpleheal",
        checked: true
    }, {
        name: "TickHealing",
        value: "tickheal",
        checked: true
    }, {
        name: "TeamSyncWithChat",
        value: "teamsync",
        checked: true
    }, {
        name: "AutoSpikeTickOnReplaced",
        value: "spiketick",
        checked: true
    }, {
        name: "UseTurretOnCounter",
        value: "countertur",
        checked: true
    }, {
        name: "UseSecondaryOnCounter",
        value: "countersec",
    }, {
        name: "ClickCombat",
        value: "clicktype",
    }, {
        name: "utoSpinning",
        value: "spin",
    }, {
        name: "BuildingHealth",
        value: "bh",
    }, {
        name: "RenderDark",
        value: "darkmode",
    }, {
        name: "ShowStackedAnimtext",
        value: "stacktext",
    }, {
        name: "DisableAnimtext",
        value: "hidetext",
    }, {
        name: "UpperCaseChatting",
        value: "chatc",
    }, {
        name: "TryHardMode",
        value: "tryhard",
        checked: true
    }, {
        name: "AlwaysRevInsta",
        value: "alwaysrev",
        checked: false
    }, {
        name: "BotMovementToNear",
        value: "botmove",
    }, ])}${HTML.newLine(1)}
    <div id = "freeCam">Freecam: none</div>
    Freecam hotkey: ${HTML.hotkey("freecumLOL", "/", "2", "1")}${HTML.newLine(1)}
    Bow Insta hotkey: ${HTML.hotkey("bowinstakey", "g", "2", "1")}${HTML.newLine(1)}
    Stacked Insta: ${HTML.hotkey("StackedInsta", "o", "2", "1")}${HTML.newLine(1)}
    One Frame hotkey: ${HTML.hotkey("zeroframe", "t", "2", "1")}${HTML.newLine(1)}
    Team Sync hotkey: ${HTML.hotkey("synckey", "b", "2", "1")}${HTML.newLine(1)}
    Debug hotkey: ${HTML.hotkey("debugkey", "Z", "2", "1")}${HTML.newLine(1)}
    Spike hotkey: ${HTML.hotkey("spikekey", "v", "2", "1")}${HTML.newLine(1)}
    Trap/Boost hotkey: ${HTML.hotkey("trapkey", "f", "2", "1")}${HTML.newLine(1)}
    Turret/Teleport hotkey: ${HTML.hotkey("turretkey", "h", "2", "1")}${HTML.newLine(1)}
    Automill hotkey: ${HTML.hotkey("millkey", "n", "2", "1")}${HTML.newLine(1)}
    Connectbot hotkey: ${HTML.hotkey("botkey", "G", "2", "1")}${HTML.newLine(1)}
    Zoom hotkey: ${HTML.hotkey("zoomkey", "-", "2", "1")}${HTML.newLine(1)}
    Zoom reset key: ${HTML.hotkey("zoomresetkey", "=", "2", "1")}${HTML.newLine(1)}
    Song hotkey: ${HTML.hotkey("songkey", "l", "2", "1")}${HTML.newLine(1)}
    Song: ${HTML.select("songs", [{
        name: "CRVN - Nobody",
        value: "1",
    }, {
        name: "Bryan Finlay, Rival - Walls",
        value: "2",
    }, {
        name: "Dr Love - Don't Stand So Close",
        value: "3",
    }, {
        name: "Domastic - Heartless",
        value: "4",
    }, {
        name: "PVRIS - Burn It All Down",
        value: "5",
    }, {
        name: "Crypt x Joey Nato - Invincible",
        value: "6",
    }, {
        Name: "Alan Walker - Space Melody",
        value: "7",
        }, {
        selected: true
    }, ])}${HTML.newLine(1)}
      ${HTML.checkBox("showch", "sendChatPacket", true, true)}${HTML.newLine(1)}
    Ratio hotkey: ${HTML.hotkey("ezkey", "p", "2", "1")}${HTML.newLine(1)}
    Vision: ${HTML.select("vision", [{
        name: "1",
        value: "1",
    }, {
        name: "1.1",
        value: "1.1",
        selected: true,
    }, {
        name: "1.2",
        value: "1.2",
    }, {
        name: "1.3",
        value: "1.3",
    }, {
        name: "1.4",
        value: "1.4",
    }, {
        name: "1.5",
        value: "1.5",
    }, ])}${HTML.newLine(1)}
    ExtraCombat(Beta): ${HTML.select("combat", [{
        name: "Original",
        value: "zyenith",
        selected: true,
    }, {
        name: "ae86",
        value: "ae",
    }, ])} - <div id = "crp" style = "display: inline-block;">lol ur bad</div>${HTML.newLine(1)}
    ExtraVisual: ${HTML.select("visual", [{
        name: "Original",
        value: "0",
        selected: true,
    }, {
    }, ])} - <div id = "vrp" style = "display: inline-block;">lol ur b a d</div>${HTML.newLine(1)}
    </div>
    <div id = "combatTab" style = "display: none">
    (region locked) ${HTML.button("serverwarper", "Warp to Active Server", `document.warpServer()`, "nothing")}${HTML.newLine(2)}
    Object for the placer: ${HTML.mod("placeconfig", [{
        name: "Windmills",
        value: "3",
        checked: true,
    }, {
    }, ])}${HTML.newLine(2)}
    One-way: ${HTML.button("streamer", "Streamer Mode", "", "nothing")}${HTML.newLine(2)}
    ~AutoFarm~
    <div class = "holder">
    ${HTML.checkBox("grind", "autoRuby", false)}${HTML.newLine(1)}
    ${HTML.checkBox("grindsec", "autoRubySec", true)}${HTML.newLine(1)}
    </div>
    ~Anti~
    <div class = "holder">
    ${HTML.checkBox("soldieranti", "soldierAntiInsta", true)}${HTML.newLine(1)}
    ${HTML.checkBox("soldierempanti", "soldierEmpAntiInsta", true)}${HTML.newLine(1)}
    ${HTML.checkBox("antitick", "anti0Tick", true)}${HTML.newLine(1)}
    ${HTML.checkBox("antirange", "antiRangedInsta", true)}${HTML.newLine(1)}
    </div>
    ~AutoBreak~
    <div class = "holder">
    ${HTML.checkBox("earlyab", "early", true)}${HTML.newLine(1)}
    earlyWaitTime ${HTML.newLine(1)}
    ${HTML.text("earlytime", "10", "6", "5")}${HTML.newLine(1)}
    ${HTML.checkBox("abactive", "activate", true)}${HTML.newLine(1)}
    ${HTML.checkBox("ab360hit", "breakitems(Patched)", false)}${HTML.newLine(1)}
    ${HTML.checkBox("abplace", "PlacementTick", true)}${HTML.newLine(1)}
    </div>
    ~autoTrigger~
    <div class = "holder">
    ${HTML.checkBox("sync", "syncShots", false)}${HTML.newLine(1)}
    syncThrottle ${HTML.newLine(1)}
    ${HTML.text("synccount", "1", "6", "2")}${HTML.newLine(1)}
    </div>
    ~MouseSync~
    <div class = "holder">
    ${HTML.checkBox("clicksync", "mclickSync", false)}${HTML.newLine(1)}
    </div>
    ~autoQ~
    <div class = "holder">
    ${HTML.checkBox("evautoq", "alwaysOn", true)}${HTML.newLine(1)}
    </div>
    ~AutoPlace~
    <div class = "holder">
    ${HTML.checkBox("replc", "AutoReplace", true)}${HTML.newLine(1)}
    ${HTML.checkBox("autoplc", "TickPlaceMent", true)}${HTML.newLine(1)}
    </div>
    ~AutoUpgrade~
    <div class = "holder">
    ${HTML.checkBox("not", "activate", false)}${HTML.newLine(1)}
    </div>
    </div>
    </div>
    `;
}
updateInnerHTML();
changeDisp(getEl("tHome"));
getEl("tHome").onclick = function() {
    changeDisp(this);
}
;
getEl("t1").onclick = function() {
    changeDisp(this);
}
;
getEl("t2").onclick = function() {
    changeDisp(this);
}
;
getEl("t3").onclick = function() {
    changeDisp(this);
}
;
getEl("streamer").onclick = function() {
    streamerMode = !streamerMode;
}
;
getEl("ccv").onfocus = function() {
    canmove = false;
};
getEl("ccv").onblur = function() {
    canmove = true;
};
let oldSelect = firstConfig[0];
let newSelect = firstConfig[0];
getEl("configs").onchange = function() {
    let value = getEl("configs").value;
    let sliced = function(val) {
        return val.slice(0, val.length - 1);
    };
    oldSelect = newSelect;
    newSelect = value;
    getEl(sliced(oldSelect)).style.display = "none";
    getEl(sliced(newSelect)).style.display = "inline-block";
}
;
function checkCheckChickenModV69(a) {
    let aw = a == "0" ? "Ae86" : a == "spyder" ? "Quasar mod" : a == "lore" ? "L._.re" : a == "zeph" ? "idk fr" : a == "cele" ? "Goofy Mod" : a == "ae" ? "Alpine A110" : a == "fz" ? "RV2" : a == "zyenith" ? "Ae86" : a == "me" ? "Pre Client V69420" : a == "hans" ? "Sofia Client" : "unknown";
    return aw;
}

getEl("crp").innerHTML = checkCheckChickenModV69(getEl("combat").value);
getEl("vrp").innerHTML = checkCheckChickenModV69(getEl("visual").value);

document.gototouchgrass = function() {
    window.onbeforeunload = undefined;
    window.location.href = "https://www.youtube.com/watch?v=dQw4w9WgXcQ";
}

let urGameRegion = "";
let botSockets = [];
let firstMan = true;
let manClan = undefined;
let healLag = 100;
var secPacket = 0;
var minPacket = 0;
var secMax = 110;
var minMax = 5100;
var secTime = 1000;
var minTime = 60000;
var firstSend = {
    sec: false,
    min: false,
};
let tmpAddress;
let wsconnected = 0;
let doMouseMove = false;
let myConfig = {
    x: 0,
    y: 0,
    sync: false,
};
let myNearAim = undefined;
let doEnemyMove = false;

function bConnect(token) {
    let o = token && new WebSocket(tmpAddress + "&token=" + encodeURIComponent(token));
    o.binaryType = "arraybuffer";
    o.firstMan = firstMan ? true : false;
    firstMan = false;
    if (o.firstMan) {
        o.allianceNotifications = [];
        o.tickC = 0;
    }

    function wsSend(ms) {
        o.send(new Uint8Array(Array.from(window.msgpack.encode(ms))));
    }

    function botSpawn() {
        wsSend(["sp", [{
            name: "punching bag",
            moofoll: 1,
            skin: "constructor",
        }]]);
    }
    o.onopen = function() {
        wsconnected++;
        botSpawn();
        botSockets.push(o);
    };
    o.onclose = function() {
        if (o.firstMan) {
            firstMan = true;
        }
    };
}


/******/
(function(modules) {
    // webpackBootstrap
    /******/
    // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/
    // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/
        // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/
        // Create a new module (and put it into the cache)
        /******/
        var module = (installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {},
            /******/
        });
        /******/
        /******/
        // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/
        // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/
        // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/
    // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/
    // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/
    // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter,
            });
            /******/
        }
        /******/
    }
    ;
    /******/
    /******/
    // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module",
            });
            /******/
        }
        /******/
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        /******/
    }
    ;
    /******/
    /******/
    // create a fake namespace object
    /******/
    // mode & 1: value is a module id, require it
    /******/
    // mode & 2: merge all properties of value into the ns
    /******/
    // mode & 4: return value when already ns object
    /******/
    // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1)
            value = __webpack_require__(value);
        /******/
        if (mode & 8)
            return value;
        /******/
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, "default", {
            enumerable: true,
            value: value,
        });
        /******/
        if (mode & 2 && typeof value != "string")
            for (var key in value)
                __webpack_require__.d(ns, key, function(key) {
                    return value[key];
                }
                                      .bind(null, key));
        /******/
        return ns;
        /******/
    }
    ;
    /******/
    /******/
    // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ? /******/
            function getDefault() {
                return module["default"];
            }
        : /******/
        function getModuleExports() {
            return module;
        }
        ;
        /******/
        __webpack_require__.d(getter, "a", getter);
        /******/
        return getter;
        /******/
    }
    ;
    /******/
    /******/
    // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    }
    ;
    /******/
    /******/
    // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/
    // Load entry module and return exports
    /******/
    return __webpack_require__((__webpack_require__.s = "./src/js/app.js"));
    /******/
}
)(/************************************************************************/
    /******/
    {
        /***/
        "./node_modules/bad-words/lib/badwords.js": /*!************************************************!*\
  !*** ./node_modules/bad-words/lib/badwords.js ***!
  \************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            const localList = __webpack_require__(/*! ./lang.json */
                "./node_modules/bad-words/lib/lang.json").words;
            const baseList = __webpack_require__(/*! badwords-list */
                "./node_modules/badwords-list/lib/index.js").array;
            class Filter {
                /**
                     * Filter constructor.
                     * @constructor
                     * @param {object} options - Filter instance options
                     * @param {boolean} options.emptyList - Instantiate filter with no blacklist
                     * @param {array} options.list - Instantiate filter with custom list
                     * @param {string} options.placeHolder - Character used to replace profane words.
                     * @param {string} options.regex - Regular expression used to sanitize words before comparing them to blacklist.
                     * @param {string} options.replaceRegex - Regular expression used to replace profane words with placeHolder.
                     */
                constructor(options={}) {
                    Object.assign(this, {
                        list: (options.emptyList && []) || Array.prototype.concat.apply(localList, [baseList, options.list || [], ]),
                        exclude: options.exclude || [],
                        placeHolder: options.placeHolder || "*",
                        regex: options.regex || /[^a-zA-Z0-9|\$|\@]|\^/g,
                        replaceRegex: options.replaceRegex || /\w/g,
                    });
                }
                /**
                     * Determine if a string contains profane language.
                     * @param {string} string - String to evaluate for profanity.
                     */
                isProfane(string) {
                    return (this.list.filter((word)=>{
                        const wordExp = new RegExp(`\\b ${word.replace(/(\W)/g, "\\$1")}\\b`,"gi");
                        return (!this.exclude.includes(word.toLowerCase()) && wordExp.test(string));
                    }
                                            ).length > 0 || false);
                }
                /**
                     * Replace a word with placeHolder characters;
                     * @param {string} string - String to replace.
                     */
                replaceWord(string) {
                    return string.replace(this.regex, "").replace(this.replaceRegex, this.placeHolder);
                }
                /**
                     * Evaluate a string for profanity and return an edited version.
                     * @param {string} string - Sentence to filter.
                     */
                clean(string) {
                    return string.split(/\b/).map((word)=>{
                        return this.isProfane(word) ? this.replaceWord(word) : word;
                    }
                                                 ).join("");
                }
                /**
                     * Add word(s) to blacklist filter / remove words from whitelist filter
                     * @param {...string} word - Word(s) to add to blacklist
                     */
                addWords() {
                    let words = Array.from(arguments);
                    this.list.push(...words);
                    words.map((word)=>word.toLowerCase()).forEach((word)=>{
                        if (this.exclude.includes(word)) {
                            this.exclude.splice(this.exclude.indexOf(word), 1);
                        }
                    }
                                                                 );
                }
                /**
                     * Add words to whitelist filter
                     * @param {...string} word - Word(s) to add to whitelist.
                     */
                removeWords() {
                    this.exclude.push(...Array.from(arguments).map((word)=>word.toLowerCase()));
                }
            }
            module.exports = Filter;
            /***/
        },
        /***/
        "./node_modules/bad-words/lib/lang.json": /*!**********************************************!*\
  !*** ./node_modules/bad-words/lib/lang.json ***!
  \**********************************************/
        /*! exports provided: words, default */
        /***/
        function(module) {
            module.exports = {
                words: ["ahole", "anus", "ash0le", "ash0les", "asholes", "ass", "Ass Monkey", "Assface", "assh0le", "assh0lez", "asshole", "assholes", "assholz", "asswipe", "azzhole", "bassterds", "bastard", "bastards", "bastardz", "basterds", "basterdz", "Biatch", "bitch", "bitches", "Blow Job", "boffing", "butthole", "buttwipe", "c0ck", "c0cks", "c0k", "Carpet Muncher", "cawk", "cawks", "Clit", "cnts", "cntz", "cock", "cockhead", "cock-head", "cocks", "CockSucker", "cock-sucker", "crap", "cum", "cunt", "cunts", "cuntz", "dick", "dild0", "dild0s", "dildo", "dildos", "dilld0", "dilld0s", "dominatricks", "dominatrics", "dominatrix", "dyke", "enema", "f u c k", "f u c k e r", "fag", "fag1t", "faget", "fagg1t", "faggit", "faggot", "fagg0t", "fagit", "fags", "fagz", "faig", "faigs", "fart", "flipping the bird", "fuck", "fucker", "fuckin", "fucking", "fucks", "Fudge Packer", "fuk", "Fukah", "Fuken", "fuker", "Fukin", "Fukk", "Fukkah", "Fukken", "Fukker", "Fukkin", "g00k", "God-damned", "h00r", "h0ar", "h0re", "hells", "hoar", "hoor", "hoore", "jackoff", "jap", "japs", "jerk-off", "jisim", "jiss", "jizm", "jizz", "knob", "knobs", "knobz", "kunt", "kunts", "kuntz", "Lezzian", "Lipshits", "Lipshitz", "masochist", "masokist", "massterbait", "masstrbait", "masstrbate", "masterbaiter", "masterbate", "masterbates", "Motha Fucker", "Motha Fuker", "Motha Fukkah", "Motha Fukker", "Mother Fucker", "Mother Fukah", "Mother Fuker", "Mother Fukkah", "Mother Fukker", "mother-fucker", "Mutha Fucker", "Mutha Fukah", "Mutha Fuker", "Mutha Fukkah", "Mutha Fukker", "n1gr", "nastt", "nigger;", "nigur;", "niiger;", "niigr;", "orafis", "orgasim;", "orgasm", "orgasum", "oriface", "orifice", "orifiss", "packi", "packie", "packy", "paki", "pakie", "paky", "pecker", "peeenus", "peeenusss", "peenus", "peinus", "pen1s", "penas", "penis", "penis-breath", "penus", "penuus", "Phuc", "Phuck", "Phuk", "Phuker", "Phukker", "polac", "polack", "polak", "Poonani", "pr1c", "pr1ck", "pr1k", "pusse", "pussee", "pussy", "puuke", "puuker", "queer", "queers", "queerz", "qweers", "qweerz", "qweir", "recktum", "rectum", "retard", "sadist", "scank", "schlong", "screwing", "semen", "sex", "sexy", "Sh!t", "sh1t", "sh1ter", "sh1ts", "sh1tter", "sh1tz", "shit", "shits", "shitter", "Shitty", "Shity", "shitz", "Shyt", "Shyte", "Shytty", "Shyty", "skanck", "skank", "skankee", "skankey", "skanks", "Skanky", "slag", "slut", "sluts", "Slutty", "slutz", "son-of-a-bitch", "tit", "turd", "va1jina", "vag1na", "vagiina", "vagina", "vaj1na", "vajina", "vullva", "vulva", "w0p", "wh00r", "wh0re", "whore", "xrated", "xxx", "b!+ch", "bitch", "blowjob", "clit", "arschloch", "fuck", "shit", "ass", "asshole", "b!tch", "b17ch", "b1tch", "bastard", "bi+ch", "boiolas", "buceta", "c0ck", "cawk", "chink", "cipa", "clits", "cock", "cum", "cunt", "dildo", "dirsa", "ejakulate", "fatass", "fcuk", "fuk", "fux0r", "hoer", "hore", "jism", "kawk", "l3itch", "l3i+ch", "lesbian", "masturbate", "masterbat*", "masterbat3", "motherfucker", "s.o.b.", "mofo", "nazi", "nigga", "nigger", "nutsack", "phuck", "pimpis", "pusse", "pussy", "scrotum", "sh!t", "shemale", "shi+", "sh!+", "slut", "smut", "teets", "tits", "boobs", "b00bs", "teez", "testical", "testicle", "titt", "w00se", "jackoff", "wank", "whoar", "whore", "*damn", "*dyke", "*fuck*", "*shit*", "@$$", "amcik", "andskota", "arse*", "assrammer", "ayir", "bi7ch", "bitch*", "bollock*", "breasts", "butt-pirate", "cabron", "cazzo", "chraa", "chuj", "Cock*", "cunt*", "d4mn", "daygo", "dego", "dick*", "dike*", "dupa", "dziwka", "ejackulate", "Ekrem*", "Ekto", "enculer", "faen", "fag*", "fanculo", "fanny", "feces", "feg", "Felcher", "ficken", "fitt*", "Flikker", "foreskin", "Fotze", "Fu(*", "fuk*", "futkretzn", "gook", "guiena", "h0r", "h4x0r", "hell", "helvete", "hoer*", "honkey", "Huevon", "hui", "injun", "jizz", "kanker*", "kike", "klootzak", "kraut", "knulle", "kuk", "kuksuger", "Kurac", "kurwa", "kusi*", "kyrpa*", "lesbo", "mamhoon", "masturbat*", "merd*", "mibun", "monkleigh", "mouliewop", "muie", "mulkku", "muschi", "nazis", "nepesaurio", "nigger*", "orospu", "paska*", "perse", "picka", "pierdol*", "pillu*", "pimmel", "piss*", "pizda", "poontsee", "poop", "porn", "p0rn", "pr0n", "preteen", "pula", "pule", "puta", "puto", "qahbeh", "queef*", "rautenberg", "schaffer", "scheiss*", "schlampe", "schmuck", "screw", "sh!t*", "sharmuta", "sharmute", "shipal", "shiz", "skribz", "skurwysyn", "sphencter", "spic", "spierdalaj", "splooge", "suka", "b00b*", "testicle*", "titt*", "twat", "vittu", "wank*", "wetback*", "wichser", "wop*", "yed", "zabourah", ],
            };
            /***/
        },
        /***/
        "./node_modules/badwords-list/lib/array.js": /*!*************************************************!*\
  !*** ./node_modules/badwords-list/lib/array.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            module.exports = ["4r5e", "5h1t", "5hit", "a55", "anal", "anus", "ar5e", "arrse", "arse", "ass", "ass-fucker", "asses", "assfucker", "assfukka", "asshole", "assholes", "asswhole", "a_s_s", "b!tch", "b00bs", "b17ch", "b1tch", "ballbag", "balls", "ballsack", "bastard", "beastial", "beastiality", "bellend", "bestial", "bestiality", "bi+ch", "biatch", "bitch", "bitcher", "bitchers", "bitches", "bitchin", "bitching", "bloody", "blow job", "blowjob", "blowjobs", "boiolas", "bollock", "bollok", "boner", "boob", "boobs", "booobs", "boooobs", "booooobs", "booooooobs", "breasts", "buceta", "bugger", "bum", "bunny fucker", "butt", "butthole", "buttmuch", "buttplug", "c0ck", "c0cksucker", "carpet muncher", "cawk", "chink", "cipa", "cl1t", "clit", "clitoris", "clits", "cnut", "cock", "cock-sucker", "cockface", "cockhead", "cockmunch", "cockmuncher", "cocks", "cocksuck", "cocksucked", "cocksucker", "cocksucking", "cocksucks", "cocksuka", "cocksukka", "cok", "cokmuncher", "coksucka", "coon", "cox", "crap", "cum", "cummer", "cumming", "cums", "cumshot", "cunilingus", "cunillingus", "cunnilingus", "cunt", "cuntlick", "cuntlicker", "cuntlicking", "cunts", "cyalis", "cyberfuc", "cyberfuck", "cyberfucked", "cyberfucker", "cyberfuckers", "cyberfucking", "d1ck", "damn", "dick", "dickhead", "dildo", "dildos", "dink", "dinks", "dirsa", "dlck", "dog-fucker", "doggin", "dogging", "donkeyribber", "doosh", "duche", "dyke", "ejaculate", "ejaculated", "ejaculates", "ejaculating", "ejaculatings", "ejaculation", "ejakulate", "f u c k", "f u c k e r", "f4nny", "fag", "fagging", "faggitt", "faggot", "faggs", "fagot", "fagots", "fags", "fanny", "fannyflaps", "fannyfucker", "fanyy", "fatass", "fcuk", "fcuker", "fcuking", "feck", "fecker", "felching", "fellate", "fellatio", "fingerfuck", "fingerfucked", "fingerfucker", "fingerfuckers", "fingerfucking", "fingerfucks", "fistfuck", "fistfucked", "fistfucker", "fistfuckers", "fistfucking", "fistfuckings", "fistfucks", "flange", "fook", "fooker", "fuck", "fucka", "fucked", "fucker", "fuckers", "fuckhead", "fuckheads", "fuckin", "fucking", "fuckings", "fuckingshitmotherfucker", "fuckme", "fucks", "fuckwhit", "fuckwit", "fudge packer", "fudgepacker", "fuk", "fuker", "fukker", "fukkin", "fuks", "fukwhit", "fukwit", "fux", "fux0r", "f_u_c_k", "gangbang", "gangbanged", "gangbangs", "gaylord", "gaysex", "goatse", "God", "god-dam", "god-damned", "goddamn", "goddamned", "hardcoresex", "hell", "heshe", "hoar", "hoare", "hoer", "homo", "hore", "horniest", "horny", "hotsex", "jack-off", "jackoff", "jap", "jerk-off", "jism", "jiz", "jizm", "jizz", "kawk", "knob", "knobead", "knobed", "knobend", "knobhead", "knobjocky", "knobjokey", "kock", "kondum", "kondums", "kum", "kummer", "kumming", "kums", "kunilingus", "l3i+ch", "l3itch", "labia", "lust", "lusting", "m0f0", "m0fo", "m45terbate", "ma5terb8", "ma5terbate", "masochist", "master-bate", "masterb8", "masterbat*", "masterbat3", "masterbate", "masterbation", "masterbations", "masturbate", "mo-fo", "mof0", "mofo", "mothafuck", "mothafucka", "mothafuckas", "mothafuckaz", "mothafucked", "mothafucker", "mothafuckers", "mothafuckin", "mothafucking", "mothafuckings", "mothafucks", "mother fucker", "motherfuck", "motherfucked", "motherfucker", "motherfuckers", "motherfuckin", "motherfucking", "motherfuckings", "motherfuckka", "motherfucks", "muff", "mutha", "muthafecker", "muthafuckker", "muther", "mutherfucker", "n1gga", "n1gger", "nazi", "nigg3r", "nigg4h", "nigga", "niggah", "niggas", "niggaz", "nigger", "niggers", "nob", "nob jokey", "nobhead", "nobjocky", "nobjokey", "numbnuts", "nutsack", "orgasim", "orgasims", "orgasm", "orgasms", "p0rn", "pawn", "pecker", "penis", "penisfucker", "phonesex", "phuck", "phuk", "phuked", "phuking", "phukked", "phukking", "phuks", "phuq", "pigfucker", "pimpis", "piss", "pissed", "pisser", "pissers", "pisses", "pissflaps", "pissin", "pissing", "pissoff", "poop", "porn", "porno", "pornography", "pornos", "prick", "pricks", "pron", "pube", "pusse", "pussi", "pussies", "pussy", "pussys", "rectum", "retard", "rimjaw", "rimming", "s hit", "s.o.b.", "sadist", "schlong", "screwing", "scroat", "scrote", "scrotum", "semen", "sex", "sh!+", "sh!t", "sh1t", "shag", "shagger", "shaggin", "shagging", "shemale", "shi+", "shit", "shitdick", "shite", "shited", "shitey", "shitfuck", "shitfull", "shithead", "shiting", "shitings", "shits", "shitted", "shitter", "shitters", "shitting", "shittings", "shitty", "skank", "slut", "sluts", "smegma", "smut", "snatch", "son-of-a-bitch", "spac", "spunk", "s_h_i_t", "t1tt1e5", "t1tties", "teets", "teez", "testical", "testicle", "tit", "titfuck", "tits", "titt", "tittie5", "tittiefucker", "titties", "tittyfuck", "tittywank", "titwank", "tosser", "turd", "tw4t", "twat", "twathead", "twatty", "twunt", "twunter", "v14gra", "v1gra", "vagina", "viagra", "vulva", "w00se", "wang", "wank", "wanker", "wanky", "whoar", "whore", "willies", "willy", "xrated", "xxx", ];
            /***/
        },
        /***/
        "./node_modules/badwords-list/lib/index.js": /*!*************************************************!*\
  !*** ./node_modules/badwords-list/lib/index.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            module.exports = {
                object: __webpack_require__(/*! ./object */
                    "./node_modules/badwords-list/lib/object.js"),
                array: __webpack_require__(/*! ./array */
                    "./node_modules/badwords-list/lib/array.js"),
                regex: __webpack_require__(/*! ./regexp */
                    "./node_modules/badwords-list/lib/regexp.js"),
            };
            /***/
        },
        /***/
        "./node_modules/badwords-list/lib/object.js": /*!**************************************************!*\
  !*** ./node_modules/badwords-list/lib/object.js ***!
  \**************************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            module.exports = {
                "4r5e": 1,
                "5h1t": 1,
                "5hit": 1,
                a55: 1,
                anal: 1,
                anus: 1,
                ar5e: 1,
                arrse: 1,
                arse: 1,
                ass: 1,
                "ass-fucker": 1,
                asses: 1,
                assfucker: 1,
                assfukka: 1,
                asshole: 1,
                assholes: 1,
                asswhole: 1,
                a_s_s: 1,
                "b!tch": 1,
                b00bs: 1,
                b17ch: 1,
                b1tch: 1,
                ballbag: 1,
                balls: 1,
                ballsack: 1,
                bastard: 1,
                beastial: 1,
                beastiality: 1,
                bellend: 1,
                bestial: 1,
                bestiality: 1,
                "bi+ch": 1,
                biatch: 1,
                bitch: 1,
                bitcher: 1,
                bitchers: 1,
                bitches: 1,
                bitchin: 1,
                bitching: 1,
                bloody: 1,
                "blow job": 1,
                blowjob: 1,
                blowjobs: 1,
                boiolas: 1,
                bollock: 1,
                bollok: 1,
                boner: 1,
                boob: 1,
                boobs: 1,
                booobs: 1,
                boooobs: 1,
                booooobs: 1,
                booooooobs: 1,
                breasts: 1,
                buceta: 1,
                bugger: 1,
                bum: 1,
                "bunny fucker": 1,
                butt: 1,
                butthole: 1,
                buttmuch: 1,
                buttplug: 1,
                c0ck: 1,
                c0cksucker: 1,
                "carpet muncher": 1,
                cawk: 1,
                chink: 1,
                cipa: 1,
                cl1t: 1,
                clit: 1,
                clitoris: 1,
                clits: 1,
                cnut: 1,
                cock: 1,
                "cock-sucker": 1,
                cockface: 1,
                cockhead: 1,
                cockmunch: 1,
                cockmuncher: 1,
                cocks: 1,
                cocksuck: 1,
                cocksucked: 1,
                cocksucker: 1,
                cocksucking: 1,
                cocksucks: 1,
                cocksuka: 1,
                cocksukka: 1,
                cok: 1,
                cokmuncher: 1,
                coksucka: 1,
                coon: 1,
                cox: 1,
                crap: 1,
                cum: 1,
                cummer: 1,
                cumming: 1,
                cums: 1,
                cumshot: 1,
                cunilingus: 1,
                cunillingus: 1,
                cunnilingus: 1,
                cunt: 1,
                cuntlick: 1,
                cuntlicker: 1,
                cuntlicking: 1,
                cunts: 1,
                cyalis: 1,
                cyberfuc: 1,
                cyberfuck: 1,
                cyberfucked: 1,
                cyberfucker: 1,
                cyberfuckers: 1,
                cyberfucking: 1,
                d1ck: 1,
                damn: 1,
                dick: 1,
                dickhead: 1,
                dildo: 1,
                dildos: 1,
                dink: 1,
                dinks: 1,
                dirsa: 1,
                dlck: 1,
                "dog-fucker": 1,
                doggin: 1,
                dogging: 1,
                donkeyribber: 1,
                doosh: 1,
                duche: 1,
                dyke: 1,
                ejaculate: 1,
                ejaculated: 1,
                ejaculates: 1,
                ejaculating: 1,
                ejaculatings: 1,
                ejaculation: 1,
                ejakulate: 1,
                "f u c k": 1,
                "f u c k e r": 1,
                f4nny: 1,
                fag: 1,
                fagging: 1,
                faggitt: 1,
                faggot: 1,
                faggs: 1,
                fagot: 1,
                fagots: 1,
                fags: 1,
                fanny: 1,
                fannyflaps: 1,
                fannyfucker: 1,
                fanyy: 1,
                fatass: 1,
                fcuk: 1,
                fcuker: 1,
                fcuking: 1,
                feck: 1,
                fecker: 1,
                felching: 1,
                fellate: 1,
                fellatio: 1,
                fingerfuck: 1,
                fingerfucked: 1,
                fingerfucker: 1,
                fingerfuckers: 1,
                fingerfucking: 1,
                fingerfucks: 1,
                fistfuck: 1,
                fistfucked: 1,
                fistfucker: 1,
                fistfuckers: 1,
                fistfucking: 1,
                fistfuckings: 1,
                fistfucks: 1,
                flange: 1,
                fook: 1,
                fooker: 1,
                fuck: 1,
                fucka: 1,
                fucked: 1,
                fucker: 1,
                fuckers: 1,
                fuckhead: 1,
                fuckheads: 1,
                fuckin: 1,
                fucking: 1,
                fuckings: 1,
                fuckingshitmotherfucker: 1,
                fuckme: 1,
                fucks: 1,
                fuckwhit: 1,
                fuckwit: 1,
                "fudge packer": 1,
                fudgepacker: 1,
                fuk: 1,
                fuker: 1,
                fukker: 1,
                fukkin: 1,
                fuks: 1,
                fukwhit: 1,
                fukwit: 1,
                fux: 1,
                fux0r: 1,
                f_u_c_k: 1,
                gangbang: 1,
                gangbanged: 1,
                gangbangs: 1,
                gaylord: 1,
                gaysex: 1,
                goatse: 1,
                God: 1,
                "god-dam": 1,
                "god-damned": 1,
                goddamn: 1,
                goddamned: 1,
                hardcoresex: 1,
                hell: 1,
                heshe: 1,
                hoar: 1,
                hoare: 1,
                hoer: 1,
                homo: 1,
                hore: 1,
                horniest: 1,
                horny: 1,
                hotsex: 1,
                "jack-off": 1,
                jackoff: 1,
                jap: 1,
                "jerk-off": 1,
                jism: 1,
                jiz: 1,
                jizm: 1,
                jizz: 1,
                kawk: 1,
                knob: 1,
                knobead: 1,
                knobed: 1,
                knobend: 1,
                knobhead: 1,
                knobjocky: 1,
                knobjokey: 1,
                kock: 1,
                kondum: 1,
                kondums: 1,
                kum: 1,
                kummer: 1,
                kumming: 1,
                kums: 1,
                kunilingus: 1,
                "l3i+ch": 1,
                l3itch: 1,
                labia: 1,
                lust: 1,
                lusting: 1,
                m0f0: 1,
                m0fo: 1,
                m45terbate: 1,
                ma5terb8: 1,
                ma5terbate: 1,
                masochist: 1,
                "master-bate": 1,
                masterb8: 1,
                "masterbat*": 1,
                masterbat3: 1,
                masterbate: 1,
                masterbation: 1,
                masterbations: 1,
                masturbate: 1,
                "mo-fo": 1,
                mof0: 1,
                mofo: 1,
                mothafuck: 1,
                mothafucka: 1,
                mothafuckas: 1,
                mothafuckaz: 1,
                mothafucked: 1,
                mothafucker: 1,
                mothafuckers: 1,
                mothafuckin: 1,
                mothafucking: 1,
                mothafuckings: 1,
                mothafucks: 1,
                "mother fucker": 1,
                motherfuck: 1,
                motherfucked: 1,
                motherfucker: 1,
                motherfuckers: 1,
                motherfuckin: 1,
                motherfucking: 1,
                motherfuckings: 1,
                motherfuckka: 1,
                motherfucks: 1,
                muff: 1,
                mutha: 1,
                muthafecker: 1,
                muthafuckker: 1,
                muther: 1,
                mutherfucker: 1,
                n1gga: 1,
                n1gger: 1,
                nazi: 1,
                nigg3r: 1,
                nigg4h: 1,
                nigga: 1,
                niggah: 1,
                niggas: 1,
                niggaz: 1,
                nigger: 1,
                niggers: 1,
                nob: 1,
                "nob jokey": 1,
                nobhead: 1,
                nobjocky: 1,
                nobjokey: 1,
                numbnuts: 1,
                nutsack: 1,
                orgasim: 1,
                orgasims: 1,
                orgasm: 1,
                orgasms: 1,
                p0rn: 1,
                pawn: 1,
                pecker: 1,
                penis: 1,
                penisfucker: 1,
                phonesex: 1,
                phuck: 1,
                phuk: 1,
                phuked: 1,
                phuking: 1,
                phukked: 1,
                phukking: 1,
                phuks: 1,
                phuq: 1,
                pigfucker: 1,
                pimpis: 1,
                piss: 1,
                pissed: 1,
                pisser: 1,
                pissers: 1,
                pisses: 1,
                pissflaps: 1,
                pissin: 1,
                pissing: 1,
                pissoff: 1,
                poop: 1,
                porn: 1,
                porno: 1,
                pornography: 1,
                pornos: 1,
                prick: 1,
                pricks: 1,
                pron: 1,
                pube: 1,
                pusse: 1,
                pussi: 1,
                pussies: 1,
                pussy: 1,
                pussys: 1,
                rectum: 1,
                retard: 1,
                rimjaw: 1,
                rimming: 1,
                "s hit": 1,
                "s.o.b.": 1,
                sadist: 1,
                schlong: 1,
                screwing: 1,
                scroat: 1,
                scrote: 1,
                scrotum: 1,
                semen: 1,
                sex: 1,
                "sh!+": 1,
                "sh!t": 1,
                sh1t: 1,
                shag: 1,
                shagger: 1,
                shaggin: 1,
                shagging: 1,
                shemale: 1,
                "shi+": 1,
                shit: 1,
                shitdick: 1,
                shite: 1,
                shited: 1,
                shitey: 1,
                shitfuck: 1,
                shitfull: 1,
                shithead: 1,
                shiting: 1,
                shitings: 1,
                shits: 1,
                shitted: 1,
                shitter: 1,
                shitters: 1,
                shitting: 1,
                shittings: 1,
                shitty: 1,
                skank: 1,
                slut: 1,
                sluts: 1,
                smegma: 1,
                smut: 1,
                snatch: 1,
                "son-of-a-bitch": 1,
                spac: 1,
                spunk: 1,
                s_h_i_t: 1,
                t1tt1e5: 1,
                t1tties: 1,
                teets: 1,
                teez: 1,
                testical: 1,
                testicle: 1,
                tit: 1,
                titfuck: 1,
                tits: 1,
                titt: 1,
                tittie5: 1,
                tittiefucker: 1,
                titties: 1,
                tittyfuck: 1,
                tittywank: 1,
                titwank: 1,
                tosser: 1,
                turd: 1,
                tw4t: 1,
                twat: 1,
                twathead: 1,
                twatty: 1,
                twunt: 1,
                twunter: 1,
                v14gra: 1,
                v1gra: 1,
                vagina: 1,
                viagra: 1,
                vulva: 1,
                w00se: 1,
                wang: 1,
                wank: 1,
                wanker: 1,
                wanky: 1,
                whoar: 1,
                whore: 1,
                willies: 1,
                willy: 1,
                xrated: 1,
                xxx: 1,
            };
            /***/
        },
        /***/
        "./node_modules/badwords-list/lib/regexp.js": /*!**************************************************!*\
  !*** ./node_modules/badwords-list/lib/regexp.js ***!
  \**************************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            module.exports = /\b(4r5e|5h1t|5hit|a55|anal|anus|ar5e|arrse|arse|ass|ass-fucker|asses|assfucker|assfukka|asshole|assholes|asswhole|a_s_s|b!tch|b00bs|b17ch|b1tch|ballbag|balls|ballsack|bastard|beastial|beastiality|bellend|bestial|bestiality|bi\+ch|biatch|bitch|bitcher|bitchers|bitches|bitchin|bitching|bloody|blow job|blowjob|blowjobs|boiolas|bollock|bollok|boner|boob|boobs|booobs|boooobs|booooobs|booooooobs|breasts|buceta|bugger|bum|bunny fucker|butt|butthole|buttmuch|buttplug|c0ck|c0cksucker|carpet muncher|cawk|chink|cipa|cl1t|clit|clitoris|clits|cnut|cock|cock-sucker|cockface|cockhead|cockmunch|cockmuncher|cocks|cocksuck|cocksucked|cocksucker|cocksucking|cocksucks|cocksuka|cocksukka|cok|cokmuncher|coksucka|coon|cox|crap|cum|cummer|cumming|cums|cumshot|cunilingus|cunillingus|cunnilingus|cunt|cuntlick|cuntlicker|cuntlicking|cunts|cyalis|cyberfuc|cyberfuck|cyberfucked|cyberfucker|cyberfuckers|cyberfucking|d1ck|damn|dick|dickhead|dildo|dildos|dink|dinks|dirsa|dlck|dog-fucker|doggin|dogging|donkeyribber|doosh|duche|dyke|ejaculate|ejaculated|ejaculates|ejaculating|ejaculatings|ejaculation|ejakulate|f u c k|f u c k e r|f4nny|fag|fagging|faggitt|faggot|faggs|fagot|fagots|fags|fanny|fannyflaps|fannyfucker|fanyy|fatass|fcuk|fcuker|fcuking|feck|fecker|felching|fellate|fellatio|fingerfuck|fingerfucked|fingerfucker|fingerfuckers|fingerfucking|fingerfucks|fistfuck|fistfucked|fistfucker|fistfuckers|fistfucking|fistfuckings|fistfucks|flange|fook|fooker|fuck|fucka|fucked|fucker|fuckers|fuckhead|fuckheads|fuckin|fucking|fuckings|fuckingshitmotherfucker|fuckme|fucks|fuckwhit|fuckwit|fudge packer|fudgepacker|fuk|fuker|fukker|fukkin|fuks|fukwhit|fukwit|fux|fux0r|f_u_c_k|gangbang|gangbanged|gangbangs|gaylord|gaysex|goatse|God|god-dam|god-damned|goddamn|goddamned|hardcoresex|hell|heshe|hoar|hoare|hoer|homo|hore|horniest|horny|hotsex|jack-off|jackoff|jap|jerk-off|jism|jiz|jizm|jizz|kawk|knob|knobead|knobed|knobend|knobhead|knobjocky|knobjokey|kock|kondum|kondums|kum|kummer|kumming|kums|kunilingus|l3i\+ch|l3itch|labia|lust|lusting|m0f0|m0fo|m45terbate|ma5terb8|ma5terbate|masochist|master-bate|masterb8|masterbat*|masterbat3|masterbate|masterbation|masterbations|masturbate|mo-fo|mof0|mofo|mothafuck|mothafucka|mothafuckas|mothafuckaz|mothafucked|mothafucker|mothafuckers|mothafuckin|mothafucking|mothafuckings|mothafucks|mother fucker|motherfuck|motherfucked|motherfucker|motherfuckers|motherfuckin|motherfucking|motherfuckings|motherfuckka|motherfucks|muff|mutha|muthafecker|muthafuckker|muther|mutherfucker|n1gga|n1gger|nazi|nigg3r|nigg4h|nigga|niggah|niggas|niggaz|nigger|niggers|nob|nob jokey|nobhead|nobjocky|nobjokey|numbnuts|nutsack|orgasim|orgasims|orgasm|orgasms|p0rn|pawn|pecker|penis|penisfucker|phonesex|phuck|phuk|phuked|phuking|phukked|phukking|phuks|phuq|pigfucker|pimpis|piss|pissed|pisser|pissers|pisses|pissflaps|pissin|pissing|pissoff|poop|porn|porno|pornography|pornos|prick|pricks|pron|pube|pusse|pussi|pussies|pussy|pussys|rectum|retard|rimjaw|rimming|s hit|s.o.b.|sadist|schlong|screwing|scroat|scrote|scrotum|semen|sex|sh!\+|sh!t|sh1t|shag|shagger|shaggin|shagging|shemale|shi\+|shit|shitdick|shite|shited|shitey|shitfuck|shitfull|shithead|shiting|shitings|shits|shitted|shitter|shitters|shitting|shittings|shitty|skank|slut|sluts|smegma|smut|snatch|son-of-a-bitch|spac|spunk|s_h_i_t|t1tt1e5|t1tties|teets|teez|testical|testicle|tit|titfuck|tits|titt|tittie5|tittiefucker|titties|tittyfuck|tittywank|titwank|tosser|turd|tw4t|twat|twathead|twatty|twunt|twunter|v14gra|v1gra|vagina|viagra|vulva|w00se|wang|wank|wanker|wanky|whoar|whore|willies|willy|xrated|xxx)\b/gi;
            /***/
        },
        /***/
        "./node_modules/base64-js/index.js": /*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            "use strict";
            exports.byteLength = byteLength;
            exports.toByteArray = toByteArray;
            exports.fromByteArray = fromByteArray;
            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (var i = 0, len = code.length; i < len; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
            }
            // Support decoding URL-safe base64 strings, as Node.js does.
            // See: https://en.wikipedia.org/wiki/Base64#URL_applications
            revLookup["-".charCodeAt(0)] = 62;
            revLookup["_".charCodeAt(0)] = 63;

            function getLens(b64) {
                var len = b64.length;
                if (len % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                // Trim off extra bytes after placeholder bytes are found
                // See: https://github.com/beatgammit/base64-js/issues/42
                var validLen = b64.indexOf("=");
                if (validLen === -1)
                    validLen = len;
                var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);
                return [validLen, placeHoldersLen];
            }
            // base64 is 4/3 + up to two characters of the original data
            function byteLength(b64) {
                var lens = getLens(b64);
                var validLen = lens[0];
                var placeHoldersLen = lens[1];
                return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
            }

            function _byteLength(b64, validLen, placeHoldersLen) {
                return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
            }

            function toByteArray(b64) {
                var tmp;
                var lens = getLens(b64);
                var validLen = lens[0];
                var placeHoldersLen = lens[1];
                var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
                var curByte = 0;
                // if there are placeholders, only get up to the last complete 4 chars
                var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
                var i;
                for (i = 0; i < len; i += 4) {
                    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
                    arr[curByte++] = (tmp >> 16) & 0xff;
                    arr[curByte++] = (tmp >> 8) & 0xff;
                    arr[curByte++] = tmp & 0xff;
                }
                if (placeHoldersLen === 2) {
                    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
                    arr[curByte++] = tmp & 0xff;
                }
                if (placeHoldersLen === 1) {
                    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
                    arr[curByte++] = (tmp >> 8) & 0xff;
                    arr[curByte++] = tmp & 0xff;
                }
                return arr;
            }

            function tripletToBase64(num) {
                return (lookup[(num >> 18) & 0x3f] + lookup[(num >> 12) & 0x3f] + lookup[(num >> 6) & 0x3f] + lookup[num & 0x3f]);
            }

            function encodeChunk(uint8, start, end) {
                var tmp;
                var output = [];
                for (var i = start; i < end; i += 3) {
                    tmp = ((uint8[i] << 16) & 0xff0000) + ((uint8[i + 1] << 8) & 0xff00) + (uint8[i + 2] & 0xff);
                    output.push(tripletToBase64(tmp));
                }
                return output.join("");
            }

            function fromByteArray(uint8) {
                var tmp;
                var len = uint8.length;
                var extraBytes = len % 3;
                // if we have 1 byte left, pad 2 bytes
                var parts = [];
                var maxChunkLength = 16383;
                // must be multiple of 3
                // go through the array every three bytes, we'll deal with trailing stuff later
                for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
                }
                // pad the end with zeros, but make sure to not forget the extra bytes
                if (extraBytes === 1) {
                    tmp = uint8[len - 1];
                    parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==");
                } else if (extraBytes === 2) {
                    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                    parts.push(lookup[tmp >> 10] + lookup[(tmp >> 4) & 0x3f] + lookup[(tmp << 2) & 0x3f] + "=");
                }
                return parts.join("");
            }
            /***/
        },
        /***/
        "./node_modules/buffer/index.js": /*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            "use strict";
            /* WEBPACK VAR INJECTION */
            (function(global) {
                /*!
                     * The buffer module from node.js, for the browser.
                     *
                     * @author   Feross Aboukhadijeh <http://feross.org>
                     * @license  MIT
                     */
                /* eslint-disable no-proto */
                var base64 = __webpack_require__(/*! base64-js */
                    "./node_modules/base64-js/index.js");
                var ieee754 = __webpack_require__(/*! ieee754 */
                    "./node_modules/ieee754/index.js");
                var isArray = __webpack_require__(/*! isarray */
                    "./node_modules/buffer/node_modules/isarray/index.js");
                exports.Buffer = Buffer;
                exports.SlowBuffer = SlowBuffer;
                exports.INSPECT_MAX_BYTES = 50;
                /**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
                Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
                /*
                     * Export kMaxLength after typed array support is determined.
                     */
                exports.kMaxLength = kMaxLength();

                function typedArraySupport() {
                    try {
                        var arr = new Uint8Array(1);
                        arr.__proto__ = {
                            __proto__: Uint8Array.prototype,
                            foo: function() {
                                return 42;
                            },
                        };
                        return (arr.foo() === 42 && // typed array instances can be augmented
                                typeof arr.subarray === "function" && // chrome 9-10 lack `subarray`
                                arr.subarray(1, 1).byteLength === 0);
                        // ie10 has broken `subarray`
                    } catch (e) {
                        return false;
                    }
                }

                function kMaxLength() {
                    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
                }

                function createBuffer(that, length) {
                    if (kMaxLength() < length) {
                        throw new RangeError("Invalid typed array length");
                    }
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        // Return an augmented `Uint8Array` instance, for best performance
                        that = new Uint8Array(length);
                        that.__proto__ = Buffer.prototype;
                    } else {
                        // Fallback: Return an object instance of the Buffer class
                        if (that === null) {
                            that = new Buffer(length);
                        }
                        that.length = length;
                    }
                    return that;
                }
                /**
                     * The Buffer constructor returns instances of `Uint8Array` that have their
                     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
                     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
                     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
                     * returns a single octet.
                     *
                     * The `Uint8Array` prototype remains unmodified.
                     */
                function Buffer(arg, encodingOrOffset, length) {
                    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                        return new Buffer(arg,encodingOrOffset,length);
                    }
                    // Common case.
                    if (typeof arg === "number") {
                        if (typeof encodingOrOffset === "string") {
                            throw new Error("If encoding is specified then the first argument must be a string");
                        }
                        return allocUnsafe(this, arg);
                    }
                    return from(this, arg, encodingOrOffset, length);
                }
                Buffer.poolSize = 8192;
                // not used by this implementation
                // TODO: Legacy, not needed anymore. Remove in next major version.
                Buffer._augment = function(arr) {
                    arr.__proto__ = Buffer.prototype;
                    return arr;
                }
                ;

                function from(that, value, encodingOrOffset, length) {
                    if (typeof value === "number") {
                        throw new TypeError('"value" argument must not be a number');
                    }
                    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
                        return fromArrayBuffer(that, value, encodingOrOffset, length);
                    }
                    if (typeof value === "string") {
                        return fromString(that, value, encodingOrOffset);
                    }
                    return fromObject(that, value);
                }
                /**
                     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
                     * if value is a number.
                     * Buffer.from(str[, encoding])
                     * Buffer.from(array)
                     * Buffer.from(buffer)
                     * Buffer.from(arrayBuffer[, byteOffset[, length]])
                     **/
                Buffer.from = function(value, encodingOrOffset, length) {
                    return from(null, value, encodingOrOffset, length);
                }
                ;
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    Buffer.prototype.__proto__ = Uint8Array.prototype;
                    Buffer.__proto__ = Uint8Array;
                    if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
                        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
                        Object.defineProperty(Buffer, Symbol.species, {
                            value: null,
                            configurable: true,
                        });
                    }
                }

                function assertSize(size) {
                    if (typeof size !== "number") {
                        throw new TypeError('"size" argument must be a number');
                    } else if (size < 0) {
                        throw new RangeError('"size" argument must not be negative');
                    }
                }

                function alloc(that, size, fill, encoding) {
                    assertSize(size);
                    if (size <= 0) {
                        return createBuffer(that, size);
                    }
                    if (fill !== undefined) {
                        // Only pay attention to encoding if it's a string. This
                        // prevents accidentally sending in a number that would
                        // be interpretted as a start offset.
                        return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
                    }
                    return createBuffer(that, size);
                }
                /**
                     * Creates a new filled Buffer instance.
                     * alloc(size[, fill[, encoding]])
                     **/
                Buffer.alloc = function(size, fill, encoding) {
                    return alloc(null, size, fill, encoding);
                }
                ;

                function allocUnsafe(that, size) {
                    assertSize(size);
                    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
                    if (!Buffer.TYPED_ARRAY_SUPPORT) {
                        for (var i = 0; i < size; ++i) {
                            that[i] = 0;
                        }
                    }
                    return that;
                }
                /**
                     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
                     * */
                Buffer.allocUnsafe = function(size) {
                    return allocUnsafe(null, size);
                }
                ;
                /**
                     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
                     */
                Buffer.allocUnsafeSlow = function(size) {
                    return allocUnsafe(null, size);
                }
                ;

                function fromString(that, string, encoding) {
                    if (typeof encoding !== "string" || encoding === "") {
                        encoding = "utf8";
                    }
                    if (!Buffer.isEncoding(encoding)) {
                        throw new TypeError('"encoding" must be a valid string encoding');
                    }
                    var length = byteLength(string, encoding) | 0;
                    that = createBuffer(that, length);
                    var actual = that.write(string, encoding);
                    if (actual !== length) {
                        // Writing a hex string, for example, that contains invalid characters will
                        // cause everything after the first invalid character to be ignored. (e.g.
                        // 'abxxcd' will be treated as 'ab')
                        that = that.slice(0, actual);
                    }
                    return that;
                }

                function fromArrayLike(that, array) {
                    var length = array.length < 0 ? 0 : checked(array.length) | 0;
                    that = createBuffer(that, length);
                    for (var i = 0; i < length; i += 1) {
                        that[i] = array[i] & 255;
                    }
                    return that;
                }

                function fromArrayBuffer(that, array, byteOffset, length) {
                    array.byteLength;
                    // this throws if `array` is not a valid ArrayBuffer
                    if (byteOffset < 0 || array.byteLength < byteOffset) {
                        throw new RangeError("'offset' is out of bounds");
                    }
                    if (array.byteLength < byteOffset + (length || 0)) {
                        throw new RangeError("'length' is out of bounds");
                    }
                    if (byteOffset === undefined && length === undefined) {
                        array = new Uint8Array(array);
                    } else if (length === undefined) {
                        array = new Uint8Array(array,byteOffset);
                    } else {
                        array = new Uint8Array(array,byteOffset,length);
                    }
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        // Return an augmented `Uint8Array` instance, for best performance
                        that = array;
                        that.__proto__ = Buffer.prototype;
                    } else {
                        // Fallback: Return an object instance of the Buffer class
                        that = fromArrayLike(that, array);
                    }
                    return that;
                }

                function fromObject(that, obj) {
                    if (Buffer.isBuffer(obj)) {
                        var len = checked(obj.length) | 0;
                        that = createBuffer(that, len);
                        if (that.length === 0) {
                            return that;
                        }
                        obj.copy(that, 0, 0, len);
                        return that;
                    }
                    if (obj) {
                        if ((typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer) || "length"in obj) {
                            if (typeof obj.length !== "number" || isnan(obj.length)) {
                                return createBuffer(that, 0);
                            }
                            return fromArrayLike(that, obj);
                        }
                        if (obj.type === "Buffer" && isArray(obj.data)) {
                            return fromArrayLike(that, obj.data);
                        }
                    }
                    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
                }

                function checked(length) {
                    // Note: cannot use `length < kMaxLength()` here because that fails when
                    // length is NaN (which is otherwise coerced to zero.)
                    if (length >= kMaxLength()) {
                        throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes");
                    }
                    return length | 0;
                }

                function SlowBuffer(length) {
                    if (+length != length) {
                        // eslint-disable-line eqeqeq
                        length = 0;
                    }
                    return Buffer.alloc(+length);
                }
                Buffer.isBuffer = function isBuffer(b) {
                    return !!(b != null && b._isBuffer);
                }
                ;
                Buffer.compare = function compare(a, b) {
                    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                        throw new TypeError("Arguments must be Buffers");
                    }
                    if (a === b)
                        return 0;
                    var x = a.length;
                    var y = b.length;
                    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y)
                        return -1;
                    if (y < x)
                        return 1;
                    return 0;
                }
                ;
                Buffer.isEncoding = function isEncoding(encoding) {
                    switch (String(encoding).toLowerCase()) {
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return true;
                        default:
                            return false;
                    }
                }
                ;
                Buffer.concat = function concat(list, length) {
                    if (!isArray(list)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    if (list.length === 0) {
                        return Buffer.alloc(0);
                    }
                    var i;
                    if (length === undefined) {
                        length = 0;
                        for (i = 0; i < list.length; ++i) {
                            length += list[i].length;
                        }
                    }
                    var buffer = Buffer.allocUnsafe(length);
                    var pos = 0;
                    for (i = 0; i < list.length; ++i) {
                        var buf = list[i];
                        if (!Buffer.isBuffer(buf)) {
                            throw new TypeError('"list" argument must be an Array of Buffers');
                        }
                        buf.copy(buffer, pos);
                        pos += buf.length;
                    }
                    return buffer;
                }
                ;

                function byteLength(string, encoding) {
                    if (Buffer.isBuffer(string)) {
                        return string.length;
                    }
                    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                        return string.byteLength;
                    }
                    if (typeof string !== "string") {
                        string = "" + string;
                    }
                    var len = string.length;
                    if (len === 0)
                        return 0;
                    // Use a for loop to avoid recursion
                    var loweredCase = false;
                    for (; ; ) {
                        switch (encoding) {
                            case "ascii":
                            case "latin1":
                            case "binary":
                                return len;
                            case "utf8":
                            case "utf-8":
                            case undefined:
                                return utf8ToBytes(string).length;
                            case "ucs2":
                            case "ucs-2":
                            case "utf16le":
                            case "utf-16le":
                                return len * 2;
                            case "hex":
                                return len >>> 1;
                            case "base64":
                                return base64ToBytes(string).length;
                            default:
                                if (loweredCase)
                                    return utf8ToBytes(string).length;
                                // assume utf8
                                encoding = ("" + encoding).toLowerCase();
                                loweredCase = true;
                        }
                    }
                }
                Buffer.byteLength = byteLength;

                function slowToString(encoding, start, end) {
                    var loweredCase = false;
                    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                    // property of a typed array.
                    // This behaves neither like String nor Uint8Array in that we set start/end
                    // to their upper/lower bounds if the value passed is out of range.
                    // undefined is handled specially as per ECMA-262 6th Edition,
                    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                    if (start === undefined || start < 0) {
                        start = 0;
                    }
                    // Return early if start > this.length. Done here to prevent potential uint32
                    // coercion fail below.
                    if (start > this.length) {
                        return "";
                    }
                    if (end === undefined || end > this.length) {
                        end = this.length;
                    }
                    if (end <= 0) {
                        return "";
                    }
                    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
                    end >>>= 0;
                    start >>>= 0;
                    if (end <= start) {
                        return "";
                    }
                    if (!encoding)
                        encoding = "utf8";
                    while (true) {
                        switch (encoding) {
                            case "hex":
                                return hexSlice(this, start, end);
                            case "utf8":
                            case "utf-8":
                                return utf8Slice(this, start, end);
                            case "ascii":
                                return asciiSlice(this, start, end);
                            case "latin1":
                            case "binary":
                                return latin1Slice(this, start, end);
                            case "base64":
                                return base64Slice(this, start, end);
                            case "ucs2":
                            case "ucs-2":
                            case "utf16le":
                            case "utf-16le":
                                return utf16leSlice(this, start, end);
                            default:
                                if (loweredCase)
                                    throw new TypeError("Unknown encoding: " + encoding);
                                encoding = (encoding + "").toLowerCase();
                                loweredCase = true;
                        }
                    }
                }
                // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
                // Buffer instances.
                Buffer.prototype._isBuffer = true;

                function swap(b, n, m) {
                    var i = b[n];
                    b[n] = b[m];
                    b[m] = i;
                }
                Buffer.prototype.swap16 = function swap16() {
                    var len = this.length;
                    if (len % 2 !== 0) {
                        throw new RangeError("Buffer size must be a multiple of 16-bits");
                    }
                    for (var i = 0; i < len; i += 2) {
                        swap(this, i, i + 1);
                    }
                    return this;
                }
                ;
                Buffer.prototype.swap32 = function swap32() {
                    var len = this.length;
                    if (len % 4 !== 0) {
                        throw new RangeError("Buffer size must be a multiple of 32-bits");
                    }
                    for (var i = 0; i < len; i += 4) {
                        swap(this, i, i + 3);
                        swap(this, i + 1, i + 2);
                    }
                    return this;
                }
                ;
                Buffer.prototype.swap64 = function swap64() {
                    var len = this.length;
                    if (len % 8 !== 0) {
                        throw new RangeError("Buffer size must be a multiple of 64-bits");
                    }
                    for (var i = 0; i < len; i += 8) {
                        swap(this, i, i + 7);
                        swap(this, i + 1, i + 6);
                        swap(this, i + 2, i + 5);
                        swap(this, i + 3, i + 4);
                    }
                    return this;
                }
                ;
                Buffer.prototype.toString = function toString() {
                    var length = this.length | 0;
                    if (length === 0)
                        return "";
                    if (arguments.length === 0)
                        return utf8Slice(this, 0, length);
                    return slowToString.apply(this, arguments);
                }
                ;
                Buffer.prototype.equals = function equals(b) {
                    if (!Buffer.isBuffer(b))
                        throw new TypeError("Argument must be a Buffer");
                    if (this === b)
                        return true;
                    return Buffer.compare(this, b) === 0;
                }
                ;
                Buffer.prototype.inspect = function inspect() {
                    var str = "";
                    var max = exports.INSPECT_MAX_BYTES;
                    if (this.length > 0) {
                        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
                        if (this.length > max)
                            str += " ... ";
                    }
                    return "<Buffer " + str + ">";
                }
                ;
                Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                    if (!Buffer.isBuffer(target)) {
                        throw new TypeError("Argument must be a Buffer");
                    }
                    if (start === undefined) {
                        start = 0;
                    }
                    if (end === undefined) {
                        end = target ? target.length : 0;
                    }
                    if (thisStart === undefined) {
                        thisStart = 0;
                    }
                    if (thisEnd === undefined) {
                        thisEnd = this.length;
                    }
                    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                        throw new RangeError("out of range index");
                    }
                    if (thisStart >= thisEnd && start >= end) {
                        return 0;
                    }
                    if (thisStart >= thisEnd) {
                        return -1;
                    }
                    if (start >= end) {
                        return 1;
                    }
                    start >>>= 0;
                    end >>>= 0;
                    thisStart >>>= 0;
                    thisEnd >>>= 0;
                    if (this === target)
                        return 0;
                    var x = thisEnd - thisStart;
                    var y = end - start;
                    var len = Math.min(x, y);
                    var thisCopy = this.slice(thisStart, thisEnd);
                    var targetCopy = target.slice(start, end);
                    for (var i = 0; i < len; ++i) {
                        if (thisCopy[i] !== targetCopy[i]) {
                            x = thisCopy[i];
                            y = targetCopy[i];
                            break;
                        }
                    }
                    if (x < y)
                        return -1;
                    if (y < x)
                        return 1;
                    return 0;
                }
                ;
                // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
                // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
                //
                // Arguments:
                // - buffer - a Buffer to search
                // - val - a string, Buffer, or number
                // - byteOffset - an index into `buffer`; will be clamped to an int32
                // - encoding - an optional encoding, relevant is val is a string
                // - dir - true for indexOf, false for lastIndexOf
                function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                    // Empty buffer means no match
                    if (buffer.length === 0)
                        return -1;
                    // Normalize byteOffset
                    if (typeof byteOffset === "string") {
                        encoding = byteOffset;
                        byteOffset = 0;
                    } else if (byteOffset > 0x7fffffff) {
                        byteOffset = 0x7fffffff;
                    } else if (byteOffset < -0x80000000) {
                        byteOffset = -0x80000000;
                    }
                    byteOffset = +byteOffset;
                    // Coerce to Number.
                    if (isNaN(byteOffset)) {
                        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                        byteOffset = dir ? 0 : buffer.length - 1;
                    }
                    // Normalize byteOffset: negative offsets start from the end of the buffer
                    if (byteOffset < 0)
                        byteOffset = buffer.length + byteOffset;
                    if (byteOffset >= buffer.length) {
                        if (dir)
                            return -1;
                        else
                            byteOffset = buffer.length - 1;
                    } else if (byteOffset < 0) {
                        if (dir)
                            byteOffset = 0;
                        else
                            return -1;
                    }
                    // Normalize val
                    if (typeof val === "string") {
                        val = Buffer.from(val, encoding);
                    }
                    // Finally, search either indexOf (if dir is true) or lastIndexOf
                    if (Buffer.isBuffer(val)) {
                        // Special case: looking for empty string/buffer always fails
                        if (val.length === 0) {
                            return -1;
                        }
                        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                    } else if (typeof val === "number") {
                        val = val & 0xff;
                        // Search for a byte value [0-255]
                        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
                            if (dir) {
                                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                            } else {
                                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                            }
                        }
                        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                    }
                    throw new TypeError("val must be string, number or Buffer");
                }

                function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                    var indexSize = 1;
                    var arrLength = arr.length;
                    var valLength = val.length;
                    if (encoding !== undefined) {
                        encoding = String(encoding).toLowerCase();
                        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                            if (arr.length < 2 || val.length < 2) {
                                return -1;
                            }
                            indexSize = 2;
                            arrLength /= 2;
                            valLength /= 2;
                            byteOffset /= 2;
                        }
                    }

                    function read(buf, i) {
                        if (indexSize === 1) {
                            return buf[i];
                        } else {
                            return buf.readUInt16BE(i * indexSize);
                        }
                    }
                    var i;
                    if (dir) {
                        var foundIndex = -1;
                        for (i = byteOffset; i < arrLength; i++) {
                            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                                if (foundIndex === -1)
                                    foundIndex = i;
                                if (i - foundIndex + 1 === valLength)
                                    return foundIndex * indexSize;
                            } else {
                                if (foundIndex !== -1)
                                    i -= i - foundIndex;
                                foundIndex = -1;
                            }
                        }
                    } else {
                        if (byteOffset + valLength > arrLength)
                            byteOffset = arrLength - valLength;
                        for (i = byteOffset; i >= 0; i--) {
                            var found = true;
                            for (var j = 0; j < valLength; j++) {
                                if (read(arr, i + j) !== read(val, j)) {
                                    found = false;
                                    break;
                                }
                            }
                            if (found)
                                return i;
                        }
                    }
                    return -1;
                }
                Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                    return this.indexOf(val, byteOffset, encoding) !== -1;
                }
                ;
                Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
                }
                ;
                Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
                }
                ;

                function hexWrite(buf, string, offset, length) {
                    offset = Number(offset) || 0;
                    var remaining = buf.length - offset;
                    if (!length) {
                        length = remaining;
                    } else {
                        length = Number(length);
                        if (length > remaining) {
                            length = remaining;
                        }
                    }
                    // must be an even number of digits
                    var strLen = string.length;
                    if (strLen % 2 !== 0)
                        throw new TypeError("Invalid hex string");
                    if (length > strLen / 2) {
                        length = strLen / 2;
                    }
                    for (var i = 0; i < length; ++i) {
                        var parsed = parseInt(string.substr(i * 2, 2), 16);
                        if (isNaN(parsed))
                            return i;
                        buf[offset + i] = parsed;
                    }
                    return i;
                }

                function utf8Write(buf, string, offset, length) {
                    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                }

                function asciiWrite(buf, string, offset, length) {
                    return blitBuffer(asciiToBytes(string), buf, offset, length);
                }

                function latin1Write(buf, string, offset, length) {
                    return asciiWrite(buf, string, offset, length);
                }

                function base64Write(buf, string, offset, length) {
                    return blitBuffer(base64ToBytes(string), buf, offset, length);
                }

                function ucs2Write(buf, string, offset, length) {
                    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                }
                Buffer.prototype.write = function write(string, offset, length, encoding) {
                    // Buffer#write(string)
                    if (offset === undefined) {
                        encoding = "utf8";
                        length = this.length;
                        offset = 0;
                        // Buffer#write(string, encoding)
                    } else if (length === undefined && typeof offset === "string") {
                        encoding = offset;
                        length = this.length;
                        offset = 0;
                        // Buffer#write(string, offset[, length][, encoding])
                    } else if (isFinite(offset)) {
                        offset = offset | 0;
                        if (isFinite(length)) {
                            length = length | 0;
                            if (encoding === undefined)
                                encoding = "utf8";
                        } else {
                            encoding = length;
                            length = undefined;
                        }
                        // legacy write(string, encoding, offset, length) - remove in v0.13
                    } else {
                        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    }
                    var remaining = this.length - offset;
                    if (length === undefined || length > remaining)
                        length = remaining;
                    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                        throw new RangeError("Attempt to write outside buffer bounds");
                    }
                    if (!encoding)
                        encoding = "utf8";
                    var loweredCase = false;
                    for (; ; ) {
                        switch (encoding) {
                            case "hex":
                                return hexWrite(this, string, offset, length);
                            case "utf8":
                            case "utf-8":
                                return utf8Write(this, string, offset, length);
                            case "ascii":
                                return asciiWrite(this, string, offset, length);
                            case "latin1":
                            case "binary":
                                return latin1Write(this, string, offset, length);
                            case "base64":
                                // Warning: maxLength not taken into account in base64Write
                                return base64Write(this, string, offset, length);
                            case "ucs2":
                            case "ucs-2":
                            case "utf16le":
                            case "utf-16le":
                                return ucs2Write(this, string, offset, length);
                            default:
                                if (loweredCase)
                                    throw new TypeError("Unknown encoding: " + encoding);
                                encoding = ("" + encoding).toLowerCase();
                                loweredCase = true;
                        }
                    }
                }
                ;
                Buffer.prototype.toJSON = function toJSON() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0),
                    };
                }
                ;

                function base64Slice(buf, start, end) {
                    if (start === 0 && end === buf.length) {
                        return base64.fromByteArray(buf);
                    } else {
                        return base64.fromByteArray(buf.slice(start, end));
                    }
                }

                function utf8Slice(buf, start, end) {
                    end = Math.min(buf.length, end);
                    var res = [];
                    var i = start;
                    while (i < end) {
                        var firstByte = buf[i];
                        var codePoint = null;
                        var bytesPerSequence = firstByte > 0xef ? 4 : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1;
                        if (i + bytesPerSequence <= end) {
                            var secondByte, thirdByte, fourthByte, tempCodePoint;
                            switch (bytesPerSequence) {
                                case 1:
                                    if (firstByte < 0x80) {
                                        codePoint = firstByte;
                                    }
                                    break;
                                case 2:
                                    secondByte = buf[i + 1];
                                    if ((secondByte & 0xc0) === 0x80) {
                                        tempCodePoint = ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);
                                        if (tempCodePoint > 0x7f) {
                                            codePoint = tempCodePoint;
                                        }
                                    }
                                    break;
                                case 3:
                                    secondByte = buf[i + 1];
                                    thirdByte = buf[i + 2];
                                    if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {
                                        tempCodePoint = ((firstByte & 0xf) << 0xc) | ((secondByte & 0x3f) << 0x6) | (thirdByte & 0x3f);
                                        if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {
                                            codePoint = tempCodePoint;
                                        }
                                    }
                                    break;
                                case 4:
                                    secondByte = buf[i + 1];
                                    thirdByte = buf[i + 2];
                                    fourthByte = buf[i + 3];
                                    if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {
                                        tempCodePoint = ((firstByte & 0xf) << 0x12) | ((secondByte & 0x3f) << 0xc) | ((thirdByte & 0x3f) << 0x6) | (fourthByte & 0x3f);
                                        if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                                            codePoint = tempCodePoint;
                                        }
                                    }
                            }
                        }
                        if (codePoint === null) {
                            // we did not generate a valid codePoint so insert a
                            // replacement char (U+FFFD) and advance only 1 byte
                            codePoint = 0xfffd;
                            bytesPerSequence = 1;
                        } else if (codePoint > 0xffff) {
                            // encode to utf16 (surrogate pair dance)
                            codePoint -= 0x10000;
                            res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
                            codePoint = 0xdc00 | (codePoint & 0x3ff);
                        }
                        res.push(codePoint);
                        i += bytesPerSequence;
                    }
                    return decodeCodePointsArray(res);
                }
                // Based on http://stackoverflow.com/a/22747272/680742, the browser with
                // the lowest limit is Chrome, with 0x10000 args.
                // We go 1 magnitude less, for safety
                var MAX_ARGUMENTS_LENGTH = 0x1000;

                function decodeCodePointsArray(codePoints) {
                    var len = codePoints.length;
                    if (len <= MAX_ARGUMENTS_LENGTH) {
                        return String.fromCharCode.apply(String, codePoints);
                        // avoid extra slice()
                    }
                    // Decode in chunks to avoid "call stack size exceeded".
                    var res = "";
                    var i = 0;
                    while (i < len) {
                        res += String.fromCharCode.apply(String, codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)));
                    }
                    return res;
                }

                function asciiSlice(buf, start, end) {
                    var ret = "";
                    end = Math.min(buf.length, end);
                    for (var i = start; i < end; ++i) {
                        ret += String.fromCharCode(buf[i] & 0x7f);
                    }
                    return ret;
                }

                function latin1Slice(buf, start, end) {
                    var ret = "";
                    end = Math.min(buf.length, end);
                    for (var i = start; i < end; ++i) {
                        ret += String.fromCharCode(buf[i]);
                    }
                    return ret;
                }

                function hexSlice(buf, start, end) {
                    var len = buf.length;
                    if (!start || start < 0)
                        start = 0;
                    if (!end || end < 0 || end > len)
                        end = len;
                    var out = "";
                    for (var i = start; i < end; ++i) {
                        out += toHex(buf[i]);
                    }
                    return out;
                }

                function utf16leSlice(buf, start, end) {
                    var bytes = buf.slice(start, end);
                    var res = "";
                    for (var i = 0; i < bytes.length; i += 2) {
                        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                    }
                    return res;
                }
                Buffer.prototype.slice = function slice(start, end) {
                    var len = this.length;
                    start = ~~start;
                    end = end === undefined ? len : ~~end;
                    if (start < 0) {
                        start += len;
                        if (start < 0)
                            start = 0;
                    } else if (start > len) {
                        start = len;
                    }
                    if (end < 0) {
                        end += len;
                        if (end < 0)
                            end = 0;
                    } else if (end > len) {
                        end = len;
                    }
                    if (end < start)
                        end = start;
                    var newBuf;
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        newBuf = this.subarray(start, end);
                        newBuf.__proto__ = Buffer.prototype;
                    } else {
                        var sliceLen = end - start;
                        newBuf = new Buffer(sliceLen,undefined);
                        for (var i = 0; i < sliceLen; ++i) {
                            newBuf[i] = this[i + start];
                        }
                    }
                    return newBuf;
                }
                ;
                /*
                     * Need to make sure that buffer isn't trying to write out of bounds.
                     */
                function checkOffset(offset, ext, length) {
                    if (offset % 1 !== 0 || offset < 0)
                        throw new RangeError("offset is not uint");
                    if (offset + ext > length)
                        throw new RangeError("Trying to access beyond buffer length");
                }
                Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert)
                        checkOffset(offset, byteLength, this.length);
                    var val = this[offset];
                    var mul = 1;
                    var i = 0;
                    while (++i < byteLength && (mul *= 0x100)) {
                        val += this[offset + i] * mul;
                    }
                    return val;
                }
                ;
                Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) {
                        checkOffset(offset, byteLength, this.length);
                    }
                    var val = this[offset + --byteLength];
                    var mul = 1;
                    while (byteLength > 0 && (mul *= 0x100)) {
                        val += this[offset + --byteLength] * mul;
                    }
                    return val;
                }
                ;
                Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 1, this.length);
                    return this[offset];
                }
                ;
                Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 2, this.length);
                    return this[offset] | (this[offset + 1] << 8);
                }
                ;
                Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 2, this.length);
                    return (this[offset] << 8) | this[offset + 1];
                }
                ;
                Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 4, this.length);
                    return ((this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + this[offset + 3] * 0x1000000);
                }
                ;
                Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 4, this.length);
                    return (this[offset] * 0x1000000 + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]));
                }
                ;
                Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert)
                        checkOffset(offset, byteLength, this.length);
                    var val = this[offset];
                    var mul = 1;
                    var i = 0;
                    while (++i < byteLength && (mul *= 0x100)) {
                        val += this[offset + i] * mul;
                    }
                    mul *= 0x80;
                    if (val >= mul)
                        val -= Math.pow(2, 8 * byteLength);
                    return val;
                }
                ;
                Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert)
                        checkOffset(offset, byteLength, this.length);
                    var i = byteLength;
                    var mul = 1;
                    var val = this[offset + --i];
                    while (i > 0 && (mul *= 0x100)) {
                        val += this[offset + --i] * mul;
                    }
                    mul *= 0x80;
                    if (val >= mul)
                        val -= Math.pow(2, 8 * byteLength);
                    return val;
                }
                ;
                Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 1, this.length);
                    if (!(this[offset] & 0x80))
                        return this[offset];
                    return (0xff - this[offset] + 1) * -1;
                }
                ;
                Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 2, this.length);
                    var val = this[offset] | (this[offset + 1] << 8);
                    return val & 0x8000 ? val | 0xffff0000 : val;
                }
                ;
                Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 2, this.length);
                    var val = this[offset + 1] | (this[offset] << 8);
                    return val & 0x8000 ? val | 0xffff0000 : val;
                }
                ;
                Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 4, this.length);
                    return (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24));
                }
                ;
                Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 4, this.length);
                    return ((this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
                }
                ;
                Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 4, this.length);
                    return ieee754.read(this, offset, true, 23, 4);
                }
                ;
                Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 4, this.length);
                    return ieee754.read(this, offset, false, 23, 4);
                }
                ;
                Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 8, this.length);
                    return ieee754.read(this, offset, true, 52, 8);
                }
                ;
                Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                    if (!noAssert)
                        checkOffset(offset, 8, this.length);
                    return ieee754.read(this, offset, false, 52, 8);
                }
                ;

                function checkInt(buf, value, offset, ext, max, min) {
                    if (!Buffer.isBuffer(buf))
                        throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (value > max || value < min)
                        throw new RangeError('"value" argument is out of bounds');
                    if (offset + ext > buf.length)
                        throw new RangeError("Index out of range");
                }
                Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) {
                        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                        checkInt(this, value, offset, byteLength, maxBytes, 0);
                    }
                    var mul = 1;
                    var i = 0;
                    this[offset] = value & 0xff;
                    while (++i < byteLength && (mul *= 0x100)) {
                        this[offset + i] = (value / mul) & 0xff;
                    }
                    return offset + byteLength;
                }
                ;
                Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) {
                        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                        checkInt(this, value, offset, byteLength, maxBytes, 0);
                    }
                    var i = byteLength - 1;
                    var mul = 1;
                    this[offset + i] = value & 0xff;
                    while (--i >= 0 && (mul *= 0x100)) {
                        this[offset + i] = (value / mul) & 0xff;
                    }
                    return offset + byteLength;
                }
                ;
                Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert)
                        checkInt(this, value, offset, 1, 0xff, 0);
                    if (!Buffer.TYPED_ARRAY_SUPPORT)
                        value = Math.floor(value);
                    this[offset] = value & 0xff;
                    return offset + 1;
                }
                ;

                function objectWriteUInt16(buf, value, offset, littleEndian) {
                    if (value < 0)
                        value = 0xffff + value + 1;
                    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> ((littleEndian ? i : 1 - i) * 8);
                    }
                }
                Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert)
                        checkInt(this, value, offset, 2, 0xffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value & 0xff;
                        this[offset + 1] = value >>> 8;
                    } else {
                        objectWriteUInt16(this, value, offset, true);
                    }
                    return offset + 2;
                }
                ;
                Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert)
                        checkInt(this, value, offset, 2, 0xffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 8;
                        this[offset + 1] = value & 0xff;
                    } else {
                        objectWriteUInt16(this, value, offset, false);
                    }
                    return offset + 2;
                }
                ;

                function objectWriteUInt32(buf, value, offset, littleEndian) {
                    if (value < 0)
                        value = 0xffffffff + value + 1;
                    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                        buf[offset + i] = (value >>> ((littleEndian ? i : 3 - i) * 8)) & 0xff;
                    }
                }
                Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert)
                        checkInt(this, value, offset, 4, 0xffffffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset + 3] = value >>> 24;
                        this[offset + 2] = value >>> 16;
                        this[offset + 1] = value >>> 8;
                        this[offset] = value & 0xff;
                    } else {
                        objectWriteUInt32(this, value, offset, true);
                    }
                    return offset + 4;
                }
                ;
                Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert)
                        checkInt(this, value, offset, 4, 0xffffffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 24;
                        this[offset + 1] = value >>> 16;
                        this[offset + 2] = value >>> 8;
                        this[offset + 3] = value & 0xff;
                    } else {
                        objectWriteUInt32(this, value, offset, false);
                    }
                    return offset + 4;
                }
                ;
                Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) {
                        var limit = Math.pow(2, 8 * byteLength - 1);
                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }
                    var i = 0;
                    var mul = 1;
                    var sub = 0;
                    this[offset] = value & 0xff;
                    while (++i < byteLength && (mul *= 0x100)) {
                        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                            sub = 1;
                        }
                        this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
                    }
                    return offset + byteLength;
                }
                ;
                Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) {
                        var limit = Math.pow(2, 8 * byteLength - 1);
                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }
                    var i = byteLength - 1;
                    var mul = 1;
                    var sub = 0;
                    this[offset + i] = value & 0xff;
                    while (--i >= 0 && (mul *= 0x100)) {
                        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                            sub = 1;
                        }
                        this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
                    }
                    return offset + byteLength;
                }
                ;
                Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert)
                        checkInt(this, value, offset, 1, 0x7f, -0x80);
                    if (!Buffer.TYPED_ARRAY_SUPPORT)
                        value = Math.floor(value);
                    if (value < 0)
                        value = 0xff + value + 1;
                    this[offset] = value & 0xff;
                    return offset + 1;
                }
                ;
                Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert)
                        checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value & 0xff;
                        this[offset + 1] = value >>> 8;
                    } else {
                        objectWriteUInt16(this, value, offset, true);
                    }
                    return offset + 2;
                }
                ;
                Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert)
                        checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 8;
                        this[offset + 1] = value & 0xff;
                    } else {
                        objectWriteUInt16(this, value, offset, false);
                    }
                    return offset + 2;
                }
                ;
                Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert)
                        checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value & 0xff;
                        this[offset + 1] = value >>> 8;
                        this[offset + 2] = value >>> 16;
                        this[offset + 3] = value >>> 24;
                    } else {
                        objectWriteUInt32(this, value, offset, true);
                    }
                    return offset + 4;
                }
                ;
                Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert)
                        checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                    if (value < 0)
                        value = 0xffffffff + value + 1;
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = value >>> 24;
                        this[offset + 1] = value >>> 16;
                        this[offset + 2] = value >>> 8;
                        this[offset + 3] = value & 0xff;
                    } else {
                        objectWriteUInt32(this, value, offset, false);
                    }
                    return offset + 4;
                }
                ;

                function checkIEEE754(buf, value, offset, ext, max, min) {
                    if (offset + ext > buf.length)
                        throw new RangeError("Index out of range");
                    if (offset < 0)
                        throw new RangeError("Index out of range");
                }

                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
                    }
                    ieee754.write(buf, value, offset, littleEndian, 23, 4);
                    return offset + 4;
                }
                Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, true, noAssert);
                }
                ;
                Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, false, noAssert);
                }
                ;

                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
                    }
                    ieee754.write(buf, value, offset, littleEndian, 52, 8);
                    return offset + 8;
                }
                Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, true, noAssert);
                }
                ;
                Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, false, noAssert);
                }
                ;
                // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
                Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                    if (!start)
                        start = 0;
                    if (!end && end !== 0)
                        end = this.length;
                    if (targetStart >= target.length)
                        targetStart = target.length;
                    if (!targetStart)
                        targetStart = 0;
                    if (end > 0 && end < start)
                        end = start;
                    // Copy 0 bytes; we're done
                    if (end === start)
                        return 0;
                    if (target.length === 0 || this.length === 0)
                        return 0;
                    // Fatal error conditions
                    if (targetStart < 0) {
                        throw new RangeError("targetStart out of bounds");
                    }
                    if (start < 0 || start >= this.length)
                        throw new RangeError("sourceStart out of bounds");
                    if (end < 0)
                        throw new RangeError("sourceEnd out of bounds");
                    // Are we oob?
                    if (end > this.length)
                        end = this.length;
                    if (target.length - targetStart < end - start) {
                        end = target.length - targetStart + start;
                    }
                    var len = end - start;
                    var i;
                    if (this === target && start < targetStart && targetStart < end) {
                        // descending copy from end
                        for (i = len - 1; i >= 0; --i) {
                            target[i + targetStart] = this[i + start];
                        }
                    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                        // ascending copy from start
                        for (i = 0; i < len; ++i) {
                            target[i + targetStart] = this[i + start];
                        }
                    } else {
                        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
                    }
                    return len;
                }
                ;
                // Usage:
                //    buffer.fill(number[, offset[, end]])
                //    buffer.fill(buffer[, offset[, end]])
                //    buffer.fill(string[, offset[, end]][, encoding])
                Buffer.prototype.fill = function fill(val, start, end, encoding) {
                    // Handle string cases:
                    if (typeof val === "string") {
                        if (typeof start === "string") {
                            encoding = start;
                            start = 0;
                            end = this.length;
                        } else if (typeof end === "string") {
                            encoding = end;
                            end = this.length;
                        }
                        if (val.length === 1) {
                            var code = val.charCodeAt(0);
                            if (code < 256) {
                                val = code;
                            }
                        }
                        if (encoding !== undefined && typeof encoding !== "string") {
                            throw new TypeError("encoding must be a string");
                        }
                        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                            throw new TypeError("Unknown encoding: " + encoding);
                        }
                    } else if (typeof val === "number") {
                        val = val & 255;
                    }
                    // Invalid ranges are not set to a default, so can range check early.
                    if (start < 0 || this.length < start || this.length < end) {
                        throw new RangeError("Out of range index");
                    }
                    if (end <= start) {
                        return this;
                    }
                    start = start >>> 0;
                    end = end === undefined ? this.length : end >>> 0;
                    if (!val)
                        val = 0;
                    var i;
                    if (typeof val === "number") {
                        for (i = start; i < end; ++i) {
                            this[i] = val;
                        }
                    } else {
                        var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val,encoding).toString());
                        var len = bytes.length;
                        for (i = 0; i < end - start; ++i) {
                            this[i + start] = bytes[i % len];
                        }
                    }
                    return this;
                }
                ;
                // HELPER FUNCTIONS
                // ================
                var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

                function base64clean(str) {
                    // Node strips out invalid characters like \n and \t from the string, base64-js does not
                    str = stringtrim(str).replace(INVALID_BASE64_RE, "");
                    // Node converts strings with length < 2 to ''
                    if (str.length < 2)
                        return "";
                    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                    while (str.length % 4 !== 0) {
                        str = str + "=";
                    }
                    return str;
                }

                function stringtrim(str) {
                    if (str.trim)
                        return str.trim();
                    return str.replace(/^\s+|\s+$/g, "");
                }

                function toHex(n) {
                    if (n < 16)
                        return "0" + n.toString(16);
                    return n.toString(16);
                }

                function utf8ToBytes(string, units) {
                    units = units || Infinity;
                    var codePoint;
                    var length = string.length;
                    var leadSurrogate = null;
                    var bytes = [];
                    for (var i = 0; i < length; ++i) {
                        codePoint = string.charCodeAt(i);
                        // is surrogate component
                        if (codePoint > 0xd7ff && codePoint < 0xe000) {
                            // last char was a lead
                            if (!leadSurrogate) {
                                // no lead yet
                                if (codePoint > 0xdbff) {
                                    // unexpected trail
                                    if ((units -= 3) > -1)
                                        bytes.push(0xef, 0xbf, 0xbd);
                                    continue;
                                } else if (i + 1 === length) {
                                    // unpaired lead
                                    if ((units -= 3) > -1)
                                        bytes.push(0xef, 0xbf, 0xbd);
                                    continue;
                                }
                                // valid lead
                                leadSurrogate = codePoint;
                                continue;
                            }
                            // 2 leads in a row
                            if (codePoint < 0xdc00) {
                                if ((units -= 3) > -1)
                                    bytes.push(0xef, 0xbf, 0xbd);
                                leadSurrogate = codePoint;
                                continue;
                            }
                            // valid surrogate pair
                            codePoint = (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) + 0x10000;
                        } else if (leadSurrogate) {
                            // valid bmp char, but last char was a lead
                            if ((units -= 3) > -1)
                                bytes.push(0xef, 0xbf, 0xbd);
                        }
                        leadSurrogate = null;
                        // encode utf8
                        if (codePoint < 0x80) {
                            if ((units -= 1) < 0)
                                break;
                            bytes.push(codePoint);
                        } else if (codePoint < 0x800) {
                            if ((units -= 2) < 0)
                                break;
                            bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);
                        } else if (codePoint < 0x10000) {
                            if ((units -= 3) < 0)
                                break;
                            bytes.push((codePoint >> 0xc) | 0xe0, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
                        } else if (codePoint < 0x110000) {
                            if ((units -= 4) < 0)
                                break;
                            bytes.push((codePoint >> 0x12) | 0xf0, ((codePoint >> 0xc) & 0x3f) | 0x80, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
                        } else {
                            throw new Error("Invalid code point");
                        }
                    }
                    return bytes;
                }

                function asciiToBytes(str) {
                    var byteArray = [];
                    for (var i = 0; i < str.length; ++i) {
                        // Node's code seems to be doing this and not & 0x7F..
                        byteArray.push(str.charCodeAt(i) & 0xff);
                    }
                    return byteArray;
                }

                function utf16leToBytes(str, units) {
                    var c, hi, lo;
                    var byteArray = [];
                    for (var i = 0; i < str.length; ++i) {
                        if ((units -= 2) < 0)
                            break;
                        c = str.charCodeAt(i);
                        hi = c >> 8;
                        lo = c % 256;
                        byteArray.push(lo);
                        byteArray.push(hi);
                    }
                    return byteArray;
                }

                function base64ToBytes(str) {
                    return base64.toByteArray(base64clean(str));
                }

                function blitBuffer(src, dst, offset, length) {
                    for (var i = 0; i < length; ++i) {
                        if (i + offset >= dst.length || i >= src.length)
                            break;
                        dst[i + offset] = src[i];
                    }
                    return i;
                }

                function isnan(val) {
                    return val !== val;
                    // eslint-disable-line no-self-compare
                }
                /* WEBPACK VAR INJECTION */
            }
            ).call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */
                "./node_modules/webpack/buildin/global.js"));
            /***/
        },
        /***/
        "./node_modules/buffer/node_modules/isarray/index.js": /*!***********************************************************!*\
  !*** ./node_modules/buffer/node_modules/isarray/index.js ***!
  \***********************************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            var toString = {}.toString;
            module.exports = Array.isArray || function(arr) {
                return toString.call(arr) == "[object Array]";
            }
            ;
            /***/
        },
        /***/
        "./node_modules/charenc/charenc.js": /*!*****************************************!*\
  !*** ./node_modules/charenc/charenc.js ***!
  \*****************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            var charenc = {
                // UTF-8 encoding
                utf8: {
                    // Convert a string to a byte array
                    stringToBytes: function(str) {
                        return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
                    },
                    // Convert a byte array to a string
                    bytesToString: function(bytes) {
                        return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
                    },
                },
                // Binary encoding
                bin: {
                    // Convert a string to a byte array
                    stringToBytes: function(str) {
                        for (var bytes = [], i = 0; i < str.length; i++)
                            bytes.push(str.charCodeAt(i) & 0xff);
                        return bytes;
                    },
                    // Convert a byte array to a string
                    bytesToString: function(bytes) {
                        for (var str = [], i = 0; i < bytes.length; i++)
                            str.push(String.fromCharCode(bytes[i]));
                        return str.join("");
                    },
                },
            };
            module.exports = charenc;
            /***/
        },
        /***/
        "./node_modules/crypt/crypt.js": /*!*************************************!*\
  !*** ./node_modules/crypt/crypt.js ***!
  \*************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            (function() {
                var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                , crypt = {
                    // Bit-wise rotation left
                    rotl: function(n, b) {
                        return (n << b) | (n >>> (32 - b));
                    },
                    // Bit-wise rotation right
                    rotr: function(n, b) {
                        return (n << (32 - b)) | (n >>> b);
                    },
                    // Swap big-endian to little-endian and vice versa
                    endian: function(n) {
                        // If number given, swap endian
                        if (n.constructor == Number) {
                            return ((crypt.rotl(n, 8) & 0x00ff00ff) | (crypt.rotl(n, 24) & 0xff00ff00));
                        }
                        // Else, assume array and swap all items
                        for (var i = 0; i < n.length; i++)
                            n[i] = crypt.endian(n[i]);
                        return n;
                    },
                    // Generate an array of any length of random bytes
                    randomBytes: function(n) {
                        for (var bytes = []; n > 0; n--)
                            bytes.push(Math.floor(Math.random() * 256));
                        return bytes;
                    },
                    // Convert a byte array to big-endian 32-bit words
                    bytesToWords: function(bytes) {
                        for (var words = [], i = 0, b = 0; i < bytes.length; i++,
                             b += 8)
                            words[b >>> 5] |= bytes[i] << (24 - (b % 32));
                        return words;
                    },
                    // Convert big-endian 32-bit words to a byte array
                    wordsToBytes: function(words) {
                        for (var bytes = [], b = 0; b < words.length * 32; b += 8)
                            bytes.push((words[b >>> 5] >>> (24 - (b % 32))) & 0xff);
                        return bytes;
                    },
                    // Convert a byte array to a hex string
                    bytesToHex: function(bytes) {
                        for (var hex = [], i = 0; i < bytes.length; i++) {
                            hex.push((bytes[i] >>> 4).toString(16));
                            hex.push((bytes[i] & 0xf).toString(16));
                        }
                        return hex.join("");
                    },
                    // Convert a hex string to a byte array
                    hexToBytes: function(hex) {
                        for (var bytes = [], c = 0; c < hex.length; c += 2)
                            bytes.push(parseInt(hex.substr(c, 2), 16));
                        return bytes;
                    },
                    // Convert a byte array to a base-64 string
                    bytesToBase64: function(bytes) {
                        for (var base64 = [], i = 0; i < bytes.length; i += 3) {
                            var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
                            for (var j = 0; j < 4; j++)
                                if (i * 8 + j * 6 <= bytes.length * 8)
                                    base64.push(base64map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                                else
                                    base64.push("=");
                        }
                        return base64.join("");
                    },
                    // Convert a base-64 string to a byte array
                    base64ToBytes: function(base64) {
                        // Remove non-base-64 characters
                        base64 = base64.replace(/[^A-Z0-9+\/]/gi, "");
                        for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
                            if (imod4 == 0)
                                continue;
                            bytes.push(((base64map.indexOf(base64.charAt(i - 1)) & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2)) | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
                        }
                        return bytes;
                    },
                };
                module.exports = crypt;
            }
            )();
            /***/
        },
        /***/
        "./node_modules/event-lite/event-lite.js": /*!***********************************************!*\
  !*** ./node_modules/event-lite/event-lite.js ***!
  \***********************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            /**
                 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
                 *
                 * @copyright Yusuke Kawasaki
                 * @license MIT
                 * @constructor
                 * @see https://github.com/kawanet/event-lite
                 * @see http://kawanet.github.io/event-lite/EventLite.html
                 * @example
                 * var EventLite = require("event-lite");
                 *
                 * function MyClass() {...}             // your class
                 *
                 * EventLite.mixin(MyClass.prototype);  // import event methods
                 *
                 * var obj = new MyClass();
                 * obj.on("foo", function() {...});     // add event listener
                 * obj.once("bar", function() {...});   // add one-time event listener
                 * obj.emit("foo");                     // dispatch event
                 * obj.emit("bar");                     // dispatch another event
                 * obj.off("foo");                      // remove event listener
                 */
            function EventLite() {
                if (!(this instanceof EventLite))
                    return new EventLite();
            }
            (function(EventLite) {
                // export the class for node.js
                if (true)
                    module.exports = EventLite;
                // property name to hold listeners
                var LISTENERS = "listeners";
                // methods to export
                var methods = {
                    on: on,
                    once: once,
                    off: off,
                    emit: emit,
                };
                // mixin to self
                mixin(EventLite.prototype);
                // export mixin function
                EventLite.mixin = mixin;
                /**
                     * Import on(), once(), off() and emit() methods into target object.
                     *
                     * @function EventLite.mixin
                     * @param target {Prototype}
                     */
                function mixin(target) {
                    for (var key in methods) {
                        target[key] = methods[key];
                    }
                    return target;
                }
                /**
                     * Add an event listener.
                     *
                     * @function EventLite.prototype.on
                     * @param type {string}
                     * @param func {Function}
                     * @returns {EventLite} Self for method chaining
                     */
                function on(type, func) {
                    getListeners(this, type).push(func);
                    return this;
                }
                /**
                     * Add one-time event listener.
                     *
                     * @function EventLite.prototype.once
                     * @param type {string}
                     * @param func {Function}
                     * @returns {EventLite} Self for method chaining
                     */
                function once(type, func) {
                    var that = this;
                    wrap.originalListener = func;
                    getListeners(that, type).push(wrap);
                    return that;

                    function wrap() {
                        off.call(that, type, wrap);
                        func.apply(this, arguments);
                    }
                }
                /**
                     * Remove an event listener.
                     *
                     * @function EventLite.prototype.off
                     * @param [type] {string}
                     * @param [func] {Function}
                     * @returns {EventLite} Self for method chaining
                     */
                function off(type, func) {
                    var that = this;
                    var listners;
                    if (!arguments.length) {
                        delete that[LISTENERS];
                    } else if (!func) {
                        listners = that[LISTENERS];
                        if (listners) {
                            delete listners[type];
                            if (!Object.keys(listners).length)
                                return off.call(that);
                        }
                    } else {
                        listners = getListeners(that, type, true);
                        if (listners) {
                            listners = listners.filter(ne);
                            if (!listners.length)
                                return off.call(that, type);
                            that[LISTENERS][type] = listners;
                        }
                    }
                    return that;

                    function ne(test) {
                        return test !== func && test.originalListener !== func;
                    }
                }
                /**
                     * Dispatch (trigger) an event.
                     *
                     * @function EventLite.prototype.emit
                     * @param type {string}
                     * @param [value] {*}
                     * @returns {boolean} True when a listener received the event
                     */
                function emit(type, value) {
                    var that = this;
                    var listeners = getListeners(that, type, true);
                    if (!listeners)
                        return false;
                    var arglen = arguments.length;
                    if (arglen === 1) {
                        listeners.forEach(zeroarg);
                    } else if (arglen === 2) {
                        listeners.forEach(onearg);
                    } else {
                        var args = Array.prototype.slice.call(arguments, 1);
                        listeners.forEach(moreargs);
                    }
                    return !!listeners.length;

                    function zeroarg(func) {
                        func.call(that);
                    }

                    function onearg(func) {
                        func.call(that, value);
                    }

                    function moreargs(func) {
                        func.apply(that, args);
                    }
                }
                /**
                     * @ignore
                     */
                function getListeners(that, type, readonly) {
                    if (readonly && !that[LISTENERS])
                        return;
                    var listeners = that[LISTENERS] || (that[LISTENERS] = {});
                    return listeners[type] || (listeners[type] = []);
                }
            }
            )(EventLite);
            /***/
        },
        /***/
        "./node_modules/ieee754/index.js": /*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            exports.read = function(buffer, offset, isLE, mLen, nBytes) {
                var e, m;
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var nBits = -7;
                var i = isLE ? nBytes - 1 : 0;
                var d = isLE ? -1 : 1;
                var s = buffer[offset + i];
                i += d;
                e = s & ((1 << -nBits) - 1);
                s >>= -nBits;
                nBits += eLen;
                for (; nBits > 0; e = e * 256 + buffer[offset + i],
                     i += d,
                     nBits -= 8) {}
                m = e & ((1 << -nBits) - 1);
                e >>= -nBits;
                nBits += mLen;
                for (; nBits > 0; m = m * 256 + buffer[offset + i],
                     i += d,
                     nBits -= 8) {}
                if (e === 0) {
                    e = 1 - eBias;
                } else if (e === eMax) {
                    return m ? NaN : (s ? -1 : 1) * Infinity;
                } else {
                    m = m + Math.pow(2, mLen);
                    e = e - eBias;
                }
                return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            }
            ;
            exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                var e, m, c;
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var i = isLE ? 0 : nBytes - 1;
                var d = isLE ? 1 : -1;
                var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
                value = Math.abs(value);
                if (isNaN(value) || value === Infinity) {
                    m = isNaN(value) ? 1 : 0;
                    e = eMax;
                } else {
                    e = Math.floor(Math.log(value) / Math.LN2);
                    if (value * (c = Math.pow(2, -e)) < 1) {
                        e--;
                        c *= 2;
                    }
                    if (e + eBias >= 1) {
                        value += rt / c;
                    } else {
                        value += rt * Math.pow(2, 1 - eBias);
                    }
                    if (value * c >= 2) {
                        e++;
                        c /= 2;
                    }
                    if (e + eBias >= eMax) {
                        m = 0;
                        e = eMax;
                    } else if (e + eBias >= 1) {
                        m = (value * c - 1) * Math.pow(2, mLen);
                        e = e + eBias;
                    } else {
                        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                        e = 0;
                    }
                }
                for (; mLen >= 8; buffer[offset + i] = m & 0xff,
                     i += d,
                     m /= 256,
                     mLen -= 8) {}
                e = (e << mLen) | m;
                eLen += mLen;
                for (; eLen > 0; buffer[offset + i] = e & 0xff,
                     i += d,
                     e /= 256,
                     eLen -= 8) {}
                buffer[offset + i - d] |= s * 128;
            }
            ;
            /***/
        },
        /***/
        "./node_modules/int64-buffer/int64-buffer.js": /*!***************************************************!*\
  !*** ./node_modules/int64-buffer/int64-buffer.js ***!
  \***************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */
            (function(Buffer) {
                // int64-buffer.js
                /*jshint -W018 */
                // Confusing use of '!'.
                /*jshint -W030 */
                // Expected an assignment or function call and instead saw an expression.
                /*jshint -W093 */
                // Did you mean to return a conditional instead of an assignment?
                var Uint64BE, Int64BE, Uint64LE, Int64LE;
                !(function(exports) {
                    // constants
                    var UNDEFINED = "undefined";
                    var BUFFER = UNDEFINED !== typeof Buffer && Buffer;
                    var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
                    var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
                    var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
                    var isArray = Array.isArray || _isArray;
                    var BIT32 = 4294967296;
                    var BIT24 = 16777216;
                    // storage class
                    var storage;
                    // Array;
                    // generate classes
                    Uint64BE = factory("Uint64BE", true, true);
                    Int64BE = factory("Int64BE", true, false);
                    Uint64LE = factory("Uint64LE", false, true);
                    Int64LE = factory("Int64LE", false, false);
                    // class factory
                    function factory(name, bigendian, unsigned) {
                        var posH = bigendian ? 0 : 4;
                        var posL = bigendian ? 4 : 0;
                        var pos0 = bigendian ? 0 : 3;
                        var pos1 = bigendian ? 1 : 2;
                        var pos2 = bigendian ? 2 : 1;
                        var pos3 = bigendian ? 3 : 0;
                        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
                        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
                        var proto = Int64.prototype;
                        var isName = "is" + name;
                        var _isInt64 = "_" + isName;
                        // properties
                        proto.buffer = void 0;
                        proto.offset = 0;
                        proto[_isInt64] = true;
                        // methods
                        proto.toNumber = toNumber;
                        proto.toString = toString;
                        proto.toJSON = toNumber;
                        proto.toArray = toArray;
                        // add .toBuffer() method only when Buffer available
                        if (BUFFER)
                            proto.toBuffer = toBuffer;
                        // add .toArrayBuffer() method only when Uint8Array available
                        if (UINT8ARRAY)
                            proto.toArrayBuffer = toArrayBuffer;
                        // isUint64BE, isInt64BE
                        Int64[isName] = isInt64;
                        // CommonJS
                        exports[name] = Int64;
                        return Int64;
                        // constructor
                        function Int64(buffer, offset, value, raddix) {
                            if (!(this instanceof Int64))
                                return new Int64(buffer,offset,value,raddix);
                            return init(this, buffer, offset, value, raddix);
                        }
                        // isUint64BE, isInt64BE
                        function isInt64(b) {
                            return !!(b && b[_isInt64]);
                        }
                        // initializer
                        function init(that, buffer, offset, value, raddix) {
                            if (UINT8ARRAY && ARRAYBUFFER) {
                                if (buffer instanceof ARRAYBUFFER)
                                    buffer = new UINT8ARRAY(buffer);
                                if (value instanceof ARRAYBUFFER)
                                    value = new UINT8ARRAY(value);
                            }
                            // Int64BE() style
                            if (!buffer && !offset && !value && !storage) {
                                // shortcut to initialize with zero
                                that.buffer = newArray(ZERO, 0);
                                return;
                            }
                            // Int64BE(value, raddix) style
                            if (!isValidBuffer(buffer, offset)) {
                                var _storage = storage || Array;
                                raddix = offset;
                                value = buffer;
                                offset = 0;
                                buffer = new _storage(8);
                            }
                            that.buffer = buffer;
                            that.offset = offset |= 0;
                            // Int64BE(buffer, offset) style
                            if (UNDEFINED === typeof value)
                                return;
                            // Int64BE(buffer, offset, value, raddix) style
                            if ("string" === typeof value) {
                                fromString(buffer, offset, value, raddix || 10);
                            } else if (isValidBuffer(value, raddix)) {
                                fromArray(buffer, offset, value, raddix);
                            } else if ("number" === typeof raddix) {
                                writeInt32(buffer, offset + posH, value);
                                // high
                                writeInt32(buffer, offset + posL, raddix);
                                // low
                            } else if (value > 0) {
                                fromPositive(buffer, offset, value);
                                // positive
                            } else if (value < 0) {
                                fromNegative(buffer, offset, value);
                                // negative
                            } else {
                                fromArray(buffer, offset, ZERO, 0);
                                // zero, NaN and others
                            }
                        }

                        function fromString(buffer, offset, str, raddix) {
                            var pos = 0;
                            var len = str.length;
                            var high = 0;
                            var low = 0;
                            if (str[0] === "-")
                                pos++;
                            var sign = pos;
                            while (pos < len) {
                                var chr = parseInt(str[pos++], raddix);
                                if (!(chr >= 0))
                                    break;
                                // NaN
                                low = low * raddix + chr;
                                high = high * raddix + Math.floor(low / BIT32);
                                low %= BIT32;
                            }
                            if (sign) {
                                high = ~high;
                                if (low) {
                                    low = BIT32 - low;
                                } else {
                                    high++;
                                }
                            }
                            writeInt32(buffer, offset + posH, high);
                            writeInt32(buffer, offset + posL, low);
                        }

                        function toNumber() {
                            var buffer = this.buffer;
                            var offset = this.offset;
                            var high = readInt32(buffer, offset + posH);
                            var low = readInt32(buffer, offset + posL);
                            if (!unsigned)
                                high |= 0;
                            // a trick to get signed
                            return high ? high * BIT32 + low : low;
                        }

                        function toString(radix) {
                            var buffer = this.buffer;
                            var offset = this.offset;
                            var high = readInt32(buffer, offset + posH);
                            var low = readInt32(buffer, offset + posL);
                            var str = "";
                            var sign = !unsigned && high & 0x80000000;
                            if (sign) {
                                high = ~high;
                                low = BIT32 - low;
                            }
                            radix = radix || 10;
                            while (1) {
                                var mod = (high % radix) * BIT32 + low;
                                high = Math.floor(high / radix);
                                low = Math.floor(mod / radix);
                                str = (mod % radix).toString(radix) + str;
                                if (!high && !low)
                                    break;
                            }
                            if (sign) {
                                str = "-" + str;
                            }
                            return str;
                        }

                        function writeInt32(buffer, offset, value) {
                            buffer[offset + pos3] = value & 255;
                            value = value >> 8;
                            buffer[offset + pos2] = value & 255;
                            value = value >> 8;
                            buffer[offset + pos1] = value & 255;
                            value = value >> 8;
                            buffer[offset + pos0] = value & 255;
                        }

                        function readInt32(buffer, offset) {
                            return (buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16) + (buffer[offset + pos2] << 8) + buffer[offset + pos3]);
                        }
                    }

                    function toArray(raw) {
                        var buffer = this.buffer;
                        var offset = this.offset;
                        storage = null;
                        // Array
                        if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer))
                            return buffer;
                        return newArray(buffer, offset);
                    }

                    function toBuffer(raw) {
                        var buffer = this.buffer;
                        var offset = this.offset;
                        storage = BUFFER;
                        if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer))
                            return buffer;
                        var dest = new BUFFER(8);
                        fromArray(dest, 0, buffer, offset);
                        return dest;
                    }

                    function toArrayBuffer(raw) {
                        var buffer = this.buffer;
                        var offset = this.offset;
                        var arrbuf = buffer.buffer;
                        storage = UINT8ARRAY;
                        if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
                            return arrbuf;
                        var dest = new UINT8ARRAY(8);
                        fromArray(dest, 0, buffer, offset);
                        return dest.buffer;
                    }

                    function isValidBuffer(buffer, offset) {
                        var len = buffer && buffer.length;
                        offset |= 0;
                        return (len && offset + 8 <= len && "string" !== typeof buffer[offset]);
                    }

                    function fromArray(destbuf, destoff, srcbuf, srcoff) {
                        destoff |= 0;
                        srcoff |= 0;
                        for (var i = 0; i < 8; i++) {
                            destbuf[destoff++] = srcbuf[srcoff++] & 255;
                        }
                    }

                    function newArray(buffer, offset) {
                        return Array.prototype.slice.call(buffer, offset, offset + 8);
                    }

                    function fromPositiveBE(buffer, offset, value) {
                        var pos = offset + 8;
                        while (pos > offset) {
                            buffer[--pos] = value & 255;
                            value /= 256;
                        }
                    }

                    function fromNegativeBE(buffer, offset, value) {
                        var pos = offset + 8;
                        value++;
                        while (pos > offset) {
                            buffer[--pos] = (-value & 255) ^ 255;
                            value /= 256;
                        }
                    }

                    function fromPositiveLE(buffer, offset, value) {
                        var end = offset + 8;
                        while (offset < end) {
                            buffer[offset++] = value & 255;
                            value /= 256;
                        }
                    }

                    function fromNegativeLE(buffer, offset, value) {
                        var end = offset + 8;
                        value++;
                        while (offset < end) {
                            buffer[offset++] = (-value & 255) ^ 255;
                            value /= 256;
                        }
                    }
                    // https://github.com/retrofox/is-array
                    function _isArray(val) {
                        return (!!val && "[object Array]" == Object.prototype.toString.call(val));
                    }
                }
                 )(true && typeof exports.nodeName !== "string" ? exports : this || {});
                /* WEBPACK VAR INJECTION */
            }
            ).call(this, __webpack_require__(/*! ./../buffer/index.js */
                "./node_modules/buffer/index.js").Buffer);
            /***/
        },
        /***/
        "./node_modules/is-buffer/index.js": /*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            /*!
                 * Determine if an object is a Buffer
                 *
                 * @author   Feross Aboukhadijeh <https://feross.org>
                 * @license  MIT
                 */
            // The _isBuffer check is for Safari 5-7 support, because it's missing
            // Object.prototype.constructor. Remove this eventually
            module.exports = function(obj) {
                return (obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer));
            }
            ;

            function isBuffer(obj) {
                return (!!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj));
            }
            // For Node v0.10 support. Remove this eventually.
            function isSlowBuffer(obj) {
                return (typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0)));
            }
            /***/
        },
        /***/
        "./node_modules/md5/md5.js": /*!*********************************!*\
  !*** ./node_modules/md5/md5.js ***!
  \*********************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            (function() {
                var crypt = __webpack_require__(/*! crypt */
                    "./node_modules/crypt/crypt.js")
                , utf8 = __webpack_require__(/*! charenc */
                    "./node_modules/charenc/charenc.js").utf8
                , isBuffer = __webpack_require__(/*! is-buffer */
                    "./node_modules/is-buffer/index.js")
                , bin = __webpack_require__(/*! charenc */
                    "./node_modules/charenc/charenc.js").bin
                , // The core
                    md5 = function(message, options) {
                        // Convert to byte array
                        if (message.constructor == String)
                            if (options && options.encoding === "binary")
                                message = bin.stringToBytes(message);
                            else
                                message = utf8.stringToBytes(message);
                        else if (isBuffer(message))
                            message = Array.prototype.slice.call(message, 0);
                        else if (!Array.isArray(message))
                            message = message.toString();
                        // else, assume byte array already
                        var m = crypt.bytesToWords(message)
                        , l = message.length * 8
                        , a = 1732584193
                        , b = -271733879
                        , c = -1732584194
                        , d = 271733878;
                        // Swap endian
                        for (var i = 0; i < m.length; i++) {
                            m[i] = (((m[i] << 8) | (m[i] >>> 24)) & 0x00ff00ff) | (((m[i] << 24) | (m[i] >>> 8)) & 0xff00ff00);
                        }
                        // Padding
                        m[l >>> 5] |= 0x80 << l % 32;
                        m[(((l + 64) >>> 9) << 4) + 14] = l;
                        // Method shortcuts
                        var FF = md5._ff
                        , GG = md5._gg
                        , HH = md5._hh
                        , II = md5._ii;
                        for (var i = 0; i < m.length; i += 16) {
                            var aa = a
                            , bb = b
                            , cc = c
                            , dd = d;
                            a = FF(a, b, c, d, m[i + 0], 7, -680876936);
                            d = FF(d, a, b, c, m[i + 1], 12, -389564586);
                            c = FF(c, d, a, b, m[i + 2], 17, 606105819);
                            b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
                            a = FF(a, b, c, d, m[i + 4], 7, -176418897);
                            d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
                            c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
                            b = FF(b, c, d, a, m[i + 7], 22, -45705983);
                            a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
                            d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
                            c = FF(c, d, a, b, m[i + 10], 17, -42063);
                            b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
                            a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
                            d = FF(d, a, b, c, m[i + 13], 12, -40341101);
                            c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
                            b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
                            a = GG(a, b, c, d, m[i + 1], 5, -165796510);
                            d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
                            c = GG(c, d, a, b, m[i + 11], 14, 643717713);
                            b = GG(b, c, d, a, m[i + 0], 20, -373897302);
                            a = GG(a, b, c, d, m[i + 5], 5, -701558691);
                            d = GG(d, a, b, c, m[i + 10], 9, 38016083);
                            c = GG(c, d, a, b, m[i + 15], 14, -660478335);
                            b = GG(b, c, d, a, m[i + 4], 20, -405537848);
                            a = GG(a, b, c, d, m[i + 9], 5, 568446438);
                            d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
                            c = GG(c, d, a, b, m[i + 3], 14, -187363961);
                            b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
                            a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
                            d = GG(d, a, b, c, m[i + 2], 9, -51403784);
                            c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
                            b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
                            a = HH(a, b, c, d, m[i + 5], 4, -378558);
                            d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
                            c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
                            b = HH(b, c, d, a, m[i + 14], 23, -35309556);
                            a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
                            d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
                            c = HH(c, d, a, b, m[i + 7], 16, -155497632);
                            b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
                            a = HH(a, b, c, d, m[i + 13], 4, 681279174);
                            d = HH(d, a, b, c, m[i + 0], 11, -358537222);
                            c = HH(c, d, a, b, m[i + 3], 16, -722521979);
                            b = HH(b, c, d, a, m[i + 6], 23, 76029189);
                            a = HH(a, b, c, d, m[i + 9], 4, -640364487);
                            d = HH(d, a, b, c, m[i + 12], 11, -421815835);
                            c = HH(c, d, a, b, m[i + 15], 16, 530742520);
                            b = HH(b, c, d, a, m[i + 2], 23, -995338651);
                            a = II(a, b, c, d, m[i + 0], 6, -198630844);
                            d = II(d, a, b, c, m[i + 7], 10, 1126891415);
                            c = II(c, d, a, b, m[i + 14], 15, -1416354905);
                            b = II(b, c, d, a, m[i + 5], 21, -57434055);
                            a = II(a, b, c, d, m[i + 12], 6, 1700485571);
                            d = II(d, a, b, c, m[i + 3], 10, -1894986606);
                            c = II(c, d, a, b, m[i + 10], 15, -1051523);
                            b = II(b, c, d, a, m[i + 1], 21, -2054922799);
                            a = II(a, b, c, d, m[i + 8], 6, 1873313359);
                            d = II(d, a, b, c, m[i + 15], 10, -30611744);
                            c = II(c, d, a, b, m[i + 6], 15, -1560198380);
                            b = II(b, c, d, a, m[i + 13], 21, 1309151649);
                            a = II(a, b, c, d, m[i + 4], 6, -145523070);
                            d = II(d, a, b, c, m[i + 11], 10, -1120210379);
                            c = II(c, d, a, b, m[i + 2], 15, 718787259);
                            b = II(b, c, d, a, m[i + 9], 21, -343485551);
                            a = (a + aa) >>> 0;
                            b = (b + bb) >>> 0;
                            c = (c + cc) >>> 0;
                            d = (d + dd) >>> 0;
                        }
                        return crypt.endian([a, b, c, d]);
                    };
                // Auxiliary functions
                md5._ff = function(a, b, c, d, x, s, t) {
                    var n = a + ((b & c) | (~b & d)) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                ;
                md5._gg = function(a, b, c, d, x, s, t) {
                    var n = a + ((b & d) | (c & ~d)) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                ;
                md5._hh = function(a, b, c, d, x, s, t) {
                    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                ;
                md5._ii = function(a, b, c, d, x, s, t) {
                    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }
                ;
                // Package private blocksize
                md5._blocksize = 16;
                md5._digestsize = 16;
                module.exports = function(message, options) {
                    if (message === undefined || message === null)
                        throw new Error("Illegal argument " + message);
                    var digestbytes = crypt.wordsToBytes(md5(message, options));
                    return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
                }
                ;
            }
            )();
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/browser.js": /*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/browser.js ***!
  \**************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // browser.js
            exports.encode = __webpack_require__(/*! ./encode */
                "./node_modules/msgpack-lite/lib/encode.js").encode;
            exports.decode = __webpack_require__(/*! ./decode */
                "./node_modules/msgpack-lite/lib/decode.js").decode;
            exports.Encoder = __webpack_require__(/*! ./encoder */
                "./node_modules/msgpack-lite/lib/encoder.js").Encoder;
            exports.Decoder = __webpack_require__(/*! ./decoder */
                "./node_modules/msgpack-lite/lib/decoder.js").Decoder;
            exports.createCodec = __webpack_require__(/*! ./ext */
                "./node_modules/msgpack-lite/lib/ext.js").createCodec;
            exports.codec = __webpack_require__(/*! ./codec */
                "./node_modules/msgpack-lite/lib/codec.js").codec;
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/buffer-global.js": /*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-global.js ***!
  \********************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */
            (function(Buffer) {
                /* globals Buffer */
                module.exports = c("undefined" !== typeof Buffer && Buffer) || c(this.Buffer) || c("undefined" !== typeof window && window.Buffer) || this.Buffer;

                function c(B) {
                    return B && B.isBuffer && B;
                }
                /* WEBPACK VAR INJECTION */
            }
            ).call(this, __webpack_require__(/*! ./../../buffer/index.js */
                "./node_modules/buffer/index.js").Buffer);
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/buffer-lite.js": /*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-lite.js ***!
  \******************************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            // buffer-lite.js
            var MAXBUFLEN = 8192;
            exports.copy = copy;
            exports.toString = toString;
            exports.write = write;
            /**
                 * Buffer.prototype.write()
                 *
                 * @param string {String}
                 * @param [offset] {Number}
                 * @returns {Number}
                 */
            function write(string, offset) {
                var buffer = this;
                var index = offset || (offset |= 0);
                var length = string.length;
                var chr = 0;
                var i = 0;
                while (i < length) {
                    chr = string.charCodeAt(i++);
                    if (chr < 128) {
                        buffer[index++] = chr;
                    } else if (chr < 0x800) {
                        // 2 bytes
                        buffer[index++] = 0xc0 | (chr >>> 6);
                        buffer[index++] = 0x80 | (chr & 0x3f);
                    } else if (chr < 0xd800 || chr > 0xdfff) {
                        // 3 bytes
                        buffer[index++] = 0xe0 | (chr >>> 12);
                        buffer[index++] = 0x80 | ((chr >>> 6) & 0x3f);
                        buffer[index++] = 0x80 | (chr & 0x3f);
                    } else {
                        // 4 bytes - surrogate pair
                        chr = (((chr - 0xd800) << 10) | (string.charCodeAt(i++) - 0xdc00)) + 0x10000;
                        buffer[index++] = 0xf0 | (chr >>> 18);
                        buffer[index++] = 0x80 | ((chr >>> 12) & 0x3f);
                        buffer[index++] = 0x80 | ((chr >>> 6) & 0x3f);
                        buffer[index++] = 0x80 | (chr & 0x3f);
                    }
                }
                return index - offset;
            }
            /**
                 * Buffer.prototype.toString()
                 *
                 * @param [encoding] {String} ignored
                 * @param [start] {Number}
                 * @param [end] {Number}
                 * @returns {String}
                 */
            function toString(encoding, start, end) {
                var buffer = this;
                var index = start | 0;
                if (!end)
                    end = buffer.length;
                var string = "";
                var chr = 0;
                while (index < end) {
                    chr = buffer[index++];
                    if (chr < 128) {
                        string += String.fromCharCode(chr);
                        continue;
                    }
                    if ((chr & 0xe0) === 0xc0) {
                        // 2 bytes
                        chr = ((chr & 0x1f) << 6) | (buffer[index++] & 0x3f);
                    } else if ((chr & 0xf0) === 0xe0) {
                        // 3 bytes
                        chr = ((chr & 0x0f) << 12) | ((buffer[index++] & 0x3f) << 6) | (buffer[index++] & 0x3f);
                    } else if ((chr & 0xf8) === 0xf0) {
                        // 4 bytes
                        chr = ((chr & 0x07) << 18) | ((buffer[index++] & 0x3f) << 12) | ((buffer[index++] & 0x3f) << 6) | (buffer[index++] & 0x3f);
                    }
                    if (chr >= 0x010000) {
                        // A surrogate pair
                        chr -= 0x010000;
                        string += String.fromCharCode((chr >>> 10) + 0xd800, (chr & 0x3ff) + 0xdc00);
                    } else {
                        string += String.fromCharCode(chr);
                    }
                }
                return string;
            }
            /**
                 * Buffer.prototype.copy()
                 *
                 * @param target {Buffer}
                 * @param [targetStart] {Number}
                 * @param [start] {Number}
                 * @param [end] {Number}
                 * @returns {number}
                 */
            function copy(target, targetStart, start, end) {
                var i;
                if (!start)
                    start = 0;
                if (!end && end !== 0)
                    end = this.length;
                if (!targetStart)
                    targetStart = 0;
                var len = end - start;
                if (target === this && start < targetStart && targetStart < end) {
                    // descending
                    for (i = len - 1; i >= 0; i--) {
                        target[i + targetStart] = this[i + start];
                    }
                } else {
                    // ascending
                    for (i = 0; i < len; i++) {
                        target[i + targetStart] = this[i + start];
                    }
                }
                return len;
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/bufferish-array.js": /*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-array.js ***!
  \**********************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // bufferish-array.js
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");
            var exports = (module.exports = alloc(0));
            exports.alloc = alloc;
            exports.concat = Bufferish.concat;
            exports.from = from;
            /**
                 * @param size {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
            function alloc(size) {
                return new Array(size);
            }
            /**
                 * @param value {Array|ArrayBuffer|Buffer|String}
                 * @returns {Array}
                 */
            function from(value) {
                if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
                    // TypedArray to Uint8Array
                    value = Bufferish.Uint8Array.from(value);
                } else if (Bufferish.isArrayBuffer(value)) {
                    // ArrayBuffer to Uint8Array
                    value = new Uint8Array(value);
                } else if (typeof value === "string") {
                    // String to Array
                    return Bufferish.from.call(exports, value);
                } else if (typeof value === "number") {
                    throw new TypeError('"value" argument must not be a number');
                }
                // Array-like to Array
                return Array.prototype.slice.call(value);
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/bufferish-buffer.js": /*!***********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-buffer.js ***!
  \***********************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // bufferish-buffer.js
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");
            var Buffer = Bufferish.global;
            var exports = (module.exports = Bufferish.hasBuffer ? alloc(0) : []);
            exports.alloc = (Bufferish.hasBuffer && Buffer.alloc) || alloc;
            exports.concat = Bufferish.concat;
            exports.from = from;
            /**
                 * @param size {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
            function alloc(size) {
                return new Buffer(size);
            }
            /**
                 * @param value {Array|ArrayBuffer|Buffer|String}
                 * @returns {Buffer}
                 */
            function from(value) {
                if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
                    // TypedArray to Uint8Array
                    value = Bufferish.Uint8Array.from(value);
                } else if (Bufferish.isArrayBuffer(value)) {
                    // ArrayBuffer to Uint8Array
                    value = new Uint8Array(value);
                } else if (typeof value === "string") {
                    // String to Buffer
                    return Bufferish.from.call(exports, value);
                } else if (typeof value === "number") {
                    throw new TypeError('"value" argument must not be a number');
                }
                // Array-like to Buffer
                if (Buffer.from && Buffer.from.length !== 1) {
                    return Buffer.from(value);
                    // node v6+
                } else {
                    return new Buffer(value);
                    // node v4
                }
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/bufferish-proto.js": /*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-proto.js ***!
  \**********************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // bufferish-proto.js
            /* jshint eqnull:true */
            var BufferLite = __webpack_require__(/*! ./buffer-lite */
                "./node_modules/msgpack-lite/lib/buffer-lite.js");
            exports.copy = copy;
            exports.slice = slice;
            exports.toString = toString;
            exports.write = gen("write");
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");
            var Buffer = Bufferish.global;
            var isBufferShim = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT"in Buffer;
            var brokenTypedArray = isBufferShim && !Buffer.TYPED_ARRAY_SUPPORT;
            /**
                 * @param target {Buffer|Uint8Array|Array}
                 * @param [targetStart] {Number}
                 * @param [start] {Number}
                 * @param [end] {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
            function copy(target, targetStart, start, end) {
                var thisIsBuffer = Bufferish.isBuffer(this);
                var targetIsBuffer = Bufferish.isBuffer(target);
                if (thisIsBuffer && targetIsBuffer) {
                    // Buffer to Buffer
                    return this.copy(target, targetStart, start, end);
                } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {
                    // Uint8Array to Uint8Array (except for minor some browsers)
                    var buffer = start || end != null ? slice.call(this, start, end) : this;
                    target.set(buffer, targetStart);
                    return buffer.length;
                } else {
                    // other cases
                    return BufferLite.copy.call(this, target, targetStart, start, end);
                }
            }
            /**
                 * @param [start] {Number}
                 * @param [end] {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
            function slice(start, end) {
                // for Buffer, Uint8Array (except for minor some browsers) and Array
                var f = this.slice || (!brokenTypedArray && this.subarray);
                if (f)
                    return f.call(this, start, end);
                // Uint8Array (for minor some browsers)
                var target = Bufferish.alloc.call(this, end - start);
                copy.call(this, target, 0, start, end);
                return target;
            }
            /**
                 * Buffer.prototype.toString()
                 *
                 * @param [encoding] {String} ignored
                 * @param [start] {Number}
                 * @param [end] {Number}
                 * @returns {String}
                 */
            function toString(encoding, start, end) {
                var f = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;
                return f.apply(this, arguments);
            }
            /**
                 * @private
                 */
            function gen(method) {
                return wrap;

                function wrap() {
                    var f = this[method] || BufferLite[method];
                    return f.apply(this, arguments);
                }
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/bufferish-uint8array.js": /*!***************************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-uint8array.js ***!
  \***************************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // bufferish-uint8array.js
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");
            var exports = (module.exports = Bufferish.hasArrayBuffer ? alloc(0) : []);
            exports.alloc = alloc;
            exports.concat = Bufferish.concat;
            exports.from = from;
            /**
                 * @param size {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
            function alloc(size) {
                return new Uint8Array(size);
            }
            /**
                 * @param value {Array|ArrayBuffer|Buffer|String}
                 * @returns {Uint8Array}
                 */
            function from(value) {
                if (Bufferish.isView(value)) {
                    // TypedArray to ArrayBuffer
                    var byteOffset = value.byteOffset;
                    var byteLength = value.byteLength;
                    value = value.buffer;
                    if (value.byteLength !== byteLength) {
                        if (value.slice) {
                            value = value.slice(byteOffset, byteOffset + byteLength);
                        } else {
                            // Android 4.1 does not have ArrayBuffer.prototype.slice
                            value = new Uint8Array(value);
                            if (value.byteLength !== byteLength) {
                                // TypedArray to ArrayBuffer to Uint8Array to Array
                                value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength);
                            }
                        }
                    }
                } else if (typeof value === "string") {
                    // String to Uint8Array
                    return Bufferish.from.call(exports, value);
                } else if (typeof value === "number") {
                    throw new TypeError('"value" argument must not be a number');
                }
                return new Uint8Array(value);
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/bufferish.js": /*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish.js ***!
  \****************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // bufferish.js
            var Buffer = (exports.global = __webpack_require__(/*! ./buffer-global */
                "./node_modules/msgpack-lite/lib/buffer-global.js"));
            var hasBuffer = (exports.hasBuffer = Buffer && !!Buffer.isBuffer);
            var hasArrayBuffer = (exports.hasArrayBuffer = "undefined" !== typeof ArrayBuffer);
            var isArray = (exports.isArray = __webpack_require__(/*! isarray */
                "./node_modules/msgpack-lite/node_modules/isarray/index.js"));
            exports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
            var isBuffer = (exports.isBuffer = hasBuffer ? Buffer.isBuffer : _false);
            var isView = (exports.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false);
            exports.alloc = alloc;
            exports.concat = concat;
            exports.from = from;
            var BufferArray = (exports.Array = __webpack_require__(/*! ./bufferish-array */
                "./node_modules/msgpack-lite/lib/bufferish-array.js"));
            var BufferBuffer = (exports.Buffer = __webpack_require__(/*! ./bufferish-buffer */
                "./node_modules/msgpack-lite/lib/bufferish-buffer.js"));
            var BufferUint8Array = (exports.Uint8Array = __webpack_require__(/*! ./bufferish-uint8array */
                "./node_modules/msgpack-lite/lib/bufferish-uint8array.js"));
            var BufferProto = (exports.prototype = __webpack_require__(/*! ./bufferish-proto */
                "./node_modules/msgpack-lite/lib/bufferish-proto.js"));
            /**
                 * @param value {Array|ArrayBuffer|Buffer|String}
                 * @returns {Buffer|Uint8Array|Array}
                 */
            function from(value) {
                if (typeof value === "string") {
                    return fromString.call(this, value);
                } else {
                    return auto(this).from(value);
                }
            }
            /**
                 * @param size {Number}
                 * @returns {Buffer|Uint8Array|Array}
                 */
            function alloc(size) {
                return auto(this).alloc(size);
            }
            /**
                 * @param list {Array} array of (Buffer|Uint8Array|Array)s
                 * @param [length]
                 * @returns {Buffer|Uint8Array|Array}
                 */
            function concat(list, length) {
                if (!length) {
                    length = 0;
                    Array.prototype.forEach.call(list, dryrun);
                }
                var ref = (this !== exports && this) || list[0];
                var result = alloc.call(ref, length);
                var offset = 0;
                Array.prototype.forEach.call(list, append);
                return result;

                function dryrun(buffer) {
                    length += buffer.length;
                }

                function append(buffer) {
                    offset += BufferProto.copy.call(buffer, result, offset);
                }
            }
            var _isArrayBuffer = _is("ArrayBuffer");

            function isArrayBuffer(value) {
                return value instanceof ArrayBuffer || _isArrayBuffer(value);
            }
            /**
                 * @private
                 */
            function fromString(value) {
                var expected = value.length * 3;
                var that = alloc.call(this, expected);
                var actual = BufferProto.write.call(that, value);
                if (expected !== actual) {
                    that = BufferProto.slice.call(that, 0, actual);
                }
                return that;
            }

            function auto(that) {
                return isBuffer(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
            }

            function _false() {
                return false;
            }

            function _is(name, key) {
                /* jshint eqnull:true */
                name = "[object " + name + "]";
                return function(value) {
                    return (value != null && {}.toString.call(key ? value[key] : value) === name);
                }
                ;
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/codec-base.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec-base.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // codec-base.js
            var IS_ARRAY = __webpack_require__(/*! isarray */
                "./node_modules/msgpack-lite/node_modules/isarray/index.js");
            exports.createCodec = createCodec;
            exports.install = install;
            exports.filter = filter;
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");

            function Codec(options) {
                if (!(this instanceof Codec))
                    return new Codec(options);
                this.options = options;
                this.init();
            }
            Codec.prototype.init = function() {
                var options = this.options;
                if (options && options.uint8array) {
                    this.bufferish = Bufferish.Uint8Array;
                }
                return this;
            }
            ;

            function install(props) {
                for (var key in props) {
                    Codec.prototype[key] = add(Codec.prototype[key], props[key]);
                }
            }

            function add(a, b) {
                return a && b ? ab : a || b;

                function ab() {
                    a.apply(this, arguments);
                    return b.apply(this, arguments);
                }
            }

            function join(filters) {
                filters = filters.slice();
                return function(value) {
                    return filters.reduce(iterator, value);
                }
                ;

                function iterator(value, filter) {
                    return filter(value);
                }
            }

            function filter(filter) {
                return IS_ARRAY(filter) ? join(filter) : filter;
            }
            // @public
            // msgpack.createCodec()
            function createCodec(options) {
                return new Codec(options);
            }
            // default shared codec
            exports.preset = createCodec({
                preset: true
            });
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/codec.js": /*!************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec.js ***!
  \************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // codec.js
            // load both interfaces
            __webpack_require__(/*! ./read-core */
                "./node_modules/msgpack-lite/lib/read-core.js");
            __webpack_require__(/*! ./write-core */
                "./node_modules/msgpack-lite/lib/write-core.js");
            // @public
            // msgpack.codec.preset
            exports.codec = {
                preset: __webpack_require__(/*! ./codec-base */
                    "./node_modules/msgpack-lite/lib/codec-base.js").preset,
            };
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/decode-buffer.js": /*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode-buffer.js ***!
  \********************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // decode-buffer.js
            exports.DecodeBuffer = DecodeBuffer;
            var preset = __webpack_require__(/*! ./read-core */
                "./node_modules/msgpack-lite/lib/read-core.js").preset;
            var FlexDecoder = __webpack_require__(/*! ./flex-buffer */
                "./node_modules/msgpack-lite/lib/flex-buffer.js").FlexDecoder;
            FlexDecoder.mixin(DecodeBuffer.prototype);

            function DecodeBuffer(options) {
                if (!(this instanceof DecodeBuffer))
                    return new DecodeBuffer(options);
                if (options) {
                    this.options = options;
                    if (options.codec) {
                        var codec = (this.codec = options.codec);
                        if (codec.bufferish)
                            this.bufferish = codec.bufferish;
                    }
                }
            }
            DecodeBuffer.prototype.codec = preset;
            DecodeBuffer.prototype.fetch = function() {
                return this.codec.decode(this);
            }
            ;
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/decode.js": /*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // decode.js
            exports.decode = decode;
            var DecodeBuffer = __webpack_require__(/*! ./decode-buffer */
                "./node_modules/msgpack-lite/lib/decode-buffer.js").DecodeBuffer;

            function decode(input, options) {
                var decoder = new DecodeBuffer(options);
                decoder.write(input);
                return decoder.read();
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/decoder.js": /*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decoder.js ***!
  \**************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // decoder.js
            exports.Decoder = Decoder;
            var EventLite = __webpack_require__(/*! event-lite */
                "./node_modules/event-lite/event-lite.js");
            var DecodeBuffer = __webpack_require__(/*! ./decode-buffer */
                "./node_modules/msgpack-lite/lib/decode-buffer.js").DecodeBuffer;

            function Decoder(options) {
                if (!(this instanceof Decoder))
                    return new Decoder(options);
                DecodeBuffer.call(this, options);
            }
            Decoder.prototype = new DecodeBuffer();
            EventLite.mixin(Decoder.prototype);
            Decoder.prototype.decode = function(chunk) {
                if (arguments.length)
                    this.write(chunk);
                this.flush();
            }
            ;
            Decoder.prototype.push = function(chunk) {
                this.emit("data", chunk);
            }
            ;
            Decoder.prototype.end = function(chunk) {
                this.decode(chunk);
                this.emit("end");
            }
            ;
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/encode-buffer.js": /*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode-buffer.js ***!
  \********************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // encode-buffer.js
            exports.EncodeBuffer = EncodeBuffer;
            var preset = __webpack_require__(/*! ./write-core */
                "./node_modules/msgpack-lite/lib/write-core.js").preset;
            var FlexEncoder = __webpack_require__(/*! ./flex-buffer */
                "./node_modules/msgpack-lite/lib/flex-buffer.js").FlexEncoder;
            FlexEncoder.mixin(EncodeBuffer.prototype);

            function EncodeBuffer(options) {
                if (!(this instanceof EncodeBuffer))
                    return new EncodeBuffer(options);
                if (options) {
                    this.options = options;
                    if (options.codec) {
                        var codec = (this.codec = options.codec);
                        if (codec.bufferish)
                            this.bufferish = codec.bufferish;
                    }
                }
            }
            EncodeBuffer.prototype.codec = preset;
            EncodeBuffer.prototype.write = function(input) {
                this.codec.encode(this, input);
            }
            ;
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/encode.js": /*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // encode.js
            exports.encode = encode;
            var EncodeBuffer = __webpack_require__(/*! ./encode-buffer */
                "./node_modules/msgpack-lite/lib/encode-buffer.js").EncodeBuffer;

            function encode(input, options) {
                var encoder = new EncodeBuffer(options);
                encoder.write(input);
                return encoder.read();
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/encoder.js": /*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encoder.js ***!
  \**************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // encoder.js
            exports.Encoder = Encoder;
            var EventLite = __webpack_require__(/*! event-lite */
                "./node_modules/event-lite/event-lite.js");
            var EncodeBuffer = __webpack_require__(/*! ./encode-buffer */
                "./node_modules/msgpack-lite/lib/encode-buffer.js").EncodeBuffer;

            function Encoder(options) {
                if (!(this instanceof Encoder))
                    return new Encoder(options);
                EncodeBuffer.call(this, options);
            }
            Encoder.prototype = new EncodeBuffer();
            EventLite.mixin(Encoder.prototype);
            Encoder.prototype.encode = function(chunk) {
                this.write(chunk);
                this.emit("data", this.read());
            }
            ;
            Encoder.prototype.end = function(chunk) {
                if (arguments.length)
                    this.encode(chunk);
                this.flush();
                this.emit("end");
            }
            ;
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/ext-buffer.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-buffer.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // ext-buffer.js
            exports.ExtBuffer = ExtBuffer;
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");

            function ExtBuffer(buffer, type) {
                if (!(this instanceof ExtBuffer))
                    return new ExtBuffer(buffer,type);
                this.buffer = Bufferish.from(buffer);
                this.type = type;
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/ext-packer.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-packer.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // ext-packer.js
            exports.setExtPackers = setExtPackers;
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");
            var Buffer = Bufferish.global;
            var packTypedArray = Bufferish.Uint8Array.from;
            var _encode;
            var ERROR_COLUMNS = {
                name: 1,
                message: 1,
                stack: 1,
                columnNumber: 1,
                fileName: 1,
                lineNumber: 1,
            };

            function setExtPackers(codec) {
                codec.addExtPacker(0x0e, Error, [packError, encode]);
                codec.addExtPacker(0x01, EvalError, [packError, encode]);
                codec.addExtPacker(0x02, RangeError, [packError, encode]);
                codec.addExtPacker(0x03, ReferenceError, [packError, encode]);
                codec.addExtPacker(0x04, SyntaxError, [packError, encode]);
                codec.addExtPacker(0x05, TypeError, [packError, encode]);
                codec.addExtPacker(0x06, URIError, [packError, encode]);
                codec.addExtPacker(0x0a, RegExp, [packRegExp, encode]);
                codec.addExtPacker(0x0b, Boolean, [packValueOf, encode]);
                codec.addExtPacker(0x0c, String, [packValueOf, encode]);
                codec.addExtPacker(0x0d, Date, [Number, encode]);
                codec.addExtPacker(0x0f, Number, [packValueOf, encode]);
                if ("undefined" !== typeof Uint8Array) {
                    codec.addExtPacker(0x11, Int8Array, packTypedArray);
                    codec.addExtPacker(0x12, Uint8Array, packTypedArray);
                    codec.addExtPacker(0x13, Int16Array, packTypedArray);
                    codec.addExtPacker(0x14, Uint16Array, packTypedArray);
                    codec.addExtPacker(0x15, Int32Array, packTypedArray);
                    codec.addExtPacker(0x16, Uint32Array, packTypedArray);
                    codec.addExtPacker(0x17, Float32Array, packTypedArray);
                    // PhantomJS/1.9.7 doesn't have Float64Array
                    if ("undefined" !== typeof Float64Array) {
                        codec.addExtPacker(0x18, Float64Array, packTypedArray);
                    }
                    // IE10 doesn't have Uint8ClampedArray
                    if ("undefined" !== typeof Uint8ClampedArray) {
                        codec.addExtPacker(0x19, Uint8ClampedArray, packTypedArray);
                    }
                    codec.addExtPacker(0x1a, ArrayBuffer, packTypedArray);
                    codec.addExtPacker(0x1d, DataView, packTypedArray);
                }
                if (Bufferish.hasBuffer) {
                    codec.addExtPacker(0x1b, Buffer, Bufferish.from);
                }
            }

            function encode(input) {
                if (!_encode)
                    _encode = __webpack_require__(/*! ./encode */
                        "./node_modules/msgpack-lite/lib/encode.js").encode;
                // lazy load
                return _encode(input);
            }

            function packValueOf(value) {
                return value.valueOf();
            }

            function packRegExp(value) {
                value = RegExp.prototype.toString.call(value).split("/");
                value.shift();
                var out = [value.pop()];
                out.unshift(value.join("/"));
                return out;
            }

            function packError(value) {
                var out = {};
                for (var key in ERROR_COLUMNS) {
                    out[key] = value[key];
                }
                return out;
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/ext-unpacker.js": /*!*******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-unpacker.js ***!
  \*******************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // ext-unpacker.js
            exports.setExtUnpackers = setExtUnpackers;
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");
            var Buffer = Bufferish.global;
            var _decode;
            var ERROR_COLUMNS = {
                name: 1,
                message: 1,
                stack: 1,
                columnNumber: 1,
                fileName: 1,
                lineNumber: 1,
            };

            function setExtUnpackers(codec) {
                codec.addExtUnpacker(0x0e, [decode, unpackError(Error)]);
                codec.addExtUnpacker(0x01, [decode, unpackError(EvalError)]);
                codec.addExtUnpacker(0x02, [decode, unpackError(RangeError)]);
                codec.addExtUnpacker(0x03, [decode, unpackError(ReferenceError)]);
                codec.addExtUnpacker(0x04, [decode, unpackError(SyntaxError)]);
                codec.addExtUnpacker(0x05, [decode, unpackError(TypeError)]);
                codec.addExtUnpacker(0x06, [decode, unpackError(URIError)]);
                codec.addExtUnpacker(0x0a, [decode, unpackRegExp]);
                codec.addExtUnpacker(0x0b, [decode, unpackClass(Boolean)]);
                codec.addExtUnpacker(0x0c, [decode, unpackClass(String)]);
                codec.addExtUnpacker(0x0d, [decode, unpackClass(Date)]);
                codec.addExtUnpacker(0x0f, [decode, unpackClass(Number)]);
                if ("undefined" !== typeof Uint8Array) {
                    codec.addExtUnpacker(0x11, unpackClass(Int8Array));
                    codec.addExtUnpacker(0x12, unpackClass(Uint8Array));
                    codec.addExtUnpacker(0x13, [unpackArrayBuffer, unpackClass(Int16Array), ]);
                    codec.addExtUnpacker(0x14, [unpackArrayBuffer, unpackClass(Uint16Array), ]);
                    codec.addExtUnpacker(0x15, [unpackArrayBuffer, unpackClass(Int32Array), ]);
                    codec.addExtUnpacker(0x16, [unpackArrayBuffer, unpackClass(Uint32Array), ]);
                    codec.addExtUnpacker(0x17, [unpackArrayBuffer, unpackClass(Float32Array), ]);
                    // PhantomJS/1.9.7 doesn't have Float64Array
                    if ("undefined" !== typeof Float64Array) {
                        codec.addExtUnpacker(0x18, [unpackArrayBuffer, unpackClass(Float64Array), ]);
                    }
                    // IE10 doesn't have Uint8ClampedArray
                    if ("undefined" !== typeof Uint8ClampedArray) {
                        codec.addExtUnpacker(0x19, unpackClass(Uint8ClampedArray));
                    }
                    codec.addExtUnpacker(0x1a, unpackArrayBuffer);
                    codec.addExtUnpacker(0x1d, [unpackArrayBuffer, unpackClass(DataView), ]);
                }
                if (Bufferish.hasBuffer) {
                    codec.addExtUnpacker(0x1b, unpackClass(Buffer));
                }
            }

            function decode(input) {
                if (!_decode)
                    _decode = __webpack_require__(/*! ./decode */
                        "./node_modules/msgpack-lite/lib/decode.js").decode;
                // lazy load
                return _decode(input);
            }

            function unpackRegExp(value) {
                return RegExp.apply(null, value);
            }

            function unpackError(Class) {
                return function(value) {
                    var out = new Class();
                    for (var key in ERROR_COLUMNS) {
                        out[key] = value[key];
                    }
                    return out;
                }
                ;
            }

            function unpackClass(Class) {
                return function(value) {
                    return new Class(value);
                }
                ;
            }

            function unpackArrayBuffer(value) {
                return new Uint8Array(value).buffer;
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/ext.js": /*!**********************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext.js ***!
  \**********************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // ext.js
            // load both interfaces
            __webpack_require__(/*! ./read-core */
                "./node_modules/msgpack-lite/lib/read-core.js");
            __webpack_require__(/*! ./write-core */
                "./node_modules/msgpack-lite/lib/write-core.js");
            exports.createCodec = __webpack_require__(/*! ./codec-base */
                "./node_modules/msgpack-lite/lib/codec-base.js").createCodec;
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/flex-buffer.js": /*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/flex-buffer.js ***!
  \******************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // flex-buffer.js
            exports.FlexDecoder = FlexDecoder;
            exports.FlexEncoder = FlexEncoder;
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");
            var MIN_BUFFER_SIZE = 2048;
            var MAX_BUFFER_SIZE = 65536;
            var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";

            function FlexDecoder() {
                if (!(this instanceof FlexDecoder))
                    return new FlexDecoder();
            }

            function FlexEncoder() {
                if (!(this instanceof FlexEncoder))
                    return new FlexEncoder();
            }
            FlexDecoder.mixin = mixinFactory(getDecoderMethods());
            FlexDecoder.mixin(FlexDecoder.prototype);
            FlexEncoder.mixin = mixinFactory(getEncoderMethods());
            FlexEncoder.mixin(FlexEncoder.prototype);

            function getDecoderMethods() {
                return {
                    bufferish: Bufferish,
                    write: write,
                    fetch: fetch,
                    flush: flush,
                    push: push,
                    pull: pull,
                    read: read,
                    reserve: reserve,
                    offset: 0,
                };

                function write(chunk) {
                    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
                    this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
                    this.offset = 0;
                }

                function flush() {
                    while (this.offset < this.buffer.length) {
                        var start = this.offset;
                        var value;
                        try {
                            value = this.fetch();
                        } catch (e) {
                            if (e && e.message != BUFFER_SHORTAGE)
                                throw e;
                            // rollback
                            this.offset = start;
                            break;
                        }
                        this.push(value);
                    }
                }

                function reserve(length) {
                    var start = this.offset;
                    var end = start + length;
                    if (end > this.buffer.length)
                        throw new Error(BUFFER_SHORTAGE);
                    this.offset = end;
                    return start;
                }
            }

            function getEncoderMethods() {
                return {
                    bufferish: Bufferish,
                    write: write,
                    fetch: fetch,
                    flush: flush,
                    push: push,
                    pull: pull,
                    read: read,
                    reserve: reserve,
                    send: send,
                    maxBufferSize: MAX_BUFFER_SIZE,
                    minBufferSize: MIN_BUFFER_SIZE,
                    offset: 0,
                    start: 0,
                };

                function fetch() {
                    var start = this.start;
                    if (start < this.offset) {
                        var end = (this.start = this.offset);
                        return Bufferish.prototype.slice.call(this.buffer, start, end);
                    }
                }

                function flush() {
                    while (this.start < this.offset) {
                        var value = this.fetch();
                        if (value)
                            this.push(value);
                    }
                }

                function pull() {
                    var buffers = this.buffers || (this.buffers = []);
                    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
                    buffers.length = 0;
                    // buffer exhausted
                    return chunk;
                }

                function reserve(length) {
                    var req = length | 0;
                    if (this.buffer) {
                        var size = this.buffer.length;
                        var start = this.offset | 0;
                        var end = start + req;
                        // is it long enough?
                        if (end < size) {
                            this.offset = end;
                            return start;
                        }
                        // flush current buffer
                        this.flush();
                        // resize it to 2x current length
                        length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
                    }
                    // minimum buffer size
                    length = Math.max(length, this.minBufferSize);
                    // allocate new buffer
                    this.buffer = this.bufferish.alloc(length);
                    this.start = 0;
                    this.offset = req;
                    return 0;
                }

                function send(buffer) {
                    var length = buffer.length;
                    if (length > this.minBufferSize) {
                        this.flush();
                        this.push(buffer);
                    } else {
                        var offset = this.reserve(length);
                        Bufferish.prototype.copy.call(buffer, this.buffer, offset);
                    }
                }
            }
            // common methods
            function write() {
                throw new Error("method not implemented: write()");
            }

            function fetch() {
                throw new Error("method not implemented: fetch()");
            }

            function read() {
                var length = this.buffers && this.buffers.length;
                // fetch the first result
                if (!length)
                    return this.fetch();
                // flush current buffer
                this.flush();
                // read from the results
                return this.pull();
            }

            function push(chunk) {
                var buffers = this.buffers || (this.buffers = []);
                buffers.push(chunk);
            }

            function pull() {
                var buffers = this.buffers || (this.buffers = []);
                return buffers.shift();
            }

            function mixinFactory(source) {
                return mixin;

                function mixin(target) {
                    for (var key in source) {
                        target[key] = source[key];
                    }
                    return target;
                }
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/read-core.js": /*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-core.js ***!
  \****************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // read-core.js
            var ExtBuffer = __webpack_require__(/*! ./ext-buffer */
                "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
            var ExtUnpacker = __webpack_require__(/*! ./ext-unpacker */
                "./node_modules/msgpack-lite/lib/ext-unpacker.js");
            var readUint8 = __webpack_require__(/*! ./read-format */
                "./node_modules/msgpack-lite/lib/read-format.js").readUint8;
            var ReadToken = __webpack_require__(/*! ./read-token */
                "./node_modules/msgpack-lite/lib/read-token.js");
            var CodecBase = __webpack_require__(/*! ./codec-base */
                "./node_modules/msgpack-lite/lib/codec-base.js");
            CodecBase.install({
                addExtUnpacker: addExtUnpacker,
                getExtUnpacker: getExtUnpacker,
                init: init,
            });
            exports.preset = init.call(CodecBase.preset);

            function getDecoder(options) {
                var readToken = ReadToken.getReadToken(options);
                return decode;

                function decode(decoder) {
                    var type = readUint8(decoder);
                    var func = readToken[type];
                    if (!func)
                        throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
                    return func(decoder);
                }
            }

            function init() {
                var options = this.options;
                this.decode = getDecoder(options);
                if (options && options.preset) {
                    ExtUnpacker.setExtUnpackers(this);
                }
                return this;
            }

            function addExtUnpacker(etype, unpacker) {
                var unpackers = this.extUnpackers || (this.extUnpackers = []);
                unpackers[etype] = CodecBase.filter(unpacker);
            }

            function getExtUnpacker(type) {
                var unpackers = this.extUnpackers || (this.extUnpackers = []);
                return unpackers[type] || extUnpacker;

                function extUnpacker(buffer) {
                    return new ExtBuffer(buffer,type);
                }
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/read-format.js": /*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-format.js ***!
  \******************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // read-format.js
            var ieee754 = __webpack_require__(/*! ieee754 */
                "./node_modules/ieee754/index.js");
            var Int64Buffer = __webpack_require__(/*! int64-buffer */
                "./node_modules/int64-buffer/int64-buffer.js");
            var Uint64BE = Int64Buffer.Uint64BE;
            var Int64BE = Int64Buffer.Int64BE;
            exports.getReadFormat = getReadFormat;
            exports.readUint8 = uint8;
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");
            var BufferProto = __webpack_require__(/*! ./bufferish-proto */
                "./node_modules/msgpack-lite/lib/bufferish-proto.js");
            var HAS_MAP = "undefined" !== typeof Map;
            var NO_ASSERT = true;

            function getReadFormat(options) {
                var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
                var int64 = options && options.int64;
                var usemap = HAS_MAP && options && options.usemap;
                var readFormat = {
                    map: usemap ? map_to_map : map_to_obj,
                    array: array,
                    str: str,
                    bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
                    ext: ext,
                    uint8: uint8,
                    uint16: uint16,
                    uint32: uint32,
                    uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
                    int8: int8,
                    int16: int16,
                    int32: int32,
                    int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
                    float32: read(4, readFloatBE),
                    float64: read(8, readDoubleBE),
                };
                return readFormat;
            }

            function map_to_obj(decoder, len) {
                var value = {};
                var i;
                var k = new Array(len);
                var v = new Array(len);
                var decode = decoder.codec.decode;
                for (i = 0; i < len; i++) {
                    k[i] = decode(decoder);
                    v[i] = decode(decoder);
                }
                for (i = 0; i < len; i++) {
                    value[k[i]] = v[i];
                }
                return value;
            }

            function map_to_map(decoder, len) {
                var value = new Map();
                var i;
                var k = new Array(len);
                var v = new Array(len);
                var decode = decoder.codec.decode;
                for (i = 0; i < len; i++) {
                    k[i] = decode(decoder);
                    v[i] = decode(decoder);
                }
                for (i = 0; i < len; i++) {
                    value.set(k[i], v[i]);
                }
                return value;
            }

            function array(decoder, len) {
                var value = new Array(len);
                var decode = decoder.codec.decode;
                for (var i = 0; i < len; i++) {
                    value[i] = decode(decoder);
                }
                return value;
            }

            function str(decoder, len) {
                var start = decoder.reserve(len);
                var end = start + len;
                return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
            }

            function bin_buffer(decoder, len) {
                var start = decoder.reserve(len);
                var end = start + len;
                var buf = BufferProto.slice.call(decoder.buffer, start, end);
                return Bufferish.from(buf);
            }

            function bin_arraybuffer(decoder, len) {
                var start = decoder.reserve(len);
                var end = start + len;
                var buf = BufferProto.slice.call(decoder.buffer, start, end);
                return Bufferish.Uint8Array.from(buf).buffer;
            }

            function ext(decoder, len) {
                var start = decoder.reserve(len + 1);
                var type = decoder.buffer[start++];
                var end = start + len;
                var unpack = decoder.codec.getExtUnpacker(type);
                if (!unpack)
                    throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
                var buf = BufferProto.slice.call(decoder.buffer, start, end);
                return unpack(buf);
            }

            function uint8(decoder) {
                var start = decoder.reserve(1);
                return decoder.buffer[start];
            }

            function int8(decoder) {
                var start = decoder.reserve(1);
                var value = decoder.buffer[start];
                return value & 0x80 ? value - 0x100 : value;
            }

            function uint16(decoder) {
                var start = decoder.reserve(2);
                var buffer = decoder.buffer;
                return (buffer[start++] << 8) | buffer[start];
            }

            function int16(decoder) {
                var start = decoder.reserve(2);
                var buffer = decoder.buffer;
                var value = (buffer[start++] << 8) | buffer[start];
                return value & 0x8000 ? value - 0x10000 : value;
            }

            function uint32(decoder) {
                var start = decoder.reserve(4);
                var buffer = decoder.buffer;
                return (buffer[start++] * 16777216 + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start]);
            }

            function int32(decoder) {
                var start = decoder.reserve(4);
                var buffer = decoder.buffer;
                return ((buffer[start++] << 24) | (buffer[start++] << 16) | (buffer[start++] << 8) | buffer[start]);
            }

            function read(len, method) {
                return function(decoder) {
                    var start = decoder.reserve(len);
                    return method.call(decoder.buffer, start, NO_ASSERT);
                }
                ;
            }

            function readUInt64BE(start) {
                return new Uint64BE(this,start).toNumber();
            }

            function readInt64BE(start) {
                return new Int64BE(this,start).toNumber();
            }

            function readUInt64BE_int64(start) {
                return new Uint64BE(this,start);
            }

            function readInt64BE_int64(start) {
                return new Int64BE(this,start);
            }

            function readFloatBE(start) {
                return ieee754.read(this, start, false, 23, 4);
            }

            function readDoubleBE(start) {
                return ieee754.read(this, start, false, 52, 8);
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/read-token.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-token.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // read-token.js
            var ReadFormat = __webpack_require__(/*! ./read-format */
                "./node_modules/msgpack-lite/lib/read-format.js");
            exports.getReadToken = getReadToken;

            function getReadToken(options) {
                var format = ReadFormat.getReadFormat(options);
                if (options && options.useraw) {
                    return init_useraw(format);
                } else {
                    return init_token(format);
                }
            }

            function init_token(format) {
                var i;
                var token = new Array(256);
                // positive fixint -- 0x00 - 0x7f
                for (i = 0x00; i <= 0x7f; i++) {
                    token[i] = constant(i);
                }
                // fixmap -- 0x80 - 0x8f
                for (i = 0x80; i <= 0x8f; i++) {
                    token[i] = fix(i - 0x80, format.map);
                }
                // fixarray -- 0x90 - 0x9f
                for (i = 0x90; i <= 0x9f; i++) {
                    token[i] = fix(i - 0x90, format.array);
                }
                // fixstr -- 0xa0 - 0xbf
                for (i = 0xa0; i <= 0xbf; i++) {
                    token[i] = fix(i - 0xa0, format.str);
                }
                // nil -- 0xc0
                token[0xc0] = constant(null);
                // (never used) -- 0xc1
                token[0xc1] = null;
                // false -- 0xc2
                // true -- 0xc3
                token[0xc2] = constant(false);
                token[0xc3] = constant(true);
                // bin 8 -- 0xc4
                // bin 16 -- 0xc5
                // bin 32 -- 0xc6
                token[0xc4] = flex(format.uint8, format.bin);
                token[0xc5] = flex(format.uint16, format.bin);
                token[0xc6] = flex(format.uint32, format.bin);
                // ext 8 -- 0xc7
                // ext 16 -- 0xc8
                // ext 32 -- 0xc9
                token[0xc7] = flex(format.uint8, format.ext);
                token[0xc8] = flex(format.uint16, format.ext);
                token[0xc9] = flex(format.uint32, format.ext);
                // float 32 -- 0xca
                // float 64 -- 0xcb
                token[0xca] = format.float32;
                token[0xcb] = format.float64;
                // uint 8 -- 0xcc
                // uint 16 -- 0xcd
                // uint 32 -- 0xce
                // uint 64 -- 0xcf
                token[0xcc] = format.uint8;
                token[0xcd] = format.uint16;
                token[0xce] = format.uint32;
                token[0xcf] = format.uint64;
                // int 8 -- 0xd0
                // int 16 -- 0xd1
                // int 32 -- 0xd2
                // int 64 -- 0xd3
                token[0xd0] = format.int8;
                token[0xd1] = format.int16;
                token[0xd2] = format.int32;
                token[0xd3] = format.int64;
                // fixext 1 -- 0xd4
                // fixext 2 -- 0xd5
                // fixext 4 -- 0xd6
                // fixext 8 -- 0xd7
                // fixext 16 -- 0xd8
                token[0xd4] = fix(1, format.ext);
                token[0xd5] = fix(2, format.ext);
                token[0xd6] = fix(4, format.ext);
                token[0xd7] = fix(8, format.ext);
                token[0xd8] = fix(16, format.ext);
                // str 8 -- 0xd9
                // str 16 -- 0xda
                // str 32 -- 0xdb
                token[0xd9] = flex(format.uint8, format.str);
                token[0xda] = flex(format.uint16, format.str);
                token[0xdb] = flex(format.uint32, format.str);
                // array 16 -- 0xdc
                // array 32 -- 0xdd
                token[0xdc] = flex(format.uint16, format.array);
                token[0xdd] = flex(format.uint32, format.array);
                // map 16 -- 0xde
                // map 32 -- 0xdf
                token[0xde] = flex(format.uint16, format.map);
                token[0xdf] = flex(format.uint32, format.map);
                // negative fixint -- 0xe0 - 0xff
                for (i = 0xe0; i <= 0xff; i++) {
                    token[i] = constant(i - 0x100);
                }
                return token;
            }

            function init_useraw(format) {
                var i;
                var token = init_token(format).slice();
                // raw 8 -- 0xd9
                // raw 16 -- 0xda
                // raw 32 -- 0xdb
                token[0xd9] = token[0xc4];
                token[0xda] = token[0xc5];
                token[0xdb] = token[0xc6];
                // fixraw -- 0xa0 - 0xbf
                for (i = 0xa0; i <= 0xbf; i++) {
                    token[i] = fix(i - 0xa0, format.bin);
                }
                return token;
            }

            function constant(value) {
                return function() {
                    return value;
                }
                ;
            }

            function flex(lenFunc, decodeFunc) {
                return function(decoder) {
                    var len = lenFunc(decoder);
                    return decodeFunc(decoder, len);
                }
                ;
            }

            function fix(len, method) {
                return function(decoder) {
                    return method(decoder, len);
                }
                ;
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/write-core.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-core.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // write-core.js
            var ExtBuffer = __webpack_require__(/*! ./ext-buffer */
                "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
            var ExtPacker = __webpack_require__(/*! ./ext-packer */
                "./node_modules/msgpack-lite/lib/ext-packer.js");
            var WriteType = __webpack_require__(/*! ./write-type */
                "./node_modules/msgpack-lite/lib/write-type.js");
            var CodecBase = __webpack_require__(/*! ./codec-base */
                "./node_modules/msgpack-lite/lib/codec-base.js");
            CodecBase.install({
                addExtPacker: addExtPacker,
                getExtPacker: getExtPacker,
                init: init,
            });
            exports.preset = init.call(CodecBase.preset);

            function getEncoder(options) {
                var writeType = WriteType.getWriteType(options);
                return encode;

                function encode(encoder, value) {
                    var func = writeType[typeof value];
                    if (!func)
                        throw new Error('Unsupported type "' + typeof value + '": ' + value);
                    func(encoder, value);
                }
            }

            function init() {
                var options = this.options;
                this.encode = getEncoder(options);
                if (options && options.preset) {
                    ExtPacker.setExtPackers(this);
                }
                return this;
            }

            function addExtPacker(etype, Class, packer) {
                packer = CodecBase.filter(packer);
                var name = Class.name;
                if (name && name !== "Object") {
                    var packers = this.extPackers || (this.extPackers = {});
                    packers[name] = extPacker;
                } else {
                    // fallback for IE
                    var list = this.extEncoderList || (this.extEncoderList = []);
                    list.unshift([Class, extPacker]);
                }

                function extPacker(value) {
                    if (packer)
                        value = packer(value);
                    return new ExtBuffer(value,etype);
                }
            }

            function getExtPacker(value) {
                var packers = this.extPackers || (this.extPackers = {});
                var c = value.constructor;
                var e = c && c.name && packers[c.name];
                if (e)
                    return e;
                // fallback for IE
                var list = this.extEncoderList || (this.extEncoderList = []);
                var len = list.length;
                for (var i = 0; i < len; i++) {
                    var pair = list[i];
                    if (c === pair[0])
                        return pair[1];
                }
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/write-token.js": /*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-token.js ***!
  \******************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // write-token.js
            var ieee754 = __webpack_require__(/*! ieee754 */
                "./node_modules/ieee754/index.js");
            var Int64Buffer = __webpack_require__(/*! int64-buffer */
                "./node_modules/int64-buffer/int64-buffer.js");
            var Uint64BE = Int64Buffer.Uint64BE;
            var Int64BE = Int64Buffer.Int64BE;
            var uint8 = __webpack_require__(/*! ./write-uint8 */
                "./node_modules/msgpack-lite/lib/write-uint8.js").uint8;
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");
            var Buffer = Bufferish.global;
            var IS_BUFFER_SHIM = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT"in Buffer;
            var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer.TYPED_ARRAY_SUPPORT;
            var Buffer_prototype = (Bufferish.hasBuffer && Buffer.prototype) || {};
            exports.getWriteToken = getWriteToken;

            function getWriteToken(options) {
                if (options && options.uint8array) {
                    return init_uint8array();
                } else if (NO_TYPED_ARRAY || (Bufferish.hasBuffer && options && options.safe)) {
                    return init_safe();
                } else {
                    return init_token();
                }
            }

            function init_uint8array() {
                var token = init_token();
                // float 32 -- 0xca
                // float 64 -- 0xcb
                token[0xca] = writeN(0xca, 4, writeFloatBE);
                token[0xcb] = writeN(0xcb, 8, writeDoubleBE);
                return token;
            }
            // Node.js and browsers with TypedArray
            function init_token() {
                // (immediate values)
                // positive fixint -- 0x00 - 0x7f
                // nil -- 0xc0
                // false -- 0xc2
                // true -- 0xc3
                // negative fixint -- 0xe0 - 0xff
                var token = uint8.slice();
                // bin 8 -- 0xc4
                // bin 16 -- 0xc5
                // bin 32 -- 0xc6
                token[0xc4] = write1(0xc4);
                token[0xc5] = write2(0xc5);
                token[0xc6] = write4(0xc6);
                // ext 8 -- 0xc7
                // ext 16 -- 0xc8
                // ext 32 -- 0xc9
                token[0xc7] = write1(0xc7);
                token[0xc8] = write2(0xc8);
                token[0xc9] = write4(0xc9);
                // float 32 -- 0xca
                // float 64 -- 0xcb
                token[0xca] = writeN(0xca, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
                token[0xcb] = writeN(0xcb, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
                // uint 8 -- 0xcc
                // uint 16 -- 0xcd
                // uint 32 -- 0xce
                // uint 64 -- 0xcf
                token[0xcc] = write1(0xcc);
                token[0xcd] = write2(0xcd);
                token[0xce] = write4(0xce);
                token[0xcf] = writeN(0xcf, 8, writeUInt64BE);
                // int 8 -- 0xd0
                // int 16 -- 0xd1
                // int 32 -- 0xd2
                // int 64 -- 0xd3
                token[0xd0] = write1(0xd0);
                token[0xd1] = write2(0xd1);
                token[0xd2] = write4(0xd2);
                token[0xd3] = writeN(0xd3, 8, writeInt64BE);
                // str 8 -- 0xd9
                // str 16 -- 0xda
                // str 32 -- 0xdb
                token[0xd9] = write1(0xd9);
                token[0xda] = write2(0xda);
                token[0xdb] = write4(0xdb);
                // array 16 -- 0xdc
                // array 32 -- 0xdd
                token[0xdc] = write2(0xdc);
                token[0xdd] = write4(0xdd);
                // map 16 -- 0xde
                // map 32 -- 0xdf
                token[0xde] = write2(0xde);
                token[0xdf] = write4(0xdf);
                return token;
            }
            // safe mode: for old browsers and who needs asserts
            function init_safe() {
                // (immediate values)
                // positive fixint -- 0x00 - 0x7f
                // nil -- 0xc0
                // false -- 0xc2
                // true -- 0xc3
                // negative fixint -- 0xe0 - 0xff
                var token = uint8.slice();
                // bin 8 -- 0xc4
                // bin 16 -- 0xc5
                // bin 32 -- 0xc6
                token[0xc4] = writeN(0xc4, 1, Buffer.prototype.writeUInt8);
                token[0xc5] = writeN(0xc5, 2, Buffer.prototype.writeUInt16BE);
                token[0xc6] = writeN(0xc6, 4, Buffer.prototype.writeUInt32BE);
                // ext 8 -- 0xc7
                // ext 16 -- 0xc8
                // ext 32 -- 0xc9
                token[0xc7] = writeN(0xc7, 1, Buffer.prototype.writeUInt8);
                token[0xc8] = writeN(0xc8, 2, Buffer.prototype.writeUInt16BE);
                token[0xc9] = writeN(0xc9, 4, Buffer.prototype.writeUInt32BE);
                // float 32 -- 0xca
                // float 64 -- 0xcb
                token[0xca] = writeN(0xca, 4, Buffer.prototype.writeFloatBE);
                token[0xcb] = writeN(0xcb, 8, Buffer.prototype.writeDoubleBE);
                // uint 8 -- 0xcc
                // uint 16 -- 0xcd
                // uint 32 -- 0xce
                // uint 64 -- 0xcf
                token[0xcc] = writeN(0xcc, 1, Buffer.prototype.writeUInt8);
                token[0xcd] = writeN(0xcd, 2, Buffer.prototype.writeUInt16BE);
                token[0xce] = writeN(0xce, 4, Buffer.prototype.writeUInt32BE);
                token[0xcf] = writeN(0xcf, 8, writeUInt64BE);
                // int 8 -- 0xd0
                // int 16 -- 0xd1
                // int 32 -- 0xd2
                // int 64 -- 0xd3
                token[0xd0] = writeN(0xd0, 1, Buffer.prototype.writeInt8);
                token[0xd1] = writeN(0xd1, 2, Buffer.prototype.writeInt16BE);
                token[0xd2] = writeN(0xd2, 4, Buffer.prototype.writeInt32BE);
                token[0xd3] = writeN(0xd3, 8, writeInt64BE);
                // str 8 -- 0xd9
                // str 16 -- 0xda
                // str 32 -- 0xdb
                token[0xd9] = writeN(0xd9, 1, Buffer.prototype.writeUInt8);
                token[0xda] = writeN(0xda, 2, Buffer.prototype.writeUInt16BE);
                token[0xdb] = writeN(0xdb, 4, Buffer.prototype.writeUInt32BE);
                // array 16 -- 0xdc
                // array 32 -- 0xdd
                token[0xdc] = writeN(0xdc, 2, Buffer.prototype.writeUInt16BE);
                token[0xdd] = writeN(0xdd, 4, Buffer.prototype.writeUInt32BE);
                // map 16 -- 0xde
                // map 32 -- 0xdf
                token[0xde] = writeN(0xde, 2, Buffer.prototype.writeUInt16BE);
                token[0xdf] = writeN(0xdf, 4, Buffer.prototype.writeUInt32BE);
                return token;
            }

            function write1(type) {
                return function(encoder, value) {
                    var offset = encoder.reserve(2);
                    var buffer = encoder.buffer;
                    buffer[offset++] = type;
                    buffer[offset] = value;
                }
                ;
            }

            function write2(type) {
                return function(encoder, value) {
                    var offset = encoder.reserve(3);
                    var buffer = encoder.buffer;
                    buffer[offset++] = type;
                    buffer[offset++] = value >>> 8;
                    buffer[offset] = value;
                }
                ;
            }

            function write4(type) {
                return function(encoder, value) {
                    var offset = encoder.reserve(5);
                    var buffer = encoder.buffer;
                    buffer[offset++] = type;
                    buffer[offset++] = value >>> 24;
                    buffer[offset++] = value >>> 16;
                    buffer[offset++] = value >>> 8;
                    buffer[offset] = value;
                }
                ;
            }

            function writeN(type, len, method, noAssert) {
                return function(encoder, value) {
                    var offset = encoder.reserve(len + 1);
                    encoder.buffer[offset++] = type;
                    method.call(encoder.buffer, value, offset, noAssert);
                }
                ;
            }

            function writeUInt64BE(value, offset) {
                new Uint64BE(this,offset,value);
            }

            function writeInt64BE(value, offset) {
                new Int64BE(this,offset,value);
            }

            function writeFloatBE(value, offset) {
                ieee754.write(this, value, offset, false, 23, 4);
            }

            function writeDoubleBE(value, offset) {
                ieee754.write(this, value, offset, false, 52, 8);
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/write-type.js": /*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-type.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            // write-type.js
            var IS_ARRAY = __webpack_require__(/*! isarray */
                "./node_modules/msgpack-lite/node_modules/isarray/index.js");
            var Int64Buffer = __webpack_require__(/*! int64-buffer */
                "./node_modules/int64-buffer/int64-buffer.js");
            var Uint64BE = Int64Buffer.Uint64BE;
            var Int64BE = Int64Buffer.Int64BE;
            var Bufferish = __webpack_require__(/*! ./bufferish */
                "./node_modules/msgpack-lite/lib/bufferish.js");
            var BufferProto = __webpack_require__(/*! ./bufferish-proto */
                "./node_modules/msgpack-lite/lib/bufferish-proto.js");
            var WriteToken = __webpack_require__(/*! ./write-token */
                "./node_modules/msgpack-lite/lib/write-token.js");
            var uint8 = __webpack_require__(/*! ./write-uint8 */
                "./node_modules/msgpack-lite/lib/write-uint8.js").uint8;
            var ExtBuffer = __webpack_require__(/*! ./ext-buffer */
                "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
            var HAS_UINT8ARRAY = "undefined" !== typeof Uint8Array;
            var HAS_MAP = "undefined" !== typeof Map;
            var extmap = [];
            extmap[1] = 0xd4;
            extmap[2] = 0xd5;
            extmap[4] = 0xd6;
            extmap[8] = 0xd7;
            extmap[16] = 0xd8;
            exports.getWriteType = getWriteType;

            function getWriteType(options) {
                var token = WriteToken.getWriteToken(options);
                var useraw = options && options.useraw;
                var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
                var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
                var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
                var usemap = HAS_MAP && options && options.usemap;
                var map = usemap ? map_to_map : obj_to_map;
                var writeType = {
                    boolean: bool,
                    function: nil,
                    number: number,
                    object: useraw ? object_raw : object,
                    string: _string(useraw ? raw_head_size : str_head_size),
                    symbol: nil,
                    undefined: nil,
                };
                return writeType;
                // false -- 0xc2
                // true -- 0xc3
                function bool(encoder, value) {
                    var type = value ? 0xc3 : 0xc2;
                    token[type](encoder, value);
                }

                function number(encoder, value) {
                    var ivalue = value | 0;
                    var type;
                    if (value !== ivalue) {
                        // float 64 -- 0xcb
                        type = 0xcb;
                        token[type](encoder, value);
                        return;
                    } else if (-0x20 <= ivalue && ivalue <= 0x7f) {
                        // positive fixint -- 0x00 - 0x7f
                        // negative fixint -- 0xe0 - 0xff
                        type = ivalue & 0xff;
                    } else if (0 <= ivalue) {
                        // uint 8 -- 0xcc
                        // uint 16 -- 0xcd
                        // uint 32 -- 0xce
                        type = ivalue <= 0xff ? 0xcc : ivalue <= 0xffff ? 0xcd : 0xce;
                    } else {
                        // int 8 -- 0xd0
                        // int 16 -- 0xd1
                        // int 32 -- 0xd2
                        type = -0x80 <= ivalue ? 0xd0 : -0x8000 <= ivalue ? 0xd1 : 0xd2;
                    }
                    token[type](encoder, ivalue);
                }
                // uint 64 -- 0xcf
                function uint64(encoder, value) {
                    var type = 0xcf;
                    token[type](encoder, value.toArray());
                }
                // int 64 -- 0xd3
                function int64(encoder, value) {
                    var type = 0xd3;
                    token[type](encoder, value.toArray());
                }
                // str 8 -- 0xd9
                // str 16 -- 0xda
                // str 32 -- 0xdb
                // fixstr -- 0xa0 - 0xbf
                function str_head_size(length) {
                    return length < 32 ? 1 : length <= 0xff ? 2 : length <= 0xffff ? 3 : 5;
                }
                // raw 16 -- 0xda
                // raw 32 -- 0xdb
                // fixraw -- 0xa0 - 0xbf
                function raw_head_size(length) {
                    return length < 32 ? 1 : length <= 0xffff ? 3 : 5;
                }

                function _string(head_size) {
                    return string;

                    function string(encoder, value) {
                        // prepare buffer
                        var length = value.length;
                        var maxsize = 5 + length * 3;
                        encoder.offset = encoder.reserve(maxsize);
                        var buffer = encoder.buffer;
                        // expected header size
                        var expected = head_size(length);
                        // expected start point
                        var start = encoder.offset + expected;
                        // write string
                        length = BufferProto.write.call(buffer, value, start);
                        // actual header size
                        var actual = head_size(length);
                        // move content when needed
                        if (expected !== actual) {
                            var targetStart = start + actual - expected;
                            var end = start + length;
                            BufferProto.copy.call(buffer, buffer, targetStart, start, end);
                        }
                        // write header
                        var type = actual === 1 ? 0xa0 + length : actual <= 3 ? 0xd7 + actual : 0xdb;
                        token[type](encoder, length);
                        // move cursor
                        encoder.offset += length;
                    }
                }

                function object(encoder, value) {
                    // null
                    if (value === null)
                        return nil(encoder, value);
                    // Buffer
                    if (isBuffer(value))
                        return bin(encoder, value);
                    // Array
                    if (IS_ARRAY(value))
                        return array(encoder, value);
                    // int64-buffer objects
                    if (Uint64BE.isUint64BE(value))
                        return uint64(encoder, value);
                    if (Int64BE.isInt64BE(value))
                        return int64(encoder, value);
                    // ext formats
                    var packer = encoder.codec.getExtPacker(value);
                    if (packer)
                        value = packer(value);
                    if (value instanceof ExtBuffer)
                        return ext(encoder, value);
                    // plain old Objects or Map
                    map(encoder, value);
                }

                function object_raw(encoder, value) {
                    // Buffer
                    if (isBuffer(value))
                        return raw(encoder, value);
                    // others
                    object(encoder, value);
                }
                // nil -- 0xc0
                function nil(encoder, value) {
                    var type = 0xc0;
                    token[type](encoder, value);
                }
                // fixarray -- 0x90 - 0x9f
                // array 16 -- 0xdc
                // array 32 -- 0xdd
                function array(encoder, value) {
                    var length = value.length;
                    var type = length < 16 ? 0x90 + length : length <= 0xffff ? 0xdc : 0xdd;
                    token[type](encoder, length);
                    var encode = encoder.codec.encode;
                    for (var i = 0; i < length; i++) {
                        encode(encoder, value[i]);
                    }
                }
                // bin 8 -- 0xc4
                // bin 16 -- 0xc5
                // bin 32 -- 0xc6
                function bin_buffer(encoder, value) {
                    var length = value.length;
                    var type = length < 0xff ? 0xc4 : length <= 0xffff ? 0xc5 : 0xc6;
                    token[type](encoder, length);
                    encoder.send(value);
                }

                function bin_arraybuffer(encoder, value) {
                    bin_buffer(encoder, new Uint8Array(value));
                }
                // fixext 1 -- 0xd4
                // fixext 2 -- 0xd5
                // fixext 4 -- 0xd6
                // fixext 8 -- 0xd7
                // fixext 16 -- 0xd8
                // ext 8 -- 0xc7
                // ext 16 -- 0xc8
                // ext 32 -- 0xc9
                function ext(encoder, value) {
                    var buffer = value.buffer;
                    var length = buffer.length;
                    var type = extmap[length] || (length < 0xff ? 0xc7 : length <= 0xffff ? 0xc8 : 0xc9);
                    token[type](encoder, length);
                    uint8[value.type](encoder);
                    encoder.send(buffer);
                }
                // fixmap -- 0x80 - 0x8f
                // map 16 -- 0xde
                // map 32 -- 0xdf
                function obj_to_map(encoder, value) {
                    var keys = Object.keys(value);
                    var length = keys.length;
                    var type = length < 16 ? 0x80 + length : length <= 0xffff ? 0xde : 0xdf;
                    token[type](encoder, length);
                    var encode = encoder.codec.encode;
                    keys.forEach(function(key) {
                        encode(encoder, key);
                        encode(encoder, value[key]);
                    });
                }
                // fixmap -- 0x80 - 0x8f
                // map 16 -- 0xde
                // map 32 -- 0xdf
                function map_to_map(encoder, value) {
                    if (!(value instanceof Map))
                        return obj_to_map(encoder, value);
                    var length = value.size;
                    var type = length < 16 ? 0x80 + length : length <= 0xffff ? 0xde : 0xdf;
                    token[type](encoder, length);
                    var encode = encoder.codec.encode;
                    value.forEach(function(val, key, m) {
                        encode(encoder, key);
                        encode(encoder, val);
                    });
                }
                // raw 16 -- 0xda
                // raw 32 -- 0xdb
                // fixraw -- 0xa0 - 0xbf
                function raw(encoder, value) {
                    var length = value.length;
                    var type = length < 32 ? 0xa0 + length : length <= 0xffff ? 0xda : 0xdb;
                    token[type](encoder, length);
                    encoder.send(value);
                }
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/lib/write-uint8.js": /*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-uint8.js ***!
  \******************************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            // write-unit8.js
            var constant = (exports.uint8 = new Array(256));
            for (var i = 0x00; i <= 0xff; i++) {
                constant[i] = write0(i);
            }

            function write0(type) {
                return function(encoder) {
                    var offset = encoder.reserve(1);
                    encoder.buffer[offset] = type;
                }
                ;
            }
            /***/
        },
        /***/
        "./node_modules/msgpack-lite/node_modules/isarray/index.js": /*!*****************************************************************!*\
  !*** ./node_modules/msgpack-lite/node_modules/isarray/index.js ***!
  \*****************************************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            var toString = {}.toString;
            module.exports = Array.isArray || function(arr) {
                return toString.call(arr) == "[object Array]";
            }
            ;
            /***/
        },
        /***/
        "./node_modules/process/browser.js": /*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            // shim for using process in browser
            var process = (module.exports = {});
            // cached from whatever global is present so that test runners that stub it
            // don't break things.  But we need to wrap it in a try catch in case it is
            // wrapped in strict mode code which doesn't define any globals.  It's inside a
            // function because try/catches deoptimize in certain engines.
            var cachedSetTimeout;
            var cachedClearTimeout;

            function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
            }

            function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
            }
            (function() {
                try {
                    if (typeof setTimeout === "function") {
                        cachedSetTimeout = setTimeout;
                    } else {
                        cachedSetTimeout = defaultSetTimout;
                    }
                } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    if (typeof clearTimeout === "function") {
                        cachedClearTimeout = clearTimeout;
                    } else {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            }
            )();

            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout(fun, 0);
                } catch (e) {
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch (e) {
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }
            }

            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout(marker);
                } catch (e) {
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout.call(null, marker);
                    } catch (e) {
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout.call(this, marker);
                    }
                }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                    return;
                }
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }

            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;
                var len = queue.length;
                while (len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
            }
            process.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun,args));
                if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
                }
            }
            ;
            // v8 likes predictible objects
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            }
            ;
            process.title = "browser";
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = "";
            // empty string to avoid regexp issues
            process.versions = {};

            function noop() {}
            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.prependListener = noop;
            process.prependOnceListener = noop;
            process.listeners = function(name) {
                return [];
            }
            ;
            process.binding = function(name) {
                throw new Error("process.binding is not supported");
            }
            ;
            process.cwd = function() {
                return "/";
            }
            ;
            process.chdir = function(dir) {
                throw new Error("process.chdir is not supported");
            }
            ;
            process.umask = function() {
                return 0;
            }
            ;
            /***/
        },
        /***/
        "./node_modules/punycode/punycode.js": /*!*******************************************!*\
  !*** ./node_modules/punycode/punycode.js ***!
  \*******************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */
            (function(module, global) {
                var __WEBPACK_AMD_DEFINE_RESULT__;
                /*! https://mths.be/punycode v1.4.1 by @mathias */
                (function(root) {
                    /** Detect free variables */
                    var freeExports = true && exports && !exports.nodeType && exports;
                    var freeModule = true && module && !module.nodeType && module;
                    var freeGlobal = typeof global == "object" && global;
                    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                        root = freeGlobal;
                    }
                    /**
                         * The `punycode` object.
                         * @name punycode
                         * @type Object
                         */
                    var punycode, /** Highest positive signed 32-bit float value */
                        maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
                        /** Bootstring parameters */
                        base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, // 0x80
                        delimiter = "-", // '\x2D'
                        /** Regular expressions */
                        regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
                        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
                        /** Error messages */
                        errors = {
                            overflow: "Overflow: input needs wider integers to process",
                            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                            "invalid-input": "Invalid input",
                        }, /** Convenience shortcuts */
                        baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, /** Temporary variable */
                        key;
                    /*--------------------------------------------------------------------------*/
                    /**
                         * A generic error utility function.
                         * @private
                         * @param {String} type The error type.
                         * @returns {Error} Throws a `RangeError` with the applicable error message.
                         */
                    function error(type) {
                        throw new RangeError(errors[type]);
                    }
                    /**
                         * A generic `Array#map` utility function.
                         * @private
                         * @param {Array} array The array to iterate over.
                         * @param {Function} callback The function that gets called for every array
                         * item.
                         * @returns {Array} A new array of values returned by the callback function.
                         */
                    function map(array, fn) {
                        var length = array.length;
                        var result = [];
                        while (length--) {
                            result[length] = fn(array[length]);
                        }
                        return result;
                    }
                    /**
                         * A simple `Array#map`-like wrapper to work with domain name strings or email
                         * addresses.
                         * @private
                         * @param {String} domain The domain name or email address.
                         * @param {Function} callback The function that gets called for every
                         * character.
                         * @returns {Array} A new string of characters returned by the callback
                         * function.
                         */
                    function mapDomain(string, fn) {
                        var parts = string.split("@");
                        var result = "";
                        if (parts.length > 1) {
                            // In email addresses, only the domain name should be punycoded. Leave
                            // the local part (i.e. everything up to `@`) intact.
                            result = parts[0] + "@";
                            string = parts[1];
                        }
                        // Avoid `split(regex)` for IE8 compatibility. See #17.
                        string = string.replace(regexSeparators, ".");
                        var labels = string.split(".");
                        var encoded = map(labels, fn).join(".");
                        return result + encoded;
                    }
                    /**
                         * Creates an array containing the numeric code points of each Unicode
                         * character in the string. While JavaScript uses UCS-2 internally,
                         * this function will convert a pair of surrogate halves (each of which
                         * UCS-2 exposes as separate characters) into a single code point,
                         * matching UTF-16.
                         * @see `punycode.ucs2.encode`
                         * @see <https://mathiasbynens.be/notes/javascript-encoding>
                         * @memberOf punycode.ucs2
                         * @name decode
                         * @param {String} string The Unicode input string (UCS-2).
                         * @returns {Array} The new array of code points.
                         */
                    function ucs2decode(string) {
                        var output = [], counter = 0, length = string.length, value, extra;
                        while (counter < length) {
                            value = string.charCodeAt(counter++);
                            if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                                // high surrogate, and there is a next character
                                extra = string.charCodeAt(counter++);
                                if ((extra & 0xfc00) == 0xdc00) {
                                    // low surrogate
                                    output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
                                } else {
                                    // unmatched surrogate; only append this code unit, in case the next
                                    // code unit is the high surrogate of a surrogate pair
                                    output.push(value);
                                    counter--;
                                }
                            } else {
                                output.push(value);
                            }
                        }
                        return output;
                    }
                    /**
                         * Creates a string based on an array of numeric code points.
                         * @see `punycode.ucs2.decode`
                         * @memberOf punycode.ucs2
                         * @name encode
                         * @param {Array} codePoints The array of numeric code points.
                         * @returns {String} The new Unicode string (UCS-2).
                         */
                    function ucs2encode(array) {
                        return map(array, function(value) {
                            var output = "";
                            if (value > 0xffff) {
                                value -= 0x10000;
                                output += stringFromCharCode(((value >>> 10) & 0x3ff) | 0xd800);
                                value = 0xdc00 | (value & 0x3ff);
                            }
                            output += stringFromCharCode(value);
                            return output;
                        }).join("");
                    }
                    /**
                         * Converts a basic code point into a digit/integer.
                         * @see `digitToBasic()`
                         * @private
                         * @param {Number} codePoint The basic numeric code point value.
                         * @returns {Number} The numeric value of a basic code point (for use in
                         * representing integers) in the range `0` to `base - 1`, or `base` if
                         * the code point does not represent a value.
                         */
                    function basicToDigit(codePoint) {
                        if (codePoint - 48 < 10) {
                            return codePoint - 22;
                        }
                        if (codePoint - 65 < 26) {
                            return codePoint - 65;
                        }
                        if (codePoint - 97 < 26) {
                            return codePoint - 97;
                        }
                        return base;
                    }
                    /**
                         * Converts a digit/integer into a basic code point.
                         * @see `basicToDigit()`
                         * @private
                         * @param {Number} digit The numeric value of a basic code point.
                         * @returns {Number} The basic code point whose value (when used for
                         * representing integers) is `digit`, which needs to be in the range
                         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                         * used; else, the lowercase form is used. The behavior is undefined
                         * if `flag` is non-zero and `digit` has no uppercase form.
                         */
                    function digitToBasic(digit, flag) {
                        //  0..25 map to ASCII a..z or A..Z
                        // 26..35 map to ASCII 0..9
                        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                    }
                    /**
                         * Bias adaptation function as per section 3.4 of RFC 3492.
                         * https://tools.ietf.org/html/rfc3492#section-3.4
                         * @private
                         */
                    function adapt(delta, numPoints, firstTime) {
                        var k = 0;
                        delta = firstTime ? floor(delta / damp) : delta >> 1;
                        delta += floor(delta / numPoints);
                        for (; /* no initialization */
                             delta > (baseMinusTMin * tMax) >> 1; k += base) {
                            delta = floor(delta / baseMinusTMin);
                        }
                        return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
                    }
                    /**
                         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                         * symbols.
                         * @memberOf punycode
                         * @param {String} input The Punycode string of ASCII-only symbols.
                         * @returns {String} The resulting string of Unicode symbols.
                         */
                    function decode(input) {
                        // Don't use UCS-2
                        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, /** Cached calculation results */
                            baseMinusT;
                        // Handle the basic code points: let `basic` be the number of input code
                        // points before the last delimiter, or `0` if there is none, then copy
                        // the first basic code points to the output.
                        basic = input.lastIndexOf(delimiter);
                        if (basic < 0) {
                            basic = 0;
                        }
                        for (j = 0; j < basic; ++j) {
                            // if it's not a basic code point
                            if (input.charCodeAt(j) >= 0x80) {
                                error("not-basic");
                            }
                            output.push(input.charCodeAt(j));
                        }
                        // Main decoding loop: start just after the last delimiter if any basic code
                        // points were copied; start at the beginning otherwise.
                        for (index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */
                             ; ) {
                            // `index` is the index of the next character to be consumed.
                            // Decode a generalized variable-length integer into `delta`,
                            // which gets added to `i`. The overflow checking is easier
                            // if we increase `i` as we go, then subtract off its starting
                            // value at the end to obtain `delta`.
                            for (oldi = i,
                                 w = 1,
                                 k = base /* no condition */
                                 ; ; k += base) {
                                if (index >= inputLength) {
                                    error("invalid-input");
                                }
                                digit = basicToDigit(input.charCodeAt(index++));
                                if (digit >= base || digit > floor((maxInt - i) / w)) {
                                    error("overflow");
                                }
                                i += digit * w;
                                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                if (digit < t) {
                                    break;
                                }
                                baseMinusT = base - t;
                                if (w > floor(maxInt / baseMinusT)) {
                                    error("overflow");
                                }
                                w *= baseMinusT;
                            }
                            out = output.length + 1;
                            bias = adapt(i - oldi, out, oldi == 0);
                            // `i` was supposed to wrap around from `out` to `0`,
                            // incrementing `n` each time, so we'll fix that now:
                            if (floor(i / out) > maxInt - n) {
                                error("overflow");
                            }
                            n += floor(i / out);
                            i %= out;
                            // Insert `n` at position `i` of the output
                            output.splice(i++, 0, n);
                        }
                        return ucs2encode(output);
                    }
                    /**
                         * Converts a string of Unicode symbols (e.g. a domain name label) to a
                         * Punycode string of ASCII-only symbols.
                         * @memberOf punycode
                         * @param {String} input The string of Unicode symbols.
                         * @returns {String} The resulting Punycode string of ASCII-only symbols.
                         */
                    function encode(input) {
                        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], /** `inputLength` will hold the number of code points in `input`. */
                            inputLength, /** Cached calculation results */
                            handledCPCountPlusOne, baseMinusT, qMinusT;
                        // Convert the input in UCS-2 to Unicode
                        input = ucs2decode(input);
                        // Cache the length
                        inputLength = input.length;
                        // Initialize the state
                        n = initialN;
                        delta = 0;
                        bias = initialBias;
                        // Handle the basic code points
                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue < 0x80) {
                                output.push(stringFromCharCode(currentValue));
                            }
                        }
                        handledCPCount = basicLength = output.length;
                        // `handledCPCount` is the number of code points that have been handled;
                        // `basicLength` is the number of basic code points.
                        // Finish the basic string - if it is not empty - with a delimiter
                        if (basicLength) {
                            output.push(delimiter);
                        }
                        // Main encoding loop:
                        while (handledCPCount < inputLength) {
                            // All non-basic code points < n have been handled already. Find the next
                            // larger one:
                            for (m = maxInt,
                                 j = 0; j < inputLength; ++j) {
                                currentValue = input[j];
                                if (currentValue >= n && currentValue < m) {
                                    m = currentValue;
                                }
                            }
                            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                            // but guard against overflow
                            handledCPCountPlusOne = handledCPCount + 1;
                            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                                error("overflow");
                            }
                            delta += (m - n) * handledCPCountPlusOne;
                            n = m;
                            for (j = 0; j < inputLength; ++j) {
                                currentValue = input[j];
                                if (currentValue < n && ++delta > maxInt) {
                                    error("overflow");
                                }
                                if (currentValue == n) {
                                    // Represent delta as a generalized variable-length integer
                                    for (q = delta,
                                         k = base /* no condition */
                                         ; ; k += base) {
                                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                        if (q < t) {
                                            break;
                                        }
                                        qMinusT = q - t;
                                        baseMinusT = base - t;
                                        output.push(stringFromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));
                                        q = floor(qMinusT / baseMinusT);
                                    }
                                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                    delta = 0;
                                    ++handledCPCount;
                                }
                            }
                            ++delta;
                            ++n;
                        }
                        return output.join("");
                    }
                    /**
                         * Converts a Punycode string representing a domain name or an email address
                         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                         * it doesn't matter if you call it on a string that has already been
                         * converted to Unicode.
                         * @memberOf punycode
                         * @param {String} input The Punycoded domain name or email address to
                         * convert to Unicode.
                         * @returns {String} The Unicode representation of the given Punycode
                         * string.
                         */
                    function toUnicode(input) {
                        return mapDomain(input, function(string) {
                            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                        });
                    }
                    /**
                         * Converts a Unicode string representing a domain name or an email address to
                         * Punycode. Only the non-ASCII parts of the domain name will be converted,
                         * i.e. it doesn't matter if you call it with a domain that's already in
                         * ASCII.
                         * @memberOf punycode
                         * @param {String} input The domain name or email address to convert, as a
                         * Unicode string.
                         * @returns {String} The Punycode representation of the given domain name or
                         * email address.
                         */
                    function toASCII(input) {
                        return mapDomain(input, function(string) {
                            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                        });
                    }
                    /*--------------------------------------------------------------------------*/
                    /** Define the public API */
                    punycode = {
                        /**
                             * A string representing the current Punycode.js version number.
                             * @memberOf punycode
                             * @type String
                             */
                        version: "1.4.1",
                        /**
                             * An object of methods to convert from JavaScript's internal character
                             * representation (UCS-2) to Unicode code points, and back.
                             * @see <https://mathiasbynens.be/notes/javascript-encoding>
                             * @memberOf punycode
                             * @type Object
                             */
                        ucs2: {
                            decode: ucs2decode,
                            encode: ucs2encode,
                        },
                        decode: decode,
                        encode: encode,
                        toASCII: toASCII,
                        toUnicode: toUnicode,
                    };
                    /** Expose `punycode` */
                    // Some AMD build optimizers, like r.js, check for specific condition patterns
                    // like the following:
                    if (true) {
                        !((__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                            return punycode;
                        }
                           .call(exports, __webpack_require__, exports, module)),
                          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    } else {}
                }
                )(this);
                /* WEBPACK VAR INJECTION */
            }
            ).call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */
                "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */
                "./node_modules/webpack/buildin/global.js"));
            /***/
        },
        /***/
        "./node_modules/querystring-es3/decode.js": /*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            "use strict";
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            // If obj.hasOwnProperty has been overridden, then calling
            // obj.hasOwnProperty(prop) will break.
            // See: https://github.com/joyent/node/issues/1707
            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            module.exports = function(qs, sep, eq, options) {
                sep = sep || "&";
                eq = eq || "=";
                var obj = {};
                if (typeof qs !== "string" || qs.length === 0) {
                    return obj;
                }
                var regexp = /\+/g;
                qs = qs.split(sep);
                var maxKeys = 1000;
                if (options && typeof options.maxKeys === "number") {
                    maxKeys = options.maxKeys;
                }
                var len = qs.length;
                // maxKeys <= 0 means that we should not limit keys count
                if (maxKeys > 0 && len > maxKeys) {
                    len = maxKeys;
                }
                for (var i = 0; i < len; ++i) {
                    var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
                    if (idx >= 0) {
                        kstr = x.substr(0, idx);
                        vstr = x.substr(idx + 1);
                    } else {
                        kstr = x;
                        vstr = "";
                    }
                    k = decodeURIComponent(kstr);
                    v = decodeURIComponent(vstr);
                    if (!hasOwnProperty(obj, k)) {
                        obj[k] = v;
                    } else if (isArray(obj[k])) {
                        obj[k].push(v);
                    } else {
                        obj[k] = [obj[k], v];
                    }
                }
                return obj;
            }
            ;
            var isArray = Array.isArray || function(xs) {
                return Object.prototype.toString.call(xs) === "[object Array]";
            }
            ;
            /***/
        },
        /***/
        "./node_modules/querystring-es3/encode.js": /*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            "use strict";
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            var stringifyPrimitive = function(v) {
                switch (typeof v) {
                    case "string":
                        return v;
                    case "boolean":
                        return v ? "true" : "false";
                    case "number":
                        return isFinite(v) ? v : "";
                    default:
                        return "";
                }
            };
            module.exports = function(obj, sep, eq, name) {
                sep = sep || "&";
                eq = eq || "=";
                if (obj === null) {
                    obj = undefined;
                }
                if (typeof obj === "object") {
                    return map(objectKeys(obj), function(k) {
                        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                        if (isArray(obj[k])) {
                            return map(obj[k], function(v) {
                                return ks + encodeURIComponent(stringifyPrimitive(v));
                            }).join(sep);
                        } else {
                            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                        }
                    }).join(sep);
                }
                if (!name)
                    return "";
                return (encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj)));
            }
            ;
            var isArray = Array.isArray || function(xs) {
                return Object.prototype.toString.call(xs) === "[object Array]";
            }
            ;

            function map(xs, f) {
                if (xs.map)
                    return xs.map(f);
                var res = [];
                for (var i = 0; i < xs.length; i++) {
                    res.push(f(xs[i], i));
                }
                return res;
            }
            var objectKeys = Object.keys || function(obj) {
                var res = [];
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                        res.push(key);
                }
                return res;
            }
            ;
            /***/
        },
        /***/
        "./node_modules/querystring-es3/index.js": /*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            "use strict";
            exports.decode = exports.parse = __webpack_require__(/*! ./decode */
                "./node_modules/querystring-es3/decode.js");
            exports.encode = exports.stringify = __webpack_require__(/*! ./encode */
                "./node_modules/querystring-es3/encode.js");
            /***/
        },
        /***/
        "./node_modules/url/url.js": /*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            "use strict";
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            var punycode = __webpack_require__(/*! punycode */
                "./node_modules/punycode/punycode.js");
            var util = __webpack_require__(/*! ./util */
                "./node_modules/url/util.js");
            exports.parse = urlParse;
            exports.resolve = urlResolve;
            exports.resolveObject = urlResolveObject;
            exports.format = urlFormat;
            exports.Url = Url;

            function Url() {
                this.protocol = null;
                this.slashes = null;
                this.auth = null;
                this.host = null;
                this.port = null;
                this.hostname = null;
                this.hash = null;
                this.search = null;
                this.query = null;
                this.pathname = null;
                this.path = null;
                this.href = null;
            }
            // Reference: RFC 3986, RFC 1808, RFC 2396
            // define these here so at least they only have to be
            // compiled once on the first module load.
            var protocolPattern = /^([a-z0-9.+-]+:)/i
            , portPattern = /:[0-9]*$/
            , // Special case for a simple path URL
                simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/
            , // RFC 2396: characters reserved for delimiting URLs.
                // We actually just auto-escape these.
                delims = ["<", ">", '"', "`", " ", "\r", "\n", "\t"]
            , // RFC 2396: characters not allowed for various reasons.
                unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims)
            , // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
                autoEscape = ["'"].concat(unwise)
            , // Characters that are never ever allowed in a hostname.
                // Note that any invalid chars are also handled, but these
                // are the ones that are *expected* to be seen, so we fast-path
                // them.
                nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape)
            , hostEndingChars = ["/", "?", "#"]
            , hostnameMaxLen = 255
            , hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/
            , hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
            , // protocols that can allow "unsafe" and "unwise" chars.
                unsafeProtocol = {
                    javascript: true,
                    "javascript:": true,
                }
            , // protocols that never have a hostname.
                hostlessProtocol = {
                    javascript: true,
                    "javascript:": true,
                }
            , // protocols that always contain a // bit.
                slashedProtocol = {
                    http: true,
                    https: true,
                    ftp: true,
                    gopher: true,
                    file: true,
                    "http:": true,
                    "https:": true,
                    "ftp:": true,
                    "gopher:": true,
                    "file:": true,
                }
            , querystring = __webpack_require__(/*! querystring */
                "./node_modules/querystring-es3/index.js");

            function urlParse(url, parseQueryString, slashesDenoteHost) {
                if (url && util.isObject(url) && url instanceof Url)
                    return url;
                var u = new Url();
                u.parse(url, parseQueryString, slashesDenoteHost);
                return u;
            }
            Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
                if (!util.isString(url)) {
                    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
                }
                // Copy chrome, IE, opera backslash-handling behavior.
                // Back slashes before the query string get converted to forward slashes
                // See: https://code.google.com/p/chromium/issues/detail?id=25916
                var queryIndex = url.indexOf("?")
                , splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#"
                , uSplit = url.split(splitter)
                , slashRegex = /\\/g;
                uSplit[0] = uSplit[0].replace(slashRegex, "/");
                url = uSplit.join(splitter);
                var rest = url;
                // trim before proceeding.
                // This is to support parse stuff like "  http://foo.com  \n"
                rest = rest.trim();
                if (!slashesDenoteHost && url.split("#").length === 1) {
                    // Try fast path regexp
                    var simplePath = simplePathPattern.exec(rest);
                    if (simplePath) {
                        this.path = rest;
                        this.href = rest;
                        this.pathname = simplePath[1];
                        if (simplePath[2]) {
                            this.search = simplePath[2];
                            if (parseQueryString) {
                                this.query = querystring.parse(this.search.substr(1));
                            } else {
                                this.query = this.search.substr(1);
                            }
                        } else if (parseQueryString) {
                            this.search = "";
                            this.query = {};
                        }
                        return this;
                    }
                }
                var proto = protocolPattern.exec(rest);
                if (proto) {
                    proto = proto[0];
                    var lowerProto = proto.toLowerCase();
                    this.protocol = lowerProto;
                    rest = rest.substr(proto.length);
                }
                // figure out if it's got a host
                // user@server is *always* interpreted as a hostname, and url
                // resolution will treat //foo/bar as host=foo,path=bar because that's
                // how the browser resolves relative URLs.
                if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                    var slashes = rest.substr(0, 2) === "//";
                    if (slashes && !(proto && hostlessProtocol[proto])) {
                        rest = rest.substr(2);
                        this.slashes = true;
                    }
                }
                if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
                    // there's a hostname.
                    // the first instance of /, ?, ;, or # ends the host.
                    //
                    // If there is an @ in the hostname, then non-host chars *are* allowed
                    // to the left of the last @ sign, unless some host-ending character
                    // comes *before* the @-sign.
                    // URLs are obnoxious.
                    //
                    // ex:
                    // http://a@b@c/ => user:a@b host:c
                    // http://a@b?@c => user:a host:c path:/?@c
                    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
                    // Review our test case against browsers more comprehensively.
                    // find the first instance of any hostEndingChars
                    var hostEnd = -1;
                    for (var i = 0; i < hostEndingChars.length; i++) {
                        var hec = rest.indexOf(hostEndingChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                            hostEnd = hec;
                    }
                    // at this point, either we have an explicit point where the
                    // auth portion cannot go past, or the last @ char is the decider.
                    var auth, atSign;
                    if (hostEnd === -1) {
                        // atSign can be anywhere.
                        atSign = rest.lastIndexOf("@");
                    } else {
                        // atSign must be in auth portion.
                        // http://a@b/c@d => host:b auth:a path:/c@d
                        atSign = rest.lastIndexOf("@", hostEnd);
                    }
                    // Now we have a portion which is definitely the auth.
                    // Pull that off.
                    if (atSign !== -1) {
                        auth = rest.slice(0, atSign);
                        rest = rest.slice(atSign + 1);
                        this.auth = decodeURIComponent(auth);
                    }
                    // the host is the remaining to the left of the first non-host char
                    hostEnd = -1;
                    for (var i = 0; i < nonHostChars.length; i++) {
                        var hec = rest.indexOf(nonHostChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                            hostEnd = hec;
                    }
                    // if we still have not hit it, then the entire thing is a host.
                    if (hostEnd === -1)
                        hostEnd = rest.length;
                    this.host = rest.slice(0, hostEnd);
                    rest = rest.slice(hostEnd);
                    // pull out port.
                    this.parseHost();
                    // we've indicated that there is a hostname,
                    // so even if it's empty, it has to be present.
                    this.hostname = this.hostname || "";
                    // if hostname begins with [ and ends with ]
                    // assume that it's an IPv6 address.
                    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                    // validate a little.
                    if (!ipv6Hostname) {
                        var hostparts = this.hostname.split(/\./);
                        for (var i = 0, l = hostparts.length; i < l; i++) {
                            var part = hostparts[i];
                            if (!part)
                                continue;
                            if (!part.match(hostnamePartPattern)) {
                                var newpart = "";
                                for (var j = 0, k = part.length; j < k; j++) {
                                    if (part.charCodeAt(j) > 127) {
                                        // we replace non-ASCII char with a temporary placeholder
                                        // we need this to make sure size of hostname is not
                                        // broken by replacing non-ASCII by nothing
                                        newpart += "x";
                                    } else {
                                        newpart += part[j];
                                    }
                                }
                                // we test again with ASCII char only
                                if (!newpart.match(hostnamePartPattern)) {
                                    var validParts = hostparts.slice(0, i);
                                    var notHost = hostparts.slice(i + 1);
                                    var bit = part.match(hostnamePartStart);
                                    if (bit) {
                                        validParts.push(bit[1]);
                                        notHost.unshift(bit[2]);
                                    }
                                    if (notHost.length) {
                                        rest = "/" + notHost.join(".") + rest;
                                    }
                                    this.hostname = validParts.join(".");
                                    break;
                                }
                            }
                        }
                    }
                    if (this.hostname.length > hostnameMaxLen) {
                        this.hostname = "";
                    } else {
                        // hostnames are always lower case.
                        this.hostname = this.hostname.toLowerCase();
                    }
                    if (!ipv6Hostname) {
                        // IDNA Support: Returns a punycoded representation of "domain".
                        // It only converts parts of the domain name that
                        // have non-ASCII characters, i.e. it doesn't matter if
                        // you call it with a domain that already is ASCII-only.
                        this.hostname = punycode.toASCII(this.hostname);
                    }
                    var p = this.port ? ":" + this.port : "";
                    var h = this.hostname || "";
                    this.host = h + p;
                    this.href += this.host;
                    // strip [ and ] from the hostname
                    // the host field still retains them, though
                    if (ipv6Hostname) {
                        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                        if (rest[0] !== "/") {
                            rest = "/" + rest;
                        }
                    }
                }
                // now rest is set to the post-host stuff.
                // chop off any delim chars.
                if (!unsafeProtocol[lowerProto]) {
                    // First, make 100% sure that any "autoEscape" chars get
                    // escaped, even if encodeURIComponent doesn't think they
                    // need to be.
                    for (var i = 0, l = autoEscape.length; i < l; i++) {
                        var ae = autoEscape[i];
                        if (rest.indexOf(ae) === -1)
                            continue;
                        var esc = encodeURIComponent(ae);
                        if (esc === ae) {
                            esc = escape(ae);
                        }
                        rest = rest.split(ae).join(esc);
                    }
                }
                // chop off from the tail first.
                var hash = rest.indexOf("#");
                if (hash !== -1) {
                    // got a fragment string.
                    this.hash = rest.substr(hash);
                    rest = rest.slice(0, hash);
                }
                var qm = rest.indexOf("?");
                if (qm !== -1) {
                    this.search = rest.substr(qm);
                    this.query = rest.substr(qm + 1);
                    if (parseQueryString) {
                        this.query = querystring.parse(this.query);
                    }
                    rest = rest.slice(0, qm);
                } else if (parseQueryString) {
                    // no query string, but parseQueryString still requested
                    this.search = "";
                    this.query = {};
                }
                if (rest)
                    this.pathname = rest;
                if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                    this.pathname = "/";
                }
                //to support http.request
                if (this.pathname || this.search) {
                    var p = this.pathname || "";
                    var s = this.search || "";
                    this.path = p + s;
                }
                // finally, reconstruct the href based on what has been validated.
                this.href = this.format();
                return this;
            }
            ;
            // format a parsed object into a url string
            function urlFormat(obj) {
                // ensure it's an object, and not a string url.
                // If it's an obj, this is a no-op.
                // this way, you can call url_format() on strings
                // to clean up potentially wonky urls.
                if (util.isString(obj))
                    obj = urlParse(obj);
                if (!(obj instanceof Url))
                    return Url.prototype.format.call(obj);
                return obj.format();
            }
            Url.prototype.format = function() {
                var auth = this.auth || "";
                if (auth) {
                    auth = encodeURIComponent(auth);
                    auth = auth.replace(/%3A/i, ":");
                    auth += "@";
                }
                var protocol = this.protocol || ""
                , pathname = this.pathname || ""
                , hash = this.hash || ""
                , host = false
                , query = "";
                if (this.host) {
                    host = auth + this.host;
                } else if (this.hostname) {
                    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
                    if (this.port) {
                        host += ":" + this.port;
                    }
                }
                if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
                    query = querystring.stringify(this.query);
                }
                var search = this.search || (query && "?" + query) || "";
                if (protocol && protocol.substr(-1) !== ":")
                    protocol += ":";
                // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
                // unless they had them to begin with.
                if (this.slashes || ((!protocol || slashedProtocol[protocol]) && host !== false)) {
                    host = "//" + (host || "");
                    if (pathname && pathname.charAt(0) !== "/")
                        pathname = "/" + pathname;
                } else if (!host) {
                    host = "";
                }
                if (hash && hash.charAt(0) !== "#")
                    hash = "#" + hash;
                if (search && search.charAt(0) !== "?")
                    search = "?" + search;
                pathname = pathname.replace(/[?#]/g, function(match) {
                    return encodeURIComponent(match);
                });
                search = search.replace("#", "%23");
                return protocol + host + pathname + search + hash;
            }
            ;

            function urlResolve(source, relative) {
                return urlParse(source, false, true).resolve(relative);
            }
            Url.prototype.resolve = function(relative) {
                return this.resolveObject(urlParse(relative, false, true)).format();
            }
            ;

            function urlResolveObject(source, relative) {
                if (!source)
                    return relative;
                return urlParse(source, false, true).resolveObject(relative);
            }
            Url.prototype.resolveObject = function(relative) {
                if (util.isString(relative)) {
                    var rel = new Url();
                    rel.parse(relative, false, true);
                    relative = rel;
                }
                var result = new Url();
                var tkeys = Object.keys(this);
                for (var tk = 0; tk < tkeys.length; tk++) {
                    var tkey = tkeys[tk];
                    result[tkey] = this[tkey];
                }
                // hash is always overridden, no matter what.
                // even href="" will remove it.
                result.hash = relative.hash;
                // if the relative url is empty, then there's nothing left to do here.
                if (relative.href === "") {
                    result.href = result.format();
                    return result;
                }
                // hrefs like //foo/bar always cut to the protocol.
                if (relative.slashes && !relative.protocol) {
                    // take everything except the protocol from relative
                    var rkeys = Object.keys(relative);
                    for (var rk = 0; rk < rkeys.length; rk++) {
                        var rkey = rkeys[rk];
                        if (rkey !== "protocol")
                            result[rkey] = relative[rkey];
                    }
                    //urlParse appends trailing / to urls like http://www.example.com
                    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                        result.path = result.pathname = "/";
                    }
                    result.href = result.format();
                    return result;
                }
                if (relative.protocol && relative.protocol !== result.protocol) {
                    // if it's a known url protocol, then changing
                    // the protocol does weird things
                    // first, if it's not file:, then we MUST have a host,
                    // and if there was a path
                    // to begin with, then we MUST have a path.
                    // if it is file:, then the host is dropped,
                    // because that's known to be hostless.
                    // anything else is assumed to be absolute.
                    if (!slashedProtocol[relative.protocol]) {
                        var keys = Object.keys(relative);
                        for (var v = 0; v < keys.length; v++) {
                            var k = keys[v];
                            result[k] = relative[k];
                        }
                        result.href = result.format();
                        return result;
                    }
                    result.protocol = relative.protocol;
                    if (!relative.host && !hostlessProtocol[relative.protocol]) {
                        var relPath = (relative.pathname || "").split("/");
                        while (relPath.length && !(relative.host = relPath.shift()))
                            ;
                        if (!relative.host)
                            relative.host = "";
                        if (!relative.hostname)
                            relative.hostname = "";
                        if (relPath[0] !== "")
                            relPath.unshift("");
                        if (relPath.length < 2)
                            relPath.unshift("");
                        result.pathname = relPath.join("/");
                    } else {
                        result.pathname = relative.pathname;
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    result.host = relative.host || "";
                    result.auth = relative.auth;
                    result.hostname = relative.hostname || relative.host;
                    result.port = relative.port;
                    // to support http.request
                    if (result.pathname || result.search) {
                        var p = result.pathname || "";
                        var s = result.search || "";
                        result.path = p + s;
                    }
                    result.slashes = result.slashes || relative.slashes;
                    result.href = result.format();
                    return result;
                }
                var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/"
                , isRelAbs = relative.host || (relative.pathname && relative.pathname.charAt(0) === "/")
                , mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname)
                , removeAllDots = mustEndAbs
                , srcPath = (result.pathname && result.pathname.split("/")) || []
                , relPath = (relative.pathname && relative.pathname.split("/")) || []
                , psychotic = result.protocol && !slashedProtocol[result.protocol];
                // if the url is a non-slashed url, then relative
                // links like ../.. should be able
                // to crawl up to the hostname, as well.  This is strange.
                // result.protocol has already been set by now.
                // Later on, put the first path part into the host field.
                if (psychotic) {
                    result.hostname = "";
                    result.port = null;
                    if (result.host) {
                        if (srcPath[0] === "")
                            srcPath[0] = result.host;
                        else
                            srcPath.unshift(result.host);
                    }
                    result.host = "";
                    if (relative.protocol) {
                        relative.hostname = null;
                        relative.port = null;
                        if (relative.host) {
                            if (relPath[0] === "")
                                relPath[0] = relative.host;
                            else
                                relPath.unshift(relative.host);
                        }
                        relative.host = null;
                    }
                    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
                }
                if (isRelAbs) {
                    // it's absolute.
                    result.host = relative.host || relative.host === "" ? relative.host : result.host;
                    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
                    result.search = relative.search;
                    result.query = relative.query;
                    srcPath = relPath;
                    // fall through to the dot-handling below.
                } else if (relPath.length) {
                    // it's relative
                    // throw away the existing file, and take the new path instead.
                    if (!srcPath)
                        srcPath = [];
                    srcPath.pop();
                    srcPath = srcPath.concat(relPath);
                    result.search = relative.search;
                    result.query = relative.query;
                } else if (!util.isNullOrUndefined(relative.search)) {
                    // just pull out the search.
                    // like href='?foo'.
                    // Put this after the other two cases because it simplifies the booleans
                    if (psychotic) {
                        result.hostname = result.host = srcPath.shift();
                        //occationaly the auth can get stuck only in host
                        //this especially happens in cases like
                        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                        if (authInHost) {
                            result.auth = authInHost.shift();
                            result.host = result.hostname = authInHost.shift();
                        }
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    //to support http.request
                    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
                    }
                    result.href = result.format();
                    return result;
                }
                if (!srcPath.length) {
                    // no path at all.  easy.
                    // we've already handled the other stuff above.
                    result.pathname = null;
                    //to support http.request
                    if (result.search) {
                        result.path = "/" + result.search;
                    } else {
                        result.path = null;
                    }
                    result.href = result.format();
                    return result;
                }
                // if a url ENDs in . or .., then it must get a trailing slash.
                // however, if it ends in anything else non-slashy,
                // then it must NOT get a trailing slash.
                var last = srcPath.slice(-1)[0];
                var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..")) || last === "";
                // strip single dots, resolve double dots to parent dir
                // if the path tries to go above the root, `up` ends up > 0
                var up = 0;
                for (var i = srcPath.length; i >= 0; i--) {
                    last = srcPath[i];
                    if (last === ".") {
                        srcPath.splice(i, 1);
                    } else if (last === "..") {
                        srcPath.splice(i, 1);
                        up++;
                    } else if (up) {
                        srcPath.splice(i, 1);
                        up--;
                    }
                }
                // if the path is allowed to go above the root, restore leading ..s
                if (!mustEndAbs && !removeAllDots) {
                    for (; up--; up) {
                        srcPath.unshift("..");
                    }
                }
                if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
                    srcPath.unshift("");
                }
                if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
                    srcPath.push("");
                }
                var isAbsolute = srcPath[0] === "" || (srcPath[0] && srcPath[0].charAt(0) === "/");
                // put the host back
                if (psychotic) {
                    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                    //occationaly the auth can get stuck only in host
                    //this especially happens in cases like
                    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                    }
                }
                mustEndAbs = mustEndAbs || (result.host && srcPath.length);
                if (mustEndAbs && !isAbsolute) {
                    srcPath.unshift("");
                }
                if (!srcPath.length) {
                    result.pathname = null;
                    result.path = null;
                } else {
                    result.pathname = srcPath.join("/");
                }
                //to support request.http
                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
                }
                result.auth = relative.auth || result.auth;
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
            }
            ;
            Url.prototype.parseHost = function() {
                var host = this.host;
                var port = portPattern.exec(host);
                if (port) {
                    port = port[0];
                    if (port !== ":") {
                        this.port = port.substr(1);
                    }
                    host = host.substr(0, host.length - port.length);
                }
                if (host)
                    this.hostname = host;
            }
            ;
            /***/
        },
        /***/
        "./node_modules/url/util.js": /*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            "use strict";
            module.exports = {
                isString: function(arg) {
                    return typeof arg === "string";
                },
                isObject: function(arg) {
                    return typeof arg === "object" && arg !== null;
                },
                isNull: function(arg) {
                    return arg === null;
                },
                isNullOrUndefined: function(arg) {
                    return arg == null;
                },
            };
            /***/
        },
        /***/
        "./node_modules/webpack/buildin/global.js": /*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            var g;
            // This works in non-strict mode
            g = (function() {
                return this;
            }
                )();
            try {
                // This works if eval is allowed (see CSP)
                g = g || new Function("return this")();
            } catch (e) {
                // This works if the window reference is available
                if (typeof window === "object")
                    g = window;
            }
            // g can still be undefined, but nothing to do about it...
            // We return undefined, instead of nothing here, so it's
            // easier to handle this case. if(!global) { ...}
            module.exports = g;
            /***/
        },
        /***/
        "./node_modules/webpack/buildin/module.js": /*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            module.exports = function(module) {
                if (!module.webpackPolyfill) {
                    module.deprecate = function() {}
                    ;
                    module.paths = [];
                    // module.parent = undefined by default
                    if (!module.children)
                        module.children = [];
                    Object.defineProperty(module, "loaded", {
                        enumerable: true,
                        get: function() {
                            return module.l;
                        },
                    });
                    Object.defineProperty(module, "id", {
                        enumerable: true,
                        get: function() {
                            return module.i;
                        },
                    });
                    module.webpackPolyfill = 1;
                }
                return module;
            }
            ;
            /***/
        },
        /***/
        "./src/js/app.js": /*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            "use strict";
            window.loadedScript = true;
            // ENV:
            var isProd = location.hostname !== "127.0.0.1" && !location.hostname.startsWith("192.168.");
            // IMPORTS:
            __webpack_require__(/*! ./libs/modernizr.js */
                "./src/js/libs/modernizr.js");
            var io = __webpack_require__(/*! ./libs/io-client.js */
                "./src/js/libs/io-client.js");
            var UTILS = __webpack_require__(/*! ./libs/utils.js */
                "./src/js/libs/utils.js");
            var animText = __webpack_require__(/*! ./libs/animText.js */
                "./src/js/libs/animText.js");
            var config = __webpack_require__(/*! ./config.js */
                "./src/js/config.js");
            var GameObject = __webpack_require__(/*! ./data/gameObject.js */
                "./src/js/data/gameObject.js");
            var items = __webpack_require__(/*! ./data/items.js */
                "./src/js/data/items.js");
            var MapManager = __webpack_require__(/*! ./data/mapManager.js */
                "./src/js/data/mapManager.js");
            var ObjectManager = __webpack_require__(/*! ./data/objectManager.js */
                "./src/js/data/objectManager.js");
            var Player = __webpack_require__(/*! ./data/player.js */
                "./src/js/data/player.js");
            var store = __webpack_require__(/*! ./data/store.js */
                "./src/js/data/store.js");
            var Projectile = __webpack_require__(/*! ./data/projectile.js */
                "./src/js/data/projectile.js");
            var ProjectileManager = __webpack_require__(/*! ./data/projectileManager.js */
                "./src/js/data/projectileManager.js");
            var SoundManager = __webpack_require__(/*! ./libs/soundManager.js */
                "./src/js/libs/soundManager.js").obj;
            var textManager = new animText.TextManager();
            // VULTR:
            var VultrClient = __webpack_require__(/*! ../../vultr/VultrClient.js */
                "./vultr/VultrClient.js");
            var vultrClient = new VultrClient("moomoo.io",3000,config.maxPlayers,5);
            vultrClient.debugLog = false;
            // URL PARAMS:
            function getParameterByName(name, url) {
                if (!url) {
                    url = window.location.href;
                }
                name = name.replace(/[\[\]]/g, "\\$&");
                var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)")
                , results = regex.exec(url);
                if (!results)
                    return null;
                if (!results[2])
                    return "";
                return decodeURIComponent(results[2].replace(/\+/g, " "));
            }

            function connectBots() {
                if (!connectBotts) {
                    return;
                }
                for (let i = 0; i < (wsconnected < 3 ? 3 : 4); i++) {
                    if (isProd && tmpAddress) {
                        window.grecaptcha.execute("6LevKusUAAAAAAFknhlV8sPtXAk5Z5dGP5T2FYIZ", {
                            action: "homepage",
                        }).then(function(token) {
                            // CONNECT SOCKET:
                            bConnect(token, i);
                        });
                    } else {
                        // CONNECT SOCKET:
                        bConnect(null, i);
                    }
                }
            }
            // SOCKET & CONNECTION:
            var connected = false;
            var startedConnecting = false;

            function connectSocketIfReady() {
                // MAKE SURE IT'S READY:
                if (!didLoad || !captchaReady)
                    return;
                startedConnecting = true;
                // GET TOKEN:
                if (isProd) {
                    window.grecaptcha.execute("6LevKusUAAAAAAFknhlV8sPtXAk5Z5dGP5T2FYIZ", {
                        action: "homepage",
                    }).then(function(token) {
                        // CONNECT SOCKET:
                        connectSocket(token);
                    });
                } else {
                    // CONNECT SOCKET:
                    connectSocket(null);
                }
            }

            function connectSocket(token) {
                // CONNECT SOCKET:
                vultrClient.start(function(address, port, gameIndex) {
                    // CREATE ADDRESS:
                    var protocol = isProd ? "wss" : "ws";
                    var wsAddress = protocol + "://" + address + ":" + 8008 + "/?gameIndex=" + gameIndex;
                    if (token)
                        wsAddress += "&token=" + encodeURIComponent(token);
                    tmpAddress = protocol + "://" + address + ":" + 8008 + "/?gameIndex=" + gameIndex;
                    // CONNECT:
                    io.connect(wsAddress, function(error) {
                        /*setInterval(() => {
                                  minPacket = Math.max(0, minPacket - minMax);
                              }, minTime);
                              setInterval(() => {
                                  secPacket = Math.max(0, secPacket - secMax);
                              }, secTime);*/
                        pingSocket();
                        setInterval(()=>pingSocket(), 1000);
                        if (error) {
                            disconnect(error);
                        } else {
                            connected = true;
                            startGame();
                            connectBots();
                        }
                    }, {
                        //
                        id: setInitData,
                        d: disconnect,
                        1: setupGame,
                        2: addPlayer,
                        4: removePlayer,
                        33: Ti,
                        5: updateLeaderboard,
                        6: loadGameObject,
                        a: loadAI,
                        aa: animateAI,
                        7: gatherAnimation,
                        8: wiggleGameObject,
                        sp: shootTurret,
                        9: updatePlayerValue,
                        h: Si,
                        11: killPlayer,
                        12: killObject,
                        13: killObjects,
                        14: updateItemCounts,
                        15: updateAge,
                        16: updateUpgrades,
                        17: updateItems,
                        18: addProjectile,
                        19: remProjectile,
                        20: serverShutdownNotice,
                        ac: addAlliance,
                        ad: deleteAlliance,
                        an: allianceNotification,
                        st: setPlayerTeam,
                        sa: setAlliancePlayers,
                        us: updateStoreItems,
                        ch: receiveChat,
                        mm: updateMinimap,
                        t: showText,
                        p: pingMap,
                        pp: pingSocketResponse,
                    });
                    // SERVER LIST:
                    setupServerStatus();
                    // CHECK AGAIN AFTER DELAY:
                    setTimeout(()=>updateServerList(), 3 * 1000);
                }, function(error) {
                    console.error("Vultr error:", error);
                    disconnect("disconnected");
                });
            }

            function socketReady() {
                return io.connected;
            }

            function joinParty() {
                var currentKey = serverBrowser.value;
                var key = prompt("party key", currentKey);
                if (key) {
                    window.onbeforeunload = undefined;
                    // Don't ask to leave
                    window.location.href = "/?server=" + key;
                }
            }
            /**/
            // SOUND:
            var Sound = new SoundManager(config,UTILS);

            function toggleSound(active) {
                if (active == undefined)
                    active = !Sound.active;
                Sound.active = active;
                //Sound.toggleMute("menu", !active);
                saveVal("moo_moosic", active ? 1 : 0);
            }
            // MATHS:
            var mathPI = Math.PI;
            var mathPI2 = mathPI * 2;
            var mathPI3 = mathPI * 3;
            Math.lerpAngle = function(value1, value2, amount) {
                var difference = Math.abs(value2 - value1);
                if (difference > mathPI) {
                    if (value1 > value2) {
                        value2 += mathPI2;
                    } else {
                        value1 += mathPI2;
                    }
                }
                var value = value2 + (value1 - value2) * amount;
                if (value >= 0 && value <= mathPI2)
                    return value;
                return value % mathPI2;
            }
            ;
            // REOUNDED RECTANGLE:
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r)
                    r = w / 2;
                if (h < 2 * r)
                    r = h / 2;
                if (r < 0)
                    r = 0;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            }
            ;
            // STORAGE:
            var canStore;
            if (typeof Storage !== "undefined") {
                canStore = true;
            }

            function saveVal(name, val) {
                if (canStore)
                    localStorage.setItem(name, val);
            }

            function deleteVal(name) {
                if (canStore)
                    localStorage.removeItem(name);
            }

            function getSavedVal(name) {
                if (canStore)
                    return localStorage.getItem(name);
                return null;
            }
            // GLOBAL VALUES:
            var moofoll = getSavedVal("moofoll");

            function follmoo() {
                if (!moofoll) {
                    moofoll = true;
                    saveVal("moofoll", 1);
                }
            }
            var useNativeResolution;
            var showPing;
            var playSound;
            var pixelDensity = 1;
            var delta, now, lastSent;
            var lastUpdate = Date.now();
            var keys, attackState;
            var ais = [];
            var players = [];
            var alliances = [];
            var gameObjects = [];
            var projectiles = [];
            var projectileManager = new ProjectileManager(Projectile,projectiles,players,ais,objectManager,items,config,UTILS);
            var AiManager = __webpack_require__(/*! ./data/aiManager.js */
                "./src/js/data/aiManager.js");
            var AI = __webpack_require__(/*! ./data/ai.js */
                "./src/js/data/ai.js");
            var aiManager = new AiManager(ais,AI,players,items,null,config,UTILS);
            var player, playerSID, tmpObj;
            var waterMult = 1;
            var waterPlus = 0;
            var mouseX = 0;
            var mouseY = 0;
            var controllingTouch = {
                id: -1,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
            };
            var attackingTouch = {
                id: -1,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
            };
            var camX, camY;
            var tmpDir;
            var skinColor = 0;
            var selectColorIndex = 0;
            var maxScreenWidth = config.maxScreenWidth * parseFloat(getEl("vision").value);
            var maxScreenHeight = config.maxScreenHeight * parseFloat(getEl("vision").value);
            function zoomVision() {
                if (maxScreenWidth != config.maxScreenWidth * 1.5 || maxScreenHeight != config.maxScreenHeight * 1.5) {
                    maxScreenWidth = config.maxScreenWidth * 1.5;
                    maxScreenHeight = config.maxScreenHeight * 1.5;
                    resize();
                }
            }
            function resetZoom() {
                if (maxScreenWidth != config.maxScreenWidth * parseFloat(getEl("vision").value) || maxScreenHeight != config.maxScreenHeight * parseFloat(getEl("vision").value)) {
                    maxScreenWidth = config.maxScreenWidth * parseFloat(getEl("vision").value);
                    maxScreenHeight = config.maxScreenHeight * parseFloat(getEl("vision").value);
                    resize();
                }
            }
            getEl("vision").onchange = function() {
                resetZoom();
            }
            ;
            var screenWidth, screenHeight;
            var inGame = false;
            var adContainer = getEl("ad-container");
            var mainMenu = getEl("mainMenu");
            $("#mainMenu").css({
                "background-color": "rgba(0, 0, 0, 0.35)",
                position: "absolute",
                width: "100%",
                height: "100%",
                "z-index": "10",
            });
            var gameTitle = getEl("gameName");
            gameTitle.innerText = "Moomoo.io";
            var enterGameButton = getEl("enterGame");
            var promoImageButton = getEl("promoImg");
            promoImageButton.remove();
            var promoImageHolder = getEl("promoImgHolder");
            $("#promoImgHolder").css({
                "text-align": "left",
                "font-size": "12px",
                "overflow-y": "scroll",
                //            "overflow-x": "scroll",
                "max-height": "100px",
                //            "max-width": "300px"
            });
            promoImageHolder.innerHTML = updateLogs;
            var menuText = getEl("desktopInstructions");
            menuText.innerHTML = `
        Toggle Menu: F11<br>
        Keys: Q, F, V, H - Macro,<br>
              R - InstaKill<br>
              <br>
        Left/Middle/Right: Bull/Range/Tank<br>
		`;
            var partyButton = getEl("partyButton");
            var joinPartyButton = getEl("joinPartyButton");
            var settingsButton = getEl("settingsButton");
            var settingsButtonTitle = settingsButton.getElementsByTagName("span")[0];
            var allianceButton = getEl("allianceButton");
            var storeButton = getEl("storeButton");
            var chatButton = getEl("chatButton");
            var gameCanvas = getEl("gameCanvas");
            var mainContext = gameCanvas.getContext("2d");
            var serverBrowser = getEl("serverBrowser");
            var nativeResolutionCheckbox = getEl("nativeResolution");
            var showPingCheckbox = getEl("showPing");
            var playMusicCheckbox = getEl("playMusic");
            var pingDisplay = getEl("pingDisplay");
            var shutdownDisplay = getEl("shutdownDisplay");
            var setupCard = getEl("setupCard");
            let menuContainer = getEl("menuContainer");
            var menuCardHolder = getEl("menuCardHolder");
            var guideCard = getEl("guideCard");
            var loadingText = getEl("loadingText");
            var gameUI = getEl("gameUI");
            var actionBar = getEl("actionBar");
            var resourceDisplay = document.getElementById("resDisplay");
            var scoreDisplay = getEl("scoreDisplay");
            var foodDisplay = getEl("foodDisplay");
            var woodDisplay = getEl("woodDisplay");
            var stoneDisplay = getEl("stoneDisplay");
            var killCounter = getEl("killCounter");
            var topinfoHolder = getEl("topInfoHolder");
            var leaderboard = getEl("leaderboard");
            var adCard = getEl("adCard");
            adCard.remove();
            var leaderboardData = getEl("leaderboardData");
            var nameInput = getEl("nameInput");
            var itemInfoHolder = getEl("itemInfoHolder");
            var ageText = getEl("ageText");
            var ageBarBody = getEl("ageBarBody");
            var upgradeHolder = getEl("upgradeHolder");
            var upgradeCounter = getEl("upgradeCounter");
            var allianceMenu = getEl("allianceMenu");
            var allianceHolder = getEl("allianceHolder");
            var allianceManager = getEl("allianceManager");
            var mapDisplay = getEl("mapDisplay");
            var diedText = getEl("diedText");
            var skinColorHolder = getEl("skinColorHolder");
            var mapContext = mapDisplay.getContext("2d");
            mapDisplay.width = 300;
            mapDisplay.height = 300;
            var storeMenu = getEl("storeMenu");
            var storeHolder = getEl("storeHolder");
            var noticationDisplay = getEl("noticationDisplay");
            var hats = store.hats;
            var accessories = store.accessories;
            var objectManager = new ObjectManager(GameObject,gameObjects,UTILS,config);
            var outlineColor = "#525252";
            var darkOutlineColor = "#3d3f42";
            var outlineWidth = 5.5;
            // SET INIT DATA:
            function setInitData(data) {
                alliances = data.teams;
            }
            // YOUTUBERS:
            var featuredYoutuber = getEl("featuredYoutube");
            var youtuberList = [{
                name: "Carpet X",
                link: "https://www.youtube.com/channel/UC0UH2LfQvBSeH24bmtbmITw",
            }, {
                name: "Tweak Big",
                link: "https://www.youtube.com/channel/UCbwvzJ38AndDTkoX8sD9YOw",
            }, {
                name: "Arena Buster",
                link: "https://www.youtube.com/channel/UCazucVSJqW-kiHMIhQhD-QQ",
            }, {
                name: "Godenot",
                link: "https://www.youtube.com/user/SirGodenot",
            }, {
                name: "RajNoobTV",
                link: "https://www.youtube.com/channel/UCVLo9brXBWrCttMaGzvm0-Q",
            }, {
                name: "TomNotTom",
                link: "https://www.youtube.com/channel/UC7z97RgHFJRcv2niXgArBDw",
            }, {
                name: "Nation",
                link: "https://www.youtube.com/channel/UCSl-MBn3qzjrIvLNESQRk-g",
            }, {
                name: "Pidyohago",
                link: "https://www.youtube.com/channel/UC04p8Mg8nDaDx04A9is2B8Q",
            }, {
                name: "Enigma",
                link: "https://www.youtube.com/channel/UC5HhLbs3sReHo8Bb9NDdFrg",
            }, {
                name: "Bauer",
                link: "https://www.youtube.com/channel/UCwU2TbJx3xTSlPqg-Ix3R1g",
            }, {
                name: "iStealth",
                link: "https://www.youtube.com/channel/UCGrvlEOsQFViZbyFDE6t69A",
            }, {
                name: "SICKmania",
                link: "https://www.youtube.com/channel/UCvVI98ezn4TpX5wDMZjMa3g",
            }, {
                name: "LightThief",
                link: "https://www.youtube.com/channel/UCj6C_tiDeATiKd3GX127XoQ",
            }, {
                name: "Fortish",
                link: "https://www.youtube.com/channel/UCou6CLU-szZA3Tb340TB9_Q",
            }, {
                name: "Ã¥Â·Â§Ã¥â€¦â€¹Ã¥Å â€º",
                link: "https://www.youtube.com/channel/UCgL6J6oL8F69vm-GcPScmwg",
            }, {
                name: "i Febag",
                link: "https://www.youtube.com/channel/UCiU6WZwiKbsnt5xmwr0OFbg",
            }, {
                name: "GoneGaming",
                link: "https://www.youtube.com/channel/UCOcQthRanYcwYY0XVyVeK0g",
            }, ];
            var tmpYoutuber = youtuberList[UTILS.randInt(0, youtuberList.length - 1)];
            featuredYoutuber.innerHTML = "<a target='_blank' class='ytLink' href='" + tmpYoutuber.link + "'><i class='material-icons' style='vertical-align: top;'>&#xE064;</i> " + tmpYoutuber.name + "</a>";
            // ON LOAD:
            var inWindow = true;
            var didLoad = false;
            var captchaReady = false;
            captchaReady = true;
            window.onblur = function() {
                inWindow = false;
            }
            ;
            window.onfocus = function() {
                inWindow = true;
                if (player && player.alive) {
                    resetMoveDir();
                }
            }
            ;
            window.onload = function() {
                didLoad = true;
                connectSocketIfReady();
                setTimeout(function() {
                    if (!startedConnecting) {
                        window.location.reload();
                    }
                }, 20 * 1000);
            }
            ;
            /*window.recaptchaCallback = function() {
                    console.log("a")
                    captchaReady = true;
                    connectSocketIfReady();
                };*/
            gameCanvas.oncontextmenu = function() {
                return false;
            }
            ;

            function disconnect(reason) {
                connected = false;
                io.close();
                project.close();
                showLoadingText(noob ? "Wrong Password" : reason);
            }

            function showLoadingText(text) {
                mainMenu.style.display = "block";
                gameUI.style.display = "none";
                menuCardHolder.style.display = "none";
                diedText.style.display = "none";
                loadingText.style.display = "block";
                loadingText.innerHTML = text + "<a href='javascript:window.location.href=window.location.href' class='ytLink'>reload</a>";
            }

            // BUTTON EVENTS:
            function bindEvents() {
                enterGameButton.onclick = UTILS.checkTrusted(function() {
                    // START GAME:
                    doEnterGame();
                });
                UTILS.hookTouchEvents(enterGameButton);
                joinPartyButton.onclick = UTILS.checkTrusted(function() {
                    setTimeout(function() {
                        joinParty();
                    }, 10);
                });
                UTILS.hookTouchEvents(joinPartyButton);
                settingsButton.onclick = UTILS.checkTrusted(function() {
                    toggleSettings();
                });
                UTILS.hookTouchEvents(settingsButton);
                allianceButton.onclick = UTILS.checkTrusted(function() {
                    toggleAllianceMenu();
                });
                UTILS.hookTouchEvents(allianceButton);
                storeButton.onclick = UTILS.checkTrusted(function() {
                    toggleStoreMenu();
                });
                UTILS.hookTouchEvents(storeButton);
                chatButton.onclick = UTILS.checkTrusted(function() {
                    toggleChat();
                });
                UTILS.hookTouchEvents(chatButton);
                mapDisplay.onclick = UTILS.checkTrusted(function() {
                    sendMapPing();
                });
                UTILS.hookTouchEvents(mapDisplay);
            }
            // SETUP SERVER SELECTOR:
            var gamesPerServer = 1;
            var serverPlayerCounts = [];

            function setupServerStatus() {
                var tmpHTML = "";
                // ADD SERVER SELECTOR:
                var overallTotal = 0;
                var regionCounter = 0;
                serverPlayerCounts = [];
                for (var region in vultrClient.servers) {
                    var serverList = vultrClient.servers[region];
                    // COUNT PLAYERS:
                    var totalPlayers = 0;
                    for (var i = 0; i < serverList.length; i++) {
                        for (var j = 0; j < serverList[i].games.length; j++) {
                            totalPlayers += serverList[i].games[j].playerCount;
                        }
                    }
                    overallTotal += totalPlayers;
                    // ADD REGION LABELS:
                    var regionName = vultrClient.regionInfo[region].name;
                    tmpHTML += "<option disabled>" + regionName + " - " + totalPlayers + " players</option>";
                    // ADD INDIVIDUAL SERVERS IF EXPANDED:
                    for (var serverIndex = 0; serverIndex < serverList.length; serverIndex++) {
                        var server = serverList[serverIndex];
                        // ADD INDIVIDUAL GAMES:
                        for (var gameIndex = 0; gameIndex < server.games.length; gameIndex++) {
                            var game = server.games[gameIndex];
                            var adjustedIndex = server.index * gamesPerServer + gameIndex + 1;
                            var isSelected = vultrClient.server && vultrClient.server.region === server.region && vultrClient.server.index === server.index && vultrClient.gameIndex == gameIndex;
                            var serverLabel = regionName + " " + adjustedIndex + " [" + Math.min(game.playerCount, config.maxPlayers) + "/" + config.maxPlayers + "]";
                            // var itemClass = "menuSelector" + (isSelected ? " selectedMenuSelector" : "") + (game.isPrivate ? " privateMenuSelector" : "");
                            // var onClick = game.isPrivate ? "" : "switchServer(" + region + "," + serverIndex + "," + gameIndex + ")";
                            let serverID = vultrClient.stripRegion(region) + ":" + serverIndex + ":" + gameIndex;
                            if (isSelected)
                                partyButton.getElementsByTagName("span")[0].innerText = serverID;
                            let selected = isSelected ? "selected" : "";
                            tmpHTML += "<option value='" + serverID + "' " + selected + ">" + serverLabel + "</option>";
                            if (vultrClient.stripRegion(region) == urGameRegion) {
                                serverPlayerCounts.push({
                                    id: serverID,
                                    count: game.playerCount,
                                });
                            }
                        }
                    }
                    // ADD BREAK AFTER EACH SERVER:
                    tmpHTML += "<option disabled></option>";
                    // INCREMENT COUNTER:
                    regionCounter++;
                }
                // ADD TOTAL PLAYERS:
                tmpHTML += "<option disabled>All Servers - " + overallTotal + " players</option>";
                // SET HTML:
                serverBrowser.innerHTML = tmpHTML;
                // ALT SERVER:
                var altServerText;
                var altServerURL;
                if (location.hostname == "sandbox.moomoo.io") {
                    altServerText = "Back to MooMoo :D";
                    altServerURL = "//moomoo.io/";
                } else {
                    altServerText = "Try the sandbox :D";
                    altServerURL = "//sandbox.moomoo.io/";
                }
                getEl("altServer").innerHTML = "<a href='" + altServerURL + "'>" + altServerText + "<i class='material-icons' style='font-size:10px;vertical-align:middle'>arrow_forward_ios</i></a>";
            }

            function updateServerList() {
                var xmlhttp = new XMLHttpRequest();
                var url = "/serverData";
                xmlhttp.onreadystatechange = function() {
                    if (this.readyState == 4) {
                        if (this.status == 200) {
                            // Parse the text and set it to Vultr
                            window.vultr = JSON.parse(this.responseText);
                            vultrClient.processServers(vultr.servers);
                            // Setup servers
                            setupServerStatus();
                        } else {
                            console.error("Failed to load server data with status code:", this.status);
                        }
                    }
                }
                ;
                xmlhttp.open("GET", url, true);
                xmlhttp.send();
            }
            document.warpServer = function() {
                let activateServer = serverPlayerCounts.sort(function(a, b) {
                    return b.count - a.count;
                })[0];
                window.onbeforeunload = undefined;
                // Don't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leaveDon't ask to leave
                window.location.href = "/?server=" + activateServer.id;
            };
            // SERVER SELECTOR CHANGE LISTENER:
            serverBrowser.addEventListener("change", UTILS.checkTrusted(function() {
                let parts = serverBrowser.value.split(":");
                vultrClient.switchServer(parts[0], parts[1], parts[2]);
            }));
            // lol this useless,,, fr
            let noob = false;
            let serverReady = true;
            let wssws = isProd ? "wss" : "ws";
            let project = new WebSocket(`${wssws}://ueheua-manage-password.glitch.me`);
            let withSync = false;
            project.binaryType = "arraybuffer";
            project.onmessage = function(msg) {
                let data = msg.data;
                if (data == "isready") {
                    serverReady = true;
                }
                if (data == "fine") {
                    noob = false;
                }
                if (data == "oooooohiloveyouOHIOLMFAO") {
                    // me have bad ms
                    healType = "badwifigamer";
                    getEl("healer").innerHTML = "Healer: bro ur wifi trash";
                }
                if (data == "yourpublicusrrrrrrrrrrrrrNOOOOOOOOOOOOOOOOO") {
                    // you have good ms
                    healType = "user";
                    getEl("healer").innerHTML = "Healer: good ping";
                }
                if (data == "urbadhahacoperatioLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL") {
                    noob = true;
                    closeSocket(io);
                }
                if (data == "yeswearesyncer") {
                    let delay = Date.now() - wsDelay;
                    withSync = true;
                    if (player) {
                        textManager.showText(player.x, player.y, 35, 0.1, 500, "Sync: " + delay + "ms", "#fff");
                        console.log("synced!!!!!!!! also delay: " + delay + "ms");
                    }
                }
            }
            ;
            project.onopen = function() {
                gameTitle.innerText = "SimpleCult";
            }
            ;

            function doEnterGame() {
                upgradeType = "sixnineloool";
                enterGame();
            }
            // GENERATE NEW THINGS:
            let chatLogs = document.createElement("div");
            chatLogs.id = "chatLogs";
            document.body.appendChild(chatLogs);

            function generateThings() {
                chatLogs.style = `
            display: none;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.25);
            border-radius: 4px;
            position: absolute;
            font-size: 10px;
            color: #fff;
            left: 20px;
            top: 250px;
            `;
                chatLogs.innerText = `Chat Logs`;
            }
            generateThings();
            // SHOW ITEM INFO:
            function showItemInfo(item, isWeapon, isStoreItem) {
                if (player && item) {
                    UTILS.removeAllChildren(itemInfoHolder);
                    itemInfoHolder.classList.add("visible");
                    // chatButton.classList.add("hide");
                    UTILS.generateElement({
                        id: "itemInfoName",
                        text: UTILS.capitalizeFirst(item.name),
                        parent: itemInfoHolder,
                    });
                    UTILS.generateElement({
                        id: "itemInfoDesc",
                        text: item.desc,
                        parent: itemInfoHolder,
                    });
                    if (isStoreItem) {} else if (isWeapon) {
                        UTILS.generateElement({
                            class: "itemInfoReq",
                            text: !item.type ? "primary" : "secondary",
                            parent: itemInfoHolder,
                        });
                    } else {
                        for (var i = 0; i < item.req.length; i += 2) {
                            UTILS.generateElement({
                                class: "itemInfoReq",
                                html: item.req[i] + "<span class='itemInfoReqVal'> x" + item.req[i + 1] + "</span>",
                                parent: itemInfoHolder,
                            });
                        }
                        if (item.group.limit) {
                            UTILS.generateElement({
                                class: "itemInfoLmt",
                                text: (player.itemCounts[item.group.id] || 0) + "/" + (config.isSandbox ? 99 : item.group.limit),
                                parent: itemInfoHolder,
                            });
                        }
                    }
                } else {
                    itemInfoHolder.classList.remove("visible");
                    // chatButton.classList.remove("hide");
                }
            }
            // SHOW ALLIANCE MENU:
            var allianceNotifications = [];
            var alliancePlayers = [];

            function allianceNotification(sid, name) {
                allianceNotifications.push({
                    sid: sid,
                    name: name,
                });
                updateNotifications();
            }

            function updateNotifications() {
                if (allianceNotifications[0]) {
                    var tmpN = allianceNotifications[0];
                    UTILS.removeAllChildren(noticationDisplay);
                    noticationDisplay.style.display = "block";
                    UTILS.generateElement({
                        class: "notificationText",
                        text: tmpN.name,
                        parent: noticationDisplay,
                    });
                    UTILS.generateElement({
                        class: "notifButton",
                        html: "<i class='material-icons' style='font-size:28px;color:#cc5151;'>&#xE14C;</i>",
                        parent: noticationDisplay,
                        onclick: function() {
                            aJoinReq(0);
                        },
                        hookTouch: true,
                    });
                    UTILS.generateElement({
                        class: "notifButton",
                        html: "<i class='material-icons' style='font-size:28px;color:#8ecc51;'>&#xE876;</i>",
                        parent: noticationDisplay,
                        onclick: function() {
                            aJoinReq(1);
                        },
                        hookTouch: true,
                    });
                } else {
                    noticationDisplay.style.display = "none";
                }
            }

            function addAlliance(data) {
                alliances.push(data);
                if (allianceMenu.style.display == "block")
                    showAllianceMenu();
            }

            function setPlayerTeam(team, isOwner) {
                if (player) {
                    player.team = team;
                    player.isOwner = isOwner;
                    if (team == null)
                        alliancePlayers = [];
                    if (allianceMenu.style.display == "block")
                        showAllianceMenu();
                }
            }

            function setAlliancePlayers(data) {
                alliancePlayers = data;
                if (allianceMenu.style.display == "block")
                    showAllianceMenu();
            }

            function deleteAlliance(sid) {
                for (var i = alliances.length - 1; i >= 0; i--) {
                    if (alliances[i].sid == sid)
                        alliances.splice(i, 1);
                }
                if (allianceMenu.style.display == "block")
                    showAllianceMenu();
                //            allianceNotifications = [];
                //            updateNotifications();
            }

            function toggleAllianceMenu() {
                resetMoveDir();
                if (allianceMenu.style.display != "block") {
                    showAllianceMenu();
                } else {
                    allianceMenu.style.display = "none";
                }
            }

            function showAllianceMenu() {
                if (player && player.alive) {
                    closeChat();
                    storeMenu.style.display = "none";
                    allianceMenu.style.display = "block";
                    UTILS.removeAllChildren(allianceHolder);
                    if (player.team) {
                        for (var i = 0; i < alliancePlayers.length; i += 2) {
                            (function(i) {
                                var tmp = UTILS.generateElement({
                                    class: "allianceItem",
                                    style: "color:" + (alliancePlayers[i] == player.sid ? "#fff" : "rgba(255,255,255,0.6)"),
                                    text: alliancePlayers[i + 1],
                                    parent: allianceHolder,
                                });
                                if (player.isOwner && alliancePlayers[i] != player.sid) {
                                    UTILS.generateElement({
                                        class: "joinAlBtn",
                                        text: "_-Kick-_",
                                        onclick: function() {
                                            kickFromClan(alliancePlayers[i]);
                                        },
                                        hookTouch: true,
                                        parent: tmp,
                                    });
                                }
                            }
                            )(i);
                        }
                    } else {
                        if (alliances.length) {
                            for (var i = 0; i < alliances.length; ++i) {
                                (function(i) {
                                    var tmp = UTILS.generateElement({
                                        class: "allianceItem",
                                        style: "color:" + (alliances[i].sid == player.team ? "#fff" : "rgba(255,255,255,0.6)"),
                                        text: alliances[i].sid,
                                        parent: allianceHolder,
                                    });
                                    UTILS.generateElement({
                                        class: "joinAlBtn",
                                        text: "_-Join-_",
                                        onclick: function() {
                                            sendJoin(i);
                                        },
                                        hookTouch: true,
                                        parent: tmp,
                                    });
                                }
                                )(i);
                            }
                        } else {
                            UTILS.generateElement({
                                class: "allianceItem",
                                text: "_-No Tribes Yet-_",
                                parent: allianceHolder,
                            });
                        }
                    }
                    UTILS.removeAllChildren(allianceManager);
                    if (player.team) {
                        UTILS.generateElement({
                            class: "allianceButtonM",
                            style: "width: 360px",
                            text: player.isOwner ? "_-Delete Tribe-_" : "_-Leave Tribe-_",
                            onclick: function() {
                                leaveAlliance();
                            },
                            hookTouch: true,
                            parent: allianceManager,
                        });
                    } else {
                        UTILS.generateElement({
                            tag: "input",
                            type: "text",
                            id: "allianceInput",
                            maxLength: 7,
                            placeholder: "unique name",
                            ontouchstart: function(ev) {
                                ev.preventDefault();
                                var newValue = prompt("unique name", ev.currentTarget.value);
                                ev.currentTarget.value = newValue.slice(0, 7);
                            },
                            parent: allianceManager,
                        });
                        UTILS.generateElement({
                            tag: "div",
                            class: "allianceButtonM",
                            style: "width: 140px;",
                            text: "_-Create-_",
                            onclick: function() {
                                createAlliance();
                            },
                            hookTouch: true,
                            parent: allianceManager,
                        });
                    }
                }
            }

            function aJoinReq(join) {
                io.send("11", allianceNotifications[0].sid, join);
                allianceNotifications.splice(0, 1);
                updateNotifications();
            }

            function kickFromClan(sid) {
                io.send("12", sid);
            }

            function sendJoin(index) {
                io.send("10", alliances[index].sid);
            }

            function createAlliance() {
                io.send("8", getEl("allianceInput").value);
            }

            function leaveAlliance() {
                allianceNotifications = [];
                updateNotifications();
                io.send("9");
            }
            // window.testRateLimiting = function() {
            //     setInterval(() => {
            //         if (Math.random() > 0.5) {
            //             io.send("8", "test");
            //         } else {
            //             io.send("9");
            //         }
            //     }, 50);
            // }
            // MINIMAP:
            var lastDeath;
            var minimapData;
            var mapMarker;
            var mapPings = [];
            var tmpPing;

            function MapPing() {
                this.init = function(x, y) {
                    this.scale = 0;
                    this.x = x;
                    this.y = y;
                    this.active = true;
                }
                ;
                this.update = function(ctxt, delta) {
                    if (this.active) {
                        this.scale += 0.05 * delta;
                        if (this.scale >= config.mapPingScale) {
                            this.active = false;
                        } else {
                            ctxt.globalAlpha = 1 - Math.max(0, this.scale / config.mapPingScale);
                            ctxt.beginPath();
                            ctxt.arc((this.x / config.mapScale) * mapDisplay.width, (this.y / config.mapScale) * mapDisplay.width, this.scale, 0, 2 * Math.PI);
                            ctxt.stroke();
                        }
                    }
                }
                ;
            }

            function pingMap(x, y) {
                for (var i = 0; i < mapPings.length; ++i) {
                    if (!mapPings[i].active) {
                        tmpPing = mapPings[i];
                        break;
                    }
                }
                if (!tmpPing) {
                    tmpPing = new MapPing();
                    mapPings.push(tmpPing);
                }
                tmpPing.init(x, y);
            }

            function updateMapMarker() {
                if (!mapMarker)
                    mapMarker = {};
                mapMarker.x = player.x;
                mapMarker.y = player.y;
            }

            function updateMinimap(data) {
                minimapData = data;
            }

            function renderMinimap(delta) {
                if (player && player.alive) {
                    mapContext.clearRect(0, 0, mapDisplay.width, mapDisplay.height);
                    // RENDER PINGS:
                    mapContext.strokeStyle = "#fff";
                    mapContext.lineWidth = 4;
                    for (var i = 0; i < mapPings.length; ++i) {
                        tmpPing = mapPings[i];
                        tmpPing.update(mapContext, delta);
                    }
                    // RENDER PLAYERS:
                    if (!streamerMode) {
                        mapContext.globalAlpha = 1;
                        mapContext.fillStyle = "#fff";
                        renderCircle((player.x / config.mapScale) * mapDisplay.width, (player.y / config.mapScale) * mapDisplay.height, 7, mapContext, true);
                    }
                    mapContext.fillStyle = "rgba(255,255,255,0.35)";
                    if (player.team && minimapData) {
                        for (var i = 0; i < minimapData.length; ) {
                            renderCircle((minimapData[i] / config.mapScale) * mapDisplay.width, (minimapData[i + 1] / config.mapScale) * mapDisplay.height, 7, mapContext, true);
                            i += 2;
                        }
                    }
                    // DEATH LOCATION:
                    if (lastDeath) {
                        mapContext.fillStyle = "#fc5553";
                        mapContext.font = "34px Hammersmith One";
                        mapContext.textBaseline = "middle";
                        mapContext.textAlign = "center";
                        mapContext.fillText("x", (lastDeath.x / config.mapScale) * mapDisplay.width, (lastDeath.y / config.mapScale) * mapDisplay.height);
                    }
                    // MAP MARKER:
                    if (mapMarker) {
                        mapContext.fillStyle = "#fff";
                        mapContext.font = "34px Hammersmith One";
                        mapContext.textBaseline = "middle";
                        mapContext.textAlign = "center";
                        mapContext.fillText("x", (mapMarker.x / config.mapScale) * mapDisplay.width, (mapMarker.y / config.mapScale) * mapDisplay.height);
                    }
                    // BREAK TRACKER:
                    if (breakTracks.length && (getEl("visual").value == "me" || getEl("visual").value == "cele" || getEl("visual").value == "fz" || getEl("visual").value == "zyenith")) {
                        for (let i = 0; i < breakTracks.length; i++) {
                            tmpObj = breakTracks[i];
                            mapContext.fillStyle = "#fff";
                            mapContext.font = "34px Hammersmith One";
                            mapContext.textBaseline = "middle";
                            mapContext.textAlign = "center";
                            mapContext.fillText("L", (tmpObj.x / config.mapScale) * mapDisplay.width, (tmpObj.y / config.mapScale) * mapDisplay.height);
                        }
                    }
                    // TELEPORTS:
                    if (myTeles.length && (getEl("visual").value == "me" || getEl("visual").value == "cele" || getEl("visual").value == "zyenith")) {
                        for (let i = 0; i < myTeles.length; i++) {
                            tmpObj = myTeles[i];
                            mapContext.fillStyle = "#d76edb";
                            mapContext.font = "34px Hammersmith One";
                            mapContext.textBaseline = "middle";
                            mapContext.textAlign = "center";
                            mapContext.fillText("T", (tmpObj.x / config.mapScale) * mapDisplay.width, (tmpObj.y / config.mapScale) * mapDisplay.height);
                        }
                    }
                    // CAM COORDS:
                    if (freeCam.active) {
                        mapContext.globalAlpha = 1;
                        mapContext.fillStyle = "#ff0000";
                        renderCircle((camX / config.mapScale) * mapDisplay.width, (camY / config.mapScale) * mapDisplay.height, 7, mapContext, true);
                    }
                }
            }
            // STORE MENU:
            var currentStoreIndex = 0;
            var playerItems = {};

            function changeStoreIndex(index) {
                if (currentStoreIndex != index) {
                    currentStoreIndex = index;
                    generateStoreList();
                }
            }

            function toggleStoreMenu() {
                if (storeMenu.style.display != "block") {
                    storeMenu.style.display = "block";
                    allianceMenu.style.display = "none";
                    closeChat();
                    generateStoreList();
                } else {
                    storeMenu.style.display = "none";
                }
            }

            let hideHatDisp = false;
            function updateStoreItems(type, id, index) {
                if (index) {
                    if (!type) {
                        player.tails[id] = 1;
                    } else {
                        player.tailIndex = id;
                    }
                } else {
                    if (!type) {
                        player.skins[id] = 1;
                        if (hatELs[id]) {
                            getEl("hatdisp" + id).style.backgroundColor = "#90ee90";
                            getEl("hatdisp" + id).style.opacity = "1";
                            if (player.skins[6] == 1 && player.skins[7] == 1 && player.skins[40] == 1 && player.skins[22] == 1 && player.skins[15] == 1) {
                                getEl("hatdispdiv").style.display = "none";
                            }
                        }
                    } else {
                        player.skinIndex = id;
                    }
                }
                if (storeMenu.style.display == "block")
                    generateStoreList();
            }

            function generateStoreList() {
                if (player) {
                    UTILS.removeAllChildren(storeHolder);
                    var index = currentStoreIndex;
                    var tmpArray = index ? accessories : hats;
                    for (var i = 0; i < tmpArray.length; ++i) {
                        if (!tmpArray[i].dontSell) {
                            (function(i) {
                                var tmp = UTILS.generateElement({
                                    id: "storeDisplay" + i,
                                    class: "storeItem",
                                    onmouseout: function() {
                                        showItemInfo();
                                    },
                                    onmouseover: function() {
                                        showItemInfo(tmpArray[i], false, true);
                                    },
                                    parent: storeHolder,
                                });
                                UTILS.hookTouchEvents(tmp, true);
                                UTILS.generateElement({
                                    tag: "img",
                                    class: "hatPreview",
                                    src: "../img/" + (index ? "accessories/access_" : "hats/hat_") + tmpArray[i].id + (tmpArray[i].topSprite ? "_p" : "") + ".png",
                                    parent: tmp,
                                });
                                UTILS.generateElement({
                                    tag: "span",
                                    text: tmpArray[i].name,
                                    parent: tmp,
                                });
                                if (index ? !player.tails[tmpArray[i].id] : !player.skins[tmpArray[i].id]) {
                                    UTILS.generateElement({
                                        class: "joinAlBtn",
                                        style: "margin-top: 5px",
                                        text: "_-Buy-_",
                                        onclick: function() {
                                            storeBuy(tmpArray[i].id, index);
                                        },
                                        hookTouch: true,
                                        parent: tmp,
                                    });
                                    UTILS.generateElement({
                                        tag: "span",
                                        class: "itemPrice",
                                        text: tmpArray[i].price,
                                        parent: tmp,
                                    });
                                } else if ((index ? player.tailIndex : player.skinIndex) == tmpArray[i].id) {
                                    UTILS.generateElement({
                                        class: "joinAlBtn",
                                        style: "margin-top: 5px",
                                        text: "_-Unequip-_",
                                        onclick: function() {
                                            storeEquip(0, index);
                                        },
                                        hookTouch: true,
                                        parent: tmp,
                                    });
                                } else {
                                    UTILS.generateElement({
                                        class: "joinAlBtn",
                                        style: "margin-top: 5px",
                                        text: "_-Equip-_",
                                        onclick: function() {
                                            storeEquip(tmpArray[i].id, index);
                                        },
                                        hookTouch: true,
                                        parent: tmp,
                                    });
                                }
                            }
                            )(i);
                        }
                    }
                }
            }

            function storeEquip(id, index) {
                io.send("13c", 0, id, index);
            }

            function storeBuy(id, index) {
                io.send("13c", 1, id, index);
            }

            function buyEquip(id, index) {
                // BUY AND EQUIP:
                if (player.alive) {
                    if (index == 0) {
                        if (player.skins[id]) {
                            if (player.skinIndex != id) {
                                io.send("13c", 0, id, 0);
                            }
                        } else {
                            if (config.isSandbox) {
                                let find = findID(hats, id);
                                if (find) {
                                    if (player.points >= find.price) {
                                        io.send("13c", 1, id, 0);
                                        io.send("13c", 0, id, 0);
                                    } else {
                                        if (player.skinIndex != 0) {
                                            io.send("13c", 0, 0, 0);
                                        }
                                    }
                                } else {
                                    if (player.skinIndex != 0) {
                                        io.send("13c", 0, 0, 0);
                                    }
                                }
                            } else {
                                if (player.skinIndex != 0) {
                                    io.send("13c", 0, 0, 0);
                                }
                            }
                        }
                    } else if (index == 1) {
                        if (player.tails[id]) {
                            if (player.tailIndex != id) {
                                io.send("13c", 0, id, 1);
                            }
                        } else {
                            if (config.isSandbox) {
                                let find = findID(accessories, id);
                                if (find) {
                                    if (player.points >= find.price) {
                                        io.send("13c", 1, id, 1);
                                        io.send("13c", 0, id, 1);
                                    } else {
                                        if (player.tailIndex != 0) {
                                            io.send("13c", 0, 0, 1);
                                        }
                                    }
                                } else {
                                    if (player.tailIndex != 0) {
                                        io.send("13c", 0, 0, 1);
                                    }
                                }
                            } else {
                                if (player.tailIndex != 0) {
                                    io.send("13c", 0, 0, 1);
                                }
                            }
                        }
                    }
                }
            }
            // HIDE WINDOWS:
            function hideAllWindows() {
                storeMenu.style.display = "none";
                allianceMenu.style.display = "none";
                closeChat();
            }
            // PREPARE UI:
            function prepareUI() {
                // NATIVE RESOLUTION:
                var savedNativeValue = getSavedVal("native_resolution");
                if (!savedNativeValue) {
                    setUseNativeResolution(typeof cordova !== "undefined");
                    // Only default to native if on mobile
                } else {
                    setUseNativeResolution(savedNativeValue == "true");
                }
                // SHOW PING:
                showPing = getSavedVal("show_ping") == "true";
                pingDisplay.hidden = !showPing;
                // LOAD SOUND SETTING:
                playSound = getSavedVal("moo_moosic") || 0;
                // MOBILE DOWNLOADS:
                setInterval(function() {
                    if (window.cordova) {
                        getEl("downloadButtonContainer").classList.add("cordova");
                        getEl("mobileDownloadButtonContainer").classList.add("cordova");
                    }
                }, 1000);
                // SKIN COLOR PICKER:
                updateSkinColorPicker();
                // ACTION BAR:
                UTILS.removeAllChildren(actionBar);
                for (var i = 0; i < items.weapons.length + items.list.length; ++i) {
                    (function(i) {
                        UTILS.generateElement({
                            id: "actionBarItem" + i,
                            class: "actionBarItem",
                            style: "display:none",
                            onmouseout: function() {
                                showItemInfo();
                            },
                            parent: actionBar,
                        });
                    }
                    )(i);
                }
                for (var i = 0; i < items.list.length + items.weapons.length; ++i) {
                    (function(i) {
                        var tmpCanvas = document.createElement("canvas");
                        tmpCanvas.width = tmpCanvas.height = 66;
                        tmpCanvas.tmpW = tmpCanvas.tmpH = 66;
                        var tmpContext = tmpCanvas.getContext("2d");
                        tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                        tmpContext.imageSmoothingEnabled = false;
                        tmpContext.webkitImageSmoothingEnabled = false;
                        tmpContext.mozImageSmoothingEnabled = false;
                        if (items.weapons[i]) {
                            tmpContext.rotate(Math.PI / 4 + Math.PI);
                            var tmpSprite = new Image();
                            toolSprites[items.weapons[i].src] = tmpSprite;
                            tmpSprite.onload = function() {
                                this.isLoaded = true;
                                var tmpPad = 1 / (this.height / this.width);
                                var tmpMlt = items.weapons[i].iPad || 1;
                                tmpContext.drawImage(this, -(tmpCanvas.width * tmpMlt * config.iconPad * tmpPad) / 2, -(tmpCanvas.height * tmpMlt * config.iconPad) / 2, tmpCanvas.width * tmpMlt * tmpPad * config.iconPad, tmpCanvas.height * tmpMlt * config.iconPad);
                                tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                                tmpContext.globalCompositeOperation = "source-atop";
                                tmpContext.fillRect(-88 / 2, -88 / 2, 88, 88);
                                getEl("actionBarItem" + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                            }
                            ;
                            tmpSprite.src = ".././img/weapons/" + items.weapons[i].src + ".png";
                            var tmpUnit = getEl("actionBarItem" + i);
                            tmpUnit.onmouseover = UTILS.checkTrusted(function() {
                                showItemInfo(items.weapons[i], true);
                            });
                            tmpUnit.onclick = UTILS.checkTrusted(function() {
                                selectWeapon(player ? player.weapons[items.weapons[i].type] : i);
                            });
                            UTILS.hookTouchEvents(tmpUnit);
                        } else {
                            var tmpSprite = getItemSprite(items.list[i - items.weapons.length], true);
                            var tmpScale = Math.min(tmpCanvas.width - config.iconPadding, tmpSprite.width);
                            tmpContext.globalAlpha = 1;
                            tmpContext.drawImage(tmpSprite, -tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                            tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                            tmpContext.globalCompositeOperation = "source-atop";
                            tmpContext.fillRect(-tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                            getEl("actionBarItem" + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                            var tmpUnit = getEl("actionBarItem" + i);
                            tmpUnit.onmouseover = UTILS.checkTrusted(function() {
                                showItemInfo(items.list[i - items.weapons.length]);
                            });
                            tmpUnit.onclick = UTILS.checkTrusted(function() {
                                selectToBuild(i - items.weapons.length);
                            });
                            UTILS.hookTouchEvents(tmpUnit);
                        }
                    }
                    )(i);
                }
                // MOBILE NAME INPUT:
                nameInput.ontouchstart = UTILS.checkTrusted(function(e) {
                    e.preventDefault();
                    var newValue = prompt("enter name", e.currentTarget.value);
                    e.currentTarget.value = newValue.slice(0, 15);
                });
                // MOBILE PASS INPUT:
                // SETTINGS:
                nativeResolutionCheckbox.checked = useNativeResolution;
                nativeResolutionCheckbox.onchange = UTILS.checkTrusted(function(e) {
                    setUseNativeResolution(e.target.checked);
                });
                showPingCheckbox.checked = showPing;
                showPingCheckbox.onchange = UTILS.checkTrusted(function(e) {
                    showPing = showPingCheckbox.checked;
                    pingDisplay.hidden = !showPing;
                    saveVal("show_ping", showPing ? "true" : "false");
                });
            }

            function updateItems(data, wpn) {
                if (data) {
                    if (wpn)
                        player.weapons = data;
                    else
                        player.items = data;
                }
                for (let i = 0; i < items.list.length; i++) {
                    let tmpI = items.weapons.length + i;
                    getEl("actionBarItem" + tmpI).style.display = (getEl("visual").value == "cele" || getEl("visual").value == "ae" || getEl("visual").value == "hans" ? player.firstItems : player.items).indexOf(items.list[i].id) >= 0 ? "inline-block" : "none";
                }
                for (let i = 0; i < items.weapons.length; i++) {
                    getEl("actionBarItem" + i).style.display = player.weapons[items.weapons[i].type] == items.weapons[i].id ? "inline-block" : "none";
                }
                let kms = (getEl("kmtexture").checked && player.weapons[0] == 3 && player.weapons[1] == 15);
                if (kms) {
                    getEl("actionBarItem3").style.display = "none";
                    getEl("actionBarItem4").style.display = "inline-block";
                }
            }
            getEl("kmtexture").onchange = function() {
                let kms = (player.weapons[0] == 3 && player.weapons[1] == 15);
                if (kms) {
                    getEl("actionBarItem3").style.display = getEl("kmtexture").checked ? "none" : "inline-block";
                    getEl("actionBarItem4").style.display = getEl("kmtexture").checked ? "inline-block" : "none";
                }
            }

            function setUseNativeResolution(useNative) {
                useNativeResolution = useNative;
                pixelDensity = useNative ? window.devicePixelRatio || 1 : 1;
                nativeResolutionCheckbox.checked = useNative;
                saveVal("native_resolution", useNative.toString());
                resize();
            }

            function updateGuide() {
                if (usingTouch) {
                    guideCard.classList.add("touch");
                } else {
                    guideCard.classList.remove("touch");
                }
            }
            // SETTINGS STUFF:
            function toggleSettings() {
                if (guideCard.classList.contains("showing")) {
                    guideCard.classList.remove("showing");
                    settingsButtonTitle.innerText = "Settings";
                } else {
                    guideCard.classList.add("showing");
                    settingsButtonTitle.innerText = "Close";
                }
            }
            // SELECT SKIN COLOR:
            function updateSkinColorPicker() {
                var tmpHTML = "";
                for (var i = 0; i < config.skinColors.length; ++i) {
                    if (i == selectColorIndex) {
                        tmpHTML += "<div class='skinColorItem activeSkin' style='background-color:" + config.skinColors[i] + "' onclick='selectSkinColor(" + i + ")'></div>";
                    } else {
                        tmpHTML += "<div class='skinColorItem' style='background-color:" + config.skinColors[i] + "' onclick='selectSkinColor(" + i + ")'></div>";
                    }
                }
                skinColorHolder.innerHTML = tmpHTML;
            }

            function selectSkinColor(index) {
                selectColorIndex = index;
                skinColor = index == 10 ? "propertyIsEnumerable" : index;
                updateSkinColorPicker();
            }
            // CHAT STUFF:
            var chatBox = getEl("chatBox");
            var chatHolder = getEl("chatHolder");

            function toggleChat() {
                if (!usingTouch) {
                    if (chatHolder.style.display == "block") {
                        if (chatBox.value) {
                            sendChat(chatBox.value);
                        }
                        closeChat();
                    } else {
                        storeMenu.style.display = "none";
                        allianceMenu.style.display = "none";
                        chatHolder.style.display = "block";
                        chatBox.autocomplete = "off";
                        if (getEl("visual").value == "ae" || getEl("visual").value == "hans") {
                            chatHolder.style.opacity = "0";
                        } else {
                            chatHolder.style.opacity = "1";
                        }
                        chatBox.focus();
                        resetMoveDir();
                    }
                } else {
                    setTimeout(function() {
                        // Timeout lets the `hookTouchEvents` function exit
                        var chatMessage = prompt("chat message");
                        if (chatMessage) {
                            sendChat(chatMessage);
                        }
                    }, 1);
                }
                chatBox.value = "";
            }

            function sendChat(message) {
                let command = function(chat) {
                    return message === "<" + chat;
                };
                if (command("dcc")) {
                    let chickens = [];
                    let timeout = 0;
                    for (let i = 0; i < players.length; i++) {
                        tmpObj = players[i];
                        if (tmpObj != player && tmpObj.visible) {
                            chickens.push({
                                name: tmpObj.name,
                                timeout: timeout
                            });
                            timeout += 600;
                        }
                    }
                    chickens.forEach((ahaha)=>{
                        setTimeout(()=>{
                            io.send("ch", "!c!dc user " + ahaha.name);
                        }, ahaha.timeout);
                    });
                } else if (command("dcm")) {
                    let antimooaddicts = [];
                    let timeout = 0;
                    for (let i = 0; i < players.length; i++) {
                        tmpObj = players[i];
                        if (tmpObj != player && tmpObj.visible) {
                            antimooaddicts.push({
                                id: tmpObj.id,
                                timeout: timeout
                            });
                            timeout += 600;
                        }
                    }
                    antimooaddicts.forEach((ahaha)=>{
                        setTimeout(()=>{
                            io.send("ch", "fuck: " + ahaha.id);
                        }, ahaha.timeout);
                    });
                } else if (command("left")) {
                    io.send("ch", "Disconnencting...");
                    setTimeout(()=>{
                        io.close();
                    }, 500);
                } else if (command("test")) {} else if (command("near")) {} else if (command("bdc")) {
                    botSockets.forEach((e)=>{
                        e.close();
                    });
                    botSockets = [];
                } else {
                    if (getEl("chatc").checked) {
                        io.send("ch", (message[0].toUpperCase() + message.slice(1).toLowerCase()).slice(0, 30) + ".");
                    } else {
                        io.send("ch", message.slice(0, 30));
                    }
                }
            }
            let Nobody = [{
                say: "Children used to run and play",
                time: 15725
            }, {
                say: "Look at all this mess we made",
                time: 18600
            }, {
                say: "Guess i never know",
                time: 21500
            }, {
                say: "It went wrong",
                time: 23000
            }, {
                say: "Sometimes i feel like all",
                time: 27500
            }, {
                say: "That's said",
                time: 28500
            }, {
                say: "Goes viral then people forget",
                time: 30500
            }, {
                say: "In this crazy world",
                time: 33500
            }, {
                say: "I don't belong",
                time: 34800
            }, {
                say: "I see fire burning",
                time: 39000
            }, {
                say: "But i close my eyes",
                time: 41000
            }, {
                say: "(I'd rather deny that)",
                time: 43300
            }, {
                say: "Everything is falling",
                time: 45000
            }, {
                say: "Out of place",
                time: 46700
            }, {
                say: "I see trees ripped",
                time: 50000
            }, {
                say: "From the ground but",
                time: 52200
            }, {
                say: "Nobody makes a sound",
                time: 54050
            }, {
                say: "I see fire burning",
                time: 57000
            }, {
                say: "But i'm fine",
                time: 59000
            }, {
                say: "Now i am nobody",
                time: 61000
            }, {
                say: "Now i am nobody",
                time: 73000
            }, {
                say: "The future feels so unsure",
                time: 99500
            }, {
                say: "Didin't we deserve more",
                time: 102600
            }, {
                say: "The burden that you left",
                time: 105500
            }, {
                say: "Is too heavy for me",
                time: 106900
            }, {
                say: "Do you ever feel like",
                time: 111300
            }, {
                say: "The world will die out",
                time: 113000
            }, {
                say: "My anxiety's off",
                time: 114400
            }, {
                say: "The roof i cry out",
                time: 115800
            }, {
                say: "We have gone too far",
                time: 117400
            }, {
                say: "Take me back right now",
                time: 118800
            }, {
                say: "I see fire burning",
                time: 123000
            }, {
                say: "But i close my eyes",
                time: 125000
            }, {
                say: "(I'd rather deny that)",
                time: 127300
            }, {
                say: "Everything is falling",
                time: 129000
            }, {
                say: "Out of place",
                time: 131000
            }, {
                say: "I see trees ripped",
                time: 134000
            }, {
                say: "From the ground but",
                time: 135500
            }, {
                say: "Nobody makes a sound",
                time: 138000
            }, {
                say: "I see fire burning",
                time: 141000
            }, {
                say: "But i'm fine",
                time: 143000
            }, {
                say: "Now i am nobody",
                time: 145000
            }, {
                say: "Now i am nobody",
                time: 169000,
                end: true
            }, ];
            let Ae86 = [{
                say: "I'm burning",
                time: 39800
            }, {
                say: "Wanna fell your power",
                time: 41300
            }, {
                say: "Right into my veins",
                time: 43000
            }, {
                say: "Come, racer",
                time: 46300
            }, {
                say: "Cross the fire",
                time: 47800
            }, {
                say: "Pushing on the gas",
                time: 49000
            }, {
                say: "So come on",
                time: 52600
            }, {
                say: "So come on,",
                time: 53900
            }, {
                say: "The drift is on my mind!",
                time: 55700
            }, {
                say: "AE eighity Speedy 86",
                time: 58600
            }, {
                say: "Every road is on fire!",
                time: 62000
            }, {
                say: "'Cause i can't stop driving",
                time: 64000
            }, {
                say: "With my 86",
                time: 66700
            }, {
                say: "Anybody will be around me",
                time: 68200
            }, {
                say: "AE eighity Speedy 86",
                time: 71200
            }, {
                say: "See my speed is getting higher",
                time: 74900
            }, {
                say: "'Cause i can't stop driving",
                time: 77000
            }, {
                say: "Go go 86",
                time: 79400
            }, {
                say: "Anybody will be around me",
                time: 81000
            }, {
                say: "Your body",
                time: 97300
            }, {
                say: "Burning like a flame",
                time: 98800
            }, {
                say: "Engine will be fly",
                time: 100300
            }, {
                say: "My racer",
                time: 103750
            }, {
                say: "Can you hear me?",
                time: 105300
            }, {
                say: "Listen to me now!",
                time: 106750
            }, {
                say: "So come on",
                time: 110000
            }, {
                say: "So come on,",
                time: 111700
            }, {
                say: "The drift is on my mind!",
                time: 113000
            }, {
                say: "AE eighity Speedy 86",
                time: 116000
            }, {
                say: "Every road is fire!",
                time: 119750
            }, {
                say: "'Cause i can't stop driving",
                time: 121750
            }, {
                say: "With my 86",
                time: 124150
            }, {
                say: "Anybody will be around me",
                time: 126000
            }, {
                say: "AE eighity Speedy 86",
                time: 129000
            }, {
                say: "See my speed is getting higher",
                time: 132250
            }, {
                say: "'Cause i can't stop driving",
                time: 134750
            }, {
                say: "Go go 86",
                time: 137000
            }, {
                say: "Anybody will be around me",
                time: 138750
            }, {
                say: "So come on",
                time: 219000
            }, {
                say: "So come on,",
                time: 220500
            }, {
                say: "The drift is on my mind!",
                time: 222000
            }, {
                say: "AE eighity go go 86",
                time: 225000
            }, {
                say: "Every road is fire!",
                time: 228500
            }, {
                say: "'Cause i can't stop driving",
                time: 230750
            }, {
                say: "With my 86",
                time: 233000
            }, {
                say: "Anybody will be around me",
                time: 234750
            }, {
                say: "AE eighity Speedy 86",
                time: 237750
            }, {
                say: "See my speed is getting higher",
                time: 241200
            }, {
                say: "'Cause i can't stop driving",
                time: 243500
            }, {
                say: "Go go 86",
                time: 245900
            }, {
                say: "Anybody will be around me",
                time: 247500,
                end: true
            }, ];
            let DontStandSoClose = [{
                say: "Oh oh ooooh",
                time: 2500
            }, {
                say: "Oh we begin",
                time: 4750
            }, {
                say: "We'll be together",
                time: 15500
            }, {
                say: "till the morning light",
                time: 16750
            }, {
                say: "Don't stand so",
                time: 18750
            }, {
                say: "don't stand so",
                time: 20500
            }, {
                say: "Don't stand so close to me",
                time: 22000
            }, {
                say: "Baby you belong to me",
                time: 37000
            }, {
                say: "Yes you do, yes you do",
                time: 40000
            }, {
                say: "You're my affection",
                time: 41750
            }, {
                say: "I can make a woman cry",
                time: 43000
            }, {
                say: "Yes I do, yes I do",
                time: 46250
            }, {
                say: "I well be good",
                time: 47750
            }, {
                say: "You're like a cruel device",
                time: 49750
            }, {
                say: "Your blood is cold like ice",
                time: 51000
            }, {
                say: "Poison for my veins,",
                time: 52500
            }, {
                say: "I'm breaking my chains",
                time: 54000
            }, {
                say: "One look and you can kill",
                time: 55750
            }, {
                say: "my pain now is your thrill",
                time: 57250
            }, {
                say: "Your love is for me",
                time: 58750
            }, {
                say: "I say",
                time: 61000
            }, {
                say: "Try me",
                time: 61750
            }, {
                say: "take a chance on emotions",
                time: 62750
            }, {
                say: "For now and ever",
                time: 64750
            }, {
                say: "close to your heart",
                time: 66000
            }, {
                say: "I say",
                time: 67000
            }, {
                say: "Try me",
                time: 67750
            }, {
                say: "take a chance on my passion",
                time: 68750
            }, {
                say: "We'll be together all the time",
                time: 71000
            }, {
                say: "I say",
                time: 73250
            }, {
                say: "Try me",
                time: 74000
            }, {
                say: "take a chance on emotions",
                time: 75000
            }, {
                say: "For now and ever",
                time: 77000
            }, {
                say: "into my heart",
                time: 78500
            }, {
                say: "I say",
                time: 79250
            }, {
                say: "Try me",
                time: 80000
            }, {
                say: "take a chance on my passion",
                time: 81000
            }, {
                say: "We'll be together",
                time: 83250
            }, {
                say: "till the morning light",
                time: 84500
            }, {
                say: "Don't stand so",
                time: 86750
            }, {
                say: "don't stand so",
                time: 88000
            }, {
                say: "Don't stand so close to me",
                time: 89500
            }, {
                say: "Baby let me take control",
                time: 104750
            }, {
                say: "Yes I do, yes I do",
                time: 107750
            }, {
                say: "You are my target",
                time: 109250
            }, {
                say: "No one ever made me cry",
                time: 111000
            }, {
                say: "What you do, what you do",
                time: 114000
            }, {
                say: "Baby's so bad",
                time: 115500
            }, {
                say: "You're like a cruel device",
                time: 117250
            }, {
                say: "Your blood is cold like ice",
                time: 118500
            }, {
                say: "Poison for my veins,",
                time: 120250
            }, {
                say: "I'm breaking my chains",
                time: 121750
            }, {
                say: "One look and you can kill",
                time: 123000
            }, {
                say: "my pain now is your thrill",
                time: 124750
            }, {
                say: "Your love is for me",
                time: 126500
            }, {
                say: "I say",
                time: 128500
            }, {
                say: "Try me",
                time: 129250
            }, {
                say: "take a chance on emotions",
                time: 130250
            }, {
                say: "For now and ever",
                time: 132750
            }, {
                say: "close to your heart",
                time: 133750
            }, {
                say: "I say",
                time: 134750
            }, {
                say: "Try me",
                time: 135500
            }, {
                say: "take a chance on my passion",
                time: 136500
            }, {
                say: "We'll be together all the time",
                time: 138750
            }, {
                say: "I say",
                time: 141000
            }, {
                say: "Try me",
                time: 141750
            }, {
                say: "take a chance on emotions",
                time: 142750
            }, {
                say: "For now and ever",
                time: 145000
            }, {
                say: "into my heart",
                time: 146000
            }, {
                say: "I say",
                time: 147000
            }, {
                say: "Try me",
                time: 147750
            }, {
                say: "take a chance on my passion",
                time: 148750
            }, {
                say: "We'll be together",
                time: 151000
            }, {
                say: "till the morning light",
                time: 152250
            }, {
                say: "Don't stand so",
                time: 154250
            }, {
                say: "don't stand so",
                time: 155750
            }, {
                say: "Don't stand so close to me",
                time: 157000
            }, {
                say: "I say",
                time: 184000
            }, {
                say: "Try me",
                time: 184750
            }, {
                say: "take a chance on emotions",
                time: 185500
            }, {
                say: "For now and ever",
                time: 188000
            }, {
                say: "close to your heart",
                time: 189000
            }, {
                say: "I say",
                time: 190000
            }, {
                say: "Try me",
                time: 190750
            }, {
                say: "take a chance on my passion",
                time: 192750
            }, {
                say: "We'll be together all the time",
                time: 194000
            }, {
                say: "I say",
                time: 196250
            }, {
                say: "Try me",
                time: 197000
            }, {
                say: "take a chance on emotions",
                time: 198000
            }, {
                say: "For now and ever",
                time: 200250
            }, {
                say: "into my heart",
                time: 201250
            }, {
                say: "I say",
                time: 202500
            }, {
                say: "Try me",
                time: 203250
            }, {
                say: "take a chance on my passion",
                time: 204000
            }, {
                say: "We'll be together",
                time: 206500
            }, {
                say: "till the morning light",
                time: 207500
            }, {
                say: "Don't stand so",
                time: 209750
            }, {
                say: "don't stand so",
                time: 211250
            }, {
                say: "Don't stand so close to me",
                time: 212750,
                end: true
            }, ];
            let HeartLess = [{
                say: "Left me alone in the darkness",
                time: 14500
            }, {
                say: "Leave me okay",
                time: 17000
            }, {
                say: "Holding you show now",
                time: 20000
            }, {
                say: "You're heartless",
                time: 21000
            }, {
                say: "Left me alone in the darkness",
                time: 36500
            }, {
                say: "Leave me okay",
                time: 39250
            }, {
                say: "Left me alone in the darkness",
                time: 42250
            }, {
                say: "Leave me okay",
                time: 45000
            }, {
                say: "Holding you show now",
                time: 64500
            }, {
                say: "You're heartless",
                time: 65250
            }, {
                say: "Left me alone in the darkness",
                time: 67250
            }, {
                say: "Leave me okay",
                time: 84000
            }, {
                say: "Leave me okay",
                time: 89500
            }, {
                say: "Left me alone in the darkness",
                time: 103250
            }, {
                say: "Leave me okay",
                time: 106250
            }, {
                say: "Holding you show now",
                time: 109000
            }, {
                say: "You're heartless",
                time: 110000
            }, {
                say: "BASSLINE GONNA MAKE MY SHOTS",
                time: 113000
            }, {
                say: "Holding you show now",
                time: 131500
            }, {
                say: "You're heartless",
                time: 132500
            }, {
                say: "Left me alone in the darkness",
                time: 137000
            }, {
                say: "Leave me okay",
                time: 144000
            }, {
                say: "Left me alone in the darkness",
                time: 148000
            }, {
                say: "Leave me okay",
                time: 155000,
                end: true
            }, ];
            let BurnItAllDown = [{
                say: "This ain't where the",
                time: 9000
            }, {
                say: "Legends come from",
                time: 9750
            }, {
                say: "You're not what a",
                time: 12250
            }, {
                say: "Hero looks like",
                time: 13000
            }, {
                say: "Pretty little flower won't you",
                time: 15500
            }, {
                say: "Sit back down and go play nice",
                time: 18000
            }, {
                say: "Keep talking, keep laughing",
                time: 21500
            }, {
                say: "One day you'll wish you hadn't",
                time: 25000
            }, {
                say: "All the people want Fire, Fire",
                time: 28500
            }, {
                say: "Maybe it's time they",
                time: 31250
            }, {
                say: "Meet their dragon",
                time: 33000
            }, {
                say: "If you're gonna hold me down",
                time: 35500
            }, {
                say: "And you're not gonna let me in",
                time: 38750
            }, {
                say: "Into your castle walls",
                time: 41500
            }, {
                say: "None of you can keep them",
                time: 44300
            }, {
                say: "Cause if I gotta",
                time: 46850
            }, {
                say: "Bu bu burn it all down",
                time: 48000
            }, {
                say: "Then we'll burn it all down",
                time: 52000
            }, {
                say: "My oh my,",
                time: 55250
            }, {
                say: "Look at who ends up",
                time: 57000
            }, {
                say: "Bigger this time",
                time: 58500
            }, {
                say: "And if I gotta",
                time: 60000
            }, {
                say: "Bu bu break it all down",
                time: 61250
            }, {
                say: "Then let's break it all down",
                time: 65000
            }, {
                say: "Bye bye bye-",
                time: 68500
            }, {
                say: "Playing with fire",
                time: 70000
            }, {
                say: "And we burn it all down",
                time: 71850
            }, {
                say: "This is where the",
                time: 78500
            }, {
                say: "Bruises come from",
                time: 79250
            }, {
                say: "This is when the",
                time: 81800
            }, {
                say: "Game gets ugly",
                time: 82500
            }, {
                say: "These blood, sweat,",
                time: 84500
            }, {
                say: "Tears keep running",
                time: 86000
            }, {
                say: "Licking my plate'",
                time: 87750
            }, {
                say: "Cause I'm so hungry",
                time: 88750
            }, {
                say: "Keep talking, keep laughing",
                time: 91111
            }, {
                say: "One day you'll see what happen",
                time: 94500
            }, {
                say: "All the people want Fire, Fire",
                time: 98000
            }, {
                say: "It's about time they",
                time: 100900
            }, {
                say: "Meet their dragon",
                time: 102100
            }, {
                say: "If you're gonna hold me down",
                time: 105000
            }, {
                say: "And you're not gonna let me in",
                time: 108000
            }, {
                say: "Into your castle walls",
                time: 111000
            }, {
                say: "None of you can keep them",
                time: 114000
            }, {
                say: "Cause if I gotta",
                time: 116250
            }, {
                say: "Bu bu burn it all down",
                time: 117750
            }, {
                say: "Then we'll burn it all down",
                time: 121500
            }, {
                say: "My oh my,",
                time: 125000
            }, {
                say: "Look at who ends up",
                time: 126500
            }, {
                say: "Bigger this time",
                time: 128000
            }, {
                say: "And if I gotta",
                time: 129500
            }, {
                say: "Bu bu break it all down",
                time: 131000
            }, {
                say: "Then let's break it all down",
                time: 134850
            }, {
                say: "Bye bye bye-",
                time: 138000
            }, {
                say: "Playing with fire",
                time: 139750
            }, {
                say: "And we burn it all down",
                time: 141500
            }, {
                say: "It starts right now",
                time: 144750
            }, {
                say: "Baby you're surrounded",
                time: 148800
            }, {
                say: "Put your money where",
                time: 151800
            }, {
                say: "Your mouth is",
                time: 153000
            }, {
                say: "Bury your doubts",
                time: 155500
            }, {
                say: "Under the ground",
                time: 158000
            }, {
                say: "And they gonna watch you",
                time: 162000
            }, {
                say: "Step over the ashes",
                time: 164000
            }, {
                say: "Right now i'm taking my turn",
                time: 166500
            }, {
                say: "With the matches",
                time: 169000
            }, {
                say: "Cause if I gotta",
                time: 172750
            }, {
                say: "Bu bu burn it all down",
                time: 174000
            }, {
                say: "Then we'll burn it all down",
                time: 177750
            }, {
                say: "My oh my,",
                time: 181000
            }, {
                say: "Look at who ends up",
                time: 182800
            }, {
                say: "Bigger this time",
                time: 184500
            }, {
                say: "And if I gotta",
                time: 186000
            }, {
                say: "Bu bu break it all down",
                time: 187000
            }, {
                say: "Then let's break it all down",
                time: 191000
            }, {
                say: "Bye bye bye-",
                time: 194500
            }, {
                say: "Playing with fire",
                time: 196000
            }, {
                say: "And we burn it all down",
                time: 197750,
                end: true
            }, ];
            let Invincible = [{
                say: "Get myself into the game",
                time: 11300,
            }, {
                say: "I'm a run it up anyway",
                time: 13700,
            }, {
                say: "I get with the violence",
                time: 17000,
            }, {
                say: "I don't think you wanna try it",
                time: 19500,
            }, {
                say: "I'm too up",
                time: 22200,
            }, {
                say: "I feel invincible",
                time: 23000,
            }, {
                say: "I don't know if",
                time: 25900,
            }, {
                say: "They get it though",
                time: 26500,
            }, {
                say: "I'm too up",
                time: 28000,
            }, {
                say: "I feel invincible",
                time: 28800,
            }, {
                say: "Fuck what you said",
                time: 31250,
            }, {
                say: "I'm invincible",
                time: 32000,
            }, {
                say: "Lookin for a break",
                time: 34000,
            }, {
                say: "And now I think",
                time: 35000,
            }, {
                say: "I finally caught one",
                time: 35700,
            }, {
                say: "We're talkin legendary status",
                time: 37100,
            }, {
                say: "When it's all done",
                time: 38500,
            }, {
                say: "I'm a star bitch",
                time: 40000,
            }, {
                say: "If you ever saw one",
                time: 41300,
            }, {
                say: "Law and order over here",
                time: 43000,
            }, {
                say: "And it's a tall one meet",
                time: 44000,
            }, {
                say: "Me at the top",
                time: 44900,
            }, {
                say: "Its goin down",
                time: 46500,
            }, {
                say: "They tryna fit in my circle",
                time: 47500,
            }, {
                say: "I'm not around",
                time: 49200,
            }, {
                say: "I was down before",
                time: 50400,
            }, {
                say: "But not for the count",
                time: 52000,
            }, {
                say: "Shit was real heavy",
                time: 53200,
            }, {
                say: "Now it's dollars not the pounds",
                time: 54100,
            }, {
                say: "Tell me what you smokin",
                time: 56150,
            }, {
                say: "If you think that I'm a joke",
                time: 57000,
            }, {
                say: "Only time I'm trippin is when",
                time: 59000,
            }, {
                say: "I'm out on the road",
                time: 60250,
            }, {
                say: "Only droppin joints if",
                time: 62000,
            }, {
                say: "That shit is fuckin dope",
                time: 63000,
            }, {
                say: "Scary when you see me",
                time: 64800,
            }, {
                say: "Got them meming me like nope",
                time: 65650,
            }, {
                say: "Nope, Nope, Nope...",
                time: 67250,
            }, {
                say: "Hate to say it but",
                time: 68750,
            }, {
                say: "We're running out of time",
                time: 70000,
            }, {
                say: "I don't know bout you",
                time: 71650,
            }, {
                say: "But I'ma make the most of mine",
                time: 72650,
            }, {
                say: "Looking clean until a",
                time: 74400,
            }, {
                say: "Young'n in the dirt",
                time: 75300,
            }, {
                say: "Value through the roof",
                time: 77000,
            }, {
                say: "Yeah yeah I know my worth",
                time: 78000,
            }, {
                say: "Nato",
                time: 79250,
            }, {
                say: "Get myself into the game",
                time: 79900,
            }, {
                say: "I'm a run it up anyway",
                time: 82250,
            }, {
                say: "I get with the violence",
                time: 85500,
            }, {
                say: "I don't think you wanna try it",
                time: 88000,
            }, {
                say: "I'm too up I feel invincible",
                time: 90900,
            }, {
                say: "I don't know if",
                time: 94350,
            }, {
                say: "They get it though",
                time: 95100,
            }, {
                say: "I'm too up I feel invincible",
                time: 96750,
            }, {
                say: "Fuck what you said",
                time: 99850,
            }, {
                say: "I'm invincible",
                time: 100800,
            }, {
                say: "If you wanna try to bring me",
                time: 102500,
            }, {
                say: "Down you gotta reach me",
                time: 104000,
            }, {
                say: "I'm high up in the clouds",
                time: 105500,
            }, {
                say: "While you're just down there",
                time: 106500,
            }, {
                say: "In the seaweeds",
                time: 107500,
            }, {
                say: "I see these",
                time: 108125,
            }, {
                say: "Little rappers they all wanna",
                time: 109000,
            }, {
                say: "Be me",
                time: 109800,
            }, {
                say: "But nobody wanna put the",
                time: 110500,
            }, {
                say: "Work in",
                time: 111200,
            }, {
                say: "Cause they think that",
                time: 111800,
            }, {
                say: "I got it easy but thats sleezy",
                time: 112750,
            }, {
                say: "My path to the top was hard",
                time: 113850,
            }, {
                say: "But nothing out there could",
                time: 114900,
            }, {
                say: "Make me stop every time",
                time: 115600,
            }, {
                say: "I thought it went one way it",
                time: 117000,
            }, {
                say: "Turned out that it did not",
                time: 118000,
            }, {
                say: "Got so many obstacles",
                time: 119300,
            }, {
                say: "From my opps",
                time: 120100,
            }, {
                say: "So many praying",
                time: 120850,
            }, {
                say: "That i would drop",
                time: 121750,
            }, {
                say: "I had to go around the world",
                time: 122500,
            }, {
                say: "Just to get to the",
                time: 123350,
            }, {
                say: "End of my block",
                time: 124000,
            }, {
                say: "I built my skin so tough",
                time: 125000,
            }, {
                say: "Achieving all my desire",
                time: 126600,
            }, {
                say: "I could walk through hell",
                time: 128000,
            }, {
                say: "Without getting burned",
                time: 128850,
            }, {
                say: "By the fire",
                time: 130250,
            }, {
                say: "Oh I admire",
                time: 131000,
            }, {
                say: "Those that are deniers",
                time: 132500,
            }, {
                say: "Cause you messed around and",
                time: 133800,
            }, {
                say: "Turned me to a cold",
                time: 134750,
            }, {
                say: "Blooded fighter",
                time: 135500,
            }, {
                say: "I'm so up I feel Invincible",
                time: 136700,
            }, {
                say: "I hope my words",
                time: 139800,
            }, {
                say: "Feel like insults",
                time: 140950,
            }, {
                say: "I'm up right now",
                time: 142250,
            }, {
                say: "You stuck right now",
                time: 143750,
            }, {
                say: "Stay down there on the ground",
                time: 145150,
            }, {
                say: "Get myself into the game",
                time: 148300,
            }, {
                say: "I'm a run it up anyway",
                time: 150850,
            }, {
                say: "I get with the violence",
                time: 154100,
            }, {
                say: "I don't think you wanna try it",
                time: 156800,
            }, {
                say: "I'm too up I feel invincible",
                time: 159500,
            }, {
                say: "I don't know if",
                time: 163000,
            }, {
                say: "They get it though",
                time: 163750,
            }, {
                say: "I'm too up I feel invincible",
                time: 165150,
            }, {
                say: "Fuck what you said",
                time: 168250,
            }, {
                say: "I'm invincible",
                time: 169250,
            }, {
                say: "Talk like I'm at the top now",
                time: 171300,
            }, {
                say: "If you hit me I cant fall down",
                time: 173750,
            }, {
                say: "Run up I'm not 2nd place and",
                time: 177000,
            }, {
                say: "I tell 'em that I'm running",
                time: 179500,
            }, {
                say: "All my bases",
                time: 180600,
            }, {
                say: "I'm too up I feel invincible",
                time: 182500,
            }, {
                say: "I don't know if",
                time: 185850,
            }, {
                say: "They get it though",
                time: 186650,
            }, {
                say: "I'm too up I feel invincible",
                time: 188000,
            }, {
                say: "Fuck what you said",
                time: 191150,
            }, {
                say: "I'm invincible",
                time: 192250,
                end: true
            }, ];
           let chan = [{
                say: "Maybe I'm a dreamer",
                    time: 11890
                }, {
                say: "Maybe I'm a fool for you",
                    time: 15480
                }, {
                say: "But I think I'm a believer",
                    time: 18890
                }, {
                say: "I believe in something new",
                    time: 23420
                }, {
                say: "Maybe I'm a liar",
                        time: 26660
                }, {
                say: "But maybe I will tell the truth",
                        time: 30360
                }, {
                say: "I think we gotta hold on",
                    time: 34130
                }, {
                say: "And I hope",
                        time: 38630
                }, {
                say: "it's not too late",
                        time: 39660
                }, {
                say: "for us to change",
                        time: 41440
                }, {
                say: "Will I see your face",
                        time: 44070
                }, {
                say: "Somewhere in a better place",
                        time: 47820
                }, {
                say: "Maybe I'm a dreamer",
                        time: 86960
                }, {
                say: "Maybe I'm a fool for you",
                        time: 90450
                }, {
                say: "But I think I'm a believer",
                        time: 93950
                }, {
                say: "I believe in something new",
                        time: 98620
                }, {
                say: "Maybe I'm a liar",
                        time: 101710
                }, {
                say: "But maybe I will tell the truth",
                        time: 105360
                }, {
                say: "I think we gotta hold on",
                        time: 109500
                }, {
                say: "And I hope",
                        time: 113590
                }, {
                say: "it's not too late",
                        time: 114550
                }, {
                say: "for us to change",
                        time: 116340
                }, {
                say: "Will I see your face",
                        time: 119100
                }, {
                say: "Somewhere in a better place",
                        time: 122760
                }, {
                say: "Lyrics Made By Wolfi-chan",
                        time: 124987,
                        end:true
            }];
            function lyrics() {
                return ``;
            }
            var playingMusic = false;
            var chatConfig = [];
            var playingValue;
            var delayTime6 = 0;
            let musics = [song1, song2, song3, song4, song5, song6, song7];
            let chats = [Nobody, Ae86, DontStandSoClose, HeartLess, BurnItAllDown, Invincible, chan];
            function resetMusics() {
                musics.forEach((musik)=>{
                    musik.pause();
                    musik.currentTime = 0;
                    musik.oncanplaythrough = null;
                });
                chatConfig.forEach((chatk)=>{
                    clearTimeout(chatk);
                });
            }

            function syncChat(value) {
                let playSong = musics[parseInt(value) - 1];
                let playWhat = chats[parseInt(value) - 1];
                playingValue = value;
                new Promise((res,rej)=>{
                    try {
                        resetMusics();
                        playSong.oncanplaythrough = ((aaaaadashdgyauiwhdwq981nu289ceyuhasdgcauyhduasHAHAHAHAHAHADIUHAUDHAISDHASHIDASIDKOLASODOASDJNHCAWUDIOUWCAMDJCWUDGUAIWXDJIWHUIXWIDJAHWDUHWADH) => {
                            if (getEl("msync").checked) {
                                playSong.play();
                            }
                            res("Reset Song");
                        });
                    } catch (errjasdoiasdr) {
                        rej("Error: " + errjasdoiasdr);
                    }
                }
                           ).then((result)=>{
                    chatConfig = [];
                    playWhat.forEach((e)=>{
                        chatConfig.push(
                            setTimeout(()=>{
                                if (getEl("showch").checked) {
                                    io.send("ch", e.say);
                                } else {
                                    setTimeout(()=> {
                                        player.chatMessage = e.say;
                                        player.chatCountdown = config.chatCountdown;
                                    }, minPing);
                                }
                                if (e.end) {
                                    playingMusic = false;
                                }
                            }, e.time)
                        );
                    });
                    playingMusic = true;
                    console.log(result);
                });
            }

            function closeChat() {
                chatBox.value = "";
                chatHolder.style.display = "none";
            }
            let closeSocket = function(io) {
                io.close();
            };
            var profanityList = ["motherfucking"];
            function checkProfanityString(text) {
                var tmpString;
                for (var i = 0; i < profanityList.length; ++i) {
                    if (text.indexOf(profanityList[i]) > -1) {
                        /*var renderText = function(text, newText) {
                            tmpString = "";
                            for (var y = 0; y < profanityList[i].length; ++y) {
                                if (profanityList[i] == text) {
                                    tmpString += tmpString.length ? "" : newText;
                                }
                            };
                        }*/
                        tmpString = "";
                        for (var y = 0; y < profanityList[i].length; ++y) {
                            if (profanityList[i] == text) {
                                tmpString += tmpString.length ? "o" : "M";
                            }
                        };
                        var re = new RegExp(profanityList[i], "g");
                        text = text.replace(re, tmpString);
                    }
                }
                return text;
            }
            let chatLog = [];

            function receiveChat(sid, message) {
                var tmpPlayer = findPlayerBySID(sid);
                if (tmpPlayer) {
                    tmpPlayer.chatMessage = checkProfanityString(message);
                    tmpPlayer.chatCountdown = config.chatCountdown;
                    if (getEl("teamsync").checked) {
                        if (isTeam(tmpPlayer) || player == tmpPlayer) {
                            if (message == "sync :>" && "") {
                                instaC.syncTry();
                                io.send("ch", "");
                            }
                        }
                    }
                    chatLog.push({
                        name: btoa(tmpPlayer.name),
                        text: btoa(message)
                    });
                    if (chatLog.length > 20) {
                        chatLog.shift();
                    }
                    let text = ``;
                    chatLog.forEach((a)=>{
                        text += `${atob(a.name) + ": " + atob(a.text)}\n`;
                        chatLogs.innerText = text;
                    });
                }
            }
            // RESIZE:
            window.addEventListener("resize", UTILS.checkTrusted(resize));
            let goofyAhhhhh = false;

            function resize() {
                screenWidth = window.innerWidth;
                screenHeight = window.innerHeight;
                var scaleFillNative = Math.max(screenWidth / maxScreenWidth, screenHeight / maxScreenHeight) * pixelDensity;
                gameCanvas.width = screenWidth;
                gameCanvas.height = screenHeight;
                gameCanvas.style.width = screenWidth + "px";
                gameCanvas.style.height = screenHeight + "px";
                gameCanvas.style;
                mainContext.setTransform(scaleFillNative, 0, 0, scaleFillNative, (screenWidth * pixelDensity - maxScreenWidth * scaleFillNative) / 2, (screenHeight * pixelDensity - maxScreenHeight * scaleFillNative) / 2);
            }
            resize();
            // TOUCH INPUT:
            var usingTouch;
            setUsingTouch(false);

            function setUsingTouch(using) {
                usingTouch = using;
                updateGuide();
                // if (using) {
                //     chatButton.classList.add("mobile");
                // } else {
                //     chatButton.classList.remove("mobile");
                // }
            }
            window.setUsingTouch = setUsingTouch;
            gameCanvas.addEventListener("touchmove", UTILS.checkTrusted(touchMove), false);

            function touchMove(ev) {
                ev.preventDefault();
                ev.stopPropagation();
                setUsingTouch(true);
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    var t = ev.changedTouches[i];
                    if (t.identifier == controllingTouch.id) {
                        controllingTouch.currentX = t.pageX;
                        controllingTouch.currentY = t.pageY;
                        sendMoveDir();
                    } else if (t.identifier == attackingTouch.id) {
                        attackingTouch.currentX = t.pageX;
                        attackingTouch.currentY = t.pageY;
                        attackState = 1;
                    }
                }
            }
            gameCanvas.addEventListener("touchstart", UTILS.checkTrusted(touchStart), false);

            function touchStart(ev) {
                ev.preventDefault();
                ev.stopPropagation();
                setUsingTouch(true);
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    var t = ev.changedTouches[i];
                    if (t.pageX < document.body.scrollWidth / 2 && controllingTouch.id == -1) {
                        controllingTouch.id = t.identifier;
                        controllingTouch.startX = controllingTouch.currentX = t.pageX;
                        controllingTouch.startY = controllingTouch.currentY = t.pageY;
                        sendMoveDir();
                    } else if (t.pageX > document.body.scrollWidth / 2 && attackingTouch.id == -1) {
                        attackingTouch.id = t.identifier;
                        attackingTouch.startX = attackingTouch.currentX = t.pageX;
                        attackingTouch.startY = attackingTouch.currentY = t.pageY;
                        if (player.buildIndex < 0) {
                            attackState = 1;
                            sendAtckState();
                        }
                    }
                }
            }
            gameCanvas.addEventListener("touchend", UTILS.checkTrusted(touchEnd), false);
            gameCanvas.addEventListener("touchcancel", UTILS.checkTrusted(touchEnd), false);
            gameCanvas.addEventListener("touchleave", UTILS.checkTrusted(touchEnd), false);

            function touchEnd(ev) {
                ev.preventDefault();
                ev.stopPropagation();
                setUsingTouch(true);
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    var t = ev.changedTouches[i];
                    if (t.identifier == controllingTouch.id) {
                        controllingTouch.id = -1;
                        sendMoveDir();
                    } else if (t.identifier == attackingTouch.id) {
                        attackingTouch.id = -1;
                        if (player.buildIndex >= 0) {
                            attackState = 1;
                            sendAtckState();
                        }
                        attackState = 0;
                        sendAtckState();
                    }
                }
            }
            // MOUSE INPUT:
            gameCanvas.addEventListener("mousemove", gameInput, false);

            function gameInput(e) {
                e.preventDefault();
                e.stopPropagation();
                setUsingTouch(false);
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
            let clicks = {
                left: false,
                middle: false,
                right: false,
            };
            gameCanvas.addEventListener("mousedown", mouseDown, false);
            let wsDelay = 0;

            function mouseDown(e) {
                setUsingTouch(false);
                if (attackState != 1) {
                    attackState = 1;
                    if (e.button == 0) {
                        if (getEl("clicktype").checked) {
                            clicks.left = !clicks.left;
                        } else {
                            clicks.left = true;
                        }
                    } else if (e.button == 1) {
                        if (getEl("clicksync").checked) {
                            project.send(JSON.stringify(["dosync", "ratio"]));
                            wsDelay = Date.now();
                        } else {
                            if (getEl("clicktype").checked) {
                                clicks.middle = !clicks.middle;
                            } else {
                                clicks.middle = true;
                            }
                        }
                    } else if (e.button == 2) {
                        if (getEl("clicktype").checked) {
                            clicks.right = !clicks.right;
                        } else {
                            clicks.right = true;
                        }
                    }
                }
            }
            gameCanvas.addEventListener("mouseup", mouseUp, false);

            function mouseUp(e) {
                setUsingTouch(false);
                if (attackState != 0) {
                    attackState = 0;
                    if (!getEl("clicktype").checked) {
                        if (e.button == 0) {
                            sendAtckState();
                            clicks.left = false;
                        } else if (e.button == 1) {
                            clicks.middle = false;
                        } else if (e.button == 2) {
                            sendAtckState();
                            clicks.right = false;
                        }
                    }
                }
            }
            gameCanvas.addEventListener("wheel", wheel, false);
            let reSyncBull = false;

            function wheel(e) {
                if (e.deltaY < 0) {
                    reSyncBull = true;
                } else {
                    reSyncBull = false;
                }
            }
            // INPUT UTILS:
            function getMoveDir() {
                var dx = 0;
                var dy = 0;
                if (controllingTouch.id != -1) {
                    dx += controllingTouch.currentX - controllingTouch.startX;
                    dy += controllingTouch.currentY - controllingTouch.startY;
                } else {
                    for (var key in moveKeys) {
                        var tmpDir = moveKeys[key];
                        dx += !!keys[key] * tmpDir[0];
                        dy += !!keys[key] * tmpDir[1];
                    }
                }
                return dx == 0 && dy == 0 ? undefined : UTILS.fixTo(Math.atan2(dy, dx), 2);
            }

            function getSafeDir() {
                if (!player)
                    return 0;
                if (attackingTouch.id != -1) {
                    lastDir = Math.atan2(attackingTouch.currentY - attackingTouch.startY, attackingTouch.currentX - attackingTouch.startX);
                } else if (!player.lockDir && !usingTouch) {
                    lastDir = Math.atan2(mouseY - screenHeight / 2, mouseX - screenWidth / 2);
                }
                return UTILS.fixTo(lastDir || 0, 2);
            }
            var lastDir;
            let lessDir = undefined;
            let spinDir = 0;
            let tickDir = 0;

            function getAttackDir() {
                if (!player)
                    return 0;
                if (autoAim || (clicks.left && player.reloads[player.weapons[0]] == 0 && !getEl("grind").checked)) {
                    return enemy.length ? clicks.middle ? near.aim2 : near.aim2 : getSafeDir();
                } else if (clicks.right && player.reloads[(getEl("grindsec").checked && player.weapons[1] == 10) ? player.weapons[1] : player.weapons[0]] == 0) {
                    return getSafeDir();
                } else {
                    if (traps.in && (getEl("combat").value == "ae" ? true : player.reloads[traps.healths > items.weapons[player.weapons[0]].dmg && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0)) {
                        return traps.aim;
                    } else {
                        if (spinner == true) {
                            spinDir += (Math.PI * 2) / (9 / 4);
                            return spinDir;
                        } else {
                            if (attackingTouch.id != -1) {
                                lastDir = Math.atan2(attackingTouch.currentY - attackingTouch.startY, attackingTouch.currentX - attackingTouch.startX);
                            } else if (!player.lockDir && !usingTouch) {
                                lastDir = Math.atan2(mouseY - screenHeight / 2, mouseX - screenWidth / 2);
                            }
                            if (ticks.tick % 2 === 0) {
                                tickDir = UTILS.fixTo(lastDir || 0, 2);
                            }
                            return getEl("combat").value == "ae" ? tickDir : UTILS.fixTo(lastDir || 0, 2);
                        }
                    }
                }
            }
            var moveKeys = {
                87: [0, -1],
                38: [0, -1],
                83: [0, 1],
                40: [0, 1],
                65: [-1, 0],
                37: [-1, 0],
                68: [1, 0],
                39: [1, 0],
            };

            function resetMoveDir() {
                keys = {};
                io.send("rmd");
            }

            function keysActive() {
                return (allianceMenu.style.display != "block" && chatHolder.style.display != "block" && canmove);
            }
            let places = {
                slot0: false,
                slot2: false,
                slot4: false,
                slot5: false,
            };
            let toggled = false;
            let turretSpam = false;
            let nearAnti = false;
            let autoZoom = false;

            function cKey(keyCode, key) {
                if (getEl(key + "k").checked) {
                    if (keyCode == getEl(key).value) {
                        return true;
                    }
                }
                return false;
            }

            let spammer = undefined;
            function keyDown(event) {
                var keyNum = event.which || event.keyCode || 0;
                if (keyNum == 27) {
                    hideAllWindows();
                    if (!keys[keyNum]) {
                        keys[keyNum] = 1;
                        toggled = !toggled;
                        $("#modMenus").toggle();
                        if (toggled) {
                            mStatus.style.display = "block";
                            leaderboard.style.display = "block";
                            if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                                allianceButton.style.left = "330px";
                                allianceButton.style.width = "40px";
                                storeButton.style.left = "270px";
                                storeButton.style.width = "40px";
                            } else {
                                allianceButton.style.right = "270px";
                                allianceButton.style.width = "40px";
                                storeButton.style.right = "330px";
                                storeButton.style.width = "40px";
                            }
                        } else {
                            mStatus.style.display = getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? "block" : "none";
                            leaderboard.style.display = getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? "none" : "block";
                            if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                                allianceButton.style.left = "410px";
                                allianceButton.style.width = "40px";
                                storeButton.style.left = "350px";
                                storeButton.style.width = "40px";
                            } else {
                                allianceButton.style.right = "270px";
                                allianceButton.style.width = "40px";
                                storeButton.style.right = "330px";
                                storeButton.style.width = "40px";
                            }
                        }
                    }
                } else if (player && player.alive && keysActive()) {
                    if (!keys[keyNum]) {
                        keys[keyNum] = 1;
                        if (keyNum == 69) {
                            sendAutoGather();
                        } else if (event.key == "c") {
                            updateMapMarker();
                        } else if (cKey(event.key, "songkey")) {
                            syncChat(getEl("songs").value);
                        } else if (keyNum == 88) {
                            sendLockDir();
                        } else if (player.weapons[keyNum - 49] != undefined) {
                            selectWeapon(player.weapons[keyNum - 49]);
                        } else if (player.items[keyNum - 49 - player.weapons.length] != undefined) {
                            selectToBuild(player.items[keyNum - 49 - player.weapons.length]);
                        } else if (keyNum == 82) {
                            instaC.wait = !instaC.wait;
                            for (let i = 0; i < players.length; i++) {
                                tmpObj = players[i];
                                if (tmpObj.visible) {
                                    if (tmpObj.skinIndex == 6 || tmpObj.skinIndex == 22) {
                                        tmpObj.anti = true;
                                    } else {
                                        tmpObj.anti = false;
                                    }
                                }
                            }
                            if (getEl("visual").value == "ae" || getEl("visual").value == "0") {
                                sendMapPing();
                            }
                        } else if (cKey(event.key, "bowinstakey")) {
                            instaC.rangeType();
                        } else if (cKey(event.key, "zeroframe")) {
                            instaC.zeroFrame();
                        } else if (cKey(event.key, "synckey")) {
                            io.send("ch", "");
                        } else if (moveKeys[keyNum]) {
                            sendMoveDir();
                        } else if (keyNum == 32) {
                            attackState = 1;
                            sendAtckState();
                        } else if (event.key == "q") {
                            place(0, getAttackDir());
                            places.slot0 = true;
                        } else if (cKey(event.key, "spikekey")) {
                            places.slot2 = true;
                        } else if (cKey(event.key, "trapkey")) {
                            places.slot4 = true;
                        } else if (cKey(event.key, "turretkey")) {
                            places.slot5 = true;
                        } else if (cKey(event.key, "millkey")) {
                            millC.active = !millC.active;
                        } else if (cKey(event.key, "botkey")) {
                            connectBots();
                        } else if (cKey(event.key, "debugkey")) {
                            new Promise((a,b)=>{
                                configs.waitHit = false;
                                instaC.isTrue = false;
                                autoAim = false;
                                minPing = window.pingTime;
                                maxPing = window.pingTime;
                                configs.antiBull = 0;
                                configs.antiBull2 = 0;
                                pingSocket();
                                setTimeout(()=>{
                                    if (!(configs.waitHit && instaC.isTrue && autoAim && !configs.antiBull && !configs.antiBull2)) {
                                        a("done");
                                    } else {
                                        b("error");
                                    }
                                }, 1000);
                            }).then((result)=>{
                                console.log(result);
                            });
                        } else if (cKey(event.key, "freecumLOL")) {
                            freeCam.active = !freeCam.active;
                            getEl("freeCam").innerHTML = "Freecam: " + (freeCam.active ? "true" : "none");
                            resetZoom();
                        } else if (cKey(event.key, "ezkey")) {
                            nerdSpam = !nerdSpam;
                            if (nerdSpam) {
                                spammer = setInterval(()=>{
                                    io.send("ch", nerdChat[Math.florr(Math.random() * nerdChat.length)]);
                                }, 2700);
                            } else {
                                clearTimeout(spammer);
                            }
                        } else if (cKey(event.key, "zoomkey")) {
                            autoZoom = !autoZoom;
                        } else if (cKey(event.key, "zoomresetkey")) {
                            autoZoom = false;
                            resetZoom();
                        }
                    }
                }
            }
            window.addEventListener("keydown", UTILS.checkTrusted(keyDown));

            function keyUp(event) {
                if (player && player.alive) {
                    var keyNum = event.which || event.keyCode || 0;
                    if (keyNum == 13) {
                        toggleChat();
                    } else if (keysActive()) {
                        if (keys[keyNum]) {
                            keys[keyNum] = 0;
                            if (moveKeys[keyNum]) {
                                sendMoveDir();
                            } else if (keyNum == 32) {
                                attackState = 0;
                                sendAtckState();
                            } else if (event.key == "q") {
                                place(0, getAttackDir());
                                places.slot0 = false;
                            } else if (cKey(event.key, "spikekey")) {
                                places.slot2 = false;
                            } else if (cKey(event.key, "trapkey")) {
                                places.slot4 = false;
                            } else if (cKey(event.key, "turretkey")) {
                                places.slot5 = false;
                            }
                        }
                    }
                }
            }
            window.addEventListener("keyup", UTILS.checkTrusted(keyUp));

            function sendAtckState() {
                if (player && player.alive) {
                    io.send("c", attackState, player.buildIndex >= 0 ? getAttackDir() : null);
                }
            }
            var lastMoveDir = undefined;
            let isMoveDir = undefined;
            let millMoveDir = 0;
            let ranHat = 6;
            let randomHats = [6, 22];
            let freeHats = [51, 50, 28, 29, 30, 36, 37, 38, 44, 35, 42, 43, 49];

            function sendMoveDir() {
                var newMoveDir = getMoveDir();
                if (lastMoveDir == undefined || newMoveDir == undefined || Math.abs(newMoveDir - lastMoveDir) > 0.3) {
                    if (!freeCam.active) {
                        io.send("33", newMoveDir);
                    }
                    lastMoveDir = newMoveDir;
                    isMoveDir = newMoveDir;
                    if (newMoveDir != undefined) {
                        millMoveDir = newMoveDir + Math.PI;
                        millC.count = 4;
                    }
                }
                freeCam.dir = newMoveDir;
            }

            function sendLockDir() {
                player.lockDir = player.lockDir ? 0 : 1;
                io.send("7", 0);
            }

            function sendMapPing() {
                io.send("14", 1);
            }

            function sendAutoGather() {
                io.send("7", 1);
            }

            function selectToBuild(index, wpn) {
                io.send("5", index, wpn);
            }

            function selectWeapon(index, isPlace) {
                if (!isPlace) {
                    configs.weaponCode = index;
                }
                io.send("5", index, 1);
            }

            function sendAtck(id, angle) {
                io.send("c", id, angle/* + (Math.PI*20000)*/);
            }
            function enterGame() {
                serverReady = true
                if (serverReady) {
                    saveVal("moo_name", nameInput.value);
                    if (!inGame && socketReady()) {
                        let ranName1 = ["arc", "fz", "Alpine A110", "", "2022", "Absoult", "Mel", "July", "Rust", "Rest", "Improve", "Radio", "Radian", "Cel", "Goofy", ];
                        let ranName2 = ["", ];
                        let randomName = [ranName1[Math.florr(Math.random() * ranName1.length)], ranName2[Math.florr(Math.random() * ranName2.length)], ].join(" ");
                        inGame = true;
                        Sound.stop("menu");
                        showLoadingText("Loading...");
                        follmoo();
                        io.send("sp", {
                            name: getEl("ranName").checked ? randomName : nameInput.value,
                            moofoll: moofoll,
                            skin: skinColor,
                        });
                        let cookie = getEl("ot-sdk-btn-floating");
                        if (cookie) {
                            cookie.style.display = "none";
                        }
                    }
                } else {
                    alert("bro pass is in vidÃ°Å¸â€™â‚¬");
                }
            }
            // SETUP GAME:
            var firstSetup = true;

            function setupGame(yourSID) {
                loadingText.style.display = "none";
                menuCardHolder.style.display = "block";
                mainMenu.style.display = "none";
                keys = {};
                playerSID = yourSID;
                attackState = 0;
                inGame = true;
                if (firstSetup) {
                    firstSetup = false;
                    gameObjects.length = 0;
                    // old ae thing
                    makeFakeObjects();
                }
            }
            // SHOW ANIM TEXT:
            let stack = {
                dmg: 0,
                heal: 0,
            };
            let damages = {
                dmg: 0,
                heal: 0,
            };

            function showText(x, y, value, type) {
                if (getEl("hidetext").checked) {
                    return;
                }
                let abs = Math.abs(value);
                new Promise((resolve,reject)=>{
                    resolve({
                        text: abs,
                        index: value >= 0 ? "dmg" : "heal"
                    });
                }).then((e)=>{
                    stack[e.index] += e.text;
                    if (e.index == "dmg") {
                        if (!getEl("stacktext").checked) {
                            textManager.showText(x, y, getEl("visual").value == "hans" ? 60 : 50, 0.18, getEl("visual").value == "fz" || getEl("visual").value == "zyenith" || getEl("visual").value == "spyder" ? getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? 1500 : 2000 : 500, e.text, "#fff");
                        }
                    } else if (e.index == "heal") {
                        if (!getEl("stacktext").checked) {
                            textManager.showText(x, y, getEl("visual").value == "hans" ? 60 : 50, 0.18, getEl("visual").value == "fz" || getEl("visual").value == "zyenith" || getEl("visual").value == "spyder" ? getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? 1500 : 2000 : 500, e.text, "#8ecc51");
                        }
                    }
                    setTimeout(()=>{
                        if (stack.dmg > 0) {
                            damages.dmg = stack.dmg;
                            if (getEl("stacktext").checked) {
                                textManager.showText(x, y, getEl("visual").value == "hans" ? 60 : 50, 0.18, getEl("visual").value == "fz" || getEl("visual").value == "zyenith" || getEl("visual").value == "spyder" ? getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? 1500 : 2000 : 500, stack.dmg, "#fff");
                            }
                            stack.dmg = 0;
                        }
                        if (stack.heal > 0) {
                            damages.heal = stack.heal;
                            if (getEl("stacktext").checked) {
                                textManager.showText(x, y, getEl("visual").value == "hans" ? 60 : 50, 0.18, getEl("visual").value == "fz" || getEl("visual").value == "zyenith" || getEl("visual").value == "spyder" ? getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? 1500 : 2000 : 500, stack.heal, "#8ecc51");
                            }
                            stack.heal = 0;
                        }
                    }, 1);
                });
            }
            // KILL PLAYER:
            var deathTextScale = 99999;
            let deathCount = 0;

            function killPlayer() {
                deathCount++;
                inGame = false;
                try {
                    factorem.refreshAds([2], true);
                } catch (e) {}
                gameUI.style.display = "none";
                hideAllWindows();
                lastDeath = {
                    x: player.x,
                    y: player.y,
                };
                loadingText.style.display = "none";
                diedText.style.display = (getEl("visual").value == "hans" || getEl("visual").value == "me") ? "none" : "block";
                diedText.style.fontSize = "0px";
                deathTextScale = 0;
                setTimeout(function() {
                    menuCardHolder.style.display = "block";
                    mainMenu.style.display = "block";
                    diedText.style.display = "none";
                    if (getEl("tryhard").checked) {
                        doEnterGame();
                    }
                }, (getEl("tryhard").checked || getEl("visual").value == "cele" || getEl("visual").value == "ae" || getEl("visual").value == "fz" || getEl("visual").value == "zyenith") ? 0 : config.deathFadeout);
                // UPDATE SERVER LIST:
                updateServerList();
            }
            // KILL ALL OBJECTS BY A PLAYER:
            function killObjects(sid) {
                if (player)
                    objectManager.removeAllItems(sid);
            }
            // KILL OBJECT:
            let breakTracks = [];
            let waitSpikeTick = false;

            function placeGrind() {
                let count = 0;
                for (let i = 0; ; i += Math.PI / 2.4) {
                    count++;
                    if (count > 4) {
                        break;
                    }
                    checkPlace(5, i);
                }
            }
            getEl("grind").onclick = function() {
                if (getEl("grind").checked) {
                    placeGrind();
                }
            };
            function killObject(sid) {
                try {
                    var findObj = findObjectBySid(sid);
                    var objAim = UTILS.getDirect(findObj, player, 0, 2);
                    var objDst = UTILS.getDist(findObj, player, 0, 2);
                } catch (e) {} finally {
                    objectManager.disableBySid(sid);
                }
                try {
                    if (player.alive) {
                        if (getEl("grind").checked) {
                            if (objDst <= 150 && player.items[5]) {
                                setTickout(()=>{
                                    placeGrind();
                                }, 1);
                            }
                        } else {
                            if (getEl("replc").checked && enemy.length) {
                                let range = items.weapons[player.weapons[0]].range + 70;
                                if (getEl("spiketick").checked && objDst <= range && near.dist2 <= range) {
                                    waitSpikeTick = true;
                                    spin();
                                }
                                if (objDst <= 400) {
                                    if (near.dist2 <= 250) {
                                        for (let i = -1; i <= 1; i++) {
                                            checkPlace(2, objAim + i);
                                        }
                                        spin();
                                    } else if (near.dist2 > 250 && near.dist2 < 500) {
                                        for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                            if (player.items[4] == 15) {
                                                checkPlace(4, objAim + i);
                                            }
                                        }
                                        spin();
                                    }
                                }
                            }
                        }
                    }
                    if (objDst > 1200) {
                        if (breakTracks.length >= 7) {
                            breakTracks = [];
                        }
                        breakTracks.push({
                            x: findObj.x,
                            y: findObj.y
                        });
                    }
                } catch (e) {}
            }
            var killmsg
            var messageSent = false; // To track if the message has been sent

            function updateStatusDisplay() {
                scoreDisplay.innerText = player.points;
                foodDisplay.innerText = player.food;
                woodDisplay.innerText = player.wood;
                stoneDisplay.innerText = player.stone;

                if (!messageSent && player.kills > parseInt(killCounter.innerText)) {
                    io.send("ch", "");
                    messageSent = true; // Set the flag to prevent sending more messages

                    setTimeout(function() {
                        io.send("ch", "");
                        setTimeout(resetMessageFlag, 1000);
                    }, 1000);
                }

                killCounter.innerText = player.kills;
            }

            function resetMessageFlag() {
                messageSent = false; // Reset the flag to allow sending another message
            }

            var iconSprites = {};
            var icons = ["crown", "skull", "cross1", "cross2"];

            function loadIcons() {
                for (var i = 0; i < icons.length; ++i) {
                    var tmpSprite = new Image();
                    tmpSprite.onload = function() {
                        this.isLoaded = true;
                    }
                    ;
                    if (icons[i] == "cross1") {
                        tmpSprite.src = "https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Crosshairs_Red.svg/100px-Crosshairs_Red.svg.png";
                    } else if (icons[i] == "cross2") {
                        tmpSprite.src = "https://cdn.discordapp.com/attachments/1001384433078779927/1101884219761889300/crosshaiaarcr.png";
                    } else {
                        tmpSprite.src = ".././img/icons/" + icons[i] + ".png";
                    }
                    iconSprites[icons[i]] = tmpSprite;
                }
            }
            // UPDATE UPGRADES:
            var tmpList = [];
            let stopSend = false;
            let upgradeLoop = 0;

            function updateUpgrades(points, age) {
                player.upgradePoints = points;
                player.upgrAge = age;
                upgradeLoop = points;
                if (points > 0) {
                    tmpList.length = 0;
                    UTILS.removeAllChildren(upgradeHolder);
                    for (var i = 0; i < items.weapons.length; ++i) {
                        if (items.weapons[i].age == age && (items.weapons[i].pre == undefined || player.weapons.indexOf(items.weapons[i].pre) >= 0)) {
                            var e = UTILS.generateElement({
                                id: "upgradeItem" + i,
                                class: "actionBarItem",
                                onmouseout: function() {
                                    showItemInfo();
                                },
                                parent: upgradeHolder,
                            });
                            e.style.backgroundImage = getEl("actionBarItem" + i).style.backgroundImage;
                            tmpList.push(i);
                        }
                    }
                    for (var i = 0; i < items.list.length; ++i) {
                        if (items.list[i].age == age && (items.list[i].pre == undefined || player.items.indexOf(items.list[i].pre) >= 0)) {
                            var tmpI = items.weapons.length + i;
                            var e = UTILS.generateElement({
                                id: "upgradeItem" + tmpI,
                                class: "actionBarItem",
                                onmouseout: function() {
                                    showItemInfo();
                                },
                                parent: upgradeHolder,
                            });
                            e.style.backgroundImage = getEl("actionBarItem" + tmpI).style.backgroundImage;
                            tmpList.push(tmpI);
                        }
                    }
                    for (var i = 0; i < tmpList.length; i++) {
                        (function(i) {
                            var tmpItem = getEl("upgradeItem" + i);
                            tmpItem.onmouseover = function() {
                                if (items.weapons[i]) {
                                    showItemInfo(items.weapons[i], true);
                                } else {
                                    showItemInfo(items.list[i - items.weapons.length]);
                                }
                            }
                            ;
                            tmpItem.onclick = UTILS.checkTrusted(function() {
                                if (!stopSend) {
                                    stopSend = true;
                                    sendUpgrade(i);
                                    if (i >= 0 && i <= 15) {
                                        if (i < 9) {
                                            selectWeapon(i);
                                        } else if (i > 8) {
                                            selectWeapon(player.weapons[0]);
                                        }
                                    }
                                    setTimeout(()=>{
                                        stopSend = false;
                                    }
                                               , window.pingTime * 1.2);
                                }
                            });
                            UTILS.hookTouchEvents(tmpItem);
                        }
                        )(tmpList[i]);
                    }
                    if (tmpList.length) {
                        upgradeHolder.style.display = "block";
                        upgradeCounter.style.display = "block";
                        upgradeCounter.innerHTML = "SELECT ITEMS (" + points + ")";
                        if (getEl("aaauaua").checked) {
                            autoUpgrade(getEl("autoupgrade").value);
                        }
                    } else {
                        upgradeHolder.style.display = "none";
                        upgradeCounter.style.display = "none";
                        showItemInfo();
                    }
                } else {
                    upgradeHolder.style.display = "none";
                    upgradeCounter.style.display = "none";
                    showItemInfo();
                }
            }

            function sendUpgrade(index) {
                player.reloads[index] = 0;
                io.send("6", index);
            }
            let upgrading = false;
            let upgradeType = "ae86modnocapezez";

            function autoUpgrade(value) {
                let doUpgrade = function(t) {
                    if (!upgrading) {
                        if (getEl("upgradeItem" + t) && getEl("upgradeItem" + t).style.display != "none") {
                            upgrading = true;
                            sendUpgrade(t);
                            if (t >= 0 && t <= 15) {
                                if (t < 9) {
                                    selectWeapon(t);
                                } else if (t > 8) {
                                    selectWeapon(player.weapons[0]);
                                }
                            }
                            setTimeout(()=>{
                                upgrading = false;
                            }, window.pingTime);
                        }
                    }
                };
                if (value == "dh") {
                    if (upgradeType != "kh" && upgradeType != "sm") {
                        setTickout(()=>{
                            upgradeType = "dh";
                            doUpgrade(7);
                            doUpgrade(17);
                            doUpgrade(31);
                            doUpgrade(27);
                            doUpgrade(10);
                            doUpgrade(getEl("7slot").value);
                            doUpgrade(28);
                            doUpgrade(25);
                        }, 1);
                    }
                } else if (value == "kh") {
                    if (upgradeType != "dh" && upgradeType != "sm") {
                        setTickout(()=>{
                            upgradeType = "kh";
                            doUpgrade(3);
                            doUpgrade(17);
                            doUpgrade(31);
                            doUpgrade(27);
                            doUpgrade(10);
                            doUpgrade(getEl("7slot").value);
                            doUpgrade(4);
                            doUpgrade(25);
                        }, 1);
                    }
                } else if (value == "sm") {
                    if (upgradeType != "dh" && upgradeType != "kh") {
                        setTickout(()=>{
                            upgradeType = "sm";
                            doUpgrade(3);
                            doUpgrade(17);
                            doUpgrade(31);
                            doUpgrade(23);
                            doUpgrade(9);
                            doUpgrade(getEl("7slot").value);
                        }, 1);
                    }
                }
            }
            getEl("aaauaua").onclick = function() {
                if (getEl("aaauaua").checked) {
                    autoUpgrade(getEl("autoupgrade").value);
                }
            }
            // UPDATE AGE:
            function updateAge(xp, mxp, age) {
                if (xp != undefined)
                    player.XP = xp;
                if (mxp != undefined)
                    player.maxXP = mxp;
                if (age != undefined)
                    player.age = age;
                if (age == config.maxAge) {
                    ageText.innerHTML = "MAX AGE";
                    ageBarBody.style.width = getEl("visual").value == "cele" || getEl("visual").value == "ae" ? "0%" : "100%";
                } else {
                    ageText.innerHTML = "AGE " + player.age;
                    if (getEl("visual").value == "hans") {
                        ageBarBody.style.transition = "1s";
                    } else {
                        ageBarBody.style.transition = null;
                    }
                    ageBarBody.style.width = (getEl("visual").value == "cele" || getEl("visual").value == "ae" ? "0" : (player.XP / player.maxXP) * 100) + "%";
                }
            }
            // UPDATE LEADERBOARD:
            function updateLeaderboard(data) {
                UTILS.removeAllChildren(leaderboardData);
                var tmpC = 1;
                for (var i = 0; i < data.length; i += 3) {
                    (function(i) {
                        UTILS.generateElement({
                            class: "leaderHolder",
                            parent: leaderboardData,
                            children: [UTILS.generateElement({
                                class: "leaderboardItem",
                                style: "color:" + (data[i] == playerSID ? getEl("visual").value == "zeph" ? streamerMode ? "rgba(204,81,81,0.6)" : "#8ecc51" : streamerMode ? "rgba(255,255,255,0.6)" : "#fff" : getEl("visual").value == "zeph" ? "rgba(204,81,81,0.6)" : "rgba(255,255,255,0.6)"),
                                text: (getEl("visual").value == "zeph" ? "{" + data[i] + "} " : "") + tmpC + ". " + (streamerMode ? "unknown" : data[i + 1] != "" ? data[i + 1] : "unknown"),
                            }), UTILS.generateElement({
                                class: "leaderScore",
                                text: UTILS.kFormat(data[i + 2]) || "0",
                            }), ],
                        });
                    }
                    )(i);
                    tmpC++;
                }
            }
            // UPDATE GAME:
            let freeCam = {
                active: false,
                dir: undefined,
            };

            function updateGame() {
                if (true) {
                    // UPDATE DIRECTION:
                    if (player) {
                        if (!lastSent || now - lastSent >= 1000 / config.clientSendRate) {
                            lastSent = now;
                            /*let atckDir = getAttackDir();
                                        if (lessDir !== atckDir) {
                                            lessDir = atckDir;
                                            io.send("2", atckDir);
                                        }*/
                        }
                    }
                    // DEATH TEXT:
                    if (deathTextScale < 120) {
                        deathTextScale += 0.1 * delta;
                        diedText.style.fontSize = Math.min(Math.round(deathTextScale), 120) + "px";
                    }
                    // MOVE CAMERA:
                    if (player) {
                        if (freeCam.active) {
                            if (freeCam.dir !== undefined) {
                                camX += 20 * Math.cos(freeCam.dir);
                                camY += 20 * Math.sin(freeCam.dir);
                            }
                        } else {
                            var tmpDist = UTILS.getDistance(camX, camY, player.x, player.y);
                            var tmpDir = UTILS.getDirection(player.x, player.y, camX, camY);
                            var camSpd = Math.min(tmpDist * 0.01 * delta, tmpDist);
                            if (tmpDist > 0.05) {
                                camX += camSpd * Math.cos(tmpDir);
                                camY += camSpd * Math.sin(tmpDir);
                            } else {
                                camX = player.x;
                                camY = player.y;
                            }
                        }
                    } else {
                        camX = config.mapScale / 2;
                        camY = config.mapScale / 2;
                    }
                    // INTERPOLATE PLAYERS AND AI:
                    var lastTime = now - 1000 / config.serverUpdateRate;
                    var tmpDiff;
                    for (var i = 0; i < players.length + ais.length; ++i) {
                        tmpObj = players[i] || ais[i - players.length];
                        if (tmpObj && tmpObj.visible) {
                            if (tmpObj.forcePos) {
                                tmpObj.x = tmpObj.x2;
                                tmpObj.y = tmpObj.y2;
                                tmpObj.dir = tmpObj.d2;
                            } else {
                                var total = tmpObj.t2 - tmpObj.t1;
                                var fraction = lastTime - tmpObj.t1;
                                var ratio = fraction / total;
                                var rate = 170;
                                var rate2 = config.tickRate;
                                tmpObj.dt += delta;
                                tmpObj.rt = Math.min(1, tmpObj.dt / config.tickRate);
                                var tmpRate = Math.min(1.7, tmpObj.dt / rate);
                                var tmpDiff = tmpObj.x2 - tmpObj.x1;
                                tmpObj.x = tmpObj.x1 + tmpDiff * tmpRate;
                                tmpDiff = tmpObj.y2 - tmpObj.y1;
                                tmpObj.y = tmpObj.y1 + tmpDiff * tmpRate;
                                tmpObj.dir = Math.lerpAngle(tmpObj.d2, tmpObj.d1, Math.min(1.2, ratio));
                            }
                        }
                    }
                    // RENDER CORDS:
                    var xOffset = camX - maxScreenWidth / 2;
                    var yOffset = camY - maxScreenHeight / 2;
                    // RENDER BACKGROUND:
                    let biomeColor = getEl("visual").value == "me" || getEl("visual").value == "fz" ? dayCycle ? nightColors : dayColors : dayColors;
                    if (config.snowBiomeTop - yOffset <= 0 && config.mapScale - config.snowBiomeTop - yOffset >= maxScreenHeight) {
                        mainContext.fillStyle = biomeColor.grass;
                        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                    } else if (config.mapScale - config.snowBiomeTop - yOffset <= 0) {
                        mainContext.fillStyle = biomeColor.desert;
                        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                    } else if (config.snowBiomeTop - yOffset >= maxScreenHeight) {
                        mainContext.fillStyle = biomeColor.snow;
                        mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                    } else if (config.snowBiomeTop - yOffset >= 0) {
                        mainContext.fillStyle = biomeColor.snow;
                        mainContext.fillRect(0, 0, maxScreenWidth, config.snowBiomeTop - yOffset);
                        mainContext.fillStyle = biomeColor.grass;
                        mainContext.fillRect(0, config.snowBiomeTop - yOffset, maxScreenWidth, maxScreenHeight - (config.snowBiomeTop - yOffset));
                    } else {
                        mainContext.fillStyle = biomeColor.grass;
                        mainContext.fillRect(0, 0, maxScreenWidth, config.mapScale - config.snowBiomeTop - yOffset);
                        mainContext.fillStyle = biomeColor.desert;
                        mainContext.fillRect(0, config.mapScale - config.snowBiomeTop - yOffset, maxScreenWidth, maxScreenHeight - (config.mapScale - config.snowBiomeTop - yOffset));
                    }
                    // RENDER WATER AREAS:
                    if (!firstSetup) {
                        waterMult += waterPlus * config.waveSpeed * delta;
                        if (waterMult >= config.waveMax) {
                            waterMult = config.waveMax;
                            waterPlus = -1;
                        } else if (waterMult <= 1) {
                            waterMult = waterPlus = 1;
                        }
                        mainContext.globalAlpha = 1;
                        mainContext.fillStyle = biomeColor.desert;
                        renderWaterBodies(xOffset, yOffset, mainContext, getEl("visual").value == "me" ? 1440 : config.riverPadding);
                        mainContext.fillStyle = biomeColor.river;
                        renderWaterBodies(xOffset, yOffset, mainContext, (waterMult - 1) * 250);
                    }
                    // RENDER GRID:
                    if (getEl("visual").value != "cele" && getEl("visual").value != "zeph") {
                        mainContext.lineWidth = getEl("visual").value == "me" ? 3 : 4;
                        mainContext.strokeStyle = "#000";
                        mainContext.globalAlpha = getEl("visual").value == "me" ? 0.05 : 0.06;
                        mainContext.beginPath();
                        let ratfrr = (getEl("visual").value == "me" ? 120 : getEl("visual").value == "spyder" ? 100 : getEl("visual").value == "zyenith" ? 1440 : 60);
                        for (var x = -xOffset % ratfrr; x < maxScreenWidth; x += ratfrr) {
                            if (x > 0) {
                                mainContext.moveTo(x, 0);
                                mainContext.lineTo(x, maxScreenHeight);
                            }
                        }
                        for (var y = -yOffset % ratfrr; y < maxScreenHeight; y += ratfrr) {
                            if (y > 0) {
                                mainContext.moveTo(0, y);
                                mainContext.lineTo(maxScreenWidth, y);
                            }
                        }
                        mainContext.stroke();
                    }
                    // RENDER BOTTOM LAYER:
                    mainContext.globalAlpha = 1;
                    mainContext.strokeStyle = outlineColor;
                    renderGameObjects(-1, xOffset, yOffset);
                    // RENDER PROJECTILES:
                    mainContext.globalAlpha = 1;
                    mainContext.lineWidth = outlineWidth;
                    renderProjectiles(0, xOffset, yOffset);
                    // RENDER PLAYERS:
                    renderPlayers(xOffset, yOffset, 0);
                    // RENDER AI:
                    mainContext.globalAlpha = 1;
                    for (var i = 0; i < ais.length; ++i) {
                        tmpObj = ais[i];
                        if (tmpObj.active && tmpObj.visible) {
                            tmpObj.animate(delta);
                            mainContext.save();
                            mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                            mainContext.rotate(tmpObj.dir + tmpObj.dirPlus - Math.PI / 2);
                            renderAI(tmpObj, mainContext);
                            mainContext.restore();
                        }
                    }
                    // RENDER GAME OBJECTS (LAYERED):
                    renderGameObjects(0, xOffset, yOffset);
                    renderProjectiles(1, xOffset, yOffset);
                    renderGameObjects(1, xOffset, yOffset);
                    renderPlayers(xOffset, yOffset, 1);
                    renderGameObjects(2, xOffset, yOffset);
                    renderGameObjects(3, xOffset, yOffset);
                    // MAP BOUNDARIES:
                    mainContext.fillStyle = "#000";
                    mainContext.globalAlpha = 0.09;
                    if (xOffset <= 0) {
                        mainContext.fillRect(0, 0, -xOffset, maxScreenHeight);
                    }
                    if (config.mapScale - xOffset <= maxScreenWidth) {
                        var tmpY = Math.max(0, -yOffset);
                        mainContext.fillRect(config.mapScale - xOffset, tmpY, maxScreenWidth - (config.mapScale - xOffset), maxScreenHeight - tmpY);
                    }
                    if (yOffset <= 0) {
                        mainContext.fillRect(-xOffset, 0, maxScreenWidth + xOffset, -yOffset);
                    }
                    if (config.mapScale - yOffset <= maxScreenHeight) {
                        var tmpX = Math.max(0, -xOffset);
                        var tmpMin = 0;
                        if (config.mapScale - xOffset <= maxScreenWidth)
                            tmpMin = maxScreenWidth - (config.mapScale - xOffset);
                        mainContext.fillRect(tmpX, config.mapScale - yOffset, maxScreenWidth - tmpX - tmpMin, maxScreenHeight - (config.mapScale - yOffset));
                    }
                    // RENDER DAY/NIGHT TIME:
                    mainContext.globalAlpha = 1;
                    mainContext.fillStyle = "rgba(0, 0, 70, 0.35)";
                    mainContext.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                    // RENDER PLAYER AND AI UI / PLAYERINFOS:
                    mainContext.strokeStyle = darkOutlineColor;
                    players.forEach((tmp)=>{
                        tmpObj = tmp;
                        if (tmpObj.visible) {
                            // NAME AND HEALTH:
                            if (tmpObj.skinIndex != 10 || tmpObj == player || (tmpObj.team && tmpObj.team == player.team)) {
                                mainContext.strokeStyle = darkOutlineColor;
                                mainContext.globalAlpha = 1;
                                let checkName = streamerMode ? tmpObj == player ? "unknown" : tmpObj.name : tmpObj.name;
                                var tmpText = getEl("visual").value == "me" ? (tmpObj.team ? "[" + tmpObj.team + "] " : "") + ("[" + tmpObj.sid + "] ") + (checkName || "") : getEl("visual").value == "spyder" ? (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (" [" + Math.floor(tmpObj.health) + "/100] {" + tmpObj.sid + "} ") + (checkName || "") + (" <" + tmpObj.shameCount + ">") : getEl("visual").value == "lore" ? (tmpObj.team ? "[" + tmpObj.team + "] " : "") + ("{" + tmpObj.sid + "} ") + (checkName || "") : getEl("visual").value == "cele" ? (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (checkName || "") + (" {" + tmpObj.shameCount + "}") : getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (tmpObj != player ? "[" + tmpObj.primaryIndex + "/" + tmpObj.secondaryIndex + "/" + tmpObj.healSid + "] " : "") + (checkName || "") : (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (checkName || "");
                                if (tmpText != "") {
                                    mainContext.font = (tmpObj.nameScale || 30) + "px Hammersmith One";
                                    mainContext.fillStyle = "#fff";
                                    mainContext.textBaseline = "middle";
                                    mainContext.textAlign = "center";
                                    mainContext.lineWidth = tmpObj.nameScale ? 11 : 8;
                                    mainContext.lineJoin = "round";
                                    mainContext.strokeText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                    mainContext.fillText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                    if (tmpObj.isLeader && iconSprites["crown"].isLoaded) {
                                        var tmpS = config.crownIconScale;
                                        var tmpX = tmpObj.x - xOffset - tmpS / 2 - mainContext.measureText(tmpText).width / 2 - config.crownPad;
                                        mainContext.drawImage(iconSprites["crown"], tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY - tmpS / 2 - 5, tmpS, tmpS);
                                    }
                                    if (tmpObj.iconIndex == 1 && iconSprites["skull"].isLoaded) {
                                        var tmpS = config.crownIconScale;
                                        var tmpX = tmpObj.x - xOffset - tmpS / 2 + mainContext.measureText(tmpText).width / 2 + config.crownPad;
                                        mainContext.drawImage(iconSprites["skull"], tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY - tmpS / 2 - 5, tmpS, tmpS);
                                    }
                                    if (instaC.wait && near.sid == tmpObj.sid && iconSprites["cross" + (tmpObj.anti ? "1" : "2")].isLoaded && getEl("visual").value != "0" && getEl("visual").value != "ae" && enemy.length) {
                                        var tmpS = near.scale * 2.2;
                                        mainContext.drawImage(iconSprites["cross" + (tmpObj.anti ? "1" : "2")], near.x - xOffset - tmpS / 2, near.y - yOffset - tmpS / 2, tmpS, tmpS);
                                    }
                                }
                                if ((getEl("visual").value == "ae" ? tmpObj == player ? true : tmpObj.hitted : true) && tmpObj.health > 0) {
                                    // HEALTH HOLDER:
                                    var tmpWidth = config.healthBarWidth;
                                    mainContext.fillStyle = darkOutlineColor;
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY, config.healthBarWidth * 2 + config.healthBarPad * 2, 17, 8);
                                    mainContext.fill();
                                    // HEALTH BAR:
                                    mainContext.fillStyle = isTeam(tmpObj) ? "#8ecc51" : "#cc5151";
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY + config.healthBarPad, config.healthBarWidth * 2 * (tmpObj.health / tmpObj.maxHealth), 17 - config.healthBarPad * 2, 7);
                                    mainContext.fill();
                                }
                                //wasd
                                if (getEl("visual").value != "0" && getEl("visual").value != "ae") {
                                    if (getEl("visual").value != "zeph" && !getEl("visual").value != "hans") {
                                        mainContext.font = "20px Hammersmith One";
                                        mainContext.fillStyle = "#fff";
                                        mainContext.textBaseline = "middle";
                                        mainContext.textAlign = "center";
                                        mainContext.lineWidth = getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? tmpObj.scale / 10 : tmpObj.nameScale ? 11 : 8;
                                        mainContext.lineJoin = "round";
                                        if (tmpObj == player) {
                                            if (getEl("visual").value == "me") {
                                                mainContext.strokeText("[" + [tmpObj.projDist, tmpObj.turretReloaded].join("/") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                                mainContext.fillText("[" + [tmpObj.projDist, tmpObj.turretReloaded].join("/") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            } else if (getEl("visual").value == "fz") {
                                                let statusss = !isNaN(maxPing) ? [maxPing, window.pingTime, minPing] : ["n", "a"];
                                                mainContext.strokeText("[" + tmpObj.turretReloaded + "," + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                                mainContext.fillText("[" + tmpObj.turretReloaded + "," + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            } else if (getEl("visual").value == "zyenith") {
                                                let statusss = [`${antiSync ? "true" : "false"}`, maxPing, minPing];
                                                mainContext.strokeText("[" + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 3);
                                                mainContext.fillText("[" + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 3);
                                            }
                                        } else {
                                            if (getEl("visual").value == "me") {
                                                mainContext.strokeText("[" + [tmpObj.healSid, tmpObj.instaThreat].join("/") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                                mainContext.fillText("[" + [tmpObj.healSid, tmpObj.instaThreat].join("/") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            } else if (getEl("visual").value == "zyenith") {
                                                // @zyenith !send method 40 Wealthy 69
                                                let statusss = [tmpObj.maxShame, 0, 0];
                                                mainContext.strokeText("[" + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                                mainContext.fillText("[" + statusss.join(",") + "]", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13.5 * 2);
                                            }
                                        }
                                    }
                                    if (getEl("visual").value == "spyder") {
                                        mainContext.strokeText(tmpObj.reloads[53] == 0 ? "true" : "false", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 30);
                                        mainContext.fillText(tmpObj.reloads[53] == 0 ? "true" : "false", tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 30);
                                    } else if (getEl("visual").value == "lore") {
                                        mainContext.strokeText(tmpObj.shameCount, tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 30);
                                        mainContext.fillText(tmpObj.shameCount, tmpObj.x - xOffset, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 30);
                                    }
                                    if (getEl("visual").value != "0" && getEl("visual").value != "zeph") {
                                        if (getEl("visual").value == "me" || getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                                            mainContext.font = (tmpObj.nameScale || 30) + "px Hammersmith One";
                                            mainContext.fillStyle = getEl("visual").value == "fz" || getEl("visual").value == "zyenith" ? "#ff0000" : tmpObj.shameCount < tmpObj.dangerShame ? "#e6e6fa" : "#cc5151";
                                            mainContext.textBaseline = "middle";
                                            mainContext.textAlign = "center";
                                            mainContext.lineWidth = tmpObj.nameScale ? 11 : 8;
                                            mainContext.lineJoin = "round";
                                            var tmpS = config.crownIconScale;
                                            var tmpX = tmpObj.x - xOffset - tmpS / 2 + mainContext.measureText(tmpText).width / 2 + config.crownPad + (tmpObj.iconIndex == 1 ? (tmpObj.nameScale || 30) * 2.75 : tmpObj.nameScale || 30);
                                            mainContext.strokeText(tmpObj.shameCount, tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                            mainContext.fillText(tmpObj.shameCount, tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                        }
                                        if (getEl("visual").value == "hans" ? tmpObj == player : true) {
                                            let PAD = getEl("visual").value == "hans" ? 2.75 : 0;
                                            let tmpX = getEl("visual").value == "hans" ? -1 : 0;
                                            let BAR = config.healthBarWidth - PAD;
                                            let tmpReloads = {
                                                primary: getEl("visual").value == "spyder" || getEl("visual").value == "hans" ? tmpObj.oldReloads[tmpObj.primaryIndex] - (tmpObj.oldReloads[tmpObj.primaryIndex] - tmpObj.reloads[tmpObj.primaryIndex]) * tmpObj.rt : tmpObj.reloads[tmpObj.primaryIndex],
                                                secondary: getEl("visual").value == "spyder" || getEl("visual").value == "hans" ? tmpObj.oldReloads[tmpObj.secondaryIndex] - (tmpObj.oldReloads[tmpObj.secondaryIndex] - tmpObj.reloads[tmpObj.secondaryIndex]) * tmpObj.rt : tmpObj.reloads[tmpObj.secondaryIndex],
                                            };
                                            // SECONDARY RELOAD HOLDER:
                                            var tmpWidth = config.healthBarWidth;
                                            mainContext.fillStyle = darkOutlineColor;
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad + 50 + PAD, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13 + tmpX, BAR + config.healthBarPad * 2, 17, 8);
                                            mainContext.fill();
                                            // SECONDARY RELOAD BAR:
                                            if (getEl("visual").value == "spyder") {
                                                mainContext.fillStyle = tmpObj.secondaryIndex == undefined || tmpObj.reloads[tmpObj.secondaryIndex] == 0 ? "#cba24f" : "#f4d393";
                                            } else if (getEl("visual").value == "lore") {
                                                mainContext.fillStyle = "#fff066";
                                            } else if (getEl("visual").value == "me") {
                                                mainContext.fillStyle = isTeam(tmpObj) ? tmpObj.secondaryIndex == undefined || tmpObj.reloads[tmpObj.secondaryIndex] == 0 ? "#8ecc51" : `hsl(${50 * Math.ceil(tmpObj.reloads[tmpObj.secondaryIndex] / 100)}, 50%, 60%)` : "#cc5151";
                                            } else if (getEl("visual").value == "cele") {
                                                mainContext.fillStyle = "#b0c4de";
                                            } else if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                                                mainContext.fillStyle = tmpObj.secondaryIndex == undefined || tmpObj.reloads[tmpObj.secondaryIndex] == 0 ? "#ffff00" : `hsl(${50 * Math.ceil(tmpObj.reloads[tmpObj.secondaryIndex] / 100)}, 50%, 60%)`;
                                            } else if (getEl("visual").value == "hans") {
                                                mainContext.fillStyle = tmpObj.secondaryIndex == undefined || tmpObj.reloads[tmpObj.secondaryIndex] == 0 ? "#8f8366" : `hsl(90, 55%, 56%)`;
                                            }
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth + 50 + PAD, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13 + config.healthBarPad + tmpX, BAR * (tmpObj.reloads[tmpObj.secondaryIndex] == undefined ? 1 : (items.weapons[tmpObj.secondaryIndex].speed - tmpReloads.secondary) / items.weapons[tmpObj.secondaryIndex].speed), (getEl("visual").value == "spyder" ? 16 : 17) - config.healthBarPad * 2, 7);
                                            mainContext.fill();
                                            // PRIMARY RELOAD HOLDER:
                                            var tmpWidth = config.healthBarWidth;
                                            mainContext.fillStyle = darkOutlineColor;
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13 + tmpX, BAR + config.healthBarPad * 2, 17, 8);
                                            mainContext.fill();
                                            // PRIMARY RELOAD BAR:
                                            if (getEl("visual").value == "spyder") {
                                                mainContext.fillStyle = tmpObj.primaryIndex == undefined || tmpObj.reloads[tmpObj.primaryIndex] == 0 ? "#cba24f" : "#f4d393";
                                            } else if (getEl("visual").value == "lore") {
                                                mainContext.fillStyle = "#fff066";
                                            } else if (getEl("visual").value == "me") {
                                                mainContext.fillStyle = isTeam(tmpObj) ? tmpObj.primaryIndex == undefined || tmpObj.reloads[tmpObj.primaryIndex] == 0 ? "#8ecc51" : `hsl(${50 * Math.ceil(tmpObj.reloads[tmpObj.primaryIndex] / 100)}, 50%, 60%)` : "#cc5151";
                                            } else if (getEl("visual").value == "cele") {
                                                mainContext.fillStyle = "#b0c4de";
                                            } else if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                                                mainContext.fillStyle = tmpObj.primaryIndex == undefined || tmpObj.reloads[tmpObj.primaryIndex] == 0 ? "#ffff00" : `hsl(${50 * Math.ceil(tmpObj.reloads[tmpObj.primaryIndex] / 100)}, 50%, 60%)`;
                                            } else if (getEl("visual").value == "hans") {
                                                mainContext.fillStyle = tmpObj.primaryIndex == undefined || tmpObj.reloads[tmpObj.primaryIndex] == 0 ? "#8f8366" : `hsl(90, 55%, 56%)`;
                                            }
                                            mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13 + config.healthBarPad + tmpX, BAR * (tmpObj.reloads[tmpObj.primaryIndex] == undefined ? 1 : (items.weapons[tmpObj.primaryIndex].speed - tmpReloads.primary) / items.weapons[tmpObj.primaryIndex].speed), (getEl("visual").value == "spyder" ? 16 : 17) - config.healthBarPad * 2, 7);
                                            mainContext.fill();
                                            if (tmpObj == player && getEl("visual").value == "zyenith") {
                                                // TURRET RELOAD HOLDER:
                                                var tmpWidth = config.healthBarWidth;
                                                mainContext.fillStyle = darkOutlineColor;
                                                mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13, config.healthBarWidth * 2 + config.healthBarPad * 2, 17, 8);
                                                mainContext.fill();
                                                // TURRET RELOAD BAR:
                                                mainContext.fillStyle = "#96963c";
                                                mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY + 13 + config.healthBarPad, config.healthBarWidth * 2 * (tmpObj.reloads[53] == undefined ? 1 : (2500 - tmpObj.reloads[53]) / 2500), 17 - config.healthBarPad * 2, 7);
                                                mainContext.fill();
                                            }
                                        }
                                    }
                                }
                            }
                        } else {}
                        if (player) {
                            if (getEl("visual").value == "me" && !isTeam(tmpObj)) {
                                let dist = UTILS.getDist(tmpObj, player, 0, 0);
                                if (dist > 600) {
                                    if (!tmpObj.notHere) {
                                        let tracerSize = tmpObj.scale * 2;
                                        let maxmin = function(fr, XorY) {
                                            return Math.max(-(fr - tracerSize), Math.min(fr - tracerSize, XorY));
                                        };
                                        let fixXY = {
                                            x: player.x - xOffset + maxmin(maxScreenWidth / 2, tmpObj.x - xOffset - (player.x - xOffset)),
                                            y: player.y - yOffset + maxmin(maxScreenHeight / 2, tmpObj.y - yOffset - (player.y - yOffset)),
                                        };
                                        let rad = UTILS.getDirect(tmpObj, player, 0, 0);
                                        mainContext.save();
                                        mainContext.translate(fixXY.x, fixXY.y);
                                        mainContext.rotate(rad + Math.PI / 2);
                                        mainContext.fillStyle = darkOutlineColor;
                                        mainContext.globalAlpha = 0.6;
                                        renderTriangle2(tracerSize, mainContext);
                                        mainContext.restore();
                                    }
                                } else {
                                    if (!tmpObj.visible) {
                                        tmpObj.notHere = true;
                                    } else {
                                        tmpObj.notHere = false;
                                    }
                                }
                            }
                        }
                    }
                                   );
                    ais.forEach((tmp)=>{
                        tmpObj = tmp;
                        if (tmpObj.visible) {
                            // NAME AND HEALTH:
                            if (tmpObj.skinIndex != 10 || tmpObj == player || (tmpObj.team && tmpObj.team == player.team)) {
                                mainContext.strokeStyle = darkOutlineColor;
                                mainContext.globalAlpha = 1;
                                var tmpText = getEl("visual").value == "me" ? "[TeamAnimal] " + (tmpObj.name || "") : getEl("visual").value == "spyder" ? tmpObj.name || "" : getEl("visual").value == "lore" ? "{" + tmpObj.sid + "} " + (tmpObj.name || "") : getEl("visual").value == "cele" ? tmpObj.name || "" : tmpObj.name || "";
                                if (tmpText != "") {
                                    mainContext.font = (tmpObj.nameScale || 30) + "px Hammersmith One";
                                    mainContext.fillStyle = "#fff";
                                    mainContext.textBaseline = "middle";
                                    mainContext.textAlign = "center";
                                    mainContext.lineWidth = tmpObj.nameScale ? 11 : 8;
                                    mainContext.lineJoin = "round";
                                    mainContext.strokeText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                    mainContext.fillText(tmpText, tmpObj.x - xOffset, tmpObj.y - yOffset - tmpObj.scale - config.nameY);
                                    if (getEl("visual").value == "me" && (tmpObj.name == "MOOSTAFA" || tmpObj.name == "MOOFIE") && iconSprites[tmpObj.name == "MOOFIE" ? "skull" : "crown"].isLoaded) {
                                        var tmpS = config.crownIconScale;
                                        var tmpX = tmpObj.x - xOffset - tmpS / 2 - mainContext.measureText(tmpText).width / 2 - config.crownPad;
                                        mainContext.drawImage(iconSprites[tmpObj.name == "MOOFIE" ? "skull" : "crown"], tmpX, tmpObj.y - yOffset - tmpObj.scale - config.nameY - tmpS / 2 - 5, tmpS, tmpS);
                                    }
                                }
                                if (tmpObj.health > 0) {
                                    // HEALTH HOLDER:
                                    var tmpWidth = config.healthBarWidth;
                                    mainContext.fillStyle = darkOutlineColor;
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY, config.healthBarWidth * 2 + config.healthBarPad * 2, 17, 8);
                                    mainContext.fill();
                                    // HEALTH BAR:
                                    mainContext.fillStyle = "#cc5151";
                                    mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY + config.healthBarPad, config.healthBarWidth * 2 * (tmpObj.health / tmpObj.maxHealth), 17 - config.healthBarPad * 2, 7);
                                    mainContext.fill();
                                    if (tmpObj.name == "MOOSTAFA") {
                                        // MOOSTAFA RELOAD HOLDER:
                                        var tmpWidth = config.healthBarWidth;
                                        mainContext.fillStyle = darkOutlineColor;
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13, config.healthBarWidth + config.healthBarPad * 2, 17, 8);
                                        mainContext.fill();
                                        // MOOSTAFA RELOAD BAR:
                                        mainContext.fillStyle = outlineColor;
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth, tmpObj.y - yOffset + tmpObj.scale + config.nameY - 13 + config.healthBarPad, config.healthBarWidth * ((600 - tmpObj.weaponReload) / 600), 17 - config.healthBarPad * 2, 7);
                                        mainContext.fill();
                                    }
                                }
                            }
                        }
                    }
                               );
                    // RENDER OBJECT HEALTH:
                    if (getEl("bh").checked) {
                        gameObjects.forEach((tmp)=>{
                            tmpObj = tmp;
                            if (tmpObj.active && tmpObj.buildHealth) {
                                if (player) {
                                    if (UTILS.getDist(tmpObj, player, 0, 0) <= 360) {
                                        // HEALTH HOLDER:
                                        var tmpWidth = config.healthBarWidth;
                                        mainContext.fillStyle = darkOutlineColor;
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth / 2 - config.healthBarPad, tmpObj.y - yOffset - config.healthBarPad, config.healthBarWidth + config.healthBarPad * 2, 17, 8);
                                        mainContext.fill();
                                        // HEALTH BAR:
                                        mainContext.fillStyle = player.sid != tmpObj.owner.sid && !findAllianceBySid(tmpObj.owner.sid) ? "#cc5151" : "#5f9ea0";
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth / 2, tmpObj.y - yOffset, config.healthBarWidth * (tmpObj.buildHealth / tmpObj.health), 17 - config.healthBarPad * 2, 7);
                                        mainContext.fill();
                                    }
                                    if (UTILS.getDist(tmpObj, player, 0, 0) <= 720 && tmpObj.doUpdate) {
                                        // RELOAD HOLDER:
                                        var tmpWidth = config.healthBarWidth;
                                        mainContext.fillStyle = darkOutlineColor;
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth / 2 - config.healthBarPad, tmpObj.y - yOffset - config.healthBarPad + 13, config.healthBarWidth + config.healthBarPad * 2, 17, 8);
                                        mainContext.fill();
                                        // RELOAD BAR:
                                        mainContext.fillStyle = "#a5974c";
                                        mainContext.roundRect(tmpObj.x - xOffset - config.healthBarWidth / 2, tmpObj.y - yOffset + 13, config.healthBarWidth * ((2200 - tmpObj.shootReload) / 2200), 17 - config.healthBarPad * 2, 7);
                                        mainContext.fill();
                                    }
                                }
                            }
                        }
                                           );
                    }
                    // RENDER ANIM TEXTS:
                    textManager.update(delta, mainContext, xOffset, yOffset);
                    // RENDER CHAT MESSAGES:
                    players.forEach((tmp)=>{
                        tmpObj = tmp;
                        if (tmpObj.visible && tmpObj.chatCountdown > 0) {
                            tmpObj.chatCountdown = Math.max(0, (tmpObj.chatCountdown -= delta));
                            mainContext.font = "32px Hammersmith One";
                            var tmpSize = mainContext.measureText(tmpObj.chatMessage);
                            mainContext.textBaseline = "middle";
                            mainContext.textAlign = "center";
                            var tmpX = tmpObj.x - xOffset;
                            var tmpY = tmpObj.y - tmpObj.scale - yOffset - 90;
                            var tmpH = 47;
                            var tmpW = tmpSize.width + 17;
                            mainContext.fillStyle = "rgba(0,0,0,0.2)";
                            mainContext.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                            mainContext.fill();
                            mainContext.fillStyle = "#fff";
                            mainContext.fillText(tmpObj.chatMessage, tmpX, tmpY);
                        }
                    }
                                   );
                }
                // RENDER MINIMAP:
                renderMinimap(delta);
                // RENDER CONTROLS:
                if (controllingTouch.id !== -1) {
                    renderControl(controllingTouch.startX, controllingTouch.startY, controllingTouch.currentX, controllingTouch.currentY);
                }
                if (attackingTouch.id !== -1) {
                    renderControl(attackingTouch.startX, attackingTouch.startY, attackingTouch.currentX, attackingTouch.currentY);
                }
                if (mainContext && (getEl("darkmode").checked || getEl("visual").value == "hans")) {
                    mainContext.beginPath();
                    let screenW = maxScreenWidth / 2;
                    let screenH = maxScreenHeight / 2;
                    let gradient = mainContext.createRadialGradient(screenW, screenH, 0, screenW, screenH, getEl("visual").value == "hans" ? maxScreenWidth : maxScreenHeight);
                    for (let i = 0; i <= 1; i++) {
                        gradient.addColorStop(i, "rgba(0, 0, 0, " + i + ")");
                    }
                    mainContext.fillStyle = gradient;
                    mainContext.rect(0, 0, maxScreenWidth, maxScreenHeight);
                    mainContext.fill();
                }
            }
            // RENDER CONTROL:
            function renderControl(startX, startY, currentX, currentY) {
                mainContext.save();
                mainContext.setTransform(1, 0, 0, 1, 0, 0);
                // mainContext.resetTransform();
                mainContext.scale(pixelDensity, pixelDensity);
                var controlRadius = 50;
                mainContext.beginPath();
                mainContext.arc(startX, startY, controlRadius, 0, Math.PI * 2, false);
                mainContext.closePath();
                mainContext.fillStyle = "rgba(255, 255, 255, 0.3)";
                mainContext.fill();
                var controlRadius = 50;
                var offsetX = currentX - startX;
                var offsetY = currentY - startY;
                var mag = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2));
                var divisor = mag > controlRadius ? mag / controlRadius : 1;
                offsetX /= divisor;
                offsetY /= divisor;
                mainContext.beginPath();
                mainContext.arc(startX + offsetX, startY + offsetY, controlRadius * 0.5, 0, Math.PI * 2, false);
                mainContext.closePath();
                mainContext.fillStyle = "white";
                mainContext.fill();
                mainContext.restore();
            }
            // RENDER PROJECTILES:
            function renderProjectiles(layer, xOffset, yOffset) {
                for (var i = 0; i < projectiles.length; ++i) {
                    tmpObj = projectiles[i];
                    if (tmpObj.active && tmpObj.layer == layer) {
                        tmpObj.update(delta);
                        if (tmpObj.active && isOnScreen(tmpObj.x - xOffset, tmpObj.y - yOffset, tmpObj.scale)) {
                            mainContext.save();
                            mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                            mainContext.rotate(tmpObj.dir);
                            renderProjectile(0, 0, tmpObj, mainContext, 1);
                            mainContext.restore();
                        }
                    }
                }
            }
            // RENDER PROJECTILE:
            var projectileSprites = {};

            function renderProjectile(x, y, obj, ctxt, debug) {
                if (obj.src) {
                    var tmpSrc = items.projectiles[obj.indx].src;
                    var tmpSprite = projectileSprites[tmpSrc];
                    if (!tmpSprite) {
                        tmpSprite = new Image();
                        tmpSprite.onload = function() {
                            this.isLoaded = true;
                        }
                        ;
                        tmpSprite.src = ".././img/weapons/" + tmpSrc + ".png";
                        projectileSprites[tmpSrc] = tmpSprite;
                    }
                    if (tmpSprite.isLoaded)
                        ctxt.drawImage(tmpSprite, x - obj.scale / 2, y - obj.scale / 2, obj.scale, obj.scale);
                } else if (obj.indx == 1) {
                    ctxt.fillStyle = "#939393";
                    renderCircle(x, y, obj.scale, ctxt);
                }
            }
            // RENDER WATER BODIES:
            function renderWaterBodies(xOffset, yOffset, ctxt, padding) {
                // MIDDLE RIVER:
                var tmpW = config.riverWidth + padding;
                var tmpY = config.mapScale / 2 - yOffset - tmpW / 2;
                if (tmpY < maxScreenHeight && tmpY + tmpW > 0) {
                    ctxt.fillRect(0, tmpY, maxScreenWidth, tmpW);
                }
            }
            // RENDER GAME OBJECTS:
            function renderGameObjects(layer, xOffset, yOffset) {
                var tmpSprite, tmpX, tmpY;
                gameObjects.forEach((tmp)=>{
                    tmpObj = tmp;
                    if (tmpObj.active) {
                        tmpX = tmpObj.x + tmpObj.xWiggle - xOffset;
                        tmpY = tmpObj.y + tmpObj.yWiggle - yOffset;
                        if (layer == 0) {
                            tmpObj.update(delta);
                        }
                        if (tmpObj.layer == layer && isOnScreen(tmpX, tmpY, tmpObj.scale + (tmpObj.blocker || 0))) {
                            if (getEl("darkmode").checked) {
                                let camXY = {
                                    x: camX,
                                    y: camY,
                                };
                                mainContext.globalAlpha = tmpObj.hideFromEnemy ? 0.6 : Math.max(0, Math.min(1, (720 - UTILS.getDist(tmpObj, camXY, 0, 0)) / 240));
                            } else {
                                mainContext.globalAlpha = tmpObj.hideFromEnemy ? 0.6 : 1;
                            }
                            if (tmpObj.isItem) {
                                if ((tmpObj.dmg || tmpObj.trap) && getEl("visual").value != "0" && getEl("visual").value != "ae" && player && player.sid != tmpObj.owner.sid && !findAllianceBySid(tmpObj.owner.sid)) {
                                    tmpSprite = getObjSprite(tmpObj);
                                } else {
                                    tmpSprite = getItemSprite(tmpObj);
                                }
                                mainContext.save();
                                mainContext.translate(tmpX, tmpY);
                                if ((getEl("visual").value != "cele" && getEl("visual").value != "ae") || tmpObj.doUpdate) {
                                    mainContext.rotate(tmpObj.dir);
                                }
                                mainContext.drawImage(tmpSprite, -(tmpSprite.width / 2), -(tmpSprite.height / 2));
                                if (tmpObj.blocker) {
                                    mainContext.strokeStyle = "#db6e6e";
                                    mainContext.globalAlpha = 0.3;
                                    mainContext.lineWidth = 6;
                                    renderCircle(0, 0, tmpObj.blocker, mainContext, false, true);
                                }
                                mainContext.restore();
                            } else {
                                tmpSprite = getResSprite(tmpObj);
                                mainContext.drawImage(tmpSprite, tmpX - tmpSprite.width / 2, tmpY - tmpSprite.height / 2);
                            }
                        }
                    }
                }
                                   );
            }
            // GATHER ANIMATION:
            let hittedObj = [];
            let hittedObj2 = [];

            function objHitC(dmg, index) {
                return new Promise((resolve,reject)=>{
                    resolve({
                        dmg: dmg,
                        index: index
                    });
                }
                                  );
            }

            function gatherAnimation(sid, didHit, index) {
                tmpObj = findPlayerBySID(sid);
                if (tmpObj) {
                    tmpObj.startAnim(didHit, index);
                    tmpObj.gatherIndex = index;
                    tmpObj.gathering = 1;
                    if (didHit) {
                        tmpObj.doTickUpdate = true;
                        let camper = tmpObj;
                        let lolnoob = hittedObj;
                        hittedObj = [];
                        doNextTick(()=>{
                            let cope = items.weapons[index];
                            let getgood = config.weaponVariants[camper.primaryVariant == undefined ? 0 : camper.primaryVariant].val;
                            let ratio = cope.sDmg || 1;
                            let damagedHeart = cope.dmg * getgood * ratio * (camper.skinIndex == 40 ? 3.3 : 1);
                            lolnoob.forEach((urbad)=>{
                                urbad.buildHealth -= damagedHeart;
                            }
                                           );
                        }
                                  );
                    }
                }
            }
            // RENDER PLAYERS:
            function renderPlayers(xOffset, yOffset, zIndex) {
                mainContext.globalAlpha = 1;
                for (var i = 0; i < players.length; ++i) {
                    tmpObj = players[i];
                    if (tmpObj.zIndex == zIndex) {
                        tmpObj.animate(delta);
                        if (tmpObj.visible) {
                            tmpObj.skinRot += 0.002 * delta;
                            tmpDir = (tmpObj == player && !(getEl("visual").value == "me" || getEl("visual").value == "spyder" || getEl("visual").value == "ae") ? getEl("visual").value == "lore" || getEl("visual").value == "zeph" || getEl("visual").value == "fz" ? getAttackDir() : getSafeDir() : tmpObj.dir) + tmpObj.dirPlus;
                            mainContext.save();
                            mainContext.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                            // RENDER PLAYER:
                            mainContext.rotate(tmpDir);
                            renderPlayer(tmpObj, mainContext);
                            mainContext.restore();
                            /*if (tmpObj) {

                                            mainContext.rotate(0);
                                            let X = {
                                                one: tmpObj.x - 12,
                                                two: tmpObj.x + 12
                                            }
                                            let Y = tmpObj.y - 3.5;

                                            // EYE:
                                            mainContext.save();
                                            mainContext.fillStyle = "#000";
                                            renderCircle2(X.one - xOffset, Y - yOffset, 8, mainContext, true, false);
                                            renderCircle2(X.two - xOffset, Y - yOffset, 8, mainContext, true, false);

                                            mainContext.fillStyle = "#fff";
                                            let maxmin = function(fr, XorY) {
                                                return Math.max(-(fr - 4), Math.min((fr - 4), XorY));
                                            }
                                            renderCircle2(X.one - xOffset, Y - yOffset, 4, mainContext, true, false);
                                            renderCircle2(X.two - xOffset, Y - yOffset, 4, mainContext, true, false);
                                            mainContext.restore();

                                        }*/
                        }
                    }
                }
            }
            // RENDER PLAYER:
            function renderPlayer(obj, ctxt) {
                ctxt = ctxt || mainContext;
                ctxt.lineWidth = outlineWidth;
                ctxt.lineJoin = "miter";
                var handAngle = (Math.PI / 4) * (items.weapons[obj.weaponIndex].armS || 1);
                var oHandAngle = obj.buildIndex < 0 ? items.weapons[obj.weaponIndex].hndS || 1 : 1;
                var oHandDist = obj.buildIndex < 0 ? items.weapons[obj.weaponIndex].hndD || 1 : 1;
                // TAIL/CAPE:
                if (obj.tailIndex > 0) {
                    renderTail(obj.tailIndex, ctxt, obj);
                }
                /*if (getEl("darkmode").checked) {
                          mainContext.shadowColor = "rgba(0, 0, 0, 0.35)";
                          mainContext.shadowOffsetX = 10;
                          mainContext.shadowOffsetY = 10;
                          mainContext.shadowBlur = 7.5;
                      }*/
                // WEAPON BELLOW HANDS:
                if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
                    renderTool(items.weapons[(getEl("kmtexture").checked && obj.weaponIndex == 3 && obj.secondaryIndex == 15) ? 4 : obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                    if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                        renderProjectile(obj.scale, 0, items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                    }
                }
                // HANDS:
                ctxt.fillStyle = config.skinColors[obj.skinColor];
                renderCircle(obj.scale * Math.cos(handAngle), obj.scale * Math.sin(handAngle), 14);
                renderCircle(obj.scale * oHandDist * Math.cos(-handAngle * oHandAngle), obj.scale * oHandDist * Math.sin(-handAngle * oHandAngle), 14);
                // WEAPON ABOVE HANDS:
                if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
                    renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                    if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                        renderProjectile(obj.scale, 0, items.projectiles[items.weapons[obj.weaponIndex].projectile], mainContext);
                    }
                }
                // BUILD ITEM:
                if (obj.buildIndex >= 0) {
                    var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
                    ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
                }
                /*if (getEl("darkmode").checked) {
                          mainContext.shadowColor = 0;
                          mainContext.shadowOffsetX = 0;
                          mainContext.shadowOffsetY = 0;
                          mainContext.shadowBlur = 0;
                      }*/
                // BODY:
                renderCircle(0, 0, obj.scale, ctxt);
                // SKIN:
                if (obj.skinIndex > 0) {
                    ctxt.rotate(Math.PI / 2);
                    renderSkin(obj.skinIndex, ctxt, null, obj);
                }
            }
            // RENDER SKINS:
            var skinSprites = {};
            var skinPointers = {};
            var tmpSkin;

            function renderSkin(index, ctxt, parentSkin, owner) {
                tmpSkin = skinSprites[index];
                if (!tmpSkin) {
                    var tmpImage = new Image();
                    tmpImage.onload = function() {
                        this.isLoaded = true;
                        this.onload = null;
                    }
                    ;
                    tmpImage.src = ".././img/hats/hat_" + index + ".png";
                    skinSprites[index] = tmpImage;
                    tmpSkin = tmpImage;
                }
                var tmpObj = parentSkin || skinPointers[index];
                if (!tmpObj) {
                    for (var i = 0; i < hats.length; ++i) {
                        if (hats[i].id == index) {
                            tmpObj = hats[i];
                            break;
                        }
                    }
                    skinPointers[index] = tmpObj;
                }
                if (tmpSkin.isLoaded)
                    ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale);
                if (!parentSkin && tmpObj.topSprite) {
                    ctxt.save();
                    ctxt.rotate(owner.skinRot);
                    renderSkin(index + "_top", ctxt, tmpObj, owner);
                    ctxt.restore();
                }
            }
            // RENDER TAIL:
            var accessSprites = {};
            var accessPointers = {};

            function renderTail(index, ctxt, owner) {
                tmpSkin = accessSprites[index];
                if (!tmpSkin) {
                    var tmpImage = new Image();
                    tmpImage.onload = function() {
                        this.isLoaded = true;
                        this.onload = null;
                    }
                    ;
                    tmpImage.src = ".././img/accessories/access_" + index + ".png";
                    accessSprites[index] = tmpImage;
                    tmpSkin = tmpImage;
                }
                var tmpObj = accessPointers[index];
                if (!tmpObj) {
                    for (var i = 0; i < accessories.length; ++i) {
                        if (accessories[i].id == index) {
                            tmpObj = accessories[i];
                            break;
                        }
                    }
                    accessPointers[index] = tmpObj;
                }
                if (tmpSkin.isLoaded) {
                    ctxt.save();
                    ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
                    if (tmpObj.spin) ctxt.rotate(owner.skinRot);
                    ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
                    ctxt.restore();
                }
            }
            // RENDER TOOL:
            var toolSprites = {};

            function renderTool(obj, variant, x, y, ctxt) {
                var tmpSrc = obj.src + (variant || "");
                var tmpSprite = toolSprites[tmpSrc];
                if (!tmpSprite) {
                    tmpSprite = new Image();
                    tmpSprite.onload = function() {
                        this.isLoaded = true;
                    }
                    ;
                    tmpSprite.src = ".././img/weapons/" + tmpSrc + ".png";
                    toolSprites[tmpSrc] = tmpSprite;
                }
                if (tmpSprite.isLoaded)
                    ctxt.drawImage(tmpSprite, x + obj.xOff - obj.length / 2, y + obj.yOff - obj.width / 2, obj.length, obj.width);
            }
            // RENDER GAME OBJECTS:
            var gameObjectSprites = {};

            function getResSprite(obj) {
                var biomeID = obj.y >= config.mapScale - config.snowBiomeTop ? 2 : obj.y <= config.snowBiomeTop ? 1 : 0;
                var tmpIndex = obj.type + "_" + obj.scale + "_" + biomeID;
                var tmpSprite = gameObjectSprites[tmpIndex];
                if (!tmpSprite) {
                    var tmpCanvas = document.createElement("canvas");
                    tmpCanvas.width = tmpCanvas.height = obj.scale * 2.1 + outlineWidth;
                    var tmpContext = tmpCanvas.getContext("2d");
                    tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                    tmpContext.rotate(UTILS.randFloat(0, Math.PI));
                    tmpContext.strokeStyle = outlineColor;
                    tmpContext.lineWidth = outlineWidth;
                    let colors = [["#b1d959", "#95b946"], ["#bade6e", "#aac76b"], ["#a7d544", "#86a63f"], ["#b4db62", "#9ebf57"], ];
                    let select = colors[Math.floor(Math.random() * colors.length)];
                    if (obj.type == 0) {
                        var tmpScale;
                        for (var i = 0; i < 2; ++i) {
                            tmpScale = tmpObj.scale * (!i ? 1 : 0.5);
                            renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                            tmpContext.fillStyle = !biomeID ? !i ? select[1] : select[0] : !i ? "#e3f1f4" : "#fff";
                            tmpContext.fill();
                            if (!i)
                                tmpContext.stroke();
                        }
                    } else if (obj.type == 1) {
                        if (biomeID == 2) {
                            tmpContext.fillStyle = "#606060";
                            renderStar(tmpContext, 6, obj.scale * 0.3, obj.scale * 0.71);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = "#89a54c";
                            renderCircle(0, 0, obj.scale * 0.55, tmpContext);
                            tmpContext.fillStyle = "#a5c65b";
                            renderCircle(0, 0, obj.scale * 0.3, tmpContext, true);
                        } else {
                            renderBlob(tmpContext, 6, tmpObj.scale, tmpObj.scale * 0.7);
                            tmpContext.fillStyle = biomeID ? "#e3f1f4" : "#89a54c";
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpContext.fillStyle = biomeID ? "#6a64af" : "#c15555";
                            var tmpRange;
                            var berries = 4;
                            var rotVal = mathPI2 / berries;
                            for (var i = 0; i < berries; ++i) {
                                tmpRange = UTILS.randInt(tmpObj.scale / 3.5, tmpObj.scale / 2.3);
                                renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i), UTILS.randInt(10, 12), tmpContext);
                            }
                        }
                    } else if (obj.type == 2 || obj.type == 3) {
                        tmpContext.fillStyle = obj.type == 2 ? biomeID == 2 ? "#938d77" : "#939393" : "#e0c655";
                        renderStar(tmpContext, 3, obj.scale, obj.scale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = obj.type == 2 ? biomeID == 2 ? "#b2ab90" : "#bcbcbc" : "#ebdca3";
                        renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                        tmpContext.fill();
                    }
                    tmpSprite = tmpCanvas;
                    gameObjectSprites[tmpIndex] = tmpSprite;
                }
                return tmpSprite;
            }
            // GET ITEM SPRITE:
            var itemSprites = [];

            function getItemSprite(obj, asIcon) {
                var tmpSprite = itemSprites[obj.id];
                if (!tmpSprite || asIcon) {
                    var tmpCanvas = document.createElement("canvas");
                    tmpCanvas.width = tmpCanvas.height = obj.scale * 2.5 + outlineWidth + (items.list[obj.id].spritePadding || 0);
                    var tmpContext = tmpCanvas.getContext("2d");
                    tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                    tmpContext.rotate(asIcon ? 0 : Math.PI / 2);
                    tmpContext.strokeStyle = outlineColor;
                    tmpContext.lineWidth = outlineWidth * (asIcon ? tmpCanvas.width / 81 : 1);
                    if (obj.name == "apple") {
                        tmpContext.fillStyle = "#c15555";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#89a54c";
                        var leafDir = -(Math.PI / 2);
                        renderLeaf(obj.scale * Math.cos(leafDir), obj.scale * Math.sin(leafDir), 25, leafDir + Math.PI / 2, tmpContext);
                    } else if (obj.name == "cookie") {
                        tmpContext.fillStyle = "#cca861";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#937c4b";
                        var chips = 4;
                        var rotVal = mathPI2 / chips;
                        var tmpRange;
                        for (var i = 0; i < chips; ++i) {
                            tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i), UTILS.randInt(4, 5), tmpContext, true);
                        }
                    } else if (obj.name == "cheese") {
                        tmpContext.fillStyle = "#f4f3ac";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#c3c28b";
                        var chips = 4;
                        var rotVal = mathPI2 / chips;
                        var tmpRange;
                        for (var i = 0; i < chips; ++i) {
                            tmpRange = UTILS.randInt(obj.scale / 2.5, obj.scale / 1.7);
                            renderCircle(tmpRange * Math.cos(rotVal * i), tmpRange * Math.sin(rotVal * i), UTILS.randInt(4, 5), tmpContext, true);
                        }
                    } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                        tmpContext.fillStyle = obj.name == "castle wall" ? "#83898e" : obj.name == "wood wall" ? "#a5974c" : "#939393";
                        var sides = obj.name == "castle wall" ? 4 : 3;
                        renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = obj.name == "castle wall" ? "#9da4aa" : obj.name == "wood wall" ? "#c9b758" : "#bcbcbc";
                        renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                        tmpContext.fillStyle = obj.name == "poison spikes" ? "#7b935d" : "#939393";
                        var tmpScale = obj.scale * 0.6;
                        renderStar(tmpContext, obj.name == "spikes" ? 5 : 6, obj.scale, tmpScale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, tmpScale, tmpContext);
                        tmpContext.fillStyle = "#c9b758";
                        renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                    } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fillStyle = "#c9b758";
                        renderRectCircle(0, 0, obj.scale * 1.5, 29, 4, tmpContext);
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale * 0.5, tmpContext);
                    } else if (obj.name == "mine") {
                        tmpContext.fillStyle = "#939393";
                        renderStar(tmpContext, 3, obj.scale, obj.scale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#bcbcbc";
                        renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "sapling") {
                        for (var i = 0; i < 2; ++i) {
                            var tmpScale = obj.scale * (!i ? 1 : 0.5);
                            renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                            tmpContext.fillStyle = !i ? "#9ebf57" : "#b4db62";
                            tmpContext.fill();
                            if (!i)
                                tmpContext.stroke();
                        }
                    } else if (obj.name == "pit trap") {
                        tmpContext.fillStyle = "#a5974c";
                        renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = outlineColor;
                        renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    } else if (obj.name == "boost pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#dbd97d";
                        renderTriangle(obj.scale * 1, tmpContext);
                    } else if (obj.name == "turret") {
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#939393";
                        var tmpLen = 50;
                        renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                    } else if (obj.name == "platform") {
                        tmpContext.fillStyle = "#cebd5f";
                        var tmpCount = 4;
                        var tmpS = obj.scale * 2;
                        var tmpW = tmpS / tmpCount;
                        var tmpX = -(obj.scale / 2);
                        for (var i = 0; i < tmpCount; ++i) {
                            renderRect(tmpX - tmpW / 2, 0, tmpW, obj.scale * 2, tmpContext);
                            tmpContext.fill();
                            tmpContext.stroke();
                            tmpX += tmpS / tmpCount;
                        }
                    } else if (obj.name == "healing pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "spawn pad") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#71aad6";
                        renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                    } else if (obj.name == "blocker") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#db6e6e";
                        renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                    } else if (obj.name == "teleporter") {
                        tmpContext.fillStyle = "#7e7f82";
                        renderCircle(0, 0, obj.scale, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.rotate(Math.PI / 4);
                        tmpContext.fillStyle = "#d76edb";
                        renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                    }
                    tmpSprite = tmpCanvas;
                    if (!asIcon)
                        itemSprites[obj.id] = tmpSprite;
                }
                return tmpSprite;
            }
            var objSprites = [];

            function getObjSprite(obj) {
                var tmpSprite = objSprites[obj.id];
                if (!tmpSprite) {
                    var tmpCanvas = document.createElement("canvas");
                    tmpCanvas.width = tmpCanvas.height = obj.scale * 2.5 + outlineWidth + (items.list[obj.id].spritePadding || 0);
                    var tmpContext = tmpCanvas.getContext("2d");
                    tmpContext.translate(tmpCanvas.width / 2, tmpCanvas.height / 2);
                    tmpContext.rotate(Math.PI / 2);
                    tmpContext.strokeStyle = outlineColor;
                    tmpContext.lineWidth = outlineWidth;
                    if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" || obj.name == "spinning spikes") {
                        tmpContext.fillStyle = obj.name == "poison spikes" ? "#7b935d" : "#939393";
                        var tmpScale = obj.scale * 0.6;
                        renderStar(tmpContext, obj.name == "spikes" ? 5 : 6, obj.scale, tmpScale);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#a5974c";
                        renderCircle(0, 0, tmpScale, tmpContext);
                        tmpContext.fillStyle = "#cc5151";
                        renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                    } else if (obj.name == "pit trap") {
                        tmpContext.fillStyle = "#a5974c";
                        renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#cc5151";
                        renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                        tmpContext.fill();
                    }
                    tmpSprite = tmpCanvas;
                    objSprites[obj.id] = tmpSprite;
                }
                return tmpSprite;
            }
            // RENDER LEAF:
            function renderLeaf(x, y, l, r, ctxt) {
                var endX = x + l * Math.cos(r);
                var endY = y + l * Math.sin(r);
                var width = l * 0.4;
                ctxt.moveTo(x, y);
                ctxt.beginPath();
                ctxt.quadraticCurveTo((x + endX) / 2 + width * Math.cos(r + Math.PI / 2), (y + endY) / 2 + width * Math.sin(r + Math.PI / 2), endX, endY);
                ctxt.quadraticCurveTo((x + endX) / 2 - width * Math.cos(r + Math.PI / 2), (y + endY) / 2 - width * Math.sin(r + Math.PI / 2), x, y);
                ctxt.closePath();
                ctxt.fill();
                ctxt.stroke();
            }
            // RENDER CIRCLE:
            function renderCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
                tmpContext = tmpContext || mainContext;
                tmpContext.beginPath();
                tmpContext.arc(x, y, scale, 0, 2 * Math.PI);
                if (!dontFill)
                    tmpContext.fill();
                if (!dontStroke)
                    tmpContext.stroke();
            }

            function renderCircle2(x, y, scale, tmpContext, dontStroke, dontFill) {
                tmpContext = tmpContext || mainContext;
                tmpContext.beginPath();
                tmpContext.ellipse(x, y, scale * 1.5, scale, Math.PI / 2, 0, Math.PI * 2);
                if (!dontFill)
                    tmpContext.fill();
                if (!dontStroke)
                    (tmpContext.lineWidth = 3.5),
                        tmpContext.stroke();
            }
            // RENDER STAR SHAPE:
            function renderStar(ctxt, spikes, outer, inner) {
                var rot = (Math.PI / 2) * 3;
                var x, y;
                var step = Math.PI / spikes;
                ctxt.beginPath();
                ctxt.moveTo(0, -outer);
                for (var i = 0; i < spikes; i++) {
                    x = Math.cos(rot) * outer;
                    y = Math.sin(rot) * outer;
                    ctxt.lineTo(x, y);
                    rot += step;
                    x = Math.cos(rot) * inner;
                    y = Math.sin(rot) * inner;
                    ctxt.lineTo(x, y);
                    rot += step;
                }
                ctxt.lineTo(0, -outer);
                ctxt.closePath();
            }
            // RENDER RECTANGLE:
            function renderRect(x, y, w, h, ctxt, stroke) {
                ctxt.fillRect(x - w / 2, y - h / 2, w, h);
                if (!stroke)
                    ctxt.strokeRect(x - w / 2, y - h / 2, w, h);
            }
            // RENDER RECTCIRCLE:
            function renderRectCircle(x, y, s, sw, seg, ctxt, stroke) {
                ctxt.save();
                ctxt.translate(x, y);
                seg = Math.ceil(seg / 2);
                for (var i = 0; i < seg; i++) {
                    renderRect(0, 0, s * 2, sw, ctxt, stroke);
                    ctxt.rotate(Math.PI / seg);
                }
                ctxt.restore();
            }
            // RENDER BLOB:
            function renderBlob(ctxt, spikes, outer, inner) {
                var rot = (Math.PI / 2) * 3;
                var x, y;
                var step = Math.PI / spikes;
                var tmpOuter;
                ctxt.beginPath();
                ctxt.moveTo(0, -inner);
                for (var i = 0; i < spikes; i++) {
                    tmpOuter = UTILS.randInt(outer + 0.9, outer * 1.2);
                    ctxt.quadraticCurveTo(Math.cos(rot + step) * tmpOuter, Math.sin(rot + step) * tmpOuter, Math.cos(rot + step * 2) * inner, Math.sin(rot + step * 2) * inner);
                    rot += step * 2;
                }
                ctxt.lineTo(0, -inner);
                ctxt.closePath();
            }
            // RENDER TRIANGLE:
            function renderTriangle(s, ctx) {
                ctx = ctx || mainContext;
                var h = s * (Math.sqrt(3) / 2);
                ctx.beginPath();
                ctx.moveTo(0, -h / 2);
                ctx.lineTo(-s / 2, h / 2);
                ctx.lineTo(s / 2, h / 2);
                ctx.lineTo(0, -h / 2);
                ctx.fill();
                ctx.closePath();
            }

            function renderTriangle2(s, ctx) {
                ctx = ctx || mainContext;
                var h = s * (Math.sqrt(3) / 2);
                ctx.beginPath();
                ctx.moveTo(0, -h / 3.5);
                ctx.lineTo(-s / 2, h / 2);
                ctx.lineTo(s / 2, h / 2);
                ctx.lineTo(0, -h / 3.5);
                ctx.fill();
                ctx.closePath();
                ctx.stroke();
            }

            function renderTriangle3(s, ctx) {
                ctx = ctx || mainContext;
                var h = s * (Math.sqrt(3) / 2);
                ctx.beginPath();
                ctx.moveTo(0, -h / 2);
                ctx.lineTo(-s / 1.5, h / 1.5);
                ctx.lineTo(s / 1.5, h / 1.5);
                ctx.lineTo(0, -h / 2);
                ctx.fill();
                ctx.closePath();
            }

            // PREPARE MENU BACKGROUND:
            function prepareMenuBackground() {
                var tmpMid = config.mapScale / 2;
                objectManager.add(0, tmpMid, tmpMid + 200, 0, config.treeScales[3], 0);
                objectManager.add(1, tmpMid, tmpMid - 480, 0, config.treeScales[3], 0);
                objectManager.add(2, tmpMid + 300, tmpMid + 450, 0, config.treeScales[3], 0);
                objectManager.add(3, tmpMid - 950, tmpMid - 130, 0, config.treeScales[2], 0);
                objectManager.add(4, tmpMid - 750, tmpMid - 400, 0, config.treeScales[3], 0);
                objectManager.add(5, tmpMid - 700, tmpMid + 400, 0, config.treeScales[2], 0);
                objectManager.add(6, tmpMid + 800, tmpMid - 200, 0, config.treeScales[3], 0);
                objectManager.add(7, tmpMid - 260, tmpMid + 340, 0, config.bushScales[3], 1);
                objectManager.add(8, tmpMid + 760, tmpMid + 310, 0, config.bushScales[3], 1);
                objectManager.add(9, tmpMid - 800, tmpMid + 100, 0, config.bushScales[3], 1);
                objectManager.add(10, tmpMid - 800, tmpMid + 300, 0, items.list[4].scale, items.list[4].id, items.list[10]);
                objectManager.add(11, tmpMid + 650, tmpMid - 390, 0, items.list[4].scale, items.list[4].id, items.list[10]);
                objectManager.add(12, tmpMid - 400, tmpMid - 450, 0, config.rockScales[2], 2);
            }
            // CREATE FAKE OBJECTS:
            function makeFakeObjects() {
                return;
                for (let i = 0; i < 500; i++) {
                    let randomXY = {
                        x: Math.floor(Math.random() * 14400),
                        y: Math.floor(Math.random() * 14400),
                    };
                    let rT = Math.floor(Math.random() * 4);
                    objectManager.add(i, randomXY.x, randomXY.y, 0, (rT == 0 ? config.treeScales : rT == 1 ? config.bushScales : rT >= 2 && config.rockScales)[Math.florr(Math.random() * (rT == 0 ? 4 : 3))], rT);
                }
            }
            // ANTI TRAP:
            let earlyAutoBreak = {
                start: false
            };

            function antiTrap(aim) {
                if (near.dist2 <= 250) {
                    for (let i = -45; i <= 45; i += 90) {
                        checkPlace(2, aim + UTILS.toRad(i) + Math.PI);
                    }
                } else if (near.dist2 <= 600) {
                    for (let i = -45; i <= 45; i += 90) {
                        if (enemy.length) {
                            checkPlace(4, aim + UTILS.toRad(i) + Math.PI);
                        }
                    }
                }
            }
            // LOAD GAME OBJECT:
            let myTeles = [];

            function loadGameObject(data) {
                for (var i = 0; i < data.length; ) {
                    objectManager.add(data[i], data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], items.list[data[i + 6]], true, data[i + 7] >= 0 ? {
                        sid: data[i + 7]
                    } : null);
                    let XY = {
                        x: data[i + 1],
                        y: data[i + 2],
                    };
                    let dist = UTILS.getDist(XY, player, 0, 2);
                    let aim = UTILS.getDirect(XY, player, 0, 2);
                    if (data[i + 6] == 22 && player.sid == data[i + 7]) {
                        myTeles.push({
                            x: data[i + 1],
                            y: data[i + 2]
                        });
                        setTimeout(()=>{
                            myTeles.shift();
                        }
                                   , 30000);
                    }
                    if (getEl("earlyab").checked) {
                        if (data[i + 6] == 15 && dist <= 100 && player.sid != data[i + 7] && !findAllianceBySid(data[i + 7])) {
                            setTimeout(()=>{
                                dist = UTILS.getDist(XY, player, 0, 2);
                                aim = UTILS.getDirect(XY, player, 0, 2);
                                traps.in = true;
                                traps.aim = aim;
                                if (!earlyAutoBreak.start) {
                                    earlyAutoBreak.start = true;
                                    earlyAutoBreak.hit = 0;
                                    earlyAutoBreak.miss = 0;
                                }
                                if (dist <= 75) {
                                    earlyAutoBreak.hit++;
                                } else {
                                    earlyAutoBreak.miss++;
                                }
                            }
                                       , parseInt(getEl("earlytime").value));
                        }
                    }
                    setTickout(()=>{
                        dist = UTILS.getDist(XY, player, 0, 2);
                        aim = UTILS.getDirect(XY, player, 0, 2);
                        if (data[i + 6] == 15 && dist <= 100 && player.sid != data[i + 7] && !findAllianceBySid(data[i + 7])) {
                            antiTrap(aim);
                        }
                    }
                               , 1);
                    i += 8;
                }
            }
            // WIGGLE GAME OBJECT:
            let ticktickticky = [];

            function antiSyncHealing(timearg) {
                antiSync = true;
                let healAnti = setInterval(()=>{
                    if (player.shameCount < 5) {
                        place(0, getAttackDir());
                    }
                }
                                           , 75);
                setTimeout(()=>{
                    clearInterval(healAnti);
                    setTimeout(()=>{
                        antiSync = false;
                    }, config.tickRate);
                }
                           , config.tickRate * timearg);
            }
            function wiggleGameObject(dir, sid) {
                tmpObj = findObjectBySid(sid);
                if (tmpObj) {
                    tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir);
                    tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir);
                    if (tmpObj.buildHealth) {
                        hittedObj.push(tmpObj);
                        //                    hittedObj2.push(tmpObj);
                    }
                }
            }
            // SHOOT TURRET:
            function shootTurret(sid, dir) {
                tmpObj = findObjectBySid(sid);
                if (tmpObj) {
                    tmpObj.dir = dir;
                    tmpObj.xWiggle += config.gatherWiggle * Math.cos(dir + Math.PI);
                    tmpObj.yWiggle += config.gatherWiggle * Math.sin(dir + Math.PI);
                    tmpObj.shootted = 1;
                }
            }
            // ADD PROJECTILE:
            let doSync = false;
            let antiSync = false;
            let runAtNextTick = [];
            let rangeBackup = [];

            function addProjectile(x, y, dir, range, speed, indx, layer, sid) {
                if (inWindow) {
                    projectileManager.addProjectile(x, y, dir, range, speed, indx, null, null, layer).sid = sid;
                }
                runAtNextTick.push(Array.prototype.slice.call(arguments));
            }

            function checkProjectileHolder(x, y, dir, range, speed, indx, layer, sid) {
                let weaponIndx = indx == 0 ? 9 : indx == 2 ? 12 : indx == 3 ? 13 : indx == 5 && 15;
                let projOffset = config.playerScale * 2;
                let projXY = {
                    x: indx == 1 ? x : x - projOffset * Math.cos(dir),
                    y: indx == 1 ? y : y - projOffset * Math.sin(dir),
                };
                let fixXY = function(tmpObj) {
                    return {
                        x2: UTILS.fixTo(tmpObj.x2, 2),
                        y2: UTILS.fixTo(tmpObj.y2, 2),
                    };
                };
                let nearPlayer = players.filter((e)=>e.visible && UTILS.getDist(projXY, e, 0, 2) <= e.scale).sort(function(a, b) {
                    return (UTILS.getDist(projXY, a, 0, 2) - UTILS.getDist(projXY, b, 0, 2));
                })[0];
                if (nearPlayer) {
                    nearPlayer.projDist = UTILS.getDist(projXY, nearPlayer, 0, 2);
                    if (indx == 1) {
                        nearPlayer.shooting[53] = 1;
                    } else {
                        nearPlayer.shootIndex = weaponIndx;
                        nearPlayer.shooting[1] = 1;
                        antiBulletSupportmentsEasyGamer69Proe(nearPlayer, dir, range, speed, indx, weaponIndx);
                    }
                }
            }
            let projectileCount = 0;

            function antiBulletSupportmentsEasyGamer69Proe(tmpObj, dir, range, speed, index, weaponIndex) {
                if (!isTeam(tmpObj)) {
                    tmpDir = UTILS.getDirect(player, tmpObj, 2, 2);
                    if (UTILS.getAngleDist(tmpDir, dir) <= 0.2) {
                        tmpObj.bowThreat[weaponIndex]++;
                        if (index == 5) {
                            projectileCount++;
                        }
                        setTimeout(()=>{
                            tmpObj.bowThreat[weaponIndex]--;
                            if (index == 5) {
                                projectileCount--;
                            }
                        }, range / speed);
                        if (tmpObj.bowThreat[9] >= 1 && (tmpObj.bowThreat[12] >= 1 || tmpObj.bowThreat[15] >= 1)) {
                            place(1, tmpObj.aim2);
                            if (getEl("antirange").checked && !antiSync) {
                                anti0Tick = 4;
                                antiSyncHealing(4);
                            }
                        } else {
                            if (projectileCount >= 2) {
                                place(1, tmpObj.aim2);
                                anti0Tick = 4;
                                if (getEl("antisync").checked && !antiSync) {
                                    antiSyncHealing(4);
                                }
                            }
                        }
                    }
                }
            }
            // REMOVE PROJECTILE:
            function remProjectile(sid, range) {
                for (var i = 0; i < projectiles.length; ++i) {
                    if (projectiles[i].sid == sid) {
                        projectiles[i].range = range;
                        let tmpObjects = hittedObj;
                        let aaaaaaaaaaaaaa = projectiles[i].dmg;
                        hittedObj = [];
                        doNextTick(()=>{
                            tmpObjects.forEach((tmp)=>{
                                if (tmp.projDmg) {
                                    tmp.buildHealth -= aaaaaaaaaaaaaa;
                                }
                            }
                                              );
                        }
                                  );
                    }
                }
            }
            // ANIMATE AI:
            function animateAI(sid) {
                tmpObj = findAIBySID(sid);
                if (tmpObj) {
                    tmpObj.startAnim();
                    tmpObj.weaponHitted = 1;
                    tmpObj.doTickUpdate = true;
                    let tmpObjects = hittedObj;
                    hittedObj = [];
                    doNextTick(()=>{
                        tmpObjects.forEach((tmp)=>{
                            tmp.buildHealth -= 232;
                        }
                                          );
                    }
                              );
                }
            }
            // ADD AI:
            function loadAI(data) {
                for (var i = 0; i < ais.length; ++i) {
                    ais[i].forcePos = !ais[i].visible;
                    ais[i].visible = false;
                }
                if (data) {
                    var tmpTime = Date.now();
                    for (var i = 0; i < data.length; ) {
                        tmpObj = findAIBySID(data[i]);
                        if (tmpObj) {
                            tmpObj.index = data[i + 1];
                            tmpObj.t1 = tmpObj.t2 === undefined ? tmpTime : tmpObj.t2;
                            tmpObj.t2 = tmpTime;
                            tmpObj.x1 = tmpObj.x;
                            tmpObj.y1 = tmpObj.y;
                            tmpObj.x2 = data[i + 2];
                            tmpObj.y2 = data[i + 3];
                            tmpObj.d1 = tmpObj.d2 === undefined ? data[i + 4] : tmpObj.d2;
                            tmpObj.d2 = data[i + 4];
                            tmpObj.health = data[i + 5];
                            tmpObj.dt = 0;
                            tmpObj.visible = true;
                            if (tmpObj.name == "MOOSTAFA") {
                                if (tmpObj.doTickUpdate) {
                                    tmpObj.doTickUpdate = false;
                                }
                                if (tmpObj.weaponHitted) {
                                    tmpObj.weaponHitted = false;
                                    tmpObj.weaponReload = 600;
                                } else {
                                    tmpObj.weaponReload = Math.max(0, tmpObj.weaponReload - config.tickRate);
                                }
                            }
                        } else {
                            tmpObj = aiManager.spawn(data[i + 2], data[i + 3], data[i + 4], data[i + 1]);
                            tmpObj.x2 = tmpObj.x;
                            tmpObj.y2 = tmpObj.y;
                            tmpObj.d2 = tmpObj.dir;
                            tmpObj.health = data[i + 5];
                            if (!aiManager.aiTypes[data[i + 1]].name)
                                tmpObj.name = config.cowNames[data[i + 6]];
                            tmpObj.forcePos = true;
                            tmpObj.sid = data[i];
                            tmpObj.visible = true;
                        }
                        i += 7;
                    }
                }
            }
            // RENDER AI:
            var aiSprites = {};

            function renderAI(obj, ctxt) {
                var tmpIndx = obj.index;
                var tmpSprite = aiSprites[tmpIndx];
                if (!tmpSprite) {
                    var tmpImg = new Image();
                    tmpImg.onload = function() {
                        this.isLoaded = true;
                        this.onload = null;
                    }
                    ;
                    tmpImg.src = ".././img/animals/" + obj.src + ".png";
                    tmpSprite = tmpImg;
                    aiSprites[tmpIndx] = tmpSprite;
                }
                if (tmpSprite.isLoaded) {
                    var tmpScale = obj.scale * 1.2 * (obj.spriteMlt || 1);
                    ctxt.drawImage(tmpSprite, -tmpScale, -tmpScale, tmpScale * 2, tmpScale * 2);
                }
            }
            // OBJECT ON SCREEN:
            function isOnScreen(x, y, s) {
                return (x + s >= 0 && x - s <= maxScreenWidth && y + s >= 0 && (y,
                                                                                s,
                                                                                maxScreenHeight));
            }
            // FUNCTIONS:
            let configs = {
                weaponCode: 0,
                antiBull: 0,
                antiBull2: 0,
                waitHit: false,
            };

            function place(id, radian) {
                try {
                    var item = items.list[player.items[id]];
                    if (player.itemCounts[item.group.id] == undefined ? true : player.itemCounts[item.group.id] < (config.isSandbox ? 99 : item.group.limit ? item.group.limit : 99)) {
                        selectToBuild(player.items[id]);
                        sendAtck(1, radian);
                        selectWeapon(configs.weaponCode, true);
                    }
                } catch (e) {}
            }

            function checkPlace(id, radian) {
                try {
                    var item = items.list[player.items[id]];
                    var tmpS = player.scale + item.scale + (item.placeOffset || 0);
                    var tmpX = player.x2 + tmpS * Math.cos(radian);
                    var tmpY = player.y2 + tmpS * Math.sin(radian);
                    if (objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, player)) {
                        if (player.itemCounts[item.group.id] == undefined ? true : player.itemCounts[item.group.id] < (config.isSandbox ? 99 : item.group.limit ? item.group.limit : 99)) {
                            selectToBuild(player.items[id]);
                            sendAtck(1, radian);
                            selectWeapon(configs.weaponCode, true);
                        }
                    }
                } catch (e) {}
            }
            // ADD NEW PLAYER:
            function addPlayer(data, isYou) {
                var tmpPlayer = findPlayerByID(data[0]);
                if (!tmpPlayer) {
                    tmpPlayer = new Player(data[0],data[1],config,UTILS,projectileManager,objectManager,players,ais,items,hats,accessories);
                    players.push(tmpPlayer);
                }
                tmpPlayer.spawn(isYou ? moofoll : null);
                tmpPlayer.visible = false;
                tmpPlayer.x2 = undefined;
                tmpPlayer.y2 = undefined;
                tmpPlayer.x3 = undefined;
                tmpPlayer.y3 = undefined;
                tmpPlayer.setData(data);
                if (isYou) {
                    player = tmpPlayer;
                    camX = player.x;
                    camY = player.y;
                    updateItems();
                    updateStatusDisplay();
                    updateAge();
                    updateUpgrades(0);
                    gameUI.style.display = "block";
                    updateItemCountHTML();
                    if (getEl("tryhard").checked) {
                        textManager.showText(player.x, player.y, 50, 0.5, 500, "Ping: " + window.pingTime, "#fff");
                    }
                    getEl("priXP").innerHTML = "Primary XP: 0 / not found";
                    getEl("secXP").innerHTML = "Secondary XP: 0 / not found";
                    setTimeout(()=>{
                        for (let i = 0; i < healthBased(); i++) {
                            place(0, getAttackDir());
                        }
                    }, 200);
                }
            }
            // REMOVE PLAYER:
            function removePlayer(id) {
                for (var i = 0; i < players.length; i++) {
                    if (players[i].id == id) {
                        if (getEl("enemyradar" + players[i].sid)) {
                            getEl("enemyradar" + players[i].sid).remove();
                        }
                        players.splice(i, 1);
                        break;
                    }
                }
            }
            // UPDATE PLAYER ITEM VALUES:
            let isItemSetted = [];

            function updateItemCountHTML(index=undefined) {
                for (let i = 0; i < items.list.length; ++i) {
                    let id = items.list[i].group.id;
                    let tmpI = items.weapons.length + i;
                    if (!isItemSetted[tmpI]) {
                        isItemSetted[tmpI] = document.createElement("div");
                        isItemSetted[tmpI].id = "itemCount" + tmpI;
                        getEl("actionBarItem" + tmpI).appendChild(isItemSetted[tmpI]);
                        isItemSetted[tmpI].style = `
                    display: block;
                    position: absolute;
                    padding-left: 5px;
                    font-size: 2em;
                    color: #fff;
                    `;
                        if (i < 3) {
                            isItemSetted[tmpI].innerHTML = Math.floor(player.food / items.list[i].req[1]);
                        } else {
                            isItemSetted[tmpI].innerHTML = player.itemCounts[id] || 0;
                        }
                    } else {
                        if (index == id) {
                            isItemSetted[tmpI].innerHTML = player.itemCounts[index] || 0;
                        }
                        if (index == undefined) {
                            if (i < 3) {
                                isItemSetted[tmpI].innerHTML = Math.floor(player.food / items.list[i].req[1]);
                            }
                        }
                    }
                    if (getEl("visual").value == "0" || getEl("visual").value == "ae") {
                        if (isItemSetted[tmpI].style.display == "block") {
                            isItemSetted[tmpI].style.display = "none";
                        }
                    } else {
                        if (isItemSetted[tmpI].style.display == "none") {
                            isItemSetted[tmpI].style.display = "block";
                        }
                    }
                }
            }

            function updateItemCounts(index, value) {
                if (player) {
                    player.itemCounts[index] = value;
                    updateItemCountHTML(index);
                }
            }
            // UPDATE PLAYER VALUE:
            function updatePlayerValue(index, value, updateView) {
                if (player) {
                    player[index] = value;
                    if (index == "food") {
                        for (let i = 0; i < 3; i++) {
                            let tmpI = items.weapons.length + i;
                            getEl("itemCount" + tmpI).innerHTML = Math.floor(player.food / items.list[i].req[1]);
                        }
                    }
                    if (index == "food" || index == "wood" || index == "stone") {
                        let XP = value - parseFloat(getEl(index + "Display").innerText);
                        if (XP > 0) {
                            doNextTick(()=>{
                                player.addWeaponXP(XP);
                            }
                                      );
                        }
                    }
                    if (updateView)
                        updateStatusDisplay();
                }
            }
            // ADVANCED:
            function applCxC(value) {
                if (player.health == 100)
                    return 0;
                if (player.skinIndex != 45 && player.skinIndex != 56) {
                    return Math.ceil(value / items.list[player.items[0]].healing);
                }
                return 0;
            }
            function healthBased() {
                if (player.health == 100)
                    return 0;
                if (player.skinIndex != 45 && player.skinIndex != 56) {
                    return Math.ceil((100 - player.health) / items.list[player.items[0]].healing);
                }
                return 0;
            }

            function calcDmg(value) {
                return value * player.skinIndex == 6 ? 0.75 : 1;
            }
            // LATER:
            function predictHeal() {}
            // UPDATE HEALTH:
            let healType = undefined;
            let guessEmpAnti = false;
            let doEmpAntiInsta = false;
            let judgeAtNextTick = false;
            let nearSpike = [];

            function Si(sid, value) {
                tmpObj = findPlayerBySID(sid);
                if (tmpObj) {
                    let tmpHealth = tmpObj.health;
                    tmpObj.health = value;
                    if (tmpHealth < tmpObj.health) {
                        if (tmpObj.hitTime) {
                            let timeSinceHit = Date.now() - tmpObj.hitTime;
                            let tmpShame = tmpObj.shameCount;
                            let tickiy = ticks.time.filter(e => e == "lag");
                            let pingSince = Math.max(120, window.pingTime);
                            tmpObj.hitTime = 0;
                            if (timeSinceHit <= (tickiy.length >= 2 ? 120 : 120)) {
                                tmpObj.shameCount += 1;
                                if (instaC.isTrue) {
                                    tmpObj.healSid = Math.min(3, tmpObj.healSid + 1);
                                }
                                if (tmpObj.shameCount > tmpObj.maxShame) {
                                    tmpObj.maxShame = tmpObj.shameCount;
                                }
                            } else {
                                tmpObj.shameCount = Math.max(0, tmpObj.shameCount - 2);
                                if (instaC.isTrue) {
                                    tmpObj.healSid = Math.max(-1, tmpObj.healSid - 1);
                                }
                            }
                            if (tmpObj != player) {
                                if (tmpShame < tmpObj.shameCount) {//                                tmpObj.dangerShame = tmpObj.shameCount;
                                }
                            } else {
                                healLag = timeSinceHit - window.pingTime;
                            }
                        }
                    } else if (tmpHealth > tmpObj.health) {
                        tmpObj.hitTime = Date.now();
                        tmpObj.hitted = true;
                        tmpObj.damaged = true;
                        let damage = tmpHealth - tmpObj.health;
                        if (tmpObj.skinIndex == 7 && (damage == 5 || (tmpObj.tailIndex == 13 && damage == 2))) {
                            tmpObj.bTick = ticks.tick;
                            if (tmpObj == player) {
                                reSyncBull = false;
                            }
                        }
                        //                               console.log(damage);
                        if (tmpObj == player) {
                            if (getEl("simpleheal").checked) {
                                simpleAutoHealer(tmpObj, damage);
                            } else {
                                autoHealer(tmpObj, damage);
                            }
                        }
                    }
                }
            }

            let stopHealing = false;
            function healIntrap(tmpObj, value) {
                let pingHeal = function() {
                    return Math.max(0, 180 - window.pingTime);
                };
                let normalMS = 70;
                let goodMS = 125;
                if (true) {
                    /*if (!stopHealing) {
                    stopHealing = true;
                    setTimeout(()=> {
                        stopHealing = false;
                    }, config.tickRate * 1.5);
                    for (let i = 0; i < healthBased(); i++) {
                        place(0, getAttackDir());
                    }
                }*/
                    (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                        for (let i = 0; i < applCxC(value); i++) {
                            place(0, getAttackDir());
                        }
                    }
                                                                          , getEl("tickheal").checked ? 2 : pingHeal());
                } else {
                    (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                        for (let i = 0; i < applCxC(value); i++) {
                            place(0, getAttackDir());
                        }
                    }
                                                                          , getEl("tickheal").checked ? 2 : pingHeal());
                }
            }
            let backupAnti = [];
            let hittedTime = Date.now();

            function autoHealer(tmpObj, value) {
                let pingHeal = function() {
                    return Math.max(0, 180 - window.pingTime);
                };
                let normalMS = 70;
                let goodMS = 125;
                let antiInsta = false;
                let findAttacker = undefined;
                if (true) {
                    if (near.dist2 <= 300) {
                        if (value >= 20 && (Date.now() - hittedTime >= 180 || Date.now() - hittedTime <= 60)) {
                            if (tmpObj.shameCount < tmpObj.dangerShame) {
                                for (let i = 0; i < applCxC(value); i++) {
                                    place(0, getAttackDir());
                                }
                            } else {
                                (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                                    for (let i = 0; i < applCxC(value); i++) {
                                        place(0, getAttackDir());
                                    }
                                }
                                                                                      , getEl("tickheal").checked ? 2 : pingHeal());
                            }
                        } else {
                            if (traps.in) {
                                healIntrap(tmpObj, value);
                            } else {
                                (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                                    for (let i = 0; i < applCxC(value); i++) {
                                        place(0, getAttackDir());
                                    }
                                }
                                                                                      , getEl("tickheal").checked ? 2 : pingHeal());
                            }
                        }
                        if (player.skinIndex == 11) {
                            if (value >= 30) {
                                instaC.isCounter = true;
                            }
                        }
                        if (value >= 20) {
                            hittedTime = Date.now();
                            judgeAtNextTick = true;
                        }
                    } else {
                        if (traps.in) {
                            healIntrap(tmpObj, value);
                        } else {
                            (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                                for (let i = 0; i < applCxC(value); i++) {
                                    place(0, getAttackDir());
                                }
                            }
                                                                                  , getEl("tickheal").checked ? 2 : pingHeal());
                        }
                    }
                }
            }

            function simpleAutoHealer(tmpObj, value) {
                let pingHeal = function() {
                    return Math.max(0, 170 - window.pingTime);
                };
                let normalMS = 70;
                let goodMS = 125;
                let antiInsta = false;
                if (true) {
                    if (nears.length) {
                        if (value >= 20) {
                            judgeAtNextTick = true;
                        }
                        for (let i = 0; i < nears.length; i++) {
                            let nearEnemy = nears[i];
                            let findAttacker = [];
                            let checkAnti = value >= (tmpObj.skinIndex == 6 ? 25 : 10) && (nearEnemy.secondaryIndex == undefined || nearEnemy.primaryIndex == undefined ? true : nearEnemy.reloads[nearEnemy.primaryIndex] == 0);
                            if (checkAnti) {
                                antiInsta = true;
                            }
                        }
                        if (antiInsta) {
                            if (tmpObj.shameCount < tmpObj.dangerShame) {
                                for (let i = 0; i < applCxC(value); i++) {
                                    place(0, getAttackDir());
                                }
                            } else {
                                (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                                    for (let i = 0; i < applCxC(value); i++) {
                                        place(0, getAttackDir());
                                    }
                                }
                                                                                      , getEl("tickheal").checked ? 2 : pingHeal());
                            }
                        } else {
                            (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                                for (let i = 0; i < applCxC(value); i++) {
                                    place(0, getAttackDir());
                                }
                            }
                                                                                  , getEl("tickheal").checked ? 2 : pingHeal());
                        }
                        if (player.skinIndex == 11) {
                            if (value >= 30) {
                                instaC.isCounter = true;
                            }
                        }
                    } else {
                        (getEl("tickheal").checked ? setTickout : setTimeout)(()=>{
                            for (let i = 0; i < applCxC(value); i++) {
                                place(0, getAttackDir());
                            }
                        }
                                                                              , getEl("tickheal").checked ? 2 : pingHeal());
                    }
                }
            }
            // CALC DAMAGE:
            function checkCanInsta(nobull) {
                let totally = 0;
                if (player.alive) {
                    let primary = {
                        weapon: player.weapons[0],
                        variant: player.primaryVariant,
                        dmg: player.weapons[0] == undefined ? 0 : items.weapons[player.weapons[0]].dmg,
                    };
                    let secondary = {
                        weapon: player.weapons[1],
                        variant: player.secondaryVariant,
                        dmg: player.weapons[1] == undefined ? 0 : items.weapons[player.weapons[1]].Pdmg,
                    };
                    let bull = player.skins[7] && !nobull ? 1.5 : 1;
                    let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1;
                    if (primary.weapon != undefined && player.reloads[primary.weapon] == 0) {
                        totally += primary.dmg * pV * bull;
                    }
                    if (secondary.weapon != undefined && player.reloads[secondary.weapon] == 0) {
                        totally += secondary.dmg;
                    }
                    if (player.skins[53] && player.reloads[53] == 0 && near.skinIndex != 22) {
                        totally += 25;
                    }
                    totally *= near.skinIndex == 6 ? 0.75 : 1;
                    return totally;
                }
                return 0;
            }

            function getDamageThreat(tmpObj) {
                tmpObj.instaThreat = 0;
                if (isTeam(tmpObj)) {
                    let primary = {
                        weapon: tmpObj.primaryIndex,
                        variant: tmpObj.primaryVariant,
                        dmg: tmpObj.primaryIndex == undefined ? 45 : items.weapons[tmpObj.primaryIndex].dmg,
                    };
                    let secondary = {
                        weapon: tmpObj.secondaryIndex,
                        variant: tmpObj.secondaryVariant,
                        dmg: tmpObj.secondaryIndex == undefined ? 50 : items.weapons[tmpObj.secondaryIndex].Pdmg,
                    };
                    let bull = tmpObj.skinIndex == 7 ? 1.5 : 1;
                    let pV = primary.variant != undefined ? config.weaponVariants[primary.variant].val : 1.18;
                    if (primary.weapon != undefined && tmpObj.reloads[primary.weapon] == 0) {
                        tmpObj.instaThreat += primary.dmg * pV * bull;
                    }
                    if (secondary.weapon != undefined && tmpObj.reloads[secondary.weapon] == 0) {
                        tmpObj.instaThreat += secondary.dmg;
                    }
                    if (tmpObj.reloads[53] === 0) {
                        tmpObj.instaThreat += 25;
                    }
                    tmpObj.instaThreat *= player.skinIndex == 6 ? 0.75 : 1;
                }
            }
            let predictDamage = 0;

            function guessDamagePrediction() {
                predictDamage = 0;
                if (enemy.length) {
                    if (near.dist2 <= 300) {
                        if (configs.antiBull2 > 0 && near.skinIndex == 11) {
                            predictDamage += items.weapons[player.weapons[0]].dmg * 0.45;
                        }
                        if (configs.antiBull2 > 0 && near.tailIndex == 21) {
                            predictDamage += items.weapons[player.weapons[0]].dmg * 0.25;
                        }
                        predictDamage *= player.skinIndex == 6 ? 0.75 : 1;
                        if ((ticks.tick - player.bTick) % config.serverUpdateRate === 0 && player.shameCount > 0) {
                            predictDamage += 5;
                            if (player.tailIndex == 13) {
                                predictDamage -= 3;
                            }
                        }
                    }
                }
            }
            // RENDER TRACER / CREDIT TO NEKOSAN:
            function addUser(tmpObj) {
                let center = {
                    x: screenWidth / 2,
                    y: screenHeight / 2,
                };
                let rad = UTILS.getDirect(tmpObj, player, 2, 2)
                let alpha = Math.min(1, (UTILS.getDistance(0, 0, player.x2 - tmpObj.x2, (player.y2 - tmpObj.y2) * (16 / 9)) * 100) / (config.maxScreenHeight / 2) / center.y);
                let dist = center.y * alpha;
                let tmpX = center.x + dist * Math.cos(rad) - 20 / 2;
                let tmpY = center.y + dist * Math.sin(rad) - 20 / 2;
                if (!getEl("enemyradar" + tmpObj.sid)) {
                    let addRadar = document.createElement("div");
                    addRadar.id = "enemyradar" + tmpObj.sid;
                    document.body.append(addRadar);
                    addRadar.style = `
                display: none;
                position: absolute;
                left: 0;
                top: 0;
                color: #fff;
                width: 0;
                height: 0;
                border-style: solid;
                border-width: 10px 0 10px 20px;
                border-color: transparent transparent transparent #fff;
                `;
                }
                if (getEl("enemyradar" + tmpObj.sid)) {
                    getEl("enemyradar" + tmpObj.sid).style.left = tmpX + "px";
                    getEl("enemyradar" + tmpObj.sid).style.top = tmpY + "px";
                    getEl("enemyradar" + tmpObj.sid).style.display = !isTeam(tmpObj) ? "block" : "none";
                    getEl("enemyradar" + tmpObj.sid).style.opacity = alpha;
                    getEl("enemyradar" + tmpObj.sid).style.transform = "rotate(" + UTILS.toAng(rad) + "deg)";
                }
            }
            let enemy = [];
            let nears = [];
            let near = [];
            let millC = {
                x: undefined,
                y: undefined,
                size: function(size) {
                    return size * 1.45;
                },
                dist: function(size) {
                    return size * 1.8;
                },
                active: config.isSandbox ? true : false,
                count: 0,
            };
            function spin() {
                let random = [2, 3, 4, 5];
                setTickout(() => {
                    spinner = true;
                    setTickout(() => {
                        spinner = false;
                    }, random[Math.floor(Math.random() * (random.length + 1))]);
                }, 1);
            }
            let stopMusket = 0;
            let doAgeInsta = false;
            let instaC = {
                wait: false,
                can: false,
                isTrue: false,
                nobull: false,
                isCounter: false,
                abCount: 0,
                changeType: function(type) {
                    instaC.wait = false;
                    instaC.isTrue = true;
                    autoAim = true;
                    if (type == "rev") {
                        selectWeapon(player.weapons[1]);
                        buyEquip(53, 0);
                        buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 0 : 21, 1);
                        sendAutoGather();
                        setTickout(()=>{
                            selectWeapon(player.weapons[0]);
                            buyEquip(7, 0);
                            buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 0 : 18, 1);
                            setTickout(()=>{
                                sendAutoGather();
                                instaC.isTrue = false;
                                autoAim = false;
                                spin();
                            }, 1);
                        }, 1);
                    } else if (type == "nobull") {
                        selectWeapon(player.weapons[0]);
                        buyEquip(getEl("combat").value == "fz" ? 11 : 6, 0);
                        buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 0 : 18, 1);
                        sendAutoGather();
                        setTickout(()=>{
                            selectWeapon(player.weapons[1]);
                            buyEquip(53, 0);
                            buyEquip(getEl("combat").value == "ae" ? 11 : getEl("combat").value == "hans" ? 0 : 21, 1);
                            setTickout(()=>{
                                sendAutoGather();
                                instaC.isTrue = false;
                                autoAim = false;
                            }, 1);
                        }, 1);
                    } else if (type == "normal") {
                        selectWeapon(player.weapons[0]);
                        buyEquip(7, 0);
                        buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 0 : 18, 1);
                        sendAutoGather();
                        setTickout(()=>{
                            selectWeapon(player.weapons[1]);
                            buyEquip(53, 0);
                            buyEquip(getEl("combat").value == "ae" ? 11 : getEl("combat").value == "hans" ? 0 : 21, 1);
                            setTickout(()=>{
                                sendAutoGather();
                                instaC.isTrue = false;
                                autoAim = false;
                                spin();
                            }, 1);
                        }, 1);
                    } else {
                        setTimeout(()=>{
                            instaC.isTrue = false;
                            autoAim = false;
                        }, 50);
                    }
                },
                syncTry: function() {
                    if (player.weapons[1] == 15) {
                        instaC.isTrue = true;
                        io.send("2", near.aim2);
                        autoAim = true;
                        rangeBackup.push(near.dist2);
                        selectWeapon(player.weapons[1]);
                        buyEquip(53, 0);
                        buyEquip(0, 1);
                        sendAutoGather();
                        setTickout(() => {
                            autoAim = false;
                            instaC.isTrue = false;
                            sendAutoGather();
                        }, 2);
                    }
                },
                zeroFrame: function() {
                    if ([4, 5].includes(player.weapons[0]) && [9, 12, 13].includes(player.weapons[1])) {
                        instaC.isTrue = true;
                        autoAim = true;
                        place(4, near.aim2);
                        setTickout(() => {
                            selectWeapon(player.weapons[1]);
                            sendAutoGather();
                            buyEquip(53, 0);
                            buyEquip(0, 1);
                            io.send("33", near.aim2);
                            setTickout(() => {
                                buyEquip(7, 0);
                                selectWeapon(player.weapons[0]);
                                io.send("33", near.aim2);
                                setTickout(() => {
                                    instaC.isTrue = false;
                                    autoAim = false;
                                    io.send("33", null);
                                    io.send("33", isMoveDir);
                                    sendAutoGather();
                                    spin();
                                }, 1);
                            }, 1);
                        }, 1);
                    }
                },
                counterType: function() {
                    instaC.isTrue = true;
                    autoAim = true;
                    selectWeapon(player.weapons[0]);
                    buyEquip(7, 0);
                    buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 0 : 21, 1);
                    sendAutoGather();
                    setTickout(()=>{
                        if ((getEl("countertur").checked && player.reloads[53] == 0 && player.skins[53]) || (getEl("countersec").checked && player.reloads[player.weapons[1]] == 0 && player.weapons[1])) {
                            if (getEl("countersec").checked && player.reloads[player.weapons[1]] == 0 && player.weapons[1]) {
                                selectWeapon(player.weapons[1]);
                            }
                            if (getEl("countertur").checked && player.reloads[53] == 0 && player.skins[53]) {
                                buyEquip(53, 0);
                            } else {
                                buyEquip(6, 0);
                            }
                            buyEquip(getEl("combat").value == "ae" ? 11 : getEl("combat").value == "hans" ? 0 : 21, 1);
                            setTickout(()=>{
                                sendAutoGather();
                                instaC.isTrue = false;
                                autoAim = false;
                                spin();
                            }, 1);
                        } else {
                            sendAutoGather();
                            instaC.isTrue = false;
                            autoAim = false;
                        }
                    }, 1);
                },
                spikeTickType: function() {
                    instaC.isTrue = true;
                    autoAim = true;
                    selectWeapon(player.weapons[0]);
                    buyEquip(7, 0);
                    buyEquip(getEl("combat").value == "ae" ? 0 : getEl("combat").value == "hans" ? 21 : 18, 1);
                    sendAutoGather();
                    setTickout(()=>{
                        sendAutoGather();
                        instaC.isTrue = false;
                        autoAim = false;
                    }, 1);
                },
                rangeType: function() {
                    instaC.isTrue = true;
                    io.send("2", near.aim2);
                    autoAim = true;
                    if (player.weapons[1] == 9) {
                        rangeBackup.push(near.dist2);
                        doAgeInsta = true;
                        selectWeapon(player.weapons[1]);
                        buyEquip(53, 0);
                        sendAutoGather();
                        setTickout(()=>{
                            sendUpgrade(12);
                            selectWeapon(player.weapons[1]);
                            setTickout(()=>{
                                sendUpgrade(15);
                                selectWeapon(player.weapons[1]);
                                setTickout(()=>{
                                    doAgeInsta = false;
                                    sendAutoGather();
                                    instaC.isTrue = false;
                                    autoAim = false;
                                }, 1);
                            }, 1);
                        }, 1);
                    } else {
                        selectWeapon(player.weapons[1]);
                        if (player.reloads[53] == 0 && near.dist2 <= 700 && near.skinIndex != 22) {
                            buyEquip(53, 0);
                        } else {
                            buyEquip(20, 0);
                        }
                        buyEquip(11, 1);
                        sendAutoGather();
                        setTickout(()=>{
                            sendAutoGather();
                            instaC.isTrue = false;
                            autoAim = false;
                        }, 2);
                    }
                },
            };
            let autoAim = false;
            let autos = {
                reloaded: false,
            };
            let traps = {
                in: false,
                aim: Number.MAX_VALUE,
                healths: 69,
            };
            let ticks = {
                tick: 0,
                delay: 0,
                time: [],
                manage: [],
            };

            function checkTestCoord(tmpObj) {
                let x = tmpObj.x2 - tmpObj.x1;
                let y = tmpObj.y2 - tmpObj.y1;
                tmpObj.x3 = tmpObj.x2 + x;
                tmpObj.y3 = tmpObj.y2 + y;
            }
            let oldXY = {
                x: undefined,
                y: undefined,
            };
            let autoQ = false;

            function isTeam(tmpObj) {
                return (tmpObj == player || (tmpObj.team && tmpObj.team == player.team));
            }
            let turretEmp = 0;
            let waitTicks = [];
            let anti0Tick = 0;
            let syncCount = 0;
            let nerdChat = ["Don't care", "didin't ask", "cry about it", "stay mad", "get real", "L", "mad seethe cope harder", "hoes mad", "basic", "skill issue", "ratio", "you fell off", "the audacity", "triggered", "any askers", "replled", "get a life", "ok and?", "cringe", "touch grass", "donowalled", "not based", "not funny didnÃ¢â‚¬â„¢t laugh", "*you're", "grammar issues", "go outside", "get good", "reported", "ad hominem", "GG!", "ask deez", "ez clap", "straight cash", "ratio again", "final ratio", "problematic", "furry lover", "retard", "bad", "cry", "ez", "easy", "basic", "need hard", "so bad", "cringe", "get teacher"];
            let nerdSpam = false;
            let hitCount = 0;
            let spinner = false;
            function combatType(type) {
                return getEl("combat").value == type;
            }
            function tmpObjDist(a, b) {
                return Math.hypot(a.y2-b.y2, a.x2-b.x2);
            }
            function Ti(data) {
                enemy = [];
                nears = [];
                near = [];
                ticks.tick++;
                ticks.time.push(Date.now() - ticks.delay <= 50 || Date.now() - ticks.delay >= 175 ? "lag" : 1);
                if (ticks.tick % 10 === 0) {
                    ticks.time = [];
                }
                if (ticks.tick % 300 === 0) {
                    if (getEl("visual").value == "fz") {
                        maxPing = window.pingTime;
                        minPing = window.pingTime;
                    }
                }
                ticks.delay = Date.now();
                var tmpTime = Date.now();
                for (let i = 0; i < players.length; ++i) {
                    players[i].forcePos = !players[i].visible;
                    players[i].visible = false;
                    if (getEl("enemyradar" + players[i].sid)) {
                        getEl("enemyradar" + players[i].sid).style.display = "none";
                    }
                }
                for (let i = 0; i < data.length; ) {
                    tmpObj = findPlayerBySID(data[i]);
                    if (tmpObj) {
                        tmpObj.t1 = tmpObj.t2 === undefined ? tmpTime : tmpObj.t2;
                        tmpObj.t2 = tmpTime;
                        tmpObj.x1 = tmpObj.x;
                        tmpObj.y1 = tmpObj.y;
                        tmpObj.x2 = data[i + 1];
                        tmpObj.y2 = data[i + 2];
                        checkTestCoord(tmpObj);
                        tmpObj.aim2 = UTILS.getDirect(tmpObj, player, 2, 2);
                        tmpObj.dist2 = UTILS.getDist(tmpObj, player, 2, 2);
                        tmpObj.aim3 = UTILS.getDirect(tmpObj, player, 3, 3);
                        tmpObj.dist3 = UTILS.getDist(tmpObj, player, 3, 3);
                        tmpObj.d1 = tmpObj.d2 === undefined ? data[i + 3] : tmpObj.d2;
                        tmpObj.d2 = data[i + 3];
                        tmpObj.dt = 0;
                        tmpObj.rt = 0;
                        tmpObj.buildIndex = data[i + 4];
                        tmpObj.weaponIndex = data[i + 5];
                        tmpObj.weaponVariant = data[i + 6];
                        tmpObj.team = data[i + 7];
                        tmpObj.isLeader = data[i + 8];
                        tmpObj.skinIndex = data[i + 9];
                        tmpObj.tailIndex = data[i + 10];
                        tmpObj.iconIndex = data[i + 11];
                        tmpObj.zIndex = data[i + 12];
                        tmpObj.visible = true;
                        if (tmpObj == player) {
                            tmpObj.syncThreats = 0;
                            tmpObj.primaryIndex = tmpObj.weapons[0];
                            tmpObj.secondaryIndex = tmpObj.weapons[1];
                            (!millC.x || !oldXY.x) && (millC.x = oldXY.x = tmpObj.x2);
                            (!millC.y || !oldXY.y) && (millC.y = oldXY.y = tmpObj.y2);
                        }
                        if (tmpObj.weaponIndex < 9) {
                            if (tmpObj != player) {
                                tmpObj.primaryIndex = tmpObj.weaponIndex;
                            }
                            tmpObj.primaryVariant = tmpObj.weaponVariant;
                        } else if (tmpObj.weaponIndex > 8) {
                            if (tmpObj != player) {
                                tmpObj.secondaryIndex = tmpObj.weaponIndex;
                            }
                            tmpObj.secondaryVariant = tmpObj.weaponVariant;
                        }
                    }
                    i += 13;
                }
                if (waitTicks.length) {
                    waitTicks.forEach((ajaj)=>{
                        ajaj();
                    });
                    waitTicks = [];
                }
                if (runAtNextTick.length) {
                    runAtNextTick.forEach((tmp)=>{
                        checkProjectileHolder(...tmp);
                    });
                    runAtNextTick = [];
                }
                syncCount = 0;
                for (let i = 0; i < data.length; ) {
                    tmpObj = findPlayerBySID(data[i]);
                    if (tmpObj) {
                        if (tmpObj.doTickUpdate) {
                            tmpObj.doTickUpdate = false;
                        }
                        if (!isTeam(tmpObj)) {
                            enemy.push(tmpObj);
                            if (tmpObj.dist2 <= (items.weapons[tmpObj.primaryIndex == undefined ? 5 : tmpObj.primaryIndex].range + (player.scale * 3)) + (getEl("addictdist").checked && window.pingTime >= 90 ? (window.pingTime / 3) : 0)) {
                                nears.push(tmpObj);
                            }
                            if (getEl("visual").value == "cele" || getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                                addUser(tmpObj);
                            }
                        }
                        if (tmpObj.pCount > -1) {
                            if ((ticks.tick - tmpObj.bTick) % config.serverUpdateRate === 0) {
                                tmpObj.pCount--;
                            }
                        }
                        tmpObj.oldReloads[53] = tmpObj.reloads[53];
                        if (tmpObj.shooting[53]) {
                            tmpObj.shooting[53] = 0;
                            tmpObj.reloads[53] = 2500 - config.tickRate;
                            tmpObj.oldReloads[53] = tmpObj.reloads[53];
                            if (getEl("antitick").checked && !isTeam(tmpObj)) {
                                if (tmpObj.primaryIndex == 5 && tmpObj.primaryVariant >= 2 && tmpObj.dist2 >= 175 && tmpObj.dist2 <= 275) {
                                    anti0Tick = 2;
                                }
                            }
                        } else {
                            if (tmpObj.reloads[53] > 0) {
                                tmpObj.reloads[53] = Math.max(0, tmpObj.reloads[53] - config.tickRate);
                                if (tmpObj.reloads[53] <= 0) {
                                    let tmp = tmpObj;
                                    tmp.turretReloaded = true;
                                    setTickout(()=>{
                                        tmp.turretReloaded = false;
                                    }, 1);
                                }
                            }
                        }
                        tmpObj.oldReloads[tmpObj.primaryIndex == undefined ? tmpObj.weaponIndex : tmpObj.primaryIndex] = tmpObj.reloads[tmpObj.primaryIndex == undefined ? tmpObj.weaponIndex : tmpObj.primaryIndex];
                        tmpObj.oldReloads[tmpObj.secondaryIndex == undefined ? tmpObj.weaponIndex : tmpObj.secondaryIndex] = tmpObj.reloads[tmpObj.secondaryIndex == undefined ? tmpObj.weaponIndex : tmpObj.secondaryIndex];
                        if (tmpObj.gathering || tmpObj.shooting[1]) {
                            if (tmpObj.gathering) {
                                tmpObj.gathering = 0;
                                tmpObj.reloads[tmpObj.gatherIndex] = items.weapons[tmpObj.gatherIndex].speed * (tmpObj.skinIndex == 20 ? 0.78 : 1);
                                tmpObj.oldReloads[tmpObj.gatherIndex] = tmpObj.reloads[tmpObj.gatherIndex];
                            }
                            if (tmpObj.shooting[1]) {
                                tmpObj.shooting[1] = 0;
                                tmpObj.reloads[tmpObj.shootIndex] = items.weapons[tmpObj.shootIndex].speed * (tmpObj.skinIndex == 20 ? 0.78 : 1);
                                tmpObj.oldReloads[tmpObj.shootIndex] = tmpObj.reloads[tmpObj.shootIndex];
                                if (tmpObj != player && player.team && tmpObj.team == player.team && player.weapons[1] == 15 && tmpObj.shootIndex == 15) {
                                    syncCount++;
                                }
                            }
                        } else {
                            if (tmpObj.buildIndex < 0) {
                                if (tmpObj.reloads[tmpObj.weaponIndex] > 0) {
                                    tmpObj.reloads[tmpObj.weaponIndex] = Math.max(0, tmpObj.reloads[tmpObj.weaponIndex] - config.tickRate);
                                    if (tmpObj.weaponIndex == tmpObj.primaryIndex) {
                                        if (tmpObj.reloads[tmpObj.primaryIndex] <= 0) {
                                            if (tmpObj == player) {
                                                configs.antiBull2++;
                                                setTickout(()=>{
                                                    configs.antiBull2--;
                                                }, 1);
                                            } else {
                                                if (!isTeam(tmpObj) && tmpObj.dist2 <= items.weapons[tmpObj.primaryIndex ? tmpObj.primaryIndex : 5].range + player.scale * 1.8 + window.pingTime / 2) {
                                                    configs.antiBull++;
                                                    setTickout(()=>{
                                                        configs.antiBull--;
                                                    }, 1);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        getDamageThreat(tmpObj);
                    }
                    i += 13;
                }
                myConfig.x = player.x2;
                myConfig.y = player.y2;
                if (ticks.tick % 24 === 0) {
                    myConfig.sync = true;
                } else {
                    myConfig.sync = false;
                }
                if (enemy.length) {
                    near = enemy.sort(function(tmp1, tmp2) {
                        return (UTILS.getDist(tmp1, player, 2, 2) - UTILS.getDist(tmp2, player, 2, 2));
                    })[0];
                    myNearAim = function(o) {
                        return UTILS.getDirect(near, o, 2, 0);
                    };
                } else {
                    myNearAim = function(nothing) {
                        return undefined;
                    };
                }
                try {
                    if (getEl("spin").checked) {
                        spinner = true;
                    } else spinner = false;
                    nears.forEach((e)=>{
                        if (e.primaryIndex != undefined && e.reloads[e.primaryIndex] == 0 && e.primaryIndex != undefined && e.reloads[e.primaryIndex] == 0) {
                            player.syncThreats++;
                        }
                    });
                    turretEmp = 0;
                    gameObjects.filter((e)=>e.active && e.doUpdate).forEach((tmp)=>{
                        if (tmp.shootted) {
                            tmp.shootted = 0;
                            tmp.shootReload = 2200 - config.tickRate;
                        } else {
                            if (tmp.shootReload > 0) {
                                tmp.shootReload = Math.max(0, tmp.shootReload - config.tickRate);
                                if (tmp.shootReload <= 0) {
                                    tmp.shootReload = 2200;
                                    if (player.sid != tmp.owner.sid && !findAllianceBySid(tmp.owner.sid) && UTILS.getDist(tmp, player, 0, 2) <= 735) {
                                        turretEmp++;
                                    }
                                }
                            }
                        }
                    }
                                                                           );
                    if ((checkCanInsta(true) >= 100 ? checkCanInsta(true) : checkCanInsta(false)) >= (player.weapons[1] == 10 ? 95 : 100) && near.dist2 <= items.weapons[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]].range + near.scale * 1.8 && instaC.wait && !instaC.isTrue && !configs.waitHit && player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0 && player.reloads[53] == 0) {
                        if (checkCanInsta(true) >= 100) {
                            instaC.nobull = true;
                        } else {
                            instaC.nobull = false;
                        }
                        instaC.can = true;
                    } else {
                        instaC.can = false;
                    }
                    guessDamagePrediction();
                    if (ticks.manage[ticks.tick]) {
                        ticks.manage[ticks.tick].forEach((doit)=>{
                            doit();
                        });
                    }
                    if (player.alive) {
                        if (player.syncThreats >= 2 && getEl("antisync").checked && !antiSync) {
                            antiSyncHealing(3);
                        }
                        if (judgeAtNextTick) {
                            judgeAtNextTick = false;
                            if (getEl("soldierempanti").checked && enemy.length && near.reloads[53] <= config.tickRate && (near.secondaryIndex != 10 && near.secondaryIndex != 11 && near.secondaryIndex != 14)) {
                                doEmpAntiInsta = true;
                            }
                        }
                        if (getEl("autoq").checked && (doAutoQ || getEl("evautoq").checked)) {
                            getEl("healer").innerHTML = "Healer: autoQ";
                            if (player.shameCount < 4 && near.dist2 <= 300 && near.reloads[near.primaryIndex] <= config.tickRate * (window.pingTime >= 200 ? 2 : 1)) {
                                autoQ = true;
                                place(0, getAttackDir());
                            } else {
                                if (autoQ) {
                                    place(0, getAttackDir());
                                }
                                autoQ = false;
                            }
                        } else {
                            autoQ = false;
                            if (nears.length >= 2) {
                                getEl("healer").innerHTML = "Healer: " + nears.length + "v1";
                            } else {
                                getEl("healer").innerHTML = "Healer: " + (window.pingTime <= 80 ? "Low Ping" : "High Ping");
                            }
                        }
                        if (syncCount >= parseInt(getEl("synccount").value)) {
                            if (getEl("sync").checked) {
                                doSync = true;
                            }
                        }
                        if (clicks.middle || doSync || withSync) {
                            if (doSync) {
                                doSync = false;
                            }
                            if (withSync) {
                                withSync = false;
                            }
                        }
                        if (instaC.can) {
                            instaC.changeType(getEl("alwaysrev").checked ? "rev" : player.weapons[1] == 10 ? "rev" : instaC.nobull ? "nobull" : "normal");
                        }
                        if (instaC.isCounter) {
                            instaC.isCounter = false;
                            if (player.reloads[player.weapons[0]] == 0 && !instaC.isTrue) {
                                instaC.counterType();
                            }
                        }
                        if (waitSpikeTick) {
                            waitSpikeTick = false;
                            if (!instaC.isTrue && player.reloads[player.weapons[0]] == 0) {
                                instaC.spikeTickType();
                            }
                        }
                        // MOUSE EVENT:
                        if (!clicks.middle && (clicks.left || clicks.right) && !instaC.isTrue && !instaC.can) {
                            if (player.weaponIndex != (clicks.right && getEl("grindsec").checked && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0])) {
                                selectWeapon(clicks.right && getEl("grindsec").checked && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]);
                            }
                            if (player.reloads[clicks.right && getEl("grindsec").checked && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0) {
                                io.send("7", 1);
                                setTickout(()=>{
                                    io.send("7", 1);
                                }, 1);
                            }
                        }
                        if (gameObjects.length) {
                            nearSpike = [];
                            nearSpike = gameObjects.filter((tmp)=>tmp.dmg && player.sid != tmp.owner.sid && !findAllianceBySid(tmp.owner.sid) && tmp.active && UTILS.getDist(tmp, player, 0, 2) < (tmp.scale + player.scale)).sort(function(a, b) {
                                return (UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2));
                            })[0];
                            let trap1 = gameObjects.filter((e)=>e.trap && e.active).sort(function(a, b) {
                                return (UTILS.getDist(a, player, 0, 2) - UTILS.getDist(b, player, 0, 2));
                            })[0];
                            if (trap1) {
                                traps.aim = UTILS.getDirect(trap1, player, 0, 2);
                                if (player.sid != trap1.owner.sid && !findAllianceBySid(trap1.owner.sid) && Math.hypot(trap1.y - player.y2, trap1.x - player.x2) <= 50 && getEl("abactive").checked) {
                                    traps.in = true;
                                    traps.healths = trap1.buildHealth;
                                    if (!instaC.isTrue && !clicks.middle && !clicks.left && !clicks.right) {
                                        if (player.weaponIndex != player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]) {
                                            selectWeapon(trap1.buildHealth > items.weapons[player.weapons[0]].dmg && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]);
                                        }
                                        if (player.reloads[trap1.buildHealth > items.weapons[player.weapons[0]].dmg && player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0 && (trap1.buildHealth > items.weapons[player.weapons[0]].dmg && player.weapons[1] == 10 ? true : !configs.waitHit)) {
                                            configs.waitHit = true;
                                            io.send("7", 1);
                                            setTickout(()=>{
                                                io.send("7", 1);
                                                configs.waitHit = false;
                                            }, 1);
                                        }
                                    }
                                } else {
                                    traps.in = false;
                                }
                            } else {
                                traps.in = false;
                            }
                        } else {
                            traps.in = false;
                        }
                        // RELOADS:
                        if (!instaC.isTrue && player.weapons[1] && !clicks.left && !clicks.right && !traps.in) {
                            if ((player.weapons[0] == 3 || player.weapons[0] == 4 || player.weapons[0] == 5) && (player.weapons[1] == 10 || player.weapons[1] == 14)) {
                                if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0) {
                                    if (!autos.reloaded) {
                                        autos.reloaded = true;
                                        if (player.weaponIndex != player.weapons[1]) {
                                            selectWeapon(player.weapons[1]);
                                        }
                                    }
                                } else {
                                    autos.reloaded = false;
                                    if (player.reloads[player.weapons[0]] > 0) {
                                        if (player.weaponIndex != player.weapons[0]) {
                                            selectWeapon(player.weapons[0]);
                                        }
                                    } else if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] > 0) {
                                        if (player.weaponIndex != player.weapons[1]) {
                                            selectWeapon(player.weapons[1]);
                                        }
                                    }
                                }
                            } else {
                                if (player.reloads[player.weapons[0]] == 0 && player.reloads[player.weapons[1]] == 0) {
                                    if (!autos.reloaded) {
                                        autos.reloaded = true;
                                        if (player.weaponIndex != player.weapons[0]) {
                                            selectWeapon(player.weapons[0]);
                                        }
                                    }
                                } else {
                                    autos.reloaded = false;
                                    if (player.reloads[player.weapons[1]] > 0) {
                                        if (player.weaponIndex != player.weapons[1]) {
                                            selectWeapon(player.weapons[1]);
                                        }
                                    } else if (player.reloads[player.weapons[1]] == 0 && player.reloads[player.weapons[0]] > 0) {
                                        if (player.weaponIndex != player.weapons[0]) {
                                            selectWeapon(player.weapons[0]);
                                        }
                                    }
                                }
                            }
                        }
                        // PLACES:
                        if (places.slot0 && !autoQ) {
                            place(0, getAttackDir());
                        } else if (places.slot2) {
                            place(2, getAttackDir());
                        } else if (places.slot4) {
                            place(4, getAttackDir());
                        } else if (places.slot5) {
                            place(5, getAttackDir());
                        }
                        if (!instaC.isTrue && (getEl("abplace").checked ? true : !traps.in)) {
                            autoPlace();
                        }
                        try {
                            let parsed = parseFloat(getEl("placeconfig").value);
                            let objectSize = millC.size(items.list[player.items[parsed]].scale);
                            let objectDist = millC.dist(items.list[player.items[parsed]].scale);
                            if (UTILS.getDist(millC, player, 0, 2) > objectDist + items.list[player.items[parsed]].placeOffset) {
                                if (millC.active) {
                                    let millDir = UTILS.getDirect(millC, player, 0, 2);
                                    let plusXY = {
                                        x: millC.x,
                                        y: millC.y
                                    };
                                    let Boom = UTILS.getDirect(plusXY, player, 0, 2);
                                    checkPlace(parsed, Boom + UTILS.toRad(objectSize));
                                    checkPlace(parsed, Boom - UTILS.toRad(objectSize));
                                    checkPlace(parsed, Boom);
                                    millC.count = Math.max(0, millC.count - 1);
                                }
                                millC.x = player.x2;
                                millC.y = player.y2;
                            }
                        } catch (e) {}
                        // EXTRA:
                        if (storeMenu.style.display != "block" && !instaC.isTrue) {
                            // Wow This Is Real Left Right:
                            if (clicks.left || clicks.right) {
                                changeHat("click");
                                changeAcc("click");
                            } else {
                                if (traps.in) {
                                    changeHat("trap");
                                    changeAcc("trap");
                                } else {
                                    changeHat("normal");
                                    changeAcc("normal");
                                }
                            }
                        }
                        // SEND DIR:
                        if (!places.slot0 && !places.slot2 && !places.slot4 && !places.slot5 && !autoQ) {
                            let atckDir = getAttackDir();
                            if (player.dir !== atckDir) {
                                lessDir = atckDir;
                                io.send("2", atckDir);
                            }
                        }
                        if (doEmpAntiInsta) {
                            doEmpAntiInsta = false;
                        }
                        if (anti0Tick > 0) {
                            anti0Tick--;
                        }
                    }
                } catch (e) {
                    console.error(e);
                }
                if (autoZoom) {
                    if (near.dist2 <= 1000) {
                        resetZoom();
                    } else {
                        zoomVision();
                    }
                } else {
                    resetZoom();
                }
            }
            function setTickout(doo, timeout) {
                if (!ticks.manage[ticks.tick + timeout]) {
                    ticks.manage[ticks.tick + timeout] = [doo];
                } else {
                    ticks.manage[ticks.tick + timeout].push(doo);
                }
            }

            function doNextTick(doo) {
                waitTicks.push(doo);
            }
            // AUTO PLACE:
            function autoPlace() {
                let nearObj = [];
                let randomDir = Math.random() * Math.PI * 2;
                if (gameObjects.length && enemy.length && getEl("autoplc").checked) {
                    let nearsa = {
                        inTrap: false,
                    };
                    nearObj = gameObjects.filter((e)=>e.trap).sort(function(a, b) {
                        return (UTILS.getDist(a, near, 0, 2) - UTILS.getDist(b, near, 0, 2));
                    })[0];
                    if (nearObj) {
                        if (!(player.sid != nearObj.owner.sid && !findAllianceBySid(nearObj.owner.sid)) && UTILS.getDist(nearObj, near, 0, 2) <= 70 && nearObj.active) {
                            nearsa.inTrap = true;
                        } else {
                            nearsa.inTrap = false;
                        }
                        if (near.dist2 <= 300) {
                            if (nearsa.inTrap || near.dist2 <= items.weapons[player.weapons[0]].range + near.scale * 1.8) {
                                if (near.dist2 <= 225) {
                                    for (let i = 0; i < Math.PI * 2; i += Math.PI / 1.5) {
                                        checkPlace(2, near.aim2 + i);
                                    }
                                } else {
                                    for (let i = Math.PI / 1.5; i < Math.PI * 2; i += Math.PI / 1.5) {
                                        checkPlace(2, near.aim2 + i);
                                    }
                                }
                            } else {
                                if (player.items[4] == 15) {
                                    if (UTILS.getDist(oldXY, player, 0, 2) >= 125) {
                                        for (let i = 0; i < Math.PI * 2; i += Math.PI / 2) {
                                            checkPlace(4, randomDir + i);
                                        }
                                        oldXY.x = player.x2;
                                        oldXY.y = player.y2;
                                    }
                                }
                            }
                        }
                    } else {
                        if (near.dist2 <= 400) {
                            if (player.items[4] == 15) {
                                checkPlace(4, near.aim2);
                            }
                        }
                    }
                }
            }
            // EQUIP HATS:
            function biomeGear() {
                if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                    buyEquip(31, 0);
                } else {
                    if (isMoveDir == undefined && (getEl("combat").value == "zyenith" || getEl("combat").value == "hans" || getEl("combat").value == "me")) {
                        buyEquip(6, 0);
                    } else {
                        if (player.y2 <= config.snowBiomeTop) {
                            buyEquip(15, 0);
                        } else {
                            buyEquip(12, 0);
                        }
                    }
                }
            }

            function safeWeapon1() {
                return (near.primaryIndex == 0 || near.primaryIndex == 6 || near.primaryIndex == 7 || near.primaryIndex == 8);
            }
            function safeWeapon2() {
                return (near.secondaryIndex == 9 || near.secondaryIndex == 10 || near.secondaryIndex == 11 || near.secondaryIndex == 14);
            }
            function changeHat(value) {
                if (value == "normal") {
                    if (anti0Tick > 0) {
                        buyEquip(6, 0);
                    } else {
                        if ((getEl("bulltick").checked && player.shameCount > 0 && (ticks.tick - player.bTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || reSyncBull) {
                            buyEquip(7, 0);
                        } else {
                            if (getEl("combat").value == "ae") {
                                buyEquip(6, 0);
                            } else if (getEl("combat").value == "fz") {
                                if (turretEmp > 0 || doEmpAntiInsta) {
                                    buyEquip(6, 0);
                                } else {
                                    if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                        buyEquip(31, 0);
                                    } else {
                                        if (enemy.length) {
                                            if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                                if (near.primaryIndex != undefined && near.reloads[near.primaryIndex] == 0 && near.secondaryIndex != undefined && near.reloads[near.secondaryIndex] == 0 && player.reloads[player.weapons[0]] <= config.tickRate && player.reloads[player.weapons[1]] == 0 && player.weapons[0] != 7 && player.weapons[0] != 8 && near.primaryIndex != 7 && near.primaryIndex != 8) {
                                                    buyEquip(11, 0);
                                                } else {
                                                    if (safeWeapon1() && safeWeapon2()) {
                                                        buyEquip(26, 0);
                                                    } else {
                                                        buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                                    }
                                                }
                                            } else {
                                                biomeGear();
                                            }
                                        } else {
                                            biomeGear();
                                        }
                                    }
                                }
                            } else if (getEl("combat").value == "me") {
                                if (turretEmp > 0 || doEmpAntiInsta) {
                                    buyEquip(6, 0);
                                } else {
                                    if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                        buyEquip(31, 0);
                                    } else {
                                        if (enemy.length) {
                                            if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                                if (configs.antiBull > 0 && player.weapons[0] != 7) {
                                                    buyEquip(11, 0);
                                                } else {
                                                    buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                                }
                                            } else {
                                                biomeGear();
                                            }
                                        } else {
                                            biomeGear();
                                        }
                                    }
                                }
                            } else {
                                if (turretEmp > 0 || doEmpAntiInsta) {
                                    buyEquip(6, 0);
                                } else {
                                    if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                        buyEquip(31, 0);
                                    } else {
                                        if (enemy.length) {
                                            if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                                if (configs.antiBull > 0 && player.weapons[0] != 7) {
                                                    buyEquip(11, 0);
                                                } else {
                                                    buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                                }
                                            } else {
                                                biomeGear();
                                            }
                                        } else {
                                            biomeGear();
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else if (value == "click") {
                    if (anti0Tick > 0) {
                        buyEquip(6, 0);
                    } else {
                        if ((getEl("bulltick").checked && player.shameCount > 0 && (ticks.tick - player.bTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || reSyncBull) {
                            buyEquip(7, 0);
                        } else {
                            if (clicks.left && player.reloads[player.weapons[0]] == 0) {
                                buyEquip(7, 0);
                            } else if (clicks.right && player.reloads[(getEl("grindsec").checked && player.weapons[1] == 10) ? player.weapons[1] : player.weapons[0]] == 0) {
                                buyEquip(40, 0);
                            } else {
                                if (getEl("combat").value == "ae") {
                                    buyEquip(6, 0);
                                } else if (getEl("combat").value == "fz") {
                                    if (turretEmp > 0 || doEmpAntiInsta) {
                                        buyEquip(6, 0);
                                    } else {
                                        if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                            buyEquip(31, 0);
                                        } else {
                                            if (near.dist2 <= 500) {
                                                if (safeWeapon1() && safeWeapon2()) {
                                                    buyEquip(26, 0);
                                                } else {
                                                    buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                                }
                                            } else {
                                                biomeGear();
                                            }
                                        }
                                    }
                                } else if (getEl("combat").value == "me") {
                                    if (turretEmp > 0 || doEmpAntiInsta) {
                                        buyEquip(6, 0);
                                    } else {
                                        if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                            buyEquip(31, 0);
                                        } else {
                                            if (clicks.left && configs.antiBull > 0 && player.weapons[0] != 7) {
                                                buyEquip(11, 0);
                                            } else {
                                                buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                            }
                                        }
                                    }
                                } else {
                                    if (turretEmp > 0 || doEmpAntiInsta) {
                                        buyEquip(6, 0);
                                    } else {
                                        if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                                            buyEquip(31, 0);
                                        } else {
                                            if (clicks.left && configs.antiBull > 0 && player.weapons[0] != 7) {
                                                buyEquip(11, 0);
                                            } else {
                                                buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else if (value == "trap") {
                    if (anti0Tick > 0) {
                        buyEquip(6, 0);
                    } else {
                        if ((getEl("bulltick").checked && player.shameCount > 0 && (ticks.tick - player.bTick) % config.serverUpdateRate === 0 && player.skinIndex != 45) || reSyncBull) {
                            buyEquip(7, 0);
                        } else {
                            if (traps.healths > items.weapons[player.weapons[0]].dmg && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0) {
                                buyEquip(40, 0);
                            } else {
                                if (getEl("combat").value == "fz") {
                                    if (turretEmp > 0 || doEmpAntiInsta) {
                                        buyEquip(6, 0);
                                    } else {
                                        if (near.dist2 <= 300) {
                                            if ((safeWeapon1() && safeWeapon2()) || (near.primaryIndex == 5 && near.dist2 >= 175)) {
                                                buyEquip(26, 0);
                                            } else {
                                                buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                            }
                                        } else {
                                            biomeGear();
                                        }
                                    }
                                } else if (getEl("combat").value == "hans") {
                                    if (turretEmp > 0 || doEmpAntiInsta || near.secondaryIndex == 10) {
                                        buyEquip(6, 0);
                                    } else {
                                        buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                    }
                                } else {
                                    if (turretEmp > 0 || doEmpAntiInsta || near.dist2 > 300) {
                                        buyEquip(6, 0);
                                    } else {
                                        buyEquip(getEl("soldieranti").checked ? 6 : 26, 0);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function changeAcc(value) {
                if (value == "normal") {
                    if (getEl("combat").value == "ae") {
                        buyEquip(11, 1);
                    } else {
                        if (player.y2 >= config.mapScale / 2 - config.riverWidth / 2 && player.y2 <= config.mapScale / 2 + config.riverWidth / 2) {
                            buyEquip(11, 1);
                        } else {
                            if (enemy.length) {
                                if (getEl("combat").value == "fz") {
                                    if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                        if (near.primaryIndex != undefined && near.reloads[near.primaryIndex] == 0 && near.secondaryIndex != undefined && near.reloads[near.secondaryIndex] == 0 && player.reloads[player.weapons[0]] <= config.tickRate && player.reloads[player.weapons[1]] == 0 && player.weapons[0] != 7 && player.weapons[0] != 8 && near.primaryIndex != 7 && near.primaryIndex != 8) {
                                            buyEquip(21, 1);
                                        } else {
                                            if (configs.antiBull > 0) {
                                                buyEquip(21, 1);
                                            } else {
                                                if ((ticks.tick - player.bTick) % config.serverUpdateRate === 0) {
                                                    buyEquip(13, 1);
                                                } else {
                                                    buyEquip(11, 1);
                                                }
                                            }
                                        }
                                    } else {
                                        buyEquip(11, 1);
                                    }
                                } else {
                                    if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                        if (configs.antiBull > 0) {
                                            buyEquip(21, 1);
                                        } else {
                                            buyEquip(11, 1);
                                        }
                                    } else {
                                        buyEquip(11, 1);
                                    }
                                }
                            } else {
                                buyEquip(11, 1);
                            }
                        }
                    }
                } else if (value == "click") {
                    if (getEl("combat").value == "ae") {
                        if (clicks.left) {
                            buyEquip(0, 1);
                        } else if (clicks.right) {
                            buyEquip(11, 1);
                        }
                    } else if (getEl("combat").value == "fz") {
                        if (configs.antiBull > 0) {
                            buyEquip(21, 1);
                        } else {
                            if (clicks.left && player.reloads[player.weapons[0]] == 0) {
                                buyEquip(near.dist2 <= 300 ? 18 : 0, 1);
                            } else if (clicks.right && player.reloads[(getEl("grindsec").checked && player.weapons[1] == 10) ? player.weapons[1] : player.weapons[0]] == 0) {
                                buyEquip(near.dist2 <= 300 ? 18 : 11, 1);
                            } else {
                                if ((ticks.tick - player.bTick) % config.serverUpdateRate === 0) {
                                    buyEquip(near.dist2 <= 500 ? 13 : 11, 1);
                                } else {
                                    buyEquip(11, 1);
                                }
                            }
                        }
                    } else {
                        buyEquip(21, 1);
                    }
                } else if (value == "trap") {
                    if (getEl("combat").value == "ae") {
                        buyEquip(0, 1);
                    } else if (getEl("combat").value == "hans") {
                        buyEquip(0, 1);
                    } else if (getEl("combat").value == "fz") {
                        if (configs.antiBull > 0) {
                            buyEquip(21, 1);
                        } else {
                            if (traps.healths > items.weapons[player.weapons[0]].dmg && player.reloads[player.weapons[1] == 10 ? player.weapons[1] : player.weapons[0]] == 0) {
                                buyEquip(near.dist2 <= 275 ? 18 : 11, 1);
                            } else {
                                if (near.dist2 <= 300) {
                                    if (instaC.wait) {
                                        buyEquip(21, 1);
                                    } else {
                                        if ((ticks.tick - player.bTick) % config.serverUpdateRate === 0) {
                                            buyEquip(13, 1);
                                        } else {
                                            buyEquip(11, 1);
                                        }
                                    }
                                } else {
                                    buyEquip(11, 1);
                                }
                            }
                        }
                    } else {
                        if (configs.antiBull > 0) {
                            buyEquip(21, 1);
                        } else {
                            if (near.dist2 <= items.weapons[near.primaryIndex ? near.primaryIndex : 5].range + player.scale * 3) {
                                buyEquip(21, 1);
                            } else {
                                buyEquip(11, 1);
                            }
                        }
                    }
                }
            }
            // FIND OBJECTS BY ID/SID:
            function findID(tmpObj, tmp) {
                return tmpObj.find((THIS)=>THIS.id === tmp);
            }

            function findSID(tmpObj, tmp) {
                return tmpObj.find((THIS)=>THIS.sid === tmp);
            }

            function findPlayerByID(id) {
                return findID(players, id);
            }

            function findPlayerBySID(sid) {
                return findSID(players, sid);
            }

            function findAIBySID(sid) {
                return findSID(ais, sid);
            }

            function findObjectBySid(sid) {
                return findSID(gameObjects, sid);
            }

            function findAllianceBySid(sid) {
                return player.team ? alliancePlayers.find((THIS)=>THIS === sid) : null;
            }
            // PING:
            var lastPing = -1;
            var maxPing = NaN;
            var minPing = NaN;
            var pingCount = 0;
            var doAutoQ = false;

            function pingSocketResponse() {
                var pingTime = Date.now() - lastPing;
                window.pingTime = pingTime;
                pingCount++;
                if (pingTime > maxPing || isNaN(maxPing)) {
                    maxPing = pingTime;
                }
                if (pingTime < minPing || isNaN(minPing)) {
                    minPing = pingTime;
                }
                if (getEl("visual").value == "zeph") {
                    pingDisplay.innerText = "Ping: " + pingTime + " ms | FPS: " + currentFPS + " frames";
                } else if (getEl("visual").value == "hans") {
                    pingDisplay.innerText = "Ping: " + pingTime + " ms / Ã‚Â© King Hans";
                } else {
                    pingDisplay.innerText = "Ping: " + pingTime + " ms";
                }
                if (pingTime >= 90) {
                    doAutoQ = true;
                } else {
                    doAutoQ = false;
                }
            }
            pingDisplay.style.display = "none";
            document.body.appendChild(pingDisplay);

            function pingSocket() {
                lastPing = Date.now();
                io.send("pp");
            }
            // SERVER SHUTDOWN NOTICE:
            function serverShutdownNotice(countdown) {
                if (countdown < 0)
                    return;
                var minutes = Math.floor(countdown / 60);
                var seconds = countdown % 60;
                seconds = ("0" + seconds).slice(-2);
                shutdownDisplay.innerText = "Server restarting in " + minutes + ":" + seconds;
                shutdownDisplay.hidden = false;
            }
            // UPDATE & ANIMATE:
            window.requestAnimFrame = (function() {
                return (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
                    window.setTimeout(callback, 1000 / 60);
                }
                       );
            }
                                      )();
            // DAY CYCLE MANAGER:
            let dayCycle = false;
            let dayColors = {
                snow: "#fff",
                river: "#91b2db",
                grass: "#b6db66",
                desert: "#dbc666",
            };
            let nightColors = {
                snow: "#e6e6e6",
                river: "#78a1d3",
                grass: "#8dba2c",
                desert: "#d3b945",
            };
            setInterval(()=>{
                dayCycle = !dayCycle;
            }
                        , 39000 * 2);
            // LMFAO:
            var mStatus = document.createElement("div");
            mStatus.id = "status";
            mStatus.style.position = "absolute";
            mStatus.style.color = "#e6e6fa";
            mStatus.style.font = "15px Hammersmith One";
            mStatus.style.top = "40px";
            mStatus.style.left = "40px";
            mStatus.style.display = "none";
            mStatus.textAlign = "right";
            document.body.appendChild(mStatus);
            let currentFPS = 0;
            let FPSTimer = 0;
            let runAtFirst = true;
            let autoMusic = false;
            let hatELs = {
                6: true,
                7: true,
                40: true,
                22: true,
                15: true
            };
            mStatus.innerHTML = `
                <style>
                .sizing {
                    font-size: 15px;
                }
                .mod {
                    font-size: 15px;
                    display: inline-block;
                }
                .augh {
                    display: inline-block;
                    width: 25px;
                    height: 25px;
                    background-size: cover;
                    background-color: #fff;
                    margin-right: -2.5px;
                    opacity: 0.4;
                }
                </style>
                <div id = "uehmod" class = "sizing" style = "display: block;">
                Ping: <div id = "pingFps" class = "mod">0</div></br>
                InstaStatus: [<div id = "instaStatus" class = "mod">0</div>]</br>
                Ticks | Lags: [<div id = "tickLag" class = "mod">0</div>]</br>
                Packet: <div id = "packetStatus" class = "mod">0</div></br>
                <div id = "nearEnemys" class = "mod">0</div></br>
                </div><div id = "fzmod" class = "sizing" style = "display: none;">
                Auto-Insta: <div id = "autoInsta1" class = "mod">0</div></br>
                Damage Prediction: <div id = "dmgPredict" class = "mod">0</div></br>
                Turrets that can hit you: <div id = "turCanHit" class = "mod">0</div></br>
                </div><div id = "zyenithmod" class = "sizing" style = "display: none;">
                <div id = "hatdispdiv" style = "display: block">
                <div id = "hatdisp6" class = "augh" style = "background-image: url(https://moomoo.io/img/hats/hat_6.png);"></div>
                <div id = "hatdisp7" class = "augh" style = "background-image: url(https://moomoo.io/img/hats/hat_7.png);"></div>
                <div id = "hatdisp40" class = "augh" style = "background-image: url(https://moomoo.io/img/hats/hat_40.png);"></div>
                <div id = "hatdisp22" class = "augh" style = "background-image: url(https://moomoo.io/img/hats/hat_22.png);"></div>
                <div id = "hatdisp15" class = "augh" style = "background-image: url(https://moomoo.io/img/hats/hat_15.png);"></div>
                </div>
                Auto-Insta: <div id = "autoInsta2" class = "mod">0</div></br>
                EAB: {<div id = "eabStatus" class = "mod">0</div>}</br>
                Music: <div id = "musicStatus" class = "mod">0</div></br>
                AdvPlacer: <div id = "millStatus" class = "mod">0</div></br>
                </div>
                `;
            function doUpdate() {
                now = Date.now();
                delta = now - lastUpdate;
                lastUpdate = now;
                FPSTimer++;
                if (runAtFirst) {
                    runAtFirst = false;
                    setInterval(()=>{
                        currentFPS = FPSTimer;
                        FPSTimer = 0;
                    }
                                , 1000);
                }
                updateGame();
                requestAnimFrame(doUpdate);
                if (player) {
                    if (getEl("visual").value == "me") {
                        getEl("instaStatus").innerHTML = [instaC.wait, instaC.isTrue, UTILS.fixTo(checkCanInsta(false), 2)].join(", ");
                        getEl("pingFps").innerHTML = `${window.pingTime}ms | Fps: ${currentFPS}`;
                        getEl("tickLag").innerHTML = ticks.time;
                        getEl("packetStatus").innerHTML = secPacket;
                        getEl("nearEnemys").innerHTML = nears.length ? "cEnemy: " + nears.length : "";
                    } else if (getEl("visual").value == "fz") {
                        getEl("autoInsta1").innerHTML = (instaC.wait ? "on" : "off").toUpperCase();
                        getEl("dmgPredict").innerHTML = predictDamage;
                        getEl("turCanHit").innerHTML = turretEmp;
                    } else if (getEl("visual").value == "zyenith") {
                        getEl("autoInsta2").innerHTML = (instaC.wait ? "on" : "off").toUpperCase();
                        getEl("eabStatus").innerHTML = earlyAutoBreak.start ? [`hit:${earlyAutoBreak.hit}`, `miss:${earlyAutoBreak.miss}`, ].join(",") : "";
                        getEl("musicStatus").innerHTML = (autoMusic ? "on" : "off").toUpperCase();
                        getEl("millStatus").innerHTML = (millC.active ? "on" : "off").toUpperCase();
                    }
                }
            }
            // START GAME:
            function startGame() {
                bindEvents();
                loadIcons();
                loadingText.style.display = "none";
                menuCardHolder.style.display = "block";
                nameInput.value = getSavedVal("moo_name") || "";
                prepareUI();
            }
            prepareMenuBackground();
            doUpdate();
            // OPEN LINK:
            function openLink(link) {
                window.open(link, "_blank");
            }
            // EXPORT VALUES:
            window.openLink = openLink;
            window.aJoinReq = aJoinReq;
            window.follmoo = follmoo;
            window.kickFromClan = kickFromClan;
            window.sendJoin = sendJoin;
            window.leaveAlliance = leaveAlliance;
            window.createAlliance = createAlliance;
            window.storeBuy = storeBuy;
            window.storeEquip = storeEquip;
            window.showItemInfo = showItemInfo;
            window.selectSkinColor = selectSkinColor;
            window.changeStoreIndex = changeStoreIndex;
            window.config = config;
            window.FRVR = [18731283, 30192, 12893, 12398123, 192381290, 1290381920, 3, 12893, 1283, 123, 1293, 9012, "real", "please", "help", "scare", "jumpscare", "homo", ];
            document.createAlliance = function(value) {
                if (player.team) {
                    io.send("9", undefined);
                    setTimeout(()=>{//                    io.send("8", value == "" ? String.fromCharCode(0) + " ".repeat(6) : value);
                    }
                               , 1000);
                } else {
                    io.send("8", value == "" ? String.fromCharCode(0) + " ".repeat(6) : value);
                }
            }
            ;
            // FUNCTIONS:
            let mapDisp = getEl("mapDisplay");
            mapDisp.style.backgroundImage = "";
            mapDisp.style.backgroundSize = "130px";
            let pingDisp = getEl("pingDisplay");
            function changeStatusDiv(id) {
                getEl("uehmod").style.display = "none";
                getEl("fzmod").style.display = "none";
                getEl("zyenithmod").style.display = "none";
                let haha = id == "me" ? "uehmod" : id == "fz" ? "fzmod" : id == "zyenith" ? "zyenithmod" : undefined;
                if (haha != undefined) {
                    getEl(haha).style.display = "block";
                }
            }
            getEl("combat").onchange = function() {
                getEl("crp").innerHTML = checkCheckChickenModV69(getEl("combat").value);
                this.blur();
            }
            function watafak(ahaha) {
                //            console.log("call");
                getEl("vrp").innerHTML = checkCheckChickenModV69(getEl("visual").value);
                changeStatusDiv(getEl("visual").value);
                if (ahaha) {
                    updateItemCountHTML();
                }
                pingDisp.style.display = "none";
                pingDisp.innerText = "Ping: " + window.pingTime + " ms";
                pingDisp.style.left = null;
                mapDisp.style.backgroundImage = "";
                mapDisp.style.backgroundColor = "rgba(0, 0, 0, 0.25)";
                foodDisplay.style.display = "block";
                woodDisplay.style.display = "block";
                stoneDisplay.style.display = "block";
                scoreDisplay.style.bottom = "160px";
                scoreDisplay.style.right = "inherit";
                scoreDisplay.style.left = "20px";
                scoreDisplay.style.backgroundPosition = "left 6px center";
                scoreDisplay.style.paddingLeft = "40px";
                scoreDisplay.style.paddingRight = "10px";
                if (getEl("visual").value == "0") {} else if (getEl("visual").value == "me") {
                    mStatus.style.color = "#e6e6fa";
                    mStatus.style.top = "40px";
                    mStatus.style.left = "40px";
                    mStatus.style.right = null;
                } else if (getEl("visual").value == "spyder") {
                    mapDisp.style.backgroundImage = "url(https://i.imgur.com/S1ogeNC.gif)";
                    pingDisp.style.display = "block";
                } else if (getEl("visual").value == "lore") {
                    mapDisp.style.backgroundImage = "url(https://ksw2-center.glitch.me/users/fzb/map.png)";
                } else if (getEl("visual").value == "cele") {} else if (getEl("visual").value == "zeph") {
                    pingDisp.style.display = "block";
                    pingDisplay.innerText = "Ping: " + window.pingTime + " ms | FPS: " + currentFPS + " frames";
                } else if (getEl("visual").value == "zeph") {} else if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                    mapDisp.style.backgroundImage = "url(https://ksw2-center.glitch.me/users/fzb/map.png)";
                } else if (getEl("visual").value == "hans") {
                    pingDisp.style.display = "block";
                    pingDisp.style.left = "90px";
                    pingDisplay.innerText = "Ping: " + window.pingTime + " ms / Ã‚Â© King Hans";
                    mapDisp.style.backgroundColor = "rgba(0, 0, 0, 0)";
                } else {}
                if (getEl("visual").value == "fz" || getEl("visual").value == "zyenith") {
                    mStatus.style.color = "#fff";
                    mStatus.style.top = "40px";
                    mStatus.style.left = null;
                    if (getEl("visual").value == "zyenith") {
                        mStatus.style.right = "40px";
                    } else {
                        mStatus.style.right = "20px";
                    }
                    mStatus.style.display = "block";
                    leaderboard.style.position = "fixed";
                    leaderboard.style.left = "20px";
                    leaderboard.style.right = null;
                    leaderboard.style.display = "none";
                    allianceButton.style.left = "410px";
                    allianceButton.style.right = null;
                    allianceButton.style.width = "40px";
                    storeButton.style.left = "350px";
                    storeButton.style.right = null;
                    storeButton.style.width = "40px";
                    chatButton.style.display = "none";
                    try {} catch (e) {}
                    resourceDisplay.appendChild(killCounter);
                    if (getEl("visual").value == "fz") {
                        killCounter.style.bottom = "185px";
                        killCounter.style.right = "20px";
                        scoreDisplay.style.bottom = "240px";
                        scoreDisplay.style.right = "20px";
                        scoreDisplay.style.left = "inherit";
                        scoreDisplay.style.backgroundPosition = "right 6px center";
                        scoreDisplay.style.paddingLeft = "10px";
                        scoreDisplay.style.paddingRight = "40px";
                    } else {
                        foodDisplay.style.display = "none";
                        woodDisplay.style.display = "none";
                        stoneDisplay.style.display = "none";
                        killCounter.style.bottom = "20px";
                        killCounter.style.right = "20px";
                    }
                } else {
                    leaderboard.style.position = null;
                    leaderboard.style.left = null;
                    leaderboard.style.right = null;
                    leaderboard.style.display = "block";
                    allianceButton.style.left = null;
                    allianceButton.style.right = "270px";
                    allianceButton.style.width = "40px";
                    storeButton.style.left = null;
                    storeButton.style.right = "330px";
                    storeButton.style.width = "40px";
                    chatButton.style.display = "block";
                    topinfoHolder.appendChild(killCounter);
                    killCounter.style.bottom = null;
                    killCounter.style.right = null;
                    mStatus.style.display = "none";
                }
                if (player) {
                    ageBarBody.style.width = (getEl("visual").value == "cele" || getEl("visual").value == "ae" ? "0" : (player.XP / player.maxXP) * 100) + "%";
                    for (var i = 0; i < items.list.length; ++i) {
                        var tmpI = items.weapons.length + i;
                        getEl("actionBarItem" + tmpI).style.display = (getEl("visual").value == "cele" || getEl("visual").value == "ae" || getEl("visual").value == "hans" ? player.firstItems : player.items).indexOf(items.list[i].id) >= 0 ? "inline-block" : "none";
                    }
                }
                //            Wut = getEl("visual").description;
            }
            watafak();
            getEl("visual").onchange = function() {
                watafak(true);
                this.blur();
            }
            ;
            /***/
        },
        /***/
        "./src/js/config.js": /*!**************************!*\
  !*** ./src/js/config.js ***!
  \**************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */
            (function(process) {
                // RENDER:
                module.exports.maxScreenWidth = 1920;
                module.exports.maxScreenHeight = 1080;
                // SERVER:
                module.exports.serverUpdateRate = 9;
                module.exports.tickRate = 1000 / module.exports.serverUpdateRate;
                module.exports.maxPlayers = process && process.argv.indexOf("--largeserver") != -1 ? 80 : 50;
                module.exports.maxPlayersHard = module.exports.maxPlayers + 10;
                module.exports.collisionDepth = 6;
                module.exports.minimapRate = 3000;
                // COLLISIONS:
                module.exports.colGrid = 10;
                // CLIENT:
                module.exports.clientSendRate = 5;
                // UI:
                module.exports.healthBarWidth = 50;
                module.exports.healthBarPad = 4.5;
                module.exports.iconPadding = 15;
                module.exports.iconPad = 0.9;
                module.exports.deathFadeout = 3000;
                module.exports.crownIconScale = 60;
                module.exports.crownPad = 35;
                // CHAT:
                module.exports.chatCountdown = 3000;
                module.exports.chatCooldown = 500;
                // SANDBOX:
                module.exports.inSandbox = process && process.env.VULTR_SCHEME === "mm_exp";
                module.exports.isSandbox = window.location.hostname == "sandbox.moomoo.io";
                // PLAYER:
                module.exports.maxAge = 100;
                module.exports.gatherAngle = Math.PI / 2.6;
                module.exports.gatherWiggle = 10;
                module.exports.hitReturnRatio = 0.25;
                module.exports.hitAngle = Math.PI / 2;
                module.exports.playerScale = 35;
                module.exports.playerSpeed = 0.0016;
                module.exports.playerDecel = 0.993;
                module.exports.nameY = 34;
                // CUSTOMIZATION:
                module.exports.skinColors = ["#bf8f54", "#cbb091", "#896c4b", "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3", "#8bc373", "#91b2db", ];
                // ANIMALS:
                module.exports.animalCount = 7;
                module.exports.aiTurnRandom = 0.06;
                module.exports.cowNames = ["Sid", "Steph", "Bmoe", "Romn", "Jononthecool", "Fiona", "Vince", "Nathan", "Nick", "Flappy", "Ronald", "Otis", "Pepe", "Mc Donald", "Theo", "Fabz", "Oliver", "Jeff", "Jimmy", "Helena", "Reaper", "Ben", "Alan", "Naomi", "XYZ", "Clever", "Jeremy", "Mike", "Destined", "Stallion", "Allison", "Meaty", "Sophia", "Vaja", "Joey", "Pendy", "Murdoch", "Theo", "Jared", "July", "Sonia", "Mel", "Dexter", "Quinn", "Milky", ];
                // WEAPONS:
                module.exports.shieldAngle = Math.PI / 3;
                module.exports.weaponVariants = [{
                    id: 0,
                    src: "",
                    xp: 0,
                    val: 1,
                }, {
                    id: 1,
                    src: "_g",
                    xp: 3000,
                    val: 1.1,
                }, {
                    id: 2,
                    src: "_d",
                    xp: 7000,
                    val: 1.18,
                }, {
                    id: 3,
                    src: "_r",
                    poison: true,
                    xp: 12000,
                    val: 1.18,
                }, ];
                module.exports.weaponXPs = [{
                    id: 0,
                    xp: 3000,
                }, {
                    id: 1,
                    xp: 7000,
                }, {
                    id: 2,
                    xp: 12000,
                }, {
                    id: 3,
                    xp: 1 / 0,
                }, ];
                module.exports.fetchVariant = function(player) {
                    var tmpXP = player.weaponXP[player.weaponIndex] || 0;
                    for (var i = module.exports.weaponVariants.length - 1; i >= 0; --i) {
                        if (tmpXP >= module.exports.weaponVariants[i].xp)
                            return module.exports.weaponVariants[i];
                    }
                }
                ;
                // NATURE:
                module.exports.resourceTypes = ["wood", "food", "stone", "points"];
                module.exports.areaCount = 7;
                module.exports.treesPerArea = 9;
                module.exports.bushesPerArea = 3;
                module.exports.totalRocks = 32;
                module.exports.goldOres = 7;
                module.exports.riverWidth = 724;
                module.exports.riverPadding = 114;
                module.exports.waterCurrent = 0.0011;
                module.exports.waveSpeed = 0.0001;
                module.exports.waveMax = 1.3;
                module.exports.treeScales = [150, 160, 165, 175];
                module.exports.bushScales = [80, 85, 95];
                module.exports.rockScales = [80, 85, 90];
                // BIOME DATA:
                module.exports.snowBiomeTop = 2400;
                module.exports.snowSpeed = 0.75;
                // DATA:
                module.exports.maxNameLength = 15;
                // MAP:
                module.exports.mapScale = 14400;
                module.exports.mapPingScale = 40;
                module.exports.mapPingTime = 2200;
                /* WEBPACK VAR INJECTION */
            }
            ).call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */
                "./node_modules/process/browser.js"));
            /***/
        },
        /***/
        "./src/js/data/ai.js": /*!***************************!*\
  !*** ./src/js/data/ai.js ***!
  \***************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            var PI2 = Math.PI * 2;
            module.exports = function(sid, objectManager, players, items, UTILS, config, scoreCallback, server) {
                this.sid = sid;
                this.isAI = true;
                this.nameIndex = UTILS.randInt(0, config.cowNames.length - 1);
                // INIT:
                this.init = function(x, y, dir, index, data) {
                    this.x = x;
                    this.y = y;
                    this.startX = data.fixedSpawn ? x : null;
                    this.startY = data.fixedSpawn ? y : null;
                    this.xVel = 0;
                    this.yVel = 0;
                    this.zIndex = 0;
                    this.dir = dir;
                    this.dirPlus = 0;
                    this.index = index;
                    this.src = data.src;
                    if (data.name)
                        this.name = data.name;
                    this.weightM = data.weightM;
                    this.speed = data.speed;
                    this.killScore = data.killScore;
                    this.turnSpeed = data.turnSpeed;
                    this.scale = data.scale;
                    this.maxHealth = data.health;
                    this.leapForce = data.leapForce;
                    this.health = this.maxHealth;
                    this.chargePlayer = data.chargePlayer;
                    this.viewRange = data.viewRange;
                    this.drop = data.drop;
                    this.dmg = data.dmg;
                    this.hostile = data.hostile;
                    this.dontRun = data.dontRun;
                    this.hitRange = data.hitRange;
                    this.hitDelay = data.hitDelay;
                    this.hitScare = data.hitScare;
                    this.spriteMlt = data.spriteMlt;
                    this.nameScale = data.nameScale;
                    this.colDmg = data.colDmg;
                    this.noTrap = data.noTrap;
                    this.spawnDelay = data.spawnDelay;
                    this.hitWait = 0;
                    this.waitCount = 1000;
                    this.moveCount = 0;
                    this.weaponReload = 0;
                    this.weaponHitted = 0;
                    this.targetDir = 0;
                    this.active = true;
                    this.alive = true;
                    this.runFrom = null;
                    this.chargeTarget = null;
                    this.dmgOverTime = {};
                    this.doTickUpdate = false;
                }
                ;
                // UPDATE:
                var timerCount = 0;
                this.update = function(delta) {
                    if (this.active) {
                        // SPAWN DELAY:
                        if (this.spawnCounter) {
                            this.spawnCounter -= delta;
                            if (this.spawnCounter <= 0) {
                                this.spawnCounter = 0;
                                this.x = this.startX || UTILS.randInt(0, config.mapScale);
                                this.y = this.startY || UTILS.randInt(0, config.mapScale);
                            }
                            return;
                        }
                        // REGENS AND AUTO:
                        timerCount -= delta;
                        if (timerCount <= 0) {
                            if (this.dmgOverTime.dmg) {
                                this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer);
                                this.dmgOverTime.time -= 1;
                                if (this.dmgOverTime.time <= 0)
                                    this.dmgOverTime.dmg = 0;
                            }
                            timerCount = 1000;
                        }
                        // BEHAVIOUR:
                        var charging = false;
                        var slowMlt = 1;
                        if (!this.zIndex && !this.lockMove && this.y >= config.mapScale / 2 - config.riverWidth / 2 && this.y <= config.mapScale / 2 + config.riverWidth / 2) {
                            slowMlt = 0.33;
                            this.xVel += config.waterCurrent * delta;
                        }
                        if (this.lockMove) {
                            this.xVel = 0;
                            this.yVel = 0;
                        } else if (this.waitCount > 0) {
                            this.waitCount -= delta;
                            if (this.waitCount <= 0) {
                                if (this.chargePlayer) {
                                    var tmpPlayer, bestDst, tmpDist;
                                    for (var i = 0; i < players.length; ++i) {
                                        if (players[i].alive && !(players[i].skin && players[i].skin.bullRepel)) {
                                            tmpDist = UTILS.getDistance(this.x, this.y, players[i].x, players[i].y);
                                            if (tmpDist <= this.viewRange && (!tmpPlayer || tmpDist < bestDst)) {
                                                bestDst = tmpDist;
                                                tmpPlayer = players[i];
                                            }
                                        }
                                    }
                                    if (tmpPlayer) {
                                        this.chargeTarget = tmpPlayer;
                                        this.moveCount = UTILS.randInt(8000, 12000);
                                    } else {
                                        this.moveCount = UTILS.randInt(1000, 2000);
                                        this.targetDir = UTILS.randFloat(-Math.PI, Math.PI);
                                    }
                                } else {
                                    this.moveCount = UTILS.randInt(4000, 10000);
                                    this.targetDir = UTILS.randFloat(-Math.PI, Math.PI);
                                }
                            }
                        } else if (this.moveCount > 0) {
                            var tmpSpd = this.speed * slowMlt;
                            if (this.runFrom && this.runFrom.active && !(this.runFrom.isPlayer && !this.runFrom.alive)) {
                                this.targetDir = UTILS.getDirection(this.x, this.y, this.runFrom.x, this.runFrom.y);
                                tmpSpd *= 1.42;
                            } else if (this.chargeTarget && this.chargeTarget.alive) {
                                this.targetDir = UTILS.getDirection(this.chargeTarget.x, this.chargeTarget.y, this.x, this.y);
                                tmpSpd *= 1.75;
                                charging = true;
                            }
                            if (this.hitWait) {
                                tmpSpd *= 0.3;
                            }
                            if (this.dir != this.targetDir) {
                                this.dir %= PI2;
                                var netAngle = (this.dir - this.targetDir + PI2) % PI2;
                                var amnt = Math.min(Math.abs(netAngle - PI2), netAngle, this.turnSpeed * delta);
                                var sign = netAngle - Math.PI >= 0 ? 1 : -1;
                                this.dir += sign * amnt + PI2;
                            }
                            this.dir %= PI2;
                            this.xVel += tmpSpd * delta * Math.cos(this.dir);
                            this.yVel += tmpSpd * delta * Math.sin(this.dir);
                            this.moveCount -= delta;
                            if (this.moveCount <= 0) {
                                this.runFrom = null;
                                this.chargeTarget = null;
                                this.waitCount = this.hostile ? 1500 : UTILS.randInt(1500, 6000);
                            }
                        }
                        // OBJECT COLL:
                        this.zIndex = 0;
                        this.lockMove = false;
                        var tmpList;
                        var tmpSpeed = UTILS.getDistance(0, 0, this.xVel * delta, this.yVel * delta);
                        var depth = Math.min(4, Math.max(1, Math.round(tmpSpeed / 40)));
                        var tMlt = 1 / depth;
                        for (var i = 0; i < depth; ++i) {
                            if (this.xVel)
                                this.x += this.xVel * delta * tMlt;
                            if (this.yVel)
                                this.y += this.yVel * delta * tMlt;
                            tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                            for (var x = 0; x < tmpList.length; ++x) {
                                for (var y = 0; y < tmpList[x].length; ++y) {
                                    if (tmpList[x][y].active)
                                        objectManager.checkCollision(this, tmpList[x][y], tMlt);
                                }
                            }
                        }
                        // HITTING:
                        var hitting = false;
                        if (this.hitWait > 0) {
                            this.hitWait -= delta;
                            if (this.hitWait <= 0) {
                                hitting = true;
                                this.hitWait = 0;
                                if (this.leapForce && !UTILS.randInt(0, 2)) {
                                    this.xVel += this.leapForce * Math.cos(this.dir);
                                    this.yVel += this.leapForce * Math.sin(this.dir);
                                }
                                var tmpList = objectManager.getGridArrays(this.x, this.y, this.hitRange);
                                var tmpObj, tmpDst;
                                for (var t = 0; t < tmpList.length; ++t) {
                                    for (var x = 0; x < tmpList[t].length; ++x) {
                                        tmpObj = tmpList[t][x];
                                        if (tmpObj.health) {
                                            tmpDst = UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y);
                                            if (tmpDst < tmpObj.scale + this.hitRange) {
                                                if (tmpObj.changeHealth(-this.dmg * 5))
                                                    objectManager.disableObj(tmpObj);
                                                objectManager.hitObj(tmpObj, UTILS.getDirection(this.x, this.y, tmpObj.x, tmpObj.y));
                                            }
                                        }
                                    }
                                }
                                for (var x = 0; x < players.length; ++x) {
                                    if (players[x].canSee(this)) {
                                        server.send(players[x].id, "aa", this.sid);
                                    }
                                }
                            }
                        }
                        // PLAYER COLLISIONS:
                        if (charging || hitting) {
                            var tmpObj, tmpDst, tmpDir;
                            for (var i = 0; i < players.length; ++i) {
                                tmpObj = players[i];
                                if (tmpObj && tmpObj.alive) {
                                    tmpDst = UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y);
                                    if (this.hitRange) {
                                        if (!this.hitWait && tmpDst <= this.hitRange + tmpObj.scale) {
                                            if (hitting) {
                                                tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                                tmpObj.changeHealth(-this.dmg);
                                                tmpObj.xVel += 0.6 * Math.cos(tmpDir);
                                                tmpObj.yVel += 0.6 * Math.sin(tmpDir);
                                                this.runFrom = null;
                                                this.chargeTarget = null;
                                                this.waitCount = 3000;
                                                this.hitWait = !UTILS.randInt(0, 2) ? 600 : 0;
                                            } else
                                                this.hitWait = this.hitDelay;
                                        }
                                    } else if (tmpDst <= this.scale + tmpObj.scale) {
                                        tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                        tmpObj.changeHealth(-this.dmg);
                                        tmpObj.xVel += 0.55 * Math.cos(tmpDir);
                                        tmpObj.yVel += 0.55 * Math.sin(tmpDir);
                                    }
                                }
                            }
                        }
                        // DECEL:
                        if (this.xVel)
                            this.xVel *= Math.pow(config.playerDecel, delta);
                        if (this.yVel)
                            this.yVel *= Math.pow(config.playerDecel, delta);
                        // MAP BOUNDARIES:
                        var tmpScale = this.scale;
                        if (this.x - tmpScale < 0) {
                            this.x = tmpScale;
                            this.xVel = 0;
                        } else if (this.x + tmpScale > config.mapScale) {
                            this.x = config.mapScale - tmpScale;
                            this.xVel = 0;
                        }
                        if (this.y - tmpScale < 0) {
                            this.y = tmpScale;
                            this.yVel = 0;
                        } else if (this.y + tmpScale > config.mapScale) {
                            this.y = config.mapScale - tmpScale;
                            this.yVel = 0;
                        }
                    }
                }
                ;
                // CAN SEE:
                this.canSee = function(other) {
                    if (!other)
                        return false;
                    if (other.skin && other.skin.invisTimer && other.noMovTimer >= other.skin.invisTimer)
                        return false;
                    var dx = Math.abs(other.x - this.x) - other.scale;
                    var dy = Math.abs(other.y - this.y) - other.scale;
                    return (dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3);
                }
                ;
                var tmpRatio = 0;
                var animIndex = 0;
                this.animate = function(delta) {
                    if (this.animTime > 0) {
                        this.animTime -= delta;
                        if (this.animTime <= 0) {
                            this.animTime = 0;
                            this.dirPlus = 0;
                            tmpRatio = 0;
                            animIndex = 0;
                        } else {
                            if (animIndex == 0) {
                                tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                                if (tmpRatio >= 1) {
                                    tmpRatio = 1;
                                    animIndex = 1;
                                }
                            } else {
                                tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                                this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                            }
                        }
                    }
                }
                ;
                // ANIMATION:
                this.startAnim = function() {
                    this.animTime = this.animSpeed = 600;
                    this.targetAngle = Math.PI * 0.8;
                    tmpRatio = 0;
                    animIndex = 0;
                }
                ;
                // CHANGE HEALTH:
                this.changeHealth = function(val, doer, runFrom) {
                    if (this.active) {
                        this.health += val;
                        if (runFrom) {
                            if (this.hitScare && !UTILS.randInt(0, this.hitScare)) {
                                this.runFrom = runFrom;
                                this.waitCount = 0;
                                this.moveCount = 2000;
                            } else if (this.hostile && this.chargePlayer && runFrom.isPlayer) {
                                this.chargeTarget = runFrom;
                                this.waitCount = 0;
                                this.moveCount = 8000;
                            } else if (!this.dontRun) {
                                this.runFrom = runFrom;
                                this.waitCount = 0;
                                this.moveCount = 2000;
                            }
                        }
                        if (val < 0 && this.hitRange && UTILS.randInt(0, 1))
                            this.hitWait = 500;
                        if (doer && doer.canSee(this) && val < 0) {
                            server.send(doer.id, "t", Math.round(this.x), Math.round(this.y), Math.round(-val), 1);
                        }
                        if (this.health <= 0) {
                            if (this.spawnDelay) {
                                this.spawnCounter = this.spawnDelay;
                                this.x = -1000000;
                                this.y = -1000000;
                            } else {
                                this.x = this.startX || UTILS.randInt(0, config.mapScale);
                                this.y = this.startY || UTILS.randInt(0, config.mapScale);
                            }
                            this.health = this.maxHealth;
                            this.runFrom = null;
                            if (doer) {
                                scoreCallback(doer, this.killScore);
                                if (this.drop) {
                                    for (var i = 0; i < this.drop.length; ) {
                                        doer.addResource(config.resourceTypes.indexOf(this.drop[i]), this.drop[i + 1]);
                                        i += 2;
                                    }
                                }
                            }
                        }
                    }
                }
                ;
            }
            ;
            /***/
        },
        /***/
        "./src/js/data/aiManager.js": /*!**********************************!*\
  !*** ./src/js/data/aiManager.js ***!
  \**********************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            // AI MANAGER:
            module.exports = function(ais, AI, players, items, objectManager, config, UTILS, scoreCallback, server) {
                // AI TYPES:
                this.aiTypes = [{
                    id: 0,
                    src: "cow_1",
                    killScore: 150,
                    health: 500,
                    weightM: 0.8,
                    speed: 0.00095,
                    turnSpeed: 0.001,
                    scale: 72,
                    drop: ["food", 50],
                }, {
                    id: 1,
                    src: "pig_1",
                    killScore: 200,
                    health: 800,
                    weightM: 0.6,
                    speed: 0.00085,
                    turnSpeed: 0.001,
                    scale: 72,
                    drop: ["food", 80],
                }, {
                    id: 2,
                    name: "Bull",
                    src: "bull_2",
                    hostile: true,
                    dmg: 20,
                    killScore: 1000,
                    health: 1800,
                    weightM: 0.5,
                    speed: 0.00094,
                    turnSpeed: 0.00074,
                    scale: 78,
                    viewRange: 800,
                    chargePlayer: true,
                    drop: ["food", 100],
                }, {
                    id: 3,
                    name: "Bully",
                    src: "bull_1",
                    hostile: true,
                    dmg: 20,
                    killScore: 2000,
                    health: 2800,
                    weightM: 0.45,
                    speed: 0.001,
                    turnSpeed: 0.0008,
                    scale: 90,
                    viewRange: 900,
                    chargePlayer: true,
                    drop: ["food", 400],
                }, {
                    id: 4,
                    name: "Wolf",
                    src: "wolf_1",
                    hostile: true,
                    dmg: 8,
                    killScore: 500,
                    health: 300,
                    weightM: 0.45,
                    speed: 0.001,
                    turnSpeed: 0.002,
                    scale: 84,
                    viewRange: 800,
                    chargePlayer: true,
                    drop: ["food", 200],
                }, {
                    id: 5,
                    name: "Quack",
                    src: "chicken_1",
                    dmg: 8,
                    killScore: 2000,
                    noTrap: true,
                    health: 300,
                    weightM: 0.2,
                    speed: 0.0018,
                    turnSpeed: 0.006,
                    scale: 70,
                    drop: ["food", 100],
                }, {
                    id: 6,
                    name: "MOOSTAFA",
                    nameScale: 50,
                    src: "enemy",
                    hostile: true,
                    dontRun: true,
                    fixedSpawn: true,
                    spawnDelay: 60000,
                    noTrap: true,
                    colDmg: 100,
                    dmg: 40,
                    killScore: 8000,
                    health: 18000,
                    weightM: 0.4,
                    speed: 0.0007,
                    turnSpeed: 0.01,
                    scale: 80,
                    spriteMlt: 1.8,
                    leapForce: 0.9,
                    viewRange: 1000,
                    hitRange: 210,
                    hitDelay: 1000,
                    chargePlayer: true,
                    drop: ["food", 100],
                }, {
                    id: 7,
                    name: "Treasure",
                    hostile: true,
                    nameScale: 35,
                    src: "crate_1",
                    fixedSpawn: true,
                    spawnDelay: 120000,
                    colDmg: 200,
                    killScore: 5000,
                    health: 20000,
                    weightM: 0.1,
                    speed: 0.0,
                    turnSpeed: 0.0,
                    scale: 70,
                    spriteMlt: 1.0,
                }, {
                    id: 8,
                    name: "MOOFIE",
                    src: "wolf_2",
                    hostile: true,
                    fixedSpawn: true,
                    dontRun: true,
                    hitScare: 4,
                    spawnDelay: 30000,
                    noTrap: true,
                    nameScale: 35,
                    dmg: 10,
                    colDmg: 100,
                    killScore: 3000,
                    health: 7000,
                    weightM: 0.45,
                    speed: 0.0015,
                    turnSpeed: 0.002,
                    scale: 90,
                    viewRange: 800,
                    chargePlayer: true,
                    drop: ["food", 1000],
                }, ];
                // SPAWN AI:
                this.spawn = function(x, y, dir, index) {
                    var tmpObj;
                    for (var i = 0; i < ais.length; ++i) {
                        if (!ais[i].active) {
                            tmpObj = ais[i];
                            break;
                        }
                    }
                    if (!tmpObj) {
                        tmpObj = new AI(ais.length,objectManager,players,items,UTILS,config,scoreCallback,server);
                        ais.push(tmpObj);
                    }
                    tmpObj.init(x, y, dir, index, this.aiTypes[index]);
                    return tmpObj;
                }
                ;
            }
            ;
            /***/
        },
        /***/
        "./src/js/data/gameObject.js": /*!***********************************!*\
  !*** ./src/js/data/gameObject.js ***!
  \***********************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            module.exports = function(sid) {
                this.sid = sid;
                // INIT:
                this.init = function(x, y, dir, scale, type, data, owner) {
                    data = data || {};
                    this.sentTo = {};
                    this.gridLocations = [];
                    this.active = true;
                    this.doUpdate = data.doUpdate;
                    this.shootReload = 2200 - (1000 / 9) * 2;
                    this.shootted = 0;
                    this.x = x;
                    this.y = y;
                    this.dir = dir;
                    this.xWiggle = 0;
                    this.yWiggle = 0;
                    this.scale = scale;
                    this.type = type;
                    this.id = data.id;
                    this.owner = owner;
                    this.name = data.name;
                    this.isItem = this.id != undefined;
                    this.group = data.group;
                    this.health = data.health;
                    this.buildHealth = data.health;
                    this.layer = 2;
                    if (this.group != undefined) {
                        this.layer = this.group.layer;
                    } else if (this.type == 0) {
                        this.layer = 3;
                    } else if (this.type == 2) {
                        this.layer = 0;
                    } else if (this.type == 4) {
                        this.layer = -1;
                    }
                    this.colDiv = data.colDiv || 1;
                    this.blocker = data.blocker;
                    this.ignoreCollision = data.ignoreCollision;
                    this.dontGather = data.dontGather;
                    this.hideFromEnemy = data.hideFromEnemy;
                    this.friction = data.friction;
                    this.projDmg = data.projDmg;
                    this.dmg = data.dmg;
                    this.pDmg = data.pDmg;
                    this.pps = data.pps;
                    this.zIndex = data.zIndex || 0;
                    this.turnSpeed = data.turnSpeed;
                    this.req = data.req;
                    this.trap = data.trap;
                    this.healCol = data.healCol;
                    this.teleport = data.teleport;
                    this.boostSpeed = data.boostSpeed;
                    this.projectile = data.projectile;
                    this.shootRange = data.shootRange;
                    this.shootRate = data.shootRate;
                    this.shootCount = this.shootRate;
                    this.spawnPoint = data.spawnPoint;
                }
                ;
                // GET HIT:
                this.changeHealth = function(amount, doer) {
                    this.health += amount;
                    return this.health <= 0;
                }
                ;
                // GET SCALE:
                this.getScale = function(sM, ig) {
                    sM = sM || 1;
                    return (this.scale * (this.isItem || this.type == 2 || this.type == 3 || this.type == 4 ? 1 : 0.6 * sM) * (ig ? 1 : this.colDiv));
                }
                ;
                // VISIBLE TO PLAYER:
                this.visibleToPlayer = function(player) {
                    return (!this.hideFromEnemy || (this.owner && (this.owner == player || (this.owner.team && player.team == this.owner.team))));
                }
                ;
                // UPDATE:
                this.update = function(delta) {
                    if (this.active) {
                        if (this.xWiggle) {
                            this.xWiggle *= Math.pow(0.99, delta);
                        }
                        if (this.yWiggle) {
                            this.yWiggle *= Math.pow(0.99, delta);
                        }
                        if (getEl("visual").value != "zyenith" && this.turnSpeed && (getEl("visual").value == "0" ? true : !this.pps)) {
                            this.dir += this.turnSpeed * delta;
                        }
                    }
                }
                ;
            }
            ;
            /***/
        },
        /***/
        "./src/js/data/items.js": /*!******************************!*\
  !*** ./src/js/data/items.js ***!
  \******************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            // ITEM GROUPS:
            module.exports.groups = [{
                id: 0,
                name: "food",
                layer: 0,
            }, {
                id: 1,
                name: "walls",
                place: true,
                limit: 30,
                layer: 0,
            }, {
                id: 2,
                name: "spikes",
                place: true,
                limit: 15,
                layer: 0,
            }, {
                id: 3,
                name: "mill",
                place: true,
                limit: 7,
                layer: 1,
            }, {
                id: 4,
                name: "mine",
                place: true,
                limit: 1,
                layer: 0,
            }, {
                id: 5,
                name: "trap",
                place: true,
                limit: 6,
                layer: -1,
            }, {
                id: 6,
                name: "booster",
                place: true,
                limit: 12,
                layer: -1,
            }, {
                id: 7,
                name: "turret",
                place: true,
                limit: 2,
                layer: 1,
            }, {
                id: 8,
                name: "watchtower",
                place: true,
                limit: 12,
                layer: 1,
            }, {
                id: 9,
                name: "buff",
                place: true,
                limit: 4,
                layer: -1,
            }, {
                id: 10,
                name: "spawn",
                place: true,
                limit: 1,
                layer: -1,
            }, {
                id: 11,
                name: "sapling",
                place: true,
                limit: 2,
                layer: 0,
            }, {
                id: 12,
                name: "blocker",
                place: true,
                limit: 3,
                layer: -1,
            }, {
                id: 13,
                name: "teleporter",
                place: true,
                limit: 2,
                layer: -1,
            }, ];
            // PROJECTILES:
            exports.projectiles = [{
                indx: 0,
                layer: 0,
                src: "arrow_1",
                dmg: 25,
                speed: 1.6,
                scale: 103,
                range: 1000,
            }, {
                indx: 1,
                layer: 1,
                dmg: 25,
                scale: 20,
            }, {
                indx: 0,
                layer: 0,
                src: "arrow_1",
                dmg: 35,
                speed: 2.5,
                scale: 103,
                range: 1200,
            }, {
                indx: 0,
                layer: 0,
                src: "arrow_1",
                dmg: 30,
                speed: 2,
                scale: 103,
                range: 1200,
            }, {
                indx: 1,
                layer: 1,
                dmg: 16,
                scale: 20,
            }, {
                indx: 0,
                layer: 0,
                src: "bullet_1",
                dmg: 50,
                speed: 3.6,
                scale: 160,
                range: 1400,
            }, ];
            // WEAPONS:
            exports.weapons = [{
                id: 0,
                type: 0,
                name: "tool hammer",
                desc: "tool for gathering all resources",
                src: "hammer_1",
                length: 140,
                width: 140,
                xOff: -3,
                yOff: 18,
                dmg: 25,
                dmg2: 25,
                range: 65,
                gather: 1,
                speed: 300,
            }, {
                id: 1,
                type: 0,
                age: 2,
                name: "hand axe",
                desc: "gathers resources at a higher rate",
                src: "axe_1",
                length: 140,
                width: 140,
                xOff: 3,
                yOff: 24,
                dmg: 30,
                dmg2: 30,
                spdMult: 1,
                range: 70,
                gather: 2,
                speed: 400,
            }, {
                id: 2,
                type: 0,
                age: 8,
                pre: 1,
                name: "great axe",
                desc: "deal more damage and gather more resources",
                src: "great_axe_1",
                length: 140,
                width: 140,
                xOff: -8,
                yOff: 25,
                dmg: 35,
                dmg2: 35,
                spdMult: 1,
                range: 75,
                gather: 4,
                speed: 400,
            }, {
                id: 3,
                type: 0,
                age: 2,
                name: "short sword",
                desc: "increased attack power but slower move speed",
                src: "sword_1",
                iPad: 1.3,
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 46,
                dmg: 35,
                dmg2: 35,
                spdMult: 0.85,
                range: 110,
                gather: 1,
                speed: 300,
            }, {
                id: 4,
                type: 0,
                age: 8,
                pre: 3,
                name: "katana",
                desc: "greater range and damage",
                src: "samurai_1",
                iPad: 1.3,
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 59,
                dmg: 40,
                dmg2: 40,
                spdMult: 0.8,
                range: 118,
                gather: 1,
                speed: 300,
            }, {
                id: 5,
                type: 0,
                age: 2,
                name: "polearm",
                desc: "long range melee weapon",
                src: "spear_1",
                iPad: 1.3,
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 53,
                dmg: 45,
                dmg2: 45,
                knock: 0.2,
                spdMult: 0.82,
                range: 142,
                gather: 1,
                speed: 700,
            }, {
                id: 6,
                type: 0,
                age: 2,
                name: "bat",
                desc: "fast long range melee weapon",
                src: "bat_1",
                iPad: 1.3,
                length: 110,
                width: 180,
                xOff: -8,
                yOff: 53,
                dmg: 20,
                dmg2: 20,
                knock: 0.7,
                range: 110,
                gather: 1,
                speed: 300,
            }, {
                id: 7,
                type: 0,
                age: 2,
                name: "daggers",
                desc: "really fast short range weapon",
                src: "dagger_1",
                iPad: 0.8,
                length: 110,
                width: 110,
                xOff: 18,
                yOff: 0,
                dmg: 20,
                dmg2: 20,
                knock: 0.1,
                range: 65,
                gather: 1,
                hitSlow: 0.1,
                spdMult: 1.13,
                speed: 100,
            }, {
                id: 8,
                type: 0,
                age: 2,
                name: "stick",
                desc: "great for gathering but very weak",
                src: "stick_1",
                length: 140,
                width: 140,
                xOff: 3,
                yOff: 24,
                dmg: 1,
                dmg2: 1,
                spdMult: 1,
                range: 70,
                gather: 7,
                speed: 400,
            }, {
                id: 9,
                type: 1,
                age: 6,
                name: "hunting bow",
                desc: "bow used for ranged combat and hunting",
                src: "bow_1",
                req: ["wood", 4],
                length: 120,
                width: 120,
                xOff: -6,
                yOff: 0,
                Pdmg: 25,
                projectile: 0,
                spdMult: 0.75,
                speed: 600,
            }, {
                id: 10,
                type: 1,
                age: 6,
                name: "great hammer",
                desc: "hammer used for destroying structures",
                src: "great_hammer_1",
                length: 140,
                width: 140,
                xOff: -9,
                yOff: 25,
                dmg: 10,
                Pdmg: 10,
                spdMult: 0.88,
                range: 75,
                sDmg: 7.5,
                gather: 1,
                speed: 400,
            }, {
                id: 11,
                type: 1,
                age: 6,
                name: "wooden shield",
                desc: "blocks projectiles and reduces melee damage",
                src: "shield_1",
                length: 120,
                width: 120,
                shield: 0.2,
                xOff: 6,
                yOff: 0,
                Pdmg: 0,
                spdMult: 0.7,
            }, {
                id: 12,
                type: 1,
                age: 8,
                pre: 9,
                name: "crossbow",
                desc: "deals more damage and has greater range",
                src: "crossbow_1",
                req: ["wood", 5],
                aboveHand: true,
                armS: 0.75,
                length: 120,
                width: 120,
                xOff: -4,
                yOff: 0,
                Pdmg: 35,
                projectile: 2,
                spdMult: 0.7,
                speed: 700,
            }, {
                id: 13,
                type: 1,
                age: 9,
                pre: 12,
                name: "repeater crossbow",
                desc: "high firerate crossbow with reduced damage",
                src: "crossbow_2",
                req: ["wood", 10],
                aboveHand: true,
                armS: 0.75,
                length: 120,
                width: 120,
                xOff: -4,
                yOff: 0,
                Pdmg: 30,
                projectile: 3,
                spdMult: 0.7,
                speed: 230,
            }, {
                id: 14,
                type: 1,
                age: 6,
                name: "mc grabby",
                desc: "steals resources from enemies",
                src: "grab_1",
                length: 130,
                width: 210,
                xOff: -8,
                yOff: 53,
                dmg: 0,
                Pdmg: 0,
                steal: 250,
                knock: 0.2,
                spdMult: 1.05,
                range: 125,
                gather: 0,
                speed: 700,
            }, {
                id: 15,
                type: 1,
                age: 9,
                pre: 12,
                name: "musket",
                desc: "slow firerate but high damage and range",
                src: "musket_1",
                req: ["stone", 10],
                aboveHand: true,
                rec: 0.35,
                armS: 0.6,
                hndS: 0.3,
                hndD: 1.6,
                length: 205,
                width: 205,
                xOff: 25,
                yOff: 0,
                Pdmg: 50,
                projectile: 5,
                hideProjectile: true,
                spdMult: 0.6,
                speed: 1500,
            }, ];
            // ITEMS:
            module.exports.list = [{
                group: module.exports.groups[0],
                name: "apple",
                desc: "restores 20 health when consumed",
                req: ["food", 10],
                consume: function(doer) {
                    return doer.changeHealth(20, doer);
                },
                scale: 22,
                holdOffset: 15,
                healing: 20,
            }, {
                age: 3,
                group: module.exports.groups[0],
                name: "cookie",
                desc: "restores 40 health when consumed",
                req: ["food", 15],
                consume: function(doer) {
                    return doer.changeHealth(40, doer);
                },
                scale: 27,
                holdOffset: 15,
                healing: 40,
            }, {
                age: 7,
                group: module.exports.groups[0],
                name: "cheese",
                desc: "restores 30 health and another 50 over 5 seconds",
                req: ["food", 25],
                consume: function(doer) {
                    if (doer.changeHealth(30, doer) || doer.health < 100) {
                        doer.dmgOverTime.dmg = -10;
                        doer.dmgOverTime.doer = doer;
                        doer.dmgOverTime.time = 5;
                        return true;
                    }
                    return false;
                },
                scale: 27,
                holdOffset: 15,
                healing: 30,
            }, {
                group: module.exports.groups[1],
                name: "wood wall",
                desc: "provides protection for your village",
                req: ["wood", 10],
                projDmg: true,
                health: 380,
                scale: 50,
                holdOffset: 20,
                placeOffset: -5,
            }, {
                age: 3,
                group: module.exports.groups[1],
                name: "stone wall",
                desc: "provides improved protection for your village",
                req: ["stone", 25],
                health: 900,
                scale: 50,
                holdOffset: 20,
                placeOffset: -5,
            }, {
                age: 7,
                group: module.exports.groups[1],
                name: "castle wall",
                desc: "provides powerful protection for your village",
                req: ["stone", 35],
                health: 1500,
                scale: 52,
                holdOffset: 20,
                placeOffset: -5,
            }, {
                group: module.exports.groups[2],
                name: "spikes",
                desc: "damages enemies when they touch them",
                req: ["wood", 20, "stone", 5],
                health: 400,
                dmg: 20,
                scale: 49,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5,
            }, {
                age: 5,
                group: module.exports.groups[2],
                name: "greater spikes",
                desc: "damages enemies when they touch them",
                req: ["wood", 30, "stone", 10],
                health: 500,
                dmg: 35,
                scale: 52,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5,
            }, {
                age: 9,
                group: module.exports.groups[2],
                name: "poison spikes",
                desc: "poisons enemies when they touch them",
                req: ["wood", 35, "stone", 15],
                health: 600,
                dmg: 30,
                pDmg: 5,
                scale: 52,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5,
            }, {
                age: 9,
                group: module.exports.groups[2],
                name: "spinning spikes",
                desc: "damages enemies when they touch them",
                req: ["wood", 30, "stone", 20],
                health: 500,
                dmg: 45,
                turnSpeed: 0.003,
                scale: 52,
                spritePadding: -23,
                holdOffset: 8,
                placeOffset: -5,
            }, {
                group: module.exports.groups[3],
                name: "windmill",
                desc: "generates gold over time",
                req: ["wood", 50, "stone", 10],
                health: 400,
                pps: 1,
                turnSpeed: 0.0016,
                spritePadding: 25,
                iconLineMult: 12,
                scale: 45,
                holdOffset: 20,
                placeOffset: 5,
            }, {
                age: 5,
                group: module.exports.groups[3],
                name: "faster windmill",
                desc: "generates more gold over time",
                req: ["wood", 60, "stone", 20],
                health: 500,
                pps: 1.5,
                turnSpeed: 0.0025,
                spritePadding: 25,
                iconLineMult: 12,
                scale: 47,
                holdOffset: 20,
                placeOffset: 5,
            }, {
                age: 8,
                group: module.exports.groups[3],
                name: "power mill",
                desc: "generates more gold over time",
                req: ["wood", 100, "stone", 50],
                health: 800,
                pps: 2,
                turnSpeed: 0.005,
                spritePadding: 25,
                iconLineMult: 12,
                scale: 47,
                holdOffset: 20,
                placeOffset: 5,
            }, {
                age: 5,
                group: module.exports.groups[4],
                type: 2,
                name: "mine",
                desc: "allows you to mine stone",
                req: ["wood", 20, "stone", 100],
                iconLineMult: 12,
                scale: 65,
                holdOffset: 20,
                placeOffset: 0,
            }, {
                age: 5,
                group: module.exports.groups[11],
                type: 0,
                name: "sapling",
                desc: "allows you to farm wood",
                req: ["wood", 150],
                iconLineMult: 12,
                colDiv: 0.5,
                scale: 110,
                holdOffset: 50,
                placeOffset: -15,
            }, {
                age: 4,
                group: module.exports.groups[5],
                name: "pit trap",
                desc: "pit that traps enemies if they walk over it",
                req: ["wood", 30, "stone", 30],
                trap: true,
                ignoreCollision: true,
                hideFromEnemy: true,
                health: 500,
                colDiv: 0.2,
                scale: 50,
                holdOffset: 20,
                placeOffset: -5,
            }, {
                age: 4,
                group: module.exports.groups[6],
                name: "boost pad",
                desc: "provides boost when stepped on",
                req: ["stone", 20, "wood", 5],
                ignoreCollision: true,
                boostSpeed: 1.5,
                health: 150,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5,
            }, {
                age: 7,
                group: module.exports.groups[7],
                doUpdate: true,
                name: "turret",
                desc: "defensive structure that shoots at enemies",
                req: ["wood", 200, "stone", 150],
                health: 800,
                projectile: 1,
                shootRange: 700,
                shootRate: 2200,
                scale: 43,
                holdOffset: 20,
                placeOffset: -5,
            }, {
                age: 7,
                group: module.exports.groups[8],
                name: "platform",
                desc: "platform to shoot over walls and cross over water",
                req: ["wood", 20],
                ignoreCollision: true,
                zIndex: 1,
                health: 300,
                scale: 43,
                holdOffset: 20,
                placeOffset: -5,
            }, {
                age: 7,
                group: module.exports.groups[9],
                name: "healing pad",
                desc: "standing on it will slowly heal you",
                req: ["wood", 30, "food", 10],
                ignoreCollision: true,
                healCol: 15,
                health: 400,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5,
            }, {
                age: 9,
                group: module.exports.groups[10],
                name: "spawn pad",
                desc: "you will spawn here when you die but it will dissapear",
                req: ["wood", 100, "stone", 100],
                health: 400,
                ignoreCollision: true,
                spawnPoint: true,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5,
            }, {
                age: 7,
                group: module.exports.groups[12],
                name: "blocker",
                desc: "blocks building in radius",
                req: ["wood", 30, "stone", 25],
                ignoreCollision: true,
                blocker: 300,
                health: 400,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5,
            }, {
                age: 7,
                group: module.exports.groups[13],
                name: "teleporter",
                desc: "teleports you to a random point on the map",
                req: ["wood", 60, "stone", 60],
                ignoreCollision: true,
                teleport: true,
                health: 200,
                colDiv: 0.7,
                scale: 45,
                holdOffset: 20,
                placeOffset: -5,
            }, ];
            // ASSIGN IDS:
            for (var i = 0; i < module.exports.list.length; ++i) {
                module.exports.list[i].id = i;
                if (module.exports.list[i].pre)
                    module.exports.list[i].pre = i - module.exports.list[i].pre;
            }
            // TROLOLOLOL:
            if (typeof window !== "undefined") {
                function shuffle(a) {
                    for (let i = a.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [a[i],a[j]] = [a[j], a[i]];
                    }
                    return a;
                }
            }
            /***/
        },
        /***/
        "./src/js/data/mapManager.js": /*!***********************************!*\
  !*** ./src/js/data/mapManager.js ***!
  \***********************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            // GLOBAL MAPMANAGER:
            module.exports = {};
            /***/
        },
        /***/
        "./src/js/data/objectManager.js": /*!**************************************!*\
  !*** ./src/js/data/objectManager.js ***!
  \**************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            var mathFloor = Math.floor;
            var mathABS = Math.abs;
            var mathCOS = Math.cos;
            var mathSIN = Math.sin;
            var mathPOW = Math.pow;
            var mathSQRT = Math.sqrt;
            module.exports = function(GameObject, gameObjects, UTILS, config, players, server) {
                this.objects = gameObjects;
                this.grids = {};
                this.updateObjects = [];
                // SET OBJECT GRIDS:
                var tmpX, tmpY;
                var tmpS = config.mapScale / config.colGrid;
                this.setObjectGrids = function(obj) {
                    var objX = Math.min(config.mapScale, Math.max(0, obj.x));
                    var objY = Math.min(config.mapScale, Math.max(0, obj.y));
                    for (var x = 0; x < config.colGrid; ++x) {
                        tmpX = x * tmpS;
                        for (var y = 0; y < config.colGrid; ++y) {
                            tmpY = y * tmpS;
                            if (objX + obj.scale >= tmpX && objX - obj.scale <= tmpX + tmpS && objY + obj.scale >= tmpY && objY - obj.scale <= tmpY + tmpS) {
                                if (!this.grids[x + "_" + y])
                                    this.grids[x + "_" + y] = [];
                                this.grids[x + "_" + y].push(obj);
                                obj.gridLocations.push(x + "_" + y);
                            }
                        }
                    }
                }
                ;
                // REMOVE OBJECT FROM GRID:
                this.removeObjGrid = function(obj) {
                    var tmpIndx;
                    for (var i = 0; i < obj.gridLocations.length; ++i) {
                        tmpIndx = this.grids[obj.gridLocations[i]].indexOf(obj);
                        if (tmpIndx >= 0) {
                            this.grids[obj.gridLocations[i]].splice(tmpIndx, 1);
                        }
                    }
                }
                ;
                // DISABLE OBJ:
                this.disableObj = function(obj) {
                    obj.active = false;
                    if (server) {
                        if (obj.owner && obj.pps)
                            obj.owner.pps -= obj.pps;
                        this.removeObjGrid(obj);
                        var tmpIndx = this.updateObjects.indexOf(obj);
                        if (tmpIndx >= 0) {
                            this.updateObjects.splice(tmpIndx, 1);
                        }
                    }
                }
                ;
                // HIT OBJECT:
                this.hitObj = function(tmpObj, tmpDir) {
                    for (var p = 0; p < players.length; ++p) {
                        if (players[p].active) {
                            if (tmpObj.sentTo[players[p].id]) {
                                if (!tmpObj.active)
                                    server.send(players[p].id, "12", tmpObj.sid);
                                else if (players[p].canSee(tmpObj))
                                    server.send(players[p].id, "8", UTILS.fixTo(tmpDir, 1), tmpObj.sid);
                            }
                            if (!tmpObj.active && tmpObj.owner == players[p])
                                players[p].changeItemCount(tmpObj.group.id, -1);
                        }
                    }
                }
                ;
                // GET GRID ARRAY:
                var tmpArray = [];
                var tmpGrid;
                this.getGridArrays = function(xPos, yPos, s) {
                    tmpX = mathFloor(xPos / tmpS);
                    tmpY = mathFloor(yPos / tmpS);
                    tmpArray.length = 0;
                    try {
                        if (this.grids[tmpX + "_" + tmpY])
                            tmpArray.push(this.grids[tmpX + "_" + tmpY]);
                        if (xPos + s >= (tmpX + 1) * tmpS) {
                            // RIGHT
                            tmpGrid = this.grids[tmpX + 1 + "_" + tmpY];
                            if (tmpGrid)
                                tmpArray.push(tmpGrid);
                            if (tmpY && yPos - s <= tmpY * tmpS) {
                                // TOP RIGHT
                                tmpGrid = this.grids[tmpX + 1 + "_" + (tmpY - 1)];
                                if (tmpGrid)
                                    tmpArray.push(tmpGrid);
                            } else if (yPos + s >= (tmpY + 1) * tmpS) {
                                // BOTTOM RIGHT
                                tmpGrid = this.grids[tmpX + 1 + "_" + (tmpY + 1)];
                                if (tmpGrid)
                                    tmpArray.push(tmpGrid);
                            }
                        }
                        if (tmpX && xPos - s <= tmpX * tmpS) {
                            // LEFT
                            tmpGrid = this.grids[tmpX - 1 + "_" + tmpY];
                            if (tmpGrid)
                                tmpArray.push(tmpGrid);
                            if (tmpY && yPos - s <= tmpY * tmpS) {
                                // TOP LEFT
                                tmpGrid = this.grids[tmpX - 1 + "_" + (tmpY - 1)];
                                if (tmpGrid)
                                    tmpArray.push(tmpGrid);
                            } else if (yPos + s >= (tmpY + 1) * tmpS) {
                                // BOTTOM LEFT
                                tmpGrid = this.grids[tmpX - 1 + "_" + (tmpY + 1)];
                                if (tmpGrid)
                                    tmpArray.push(tmpGrid);
                            }
                        }
                        if (yPos + s >= (tmpY + 1) * tmpS) {
                            // BOTTOM
                            tmpGrid = this.grids[tmpX + "_" + (tmpY + 1)];
                            if (tmpGrid)
                                tmpArray.push(tmpGrid);
                        }
                        if (tmpY && yPos - s <= tmpY * tmpS) {
                            // TOP
                            tmpGrid = this.grids[tmpX + "_" + (tmpY - 1)];
                            if (tmpGrid)
                                tmpArray.push(tmpGrid);
                        }
                    } catch (e) {}
                    return tmpArray;
                }
                ;
                // ADD NEW:
                var tmpObj;
                this.add = function(sid, x, y, dir, s, type, data, setSID, owner) {
                    tmpObj = gameObjects.find((tmp)=>tmp.sid == sid);
                    if (!tmpObj) {
                        tmpObj = gameObjects.find((tmp)=>!tmp.active);
                        if (!tmpObj) {
                            tmpObj = new GameObject(sid);
                            gameObjects.push(tmpObj);
                        }
                    }
                    if (setSID)
                        tmpObj.sid = sid;
                    tmpObj.init(x, y, dir, s, type, data, owner);
                    if (server) {
                        this.setObjectGrids(tmpObj);
                        if (tmpObj.doUpdate)
                            this.updateObjects.push(tmpObj);
                    }
                }
                ;
                // DISABLE BY SID:
                this.disableBySid = function(sid) {
                    let find = gameObjects.find((tmp)=>tmp.sid == sid);
                    if (find) {
                        this.disableObj(find);
                    }
                }
                ;
                // REMOVE ALL FROM PLAYER:
                this.removeAllItems = function(sid, server) {
                    gameObjects.filter((tmp)=>tmp.active && tmp.owner && tmp.owner.sid == sid).forEach((tmp)=>this.disableObj(tmp));
                    if (server) {
                        server.broadcast("13", sid);
                    }
                }
                ;
                // FETCH SPAWN OBJECT:
                this.fetchSpawnObj = function(sid) {
                    var tmpLoc = null;
                    for (var i = 0; i < gameObjects.length; ++i) {
                        tmpObj = gameObjects[i];
                        if (tmpObj.active && tmpObj.owner && tmpObj.owner.sid == sid && tmpObj.spawnPoint) {
                            tmpLoc = [tmpObj.x, tmpObj.y];
                            this.disableObj(tmpObj);
                            server.broadcast("12", tmpObj.sid);
                            if (tmpObj.owner) {
                                tmpObj.owner.changeItemCount(tmpObj.group.id, -1);
                            }
                            break;
                        }
                    }
                    return tmpLoc;
                }
                ;
                // CHECK IF PLACABLE:
                this.checkItemLocation = function(x, y, s, sM, indx, ignoreWater, placer) {
                    let cantPlace = gameObjects.find((tmp)=>tmp.active && UTILS.getDistance(x, y, tmp.x, tmp.y) < s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem)));
                    if (cantPlace) {
                        return false;
                    }
                    if (!ignoreWater && indx != 18 && y >= config.mapScale / 2 - config.riverWidth / 2 && y <= config.mapScale / 2 + config.riverWidth / 2) {
                        return false;
                    }
                    return true;
                }
                ;
                // ADD PROJECTILE:
                this.addProjectile = function(x, y, dir, range, indx) {
                    var tmpData = items.projectiles[indx];
                    var tmpProj = projectiles.find((tmp)=>!tmp.active);
                    if (!tmpProj) {
                        tmpProj = new Projectile(players,UTILS);
                        projectiles.push(tmpProj);
                    }
                    tmpProj.init(indx, x, y, dir, tmpData.speed, range, tmpData.scale);
                }
                ;
                // CHECK PLAYER COLLISION:
                this.checkCollision = function(player, other, delta) {
                    delta = delta || 1;
                    var dx = player.x - other.x;
                    var dy = player.y - other.y;
                    var tmpLen = player.scale + other.scale;
                    if (mathABS(dx) <= tmpLen || mathABS(dy) <= tmpLen) {
                        tmpLen = player.scale + (other.getScale ? other.getScale() : other.scale);
                        var tmpInt = mathSQRT(dx * dx + dy * dy) - tmpLen;
                        if (tmpInt <= 0) {
                            if (!other.ignoreCollision) {
                                var tmpDir = UTILS.getDirection(player.x, player.y, other.x, other.y);
                                var tmpDist = UTILS.getDistance(player.x, player.y, other.x, other.y);
                                if (other.isPlayer) {
                                    tmpInt = (tmpInt * -1) / 2;
                                    player.x += tmpInt * mathCOS(tmpDir);
                                    player.y += tmpInt * mathSIN(tmpDir);
                                    other.x -= tmpInt * mathCOS(tmpDir);
                                    other.y -= tmpInt * mathSIN(tmpDir);
                                } else {
                                    player.x = other.x + tmpLen * mathCOS(tmpDir);
                                    player.y = other.y + tmpLen * mathSIN(tmpDir);
                                    player.xVel *= 0.75;
                                    player.yVel *= 0.75;
                                }
                                if (other.dmg && other.owner != player && !(other.owner && other.owner.team && other.owner.team == player.team)) {
                                    player.changeHealth(-other.dmg, other.owner, other);
                                    var tmpSpd = 1.5 * (other.weightM || 1);
                                    player.xVel += tmpSpd * mathCOS(tmpDir);
                                    player.yVel += tmpSpd * mathSIN(tmpDir);
                                    if (other.pDmg && !(player.skin && player.skin.poisonRes)) {
                                        player.dmgOverTime.dmg = other.pDmg;
                                        player.dmgOverTime.time = 5;
                                        player.dmgOverTime.doer = other.owner;
                                    }
                                    if (player.colDmg && other.health) {
                                        if (other.changeHealth(-player.colDmg))
                                            this.disableObj(other);
                                        this.hitObj(other, UTILS.getDirection(player.x, player.y, other.x, other.y));
                                    }
                                }
                            } else if (other.trap && !player.noTrap && other.owner != player && !(other.owner && other.owner.team && other.owner.team == player.team)) {
                                player.lockMove = true;
                                other.hideFromEnemy = false;
                            } else if (other.boostSpeed) {
                                player.xVel += delta * other.boostSpeed * (other.weightM || 1) * mathCOS(other.dir);
                                player.yVel += delta * other.boostSpeed * (other.weightM || 1) * mathSIN(other.dir);
                            } else if (other.healCol) {
                                player.healCol = other.healCol;
                            } else if (other.teleport) {
                                player.x = UTILS.randInt(0, config.mapScale);
                                player.y = UTILS.randInt(0, config.mapScale);
                            }
                            if (other.zIndex > player.zIndex)
                                player.zIndex = other.zIndex;
                            return true;
                        }
                    }
                    return false;
                }
                ;
            }
            ;
            /***/
        },
        /***/
        "./src/js/data/player.js": /*!*******************************!*\
  !*** ./src/js/data/player.js ***!
  \*******************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            var LangFilter = __webpack_require__(/*! bad-words */
                "./node_modules/bad-words/lib/badwords.js");
            var langFilter = new LangFilter();
            var newProfane = ["jew", "black", "baby", "child", "white", "porn", "pedo", "trump", "clinton", "hitler", "nazi", "gay", "pride", "sex", "pleasure", "touch", "poo", "kids", "rape", "white power", "nigga", "nig nog", "doggy", "rapist", "boner", "nigger", "nigg", "finger", "nogger", "nagger", "nig", "fag", "gai", "pole", "stripper", "penis", "vagina", "pussy", "nazi", "hitler", "stalin", "burn", "chamber", "cock", "peen", "dick", "spick", "nieger", "die", "satan", "n|ig", "nlg", "cunt", "c0ck", "fag", "lick", "condom", "anal", "shit", "phile", "little", "kids", "free KR", "tiny", "sidney", "ass", "kill", ".io", "(dot)", "[dot]", "mini", "whiore", "whore", "faggot", "github", "1337", "666", "satan", "senpa", "discord", "d1scord", "mistik", ".io", "senpa.io", "sidney", "sid", "senpaio", "vries", "asa", ];
            langFilter.addWords(...newProfane);
            var mathABS = Math.abs;
            var mathCOS = Math.cos;
            var mathSIN = Math.sin;
            var mathPOW = Math.pow;
            var mathSQRT = Math.sqrt;
            module.exports = function(id, sid, config, UTILS, projectileManager, objectManager, players, ais, items, hats, accessories, server, scoreCallback, iconCallback) {
                this.id = id;
                this.sid = sid;
                this.tmpScore = 0;
                this.team = null;
                this.skinIndex = 0;
                this.tailIndex = 0;
                this.hitTime = 0;
                this.tails = {};
                for (var i = 0; i < accessories.length; ++i) {
                    if (accessories[i].price <= 0)
                        this.tails[accessories[i].id] = 1;
                }
                this.skins = {};
                for (var i = 0; i < hats.length; ++i) {
                    if (hats[i].price <= 0)
                        this.skins[hats[i].id] = 1;
                }
                this.points = 0;
                this.dt = 0;
                this.rt = 0;
                this.hidden = false;
                this.itemCounts = {};
                this.isPlayer = true;
                this.pps = 0;
                this.moveDir = undefined;
                this.skinRot = 0;
                this.lastPing = 0;
                this.iconIndex = 0;
                this.skinColor = 0;
                this.dangerShame = 5;
                this.projDist = 0;
                // SPAWN:
                this.spawn = function(moofoll) {
                    // ADDED MODULES:
                    this.finded = 0;
                    this.syncThreats = 0;
                    this.primaryIndex = undefined;
                    this.secondaryIndex = undefined;
                    this.primaryVariant = undefined;
                    this.secondaryVariant = undefined;
                    this.gatherIndex = undefined;
                    this.shootIndex = undefined;
                    this.bowThreat = {
                        9: 0,
                        12: 0,
                        13: 0,
                        15: 0,
                    };
                    this.aim2 = 0;
                    this.dist2 = 0;
                    this.aim3 = 0;
                    this.dist3 = 0;
                    this.notHere = false;
                    this.bTick = 0;
                    this.pCount = 0;
                    this.hitted = false;
                    this.anti = false;
                    this.healSid = -1;
                    this.damaged = false;
                    this.active = true;
                    this.alive = true;
                    this.lockMove = false;
                    this.lockDir = false;
                    this.minimapCounter = 0;
                    this.chatCountdown = 0;
                    this.shameCount = 0;
                    this.shameTimer = 0;
                    this.antiClown = 4;
                    this.maxShame = 7;
                    this.sentTo = {};
                    this.gathering = 0;
                    this.shooting = {};
                    this.autoGather = 0;
                    this.animTime = 0;
                    this.animSpeed = 0;
                    this.mouseState = 0;
                    this.buildIndex = -1;
                    this.weaponIndex = 0;
                    this.dmgOverTime = {};
                    this.noMovTimer = 0;
                    this.maxXP = 300;
                    this.XP = 0;
                    this.age = 1;
                    this.kills = 0;
                    this.upgrAge = 2;
                    this.upgradePoints = 0;
                    this.x = 0;
                    this.y = 0;
                    this.zIndex = 0;
                    this.xVel = 0;
                    this.yVel = 0;
                    this.slowMult = 1;
                    this.dir = 0;
                    this.dirPlus = 0;
                    this.targetDir = 0;
                    this.targetAngle = 0;
                    this.maxHealth = 100;
                    this.health = this.maxHealth;
                    this.scale = config.playerScale;
                    this.speed = config.playerSpeed;
                    this.resetMoveDir();
                    this.resetResources(moofoll);
                    this.firstItems = [0, 3, 6, 10];
                    this.items = [0, 3, 6, 10];
                    this.weapons = [0];
                    this.shootCount = 0;
                    this.weaponXP = [];
                    this.reloads = {
                        0: 0,
                        1: 0,
                        2: 0,
                        3: 0,
                        4: 0,
                        5: 0,
                        6: 0,
                        7: 0,
                        8: 0,
                        9: 0,
                        10: 0,
                        11: 0,
                        12: 0,
                        13: 0,
                        14: 0,
                        15: 0,
                        53: 0,
                    };
                    this.oldReloads = {
                        0: 0,
                        1: 0,
                        2: 0,
                        3: 0,
                        4: 0,
                        5: 0,
                        6: 0,
                        7: 0,
                        8: 0,
                        9: 0,
                        10: 0,
                        11: 0,
                        12: 0,
                        13: 0,
                        14: 0,
                        15: 0,
                        53: 0,
                    };
                    this.turretReloaded = false;
                    this.doTickUpdate = false;
                    this.instaThreat = 0;
                }
                ;
                // RESET MOVE DIR:
                this.resetMoveDir = function() {
                    this.moveDir = undefined;
                }
                ;
                // RESET RESOURCES:
                this.resetResources = function(moofoll) {
                    for (var i = 0; i < config.resourceTypes.length; ++i) {
                        this[config.resourceTypes[i]] = moofoll ? 100 : 0;
                    }
                }
                ;
                // ADD ITEM:
                this.addItem = function(id) {
                    var tmpItem = items.list[id];
                    if (tmpItem) {
                        for (var i = 0; i < this.items.length; ++i) {
                            if (items.list[this.items[i]].group == tmpItem.group) {
                                if (this.buildIndex == this.items[i])
                                    this.buildIndex = id;
                                this.items[i] = id;
                                return true;
                            }
                        }
                        this.items.push(id);
                        return true;
                    }
                    return false;
                }
                ;
                // SET USER DATA:
                this.setUserData = function(data) {
                    if (data) {
                        // SET INITIAL NAME:
                        this.name = "unknown";
                        // VALIDATE NAME:
                        var name = data.name + "";
                        name = name.slice(0, config.maxNameLength);
                        name = name.replace(/[^\w:\(\)\/? -]+/gim, " ");
                        // USE SPACE SO WE CAN CHECK PROFANITY
                        name = name.replace(/[^\x00-\x7F]/g, " ");
                        name = name.trim();
                        // CHECK IF IS PROFANE:
                        var isProfane = false;
                        var convertedName = name.toLowerCase().replace(/\s/g, "").replace(/1/g, "i").replace(/0/g, "o").replace(/5/g, "s");
                        for (var word of langFilter.list) {
                            if (convertedName.indexOf(word) != -1) {
                                isProfane = true;
                                break;
                            }
                        }
                        if (name.length > 0 && !isProfane) {
                            this.name = name;
                        }
                        // SKIN:
                        this.skinColor = 0;
                        if (config.skinColors[data.skin])
                            this.skinColor = data.skin;
                    }
                }
                ;
                // GET DATA TO SEND:
                this.getData = function() {
                    return [this.id, this.sid, this.name, UTILS.fixTo(this.x, 2), UTILS.fixTo(this.y, 2), UTILS.fixTo(this.dir, 3), this.health, this.maxHealth, this.scale, this.skinColor, ];
                }
                ;
                // SET DATA:
                this.setData = function(data) {
                    this.id = data[0];
                    this.sid = data[1];
                    this.name = data[2];
                    this.x = data[3];
                    this.y = data[4];
                    this.dir = data[5];
                    this.health = data[6];
                    this.maxHealth = data[7];
                    this.scale = data[8];
                    this.skinColor = data[9];
                }
                ;
                // UPDATE:
                var timerCount = 0;
                this.update = function(delta) {
                    if (!this.alive)
                        return;
                    // SHAME SHAME SHAME:
                    if (this.shameTimer > 0) {
                        this.shameTimer -= delta;
                        if (this.shameTimer <= 0) {
                            this.shameTimer = 0;
                            this.shameCount = 0;
                        }
                    }
                    // REGENS AND AUTO:
                    timerCount -= delta;
                    if (timerCount <= 0) {
                        var regenAmount = (this.skin && this.skin.healthRegen ? this.skin.healthRegen : 0) + (this.tail && this.tail.healthRegen ? this.tail.healthRegen : 0);
                        if (regenAmount) {
                            this.changeHealth(regenAmount, this);
                        }
                        if (this.dmgOverTime.dmg) {
                            this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer);
                            this.dmgOverTime.time -= 1;
                            if (this.dmgOverTime.time <= 0)
                                this.dmgOverTime.dmg = 0;
                        }
                        if (this.healCol) {
                            this.changeHealth(this.healCol, this);
                        }
                        timerCount = 1000;
                    }
                    // CHECK KILL:
                    if (!this.alive)
                        return;
                    // SLOWER:
                    if (this.slowMult < 1) {
                        this.slowMult += 0.0008 * delta;
                        if (this.slowMult > 1)
                            this.slowMult = 1;
                    }
                    // MOVE:
                    this.noMovTimer += delta;
                    if (this.xVel || this.yVel)
                        this.noMovTimer = 0;
                    if (this.lockMove) {
                        this.xVel = 0;
                        this.yVel = 0;
                    } else {
                        var spdMult = (this.buildIndex >= 0 ? 0.5 : 1) * (items.weapons[this.weaponIndex].spdMult || 1) * (this.skin ? this.skin.spdMult || 1 : 1) * (this.tail ? this.tail.spdMult || 1 : 1) * (this.y <= config.snowBiomeTop ? this.skin && this.skin.coldM ? 1 : config.snowSpeed : 1) * this.slowMult;
                        if (!this.zIndex && this.y >= config.mapScale / 2 - config.riverWidth / 2 && this.y <= config.mapScale / 2 + config.riverWidth / 2) {
                            if (this.skin && this.skin.watrImm) {
                                spdMult *= 0.75;
                                this.xVel += config.waterCurrent * 0.4 * delta;
                            } else {
                                spdMult *= 0.33;
                                this.xVel += config.waterCurrent * delta;
                            }
                        }
                        var xVel = this.moveDir != undefined ? mathCOS(this.moveDir) : 0;
                        var yVel = this.moveDir != undefined ? mathSIN(this.moveDir) : 0;
                        var length = mathSQRT(xVel * xVel + yVel * yVel);
                        if (length != 0) {
                            xVel /= length;
                            yVel /= length;
                        }
                        if (xVel)
                            this.xVel += xVel * this.speed * spdMult * delta;
                        if (yVel)
                            this.yVel += yVel * this.speed * spdMult * delta;
                    }
                    // OBJECT COLL:
                    this.zIndex = 0;
                    this.lockMove = false;
                    this.healCol = 0;
                    var tmpList;
                    var tmpSpeed = UTILS.getDistance(0, 0, this.xVel * delta, this.yVel * delta);
                    var depth = Math.min(4, Math.max(1, Math.round(tmpSpeed / 40)));
                    var tMlt = 1 / depth;
                    for (var i = 0; i < depth; ++i) {
                        if (this.xVel)
                            this.x += this.xVel * delta * tMlt;
                        if (this.yVel)
                            this.y += this.yVel * delta * tMlt;
                        tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                        for (var x = 0; x < tmpList.length; ++x) {
                            for (var y = 0; y < tmpList[x].length; ++y) {
                                if (tmpList[x][y].active)
                                    objectManager.checkCollision(this, tmpList[x][y], tMlt);
                            }
                        }
                    }
                    // PLAYER COLLISIONS:
                    var tmpIndx = players.indexOf(this);
                    for (var i = tmpIndx + 1; i < players.length; ++i) {
                        if (players[i] != this && players[i].alive)
                            objectManager.checkCollision(this, players[i]);
                    }
                    // DECEL:
                    if (this.xVel) {
                        this.xVel *= mathPOW(config.playerDecel, delta);
                        if (this.xVel <= 0.01 && this.xVel >= -0.01)
                            this.xVel = 0;
                    }
                    if (this.yVel) {
                        this.yVel *= mathPOW(config.playerDecel, delta);
                        if (this.yVel <= 0.01 && this.yVel >= -0.01)
                            this.yVel = 0;
                    }
                    // MAP BOUNDARIES:
                    if (this.x - this.scale < 0) {
                        this.x = this.scale;
                    } else if (this.x + this.scale > config.mapScale) {
                        this.x = config.mapScale - this.scale;
                    }
                    if (this.y - this.scale < 0) {
                        this.y = this.scale;
                    } else if (this.y + this.scale > config.mapScale) {
                        this.y = config.mapScale - this.scale;
                    }
                    // USE WEAPON OR TOOL:
                    if (this.buildIndex < 0) {
                        if (this.reloads[this.weaponIndex] > 0) {
                            this.reloads[this.weaponIndex] -= delta;
                            this.gathering = this.mouseState;
                        } else if (this.gathering || this.autoGather) {
                            var worked = true;
                            if (items.weapons[this.weaponIndex].gather != undefined) {
                                this.gather(players);
                            } else if (items.weapons[this.weaponIndex].projectile != undefined && this.hasRes(items.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0)) {
                                this.useRes(items.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0);
                                this.noMovTimer = 0;
                                var tmpIndx = items.weapons[this.weaponIndex].projectile;
                                var projOffset = this.scale * 2;
                                var aMlt = this.skin && this.skin.aMlt ? this.skin.aMlt : 1;
                                if (items.weapons[this.weaponIndex].rec) {
                                    this.xVel -= items.weapons[this.weaponIndex].rec * mathCOS(this.dir);
                                    this.yVel -= items.weapons[this.weaponIndex].rec * mathSIN(this.dir);
                                }
                                projectileManager.addProjectile(this.x + projOffset * mathCOS(this.dir), this.y + projOffset * mathSIN(this.dir), this.dir, items.projectiles[tmpIndx].range * aMlt, items.projectiles[tmpIndx].speed * aMlt, tmpIndx, this, null, this.zIndex);
                            } else {
                                worked = false;
                            }
                            this.gathering = this.mouseState;
                            if (worked) {
                                this.reloads[this.weaponIndex] = items.weapons[this.weaponIndex].speed * (this.skin ? this.skin.atkSpd || 1 : 1);
                            }
                        }
                    }
                }
                ;
                // ADD WEAPON XP:
                this.addWeaponXP = function(amnt) {
                    if (!this.weaponXP[this.weaponIndex])
                        this.weaponXP[this.weaponIndex] = 0;
                    this.weaponXP[this.weaponIndex] += amnt;
                    if (this.weaponIndex == this.weapons[0]) {
                        getEl("priXP").innerHTML = "Primary XP: " + this.weaponXP[this.weapons[0]] + " / " + config.weaponXPs[this.weaponVariant].xp;
                    } else if (this.weaponIndex == this.weapons[1]) {
                        getEl("secXP").innerHTML = "Secondary XP: " + this.weaponXP[this.weapons[1]] + " / " + config.weaponXPs[this.weaponVariant].xp;
                    }
                }
                ;
                // EARN XP:
                this.earnXP = function(amount) {
                    if (this.age < config.maxAge) {
                        this.XP += amount;
                        if (this.XP >= this.maxXP) {
                            if (this.age < config.maxAge) {
                                this.age++;
                                this.XP = 0;
                                this.maxXP *= 1.2;
                            } else {
                                this.XP = this.maxXP;
                            }
                            this.upgradePoints++;
                            server.send(this.id, "16", this.upgradePoints, this.upgrAge);
                            server.send(this.id, "15", this.XP, UTILS.fixTo(this.maxXP, 1), this.age);
                        } else {
                            server.send(this.id, "15", this.XP);
                        }
                    }
                }
                ;
                // CHANGE HEALTH:
                this.changeHealth = function(amount, doer) {
                    if (amount > 0 && this.health >= this.maxHealth)
                        return false;
                    if (amount < 0 && this.skin)
                        amount *= this.skin.dmgMult || 1;
                    if (amount < 0 && this.tail)
                        amount *= this.tail.dmgMult || 1;
                    if (amount < 0)
                        this.hitTime = Date.now();
                    this.health += amount;
                    if (this.health > this.maxHealth) {
                        amount -= this.health - this.maxHealth;
                        this.health = this.maxHealth;
                    }
                    if (this.health <= 0)
                        this.kill(doer);
                    for (var i = 0; i < players.length; ++i) {
                        if (this.sentTo[players[i].id])
                            server.send(players[i].id, "h", this.sid, Math.round(this.health));
                    }
                    if (doer && doer.canSee(this) && !(doer == this && amount < 0)) {
                        server.send(doer.id, "t", Math.round(this.x), Math.round(this.y), Math.round(-amount), 1);
                    }
                    return true;
                }
                ;
                // KILL:
                this.kill = function(doer) {
                    if (doer && doer.alive) {
                        doer.kills++;
                        if (doer.skin && doer.skin.goldSteal)
                            scoreCallback(doer, Math.round(this.points / 2));
                        else
                            scoreCallback(doer, Math.round(this.age * 100 * (doer.skin && doer.skin.kScrM ? doer.skin.kScrM : 1)));
                        server.send(doer.id, "9", "kills", doer.kills, 1);
                    }
                    this.alive = false;
                    server.send(this.id, "11");
                    iconCallback();
                }
                ;
                // ADD RESOURCE:
                this.addResource = function(type, amount, auto) {
                    if (!auto && amount > 0)
                        this.addWeaponXP(amount);
                    if (type == 3) {
                        scoreCallback(this, amount, true);
                    } else {
                        this[config.resourceTypes[type]] += amount;
                        server.send(this.id, "9", config.resourceTypes[type], this[config.resourceTypes[type]], 1);
                    }
                }
                ;
                // CHANGE ITEM COUNT:
                this.changeItemCount = function(index, value) {
                    this.itemCounts[index] = this.itemCounts[index] || 0;
                    this.itemCounts[index] += value;
                    server.send(this.id, "14", index, this.itemCounts[index]);
                }
                ;
                // BUILD:
                this.buildItem = function(item) {
                    var tmpS = this.scale + item.scale + (item.placeOffset || 0);
                    var tmpX = this.x + tmpS * mathCOS(this.dir);
                    var tmpY = this.y + tmpS * mathSIN(this.dir);
                    if (this.canBuild(item) && !(item.consume && this.skin && this.skin.noEat) && (item.consume || objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, this))) {
                        var worked = false;
                        if (item.consume) {
                            if (this.hitTime) {
                                var timeSinceHit = Date.now() - this.hitTime;
                                this.hitTime = 0;
                                if (timeSinceHit <= 120) {
                                    this.shameCount++;
                                    if (this.shameCount >= 8) {
                                        this.shameTimer = 30000;
                                        this.shameCount = 0;
                                    }
                                } else {
                                    this.shameCount -= 2;
                                    if (this.shameCount <= 0) {
                                        this.shameCount = 0;
                                    }
                                }
                            }
                            if (this.shameTimer <= 0)
                                worked = item.consume(this);
                        } else {
                            worked = true;
                            if (item.group.limit) {
                                this.changeItemCount(item.group.id, 1);
                            }
                            if (item.pps)
                                this.pps += item.pps;
                            objectManager.add(objectManager.objects.length, tmpX, tmpY, this.dir, item.scale, item.type, item, false, this);
                        }
                        if (worked) {
                            this.useRes(item);
                            this.buildIndex = -1;
                        }
                    }
                }
                ;
                // HAS RESOURCES:
                this.hasRes = function(item, mult) {
                    for (var i = 0; i < item.req.length; ) {
                        if (this[item.req[i]] < Math.round(item.req[i + 1] * (mult || 1)))
                            return false;
                        i += 2;
                    }
                    return true;
                }
                ;
                // USE RESOURCES:
                this.useRes = function(item, mult) {
                    if (config.inSandbox)
                        return;
                    for (var i = 0; i < item.req.length; ) {
                        this.addResource(config.resourceTypes.indexOf(item.req[i]), -Math.round(item.req[i + 1] * (mult || 1)));
                        i += 2;
                    }
                }
                ;
                // CAN BUILD:
                this.canBuild = function(item) {
                    if (config.inSandbox)
                        return true;
                    if (item.group.limit && this.itemCounts[item.group.id] >= item.group.limit)
                        return false;
                    return this.hasRes(item);
                }
                ;
                // GATHER:
                this.gather = function() {
                    // SHOW:
                    this.noMovTimer = 0;
                    // SLOW MOVEMENT:
                    this.slowMult -= items.weapons[this.weaponIndex].hitSlow || 0.3;
                    if (this.slowMult < 0)
                        this.slowMult = 0;
                    // VARIANT DMG:
                    var tmpVariant = config.fetchVariant(this);
                    var applyPoison = tmpVariant.poison;
                    var variantDmg = tmpVariant.val;
                    // CHECK IF HIT GAME OBJECT:
                    var hitObjs = {};
                    var tmpDist, tmpDir, tmpObj, hitSomething;
                    var tmpList = objectManager.getGridArrays(this.x, this.y, items.weapons[this.weaponIndex].range);
                    for (var t = 0; t < tmpList.length; ++t) {
                        for (var i = 0; i < tmpList[t].length; ++i) {
                            tmpObj = tmpList[t][i];
                            if (tmpObj.active && !tmpObj.dontGather && !hitObjs[tmpObj.sid] && tmpObj.visibleToPlayer(this)) {
                                tmpDist = UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y) - tmpObj.scale;
                                if (tmpDist <= items.weapons[this.weaponIndex].range) {
                                    tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                    if (UTILS.getAngleDist(tmpDir, this.dir) <= config.gatherAngle) {
                                        hitObjs[tmpObj.sid] = 1;
                                        if (tmpObj.health) {
                                            if (tmpObj.changeHealth(-items.weapons[this.weaponIndex].dmg * variantDmg * (items.weapons[this.weaponIndex].sDmg || 1) * (this.skin && this.skin.bDmg ? this.skin.bDmg : 1), this)) {
                                                for (var x = 0; x < tmpObj.req.length; ) {
                                                    this.addResource(config.resourceTypes.indexOf(tmpObj.req[x]), tmpObj.req[x + 1]);
                                                    x += 2;
                                                }
                                                objectManager.disableObj(tmpObj);
                                            }
                                        } else {
                                            this.earnXP(4 * items.weapons[this.weaponIndex].gather);
                                            var count = items.weapons[this.weaponIndex].gather + (tmpObj.type == 3 ? 4 : 0);
                                            if (this.skin && this.skin.extraGold) {
                                                this.addResource(3, 1);
                                            }
                                            this.addResource(tmpObj.type, count);
                                        }
                                        hitSomething = true;
                                        objectManager.hitObj(tmpObj, tmpDir);
                                    }
                                }
                            }
                        }
                    }
                    // CHECK IF HIT PLAYER:
                    for (var i = 0; i < players.length + ais.length; ++i) {
                        tmpObj = players[i] || ais[i - players.length];
                        if (tmpObj != this && tmpObj.alive && !(tmpObj.team && tmpObj.team == this.team)) {
                            tmpDist = UTILS.getDistance(this.x, this.y, tmpObj.x, tmpObj.y) - tmpObj.scale * 1.8;
                            if (tmpDist <= items.weapons[this.weaponIndex].range) {
                                tmpDir = UTILS.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                if (UTILS.getAngleDist(tmpDir, this.dir) <= config.gatherAngle) {
                                    // STEAL RESOURCES:
                                    var stealCount = items.weapons[this.weaponIndex].steal;
                                    if (stealCount && tmpObj.addResource) {
                                        stealCount = Math.min(tmpObj.points || 0, stealCount);
                                        this.addResource(3, stealCount);
                                        tmpObj.addResource(3, -stealCount);
                                    }
                                    // MELEE HIT PLAYER:
                                    var dmgMlt = variantDmg;
                                    if (tmpObj.weaponIndex != undefined && items.weapons[tmpObj.weaponIndex].shield && UTILS.getAngleDist(tmpDir + Math.PI, tmpObj.dir) <= config.shieldAngle) {
                                        dmgMlt = items.weapons[tmpObj.weaponIndex].shield;
                                    }
                                    var dmgVal = items.weapons[this.weaponIndex].dmg * (this.skin && this.skin.dmgMultO ? this.skin.dmgMultO : 1) * (this.tail && this.tail.dmgMultO ? this.tail.dmgMultO : 1);
                                    var tmpSpd = 0.3 * (tmpObj.weightM || 1) + (items.weapons[this.weaponIndex].knock || 0);
                                    tmpObj.xVel += tmpSpd * mathCOS(tmpDir);
                                    tmpObj.yVel += tmpSpd * mathSIN(tmpDir);
                                    if (this.skin && this.skin.healD)
                                        this.changeHealth(dmgVal * dmgMlt * this.skin.healD, this);
                                    if (this.tail && this.tail.healD)
                                        this.changeHealth(dmgVal * dmgMlt * this.tail.healD, this);
                                    if (tmpObj.skin && tmpObj.skin.dmg && dmgMlt == 1)
                                        this.changeHealth(-dmgVal * tmpObj.skin.dmg, tmpObj);
                                    if (tmpObj.tail && tmpObj.tail.dmg && dmgMlt == 1)
                                        this.changeHealth(-dmgVal * tmpObj.tail.dmg, tmpObj);
                                    if (tmpObj.dmgOverTime && this.skin && this.skin.poisonDmg && !(tmpObj.skin && tmpObj.skin.poisonRes)) {
                                        tmpObj.dmgOverTime.dmg = this.skin.poisonDmg;
                                        tmpObj.dmgOverTime.time = this.skin.poisonTime || 1;
                                        tmpObj.dmgOverTime.doer = this;
                                    }
                                    if (tmpObj.dmgOverTime && applyPoison && !(tmpObj.skin && tmpObj.skin.poisonRes)) {
                                        tmpObj.dmgOverTime.dmg = 5;
                                        tmpObj.dmgOverTime.time = 5;
                                        tmpObj.dmgOverTime.doer = this;
                                    }
                                    if (tmpObj.skin && tmpObj.skin.dmgK) {
                                        this.xVel -= tmpObj.skin.dmgK * mathCOS(tmpDir);
                                        this.yVel -= tmpObj.skin.dmgK * mathSIN(tmpDir);
                                    }
                                    tmpObj.changeHealth(-dmgVal * dmgMlt, this, this);
                                }
                            }
                        }
                    }
                    // SEND FOR ANIMATION:
                    this.sendAnimation(hitSomething ? 1 : 0);
                }
                ;
                // SEND ANIMATION:
                this.sendAnimation = function(hit) {
                    for (var i = 0; i < players.length; ++i) {
                        if (this.sentTo[players[i].id] && this.canSee(players[i])) {
                            server.send(players[i].id, "7", this.sid, hit ? 1 : 0, this.weaponIndex);
                        }
                    }
                }
                ;
                // ANIMATE:
                var tmpRatio = 0;
                var animIndex = 0;
                this.animate = function(delta) {
                    if (this.animTime > 0) {
                        this.animTime -= delta;
                        if (this.animTime <= 0) {
                            this.animTime = 0;
                            this.dirPlus = 0;
                            tmpRatio = 0;
                            animIndex = 0;
                        } else {
                            if (animIndex == 0) {
                                tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.min(1, tmpRatio));
                                if (tmpRatio >= 1) {
                                    tmpRatio = 1;
                                    animIndex = 1;
                                }
                            } else {
                                tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                                this.dirPlus = UTILS.lerp(0, this.targetAngle, Math.max(0, tmpRatio));
                            }
                        }
                    }
                }
                ;
                // GATHER ANIMATION:
                this.startAnim = function(didHit, index) {
                    this.animTime = this.animSpeed = items.weapons[index].speed;
                    this.targetAngle = didHit ? -config.hitAngle : -Math.PI;
                    tmpRatio = 0;
                    animIndex = 0;
                }
                ;
                // CAN SEE:
                this.canSee = function(other) {
                    if (!other)
                        return false;
                    if (other.skin && other.skin.invisTimer && other.noMovTimer >= other.skin.invisTimer)
                        return false;
                    var dx = mathABS(other.x - this.x) - other.scale;
                    var dy = mathABS(other.y - this.y) - other.scale;
                    return (dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3);
                }
                ;
            }
            ;
            /***/
        },
        /***/
        "./src/js/data/projectile.js": /*!***********************************!*\
  !*** ./src/js/data/projectile.js ***!
  \***********************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            module.exports = function(players, ais, objectManager, items, config, UTILS, server) {
                // INIT:
                this.init = function(indx, x, y, dir, spd, dmg, rng, scl, owner) {
                    this.active = true;
                    this.indx = indx;
                    this.x = x;
                    this.y = y;
                    this.dir = dir;
                    this.skipMov = true;
                    this.speed = spd;
                    this.dmg = dmg;
                    this.scale = scl;
                    this.range = rng;
                    this.owner = owner;
                    if (server)
                        this.sentTo = {};
                }
                ;
                // UPDATE:
                var objectsHit = [];
                var tmpObj;
                this.update = function(delta) {
                    if (this.active) {
                        var tmpSpeed = this.speed * delta;
                        var tmpScale;
                        if (!this.skipMov) {
                            this.x += tmpSpeed * Math.cos(this.dir);
                            this.y += tmpSpeed * Math.sin(this.dir);
                            this.range -= tmpSpeed;
                            if (this.range <= 0) {
                                this.x += this.range * Math.cos(this.dir);
                                this.y += this.range * Math.sin(this.dir);
                                tmpSpeed = 1;
                                this.range = 0;
                                this.active = false;
                            }
                        } else {
                            this.skipMov = false;
                        }
                        if (server) {
                            for (var i = 0; i < players.length; ++i) {
                                if (!this.sentTo[players[i].id] && players[i].canSee(this)) {
                                    this.sentTo[players[i].id] = 1;
                                    server.send(players[i].id, "18", UTILS.fixTo(this.x, 1), UTILS.fixTo(this.y, 1), UTILS.fixTo(this.dir, 2), UTILS.fixTo(this.range, 1), this.speed, this.indx, this.layer, this.sid);
                                }
                            }
                            objectsHit.length = 0;
                            for (var i = 0; i < players.length + ais.length; ++i) {
                                tmpObj = players[i] || ais[i - players.length];
                                if (tmpObj.alive && tmpObj != this.owner && !(this.owner.team && tmpObj.team == this.owner.team)) {
                                    if (UTILS.lineInRect(tmpObj.x - tmpObj.scale, tmpObj.y - tmpObj.scale, tmpObj.x + tmpObj.scale, tmpObj.y + tmpObj.scale, this.x, this.y, this.x + tmpSpeed * Math.cos(this.dir), this.y + tmpSpeed * Math.sin(this.dir))) {
                                        objectsHit.push(tmpObj);
                                    }
                                }
                            }
                            var tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                            for (var x = 0; x < tmpList.length; ++x) {
                                for (var y = 0; y < tmpList[x].length; ++y) {
                                    tmpObj = tmpList[x][y];
                                    tmpScale = tmpObj.getScale();
                                    if (tmpObj.active && !(this.ignoreObj == tmpObj.sid) && this.layer <= tmpObj.layer && objectsHit.indexOf(tmpObj) < 0 && !tmpObj.ignoreCollision && UTILS.lineInRect(tmpObj.x - tmpScale, tmpObj.y - tmpScale, tmpObj.x + tmpScale, tmpObj.y + tmpScale, this.x, this.y, this.x + tmpSpeed * Math.cos(this.dir), this.y + tmpSpeed * Math.sin(this.dir))) {
                                        objectsHit.push(tmpObj);
                                    }
                                }
                            }
                            // HIT OBJECTS:
                            if (objectsHit.length > 0) {
                                var hitObj = null;
                                var shortDist = null;
                                var tmpDist = null;
                                for (var i = 0; i < objectsHit.length; ++i) {
                                    tmpDist = UTILS.getDistance(this.x, this.y, objectsHit[i].x, objectsHit[i].y);
                                    if (shortDist == null || tmpDist < shortDist) {
                                        shortDist = tmpDist;
                                        hitObj = objectsHit[i];
                                    }
                                }
                                if (hitObj.isPlayer || hitObj.isAI) {
                                    var tmpSd = 0.3 * (hitObj.weightM || 1);
                                    hitObj.xVel += tmpSd * Math.cos(this.dir);
                                    hitObj.yVel += tmpSd * Math.sin(this.dir);
                                    if (hitObj.weaponIndex == undefined || !(items.weapons[hitObj.weaponIndex].shield && UTILS.getAngleDist(this.dir + Math.PI, hitObj.dir) <= config.shieldAngle)) {
                                        hitObj.changeHealth(-this.dmg, this.owner, this.owner);
                                    }
                                } else {
                                    if (hitObj.projDmg && hitObj.health && hitObj.changeHealth(-this.dmg)) {
                                        objectManager.disableObj(hitObj);
                                    }
                                    for (var i = 0; i < players.length; ++i) {
                                        if (players[i].active) {
                                            if (hitObj.sentTo[players[i].id]) {
                                                if (hitObj.active) {
                                                    if (players[i].canSee(hitObj))
                                                        server.send(players[i].id, "8", UTILS.fixTo(this.dir, 2), hitObj.sid);
                                                } else {
                                                    server.send(players[i].id, "12", hitObj.sid);
                                                }
                                            }
                                            if (!hitObj.active && hitObj.owner == players[i])
                                                players[i].changeItemCount(hitObj.group.id, -1);
                                        }
                                    }
                                }
                                this.active = false;
                                for (var i = 0; i < players.length; ++i) {
                                    if (this.sentTo[players[i].id])
                                        server.send(players[i].id, "19", this.sid, UTILS.fixTo(shortDist, 1));
                                }
                            }
                        }
                    }
                }
                ;
            }
            ;
            /***/
        },
        /***/
        "./src/js/data/projectileManager.js": /*!******************************************!*\
  !*** ./src/js/data/projectileManager.js ***!
  \******************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            module.exports = function(Projectile, projectiles, players, ais, objectManager, items, config, UTILS, server) {
                this.addProjectile = function(x, y, dir, range, speed, indx, owner, ignoreObj, layer) {
                    var tmpData = items.projectiles[indx];
                    var tmpProj = projectiles.find((tmp)=>!tmp.active);
                    if (!tmpProj) {
                        tmpProj = new Projectile(players,ais,objectManager,items,config,UTILS,server);
                        tmpProj.sid = projectiles.length;
                        projectiles.push(tmpProj);
                    }
                    tmpProj.init(indx, x, y, dir, speed, tmpData.dmg, range, tmpData.scale, owner);
                    tmpProj.ignoreObj = ignoreObj;
                    tmpProj.layer = layer || tmpData.layer;
                    tmpProj.src = tmpData.src;
                    return tmpProj;
                }
                ;
            }
            ;
            /***/
        },
        /***/
        "./src/js/data/store.js": /*!******************************!*\
  !*** ./src/js/data/store.js ***!
  \******************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            // STORE HATS:
            module.exports.hats = [{
                id: 45,
                name: "Shame!",
                dontSell: true,
                price: 0,
                scale: 120,
                desc: "hacks are for losers",
            }, {
                id: 51,
                name: "Moo Cap",
                price: 0,
                scale: 120,
                desc: "coolest mooer around",
            }, {
                id: 50,
                name: "Apple Cap",
                price: 0,
                scale: 120,
                desc: "apple farms remembers",
            }, {
                id: 28,
                name: "Moo Head",
                price: 0,
                scale: 120,
                desc: "no effect",
            }, {
                id: 29,
                name: "Pig Head",
                price: 0,
                scale: 120,
                desc: "no effect",
            }, {
                id: 30,
                name: "Fluff Head",
                price: 0,
                scale: 120,
                desc: "no effect",
            }, {
                id: 36,
                name: "Pandou Head",
                price: 0,
                scale: 120,
                desc: "no effect",
            }, {
                id: 37,
                name: "Bear Head",
                price: 0,
                scale: 120,
                desc: "no effect",
            }, {
                id: 38,
                name: "Monkey Head",
                price: 0,
                scale: 120,
                desc: "no effect",
            }, {
                id: 44,
                name: "Polar Head",
                price: 0,
                scale: 120,
                desc: "no effect",
            }, {
                id: 35,
                name: "Fez Hat",
                price: 0,
                scale: 120,
                desc: "no effect",
            }, {
                id: 42,
                name: "Enigma Hat",
                price: 0,
                scale: 120,
                desc: "join the enigma army",
            }, {
                id: 43,
                name: "Blitz Hat",
                price: 0,
                scale: 120,
                desc: "hey everybody i'm blitz",
            }, {
                id: 49,
                name: "Bob XIII Hat",
                price: 0,
                scale: 120,
                desc: "like and subscribe",
            }, {
                id: 57,
                name: "Pumpkin",
                price: 50,
                scale: 120,
                desc: "Spooooky",
            }, {
                id: 8,
                name: "Bummle Hat",
                price: 100,
                scale: 120,
                desc: "no effect",
            }, {
                id: 2,
                name: "Straw Hat",
                price: 500,
                scale: 120,
                desc: "no effect",
            }, {
                id: 15,
                name: "Winter Cap",
                price: 600,
                scale: 120,
                desc: "allows you to move at normal speed in snow",
                coldM: 1,
            }, {
                id: 5,
                name: "Cowboy Hat",
                price: 1000,
                scale: 120,
                desc: "no effect",
            }, {
                id: 4,
                name: "Ranger Hat",
                price: 2000,
                scale: 120,
                desc: "no effect",
            }, {
                id: 18,
                name: "Explorer Hat",
                price: 2000,
                scale: 120,
                desc: "no effect",
            }, {
                id: 31,
                name: "Flipper Hat",
                price: 2500,
                scale: 120,
                desc: "have more control while in water",
                watrImm: true,
            }, {
                id: 1,
                name: "Marksman Cap",
                price: 3000,
                scale: 120,
                desc: "increases arrow speed and range",
                aMlt: 1.3,
            }, {
                id: 10,
                name: "Bush Gear",
                price: 3000,
                scale: 160,
                desc: "allows you to disguise yourself as a bush",
            }, {
                id: 48,
                name: "Halo",
                price: 3000,
                scale: 120,
                desc: "no effect",
            }, {
                id: 6,
                name: "Soldier Helmet",
                price: 4000,
                scale: 120,
                desc: "reduces damage taken but slows movement",
                spdMult: 0.94,
                dmgMult: 0.75,
            }, {
                id: 23,
                name: "Anti Venom Gear",
                price: 4000,
                scale: 120,
                desc: "makes you immune to poison",
                poisonRes: 1,
            }, {
                id: 13,
                name: "Medic Gear",
                price: 5000,
                scale: 110,
                desc: "slowly regenerates health over time",
                healthRegen: 3,
            }, {
                id: 9,
                name: "Miners Helmet",
                price: 5000,
                scale: 120,
                desc: "earn 1 extra gold per resource",
                extraGold: 1,
            }, {
                id: 32,
                name: "Musketeer Hat",
                price: 5000,
                scale: 120,
                desc: "reduces cost of projectiles",
                projCost: 0.5,
            }, {
                id: 7,
                name: "Bull Helmet",
                price: 6000,
                scale: 120,
                desc: "increases damage done but drains health",
                healthRegen: -5,
                dmgMultO: 1.5,
                spdMult: 0.96,
            }, {
                id: 22,
                name: "Emp Helmet",
                price: 6000,
                scale: 120,
                desc: "turrets won't attack but you move slower",
                antiTurret: 1,
                spdMult: 0.7,
            }, {
                id: 12,
                name: "Booster Hat",
                price: 6000,
                scale: 120,
                desc: "increases your movement speed",
                spdMult: 1.16,
            }, {
                id: 26,
                name: "Barbarian Armor",
                price: 8000,
                scale: 120,
                desc: "knocks back enemies that attack you",
                dmgK: 0.6,
            }, {
                id: 21,
                name: "Plague Mask",
                price: 10000,
                scale: 120,
                desc: "melee attacks deal poison damage",
                poisonDmg: 5,
                poisonTime: 6,
            }, {
                id: 46,
                name: "Bull Mask",
                price: 10000,
                scale: 120,
                desc: "bulls won't target you unless you attack them",
                bullRepel: 1,
            }, {
                id: 14,
                name: "Windmill Hat",
                topSprite: true,
                price: 10000,
                scale: 120,
                desc: "generates points while worn",
                pps: 1.5,
            }, {
                id: 11,
                name: "Spike Gear",
                topSprite: true,
                price: 10000,
                scale: 120,
                desc: "deal damage to players that damage you",
                dmg: 0.45,
            }, {
                id: 53,
                name: "Turret Gear",
                topSprite: true,
                price: 10000,
                scale: 120,
                desc: "you become a walking turret",
                turret: {
                    proj: 1,
                    range: 700,
                    rate: 2500,
                },
                spdMult: 0.7,
            }, {
                id: 20,
                name: "Samurai Armor",
                price: 12000,
                scale: 120,
                desc: "increased attack speed and fire rate",
                atkSpd: 0.78,
            }, {
                id: 58,
                name: "Dark Knight",
                price: 12000,
                scale: 120,
                desc: "restores health when you deal damage",
                healD: 0.4,
            }, {
                id: 27,
                name: "Scavenger Gear",
                price: 15000,
                scale: 120,
                desc: "earn double points for each kill",
                kScrM: 2,
            }, {
                id: 40,
                name: "Tank Gear",
                price: 15000,
                scale: 120,
                desc: "increased damage to buildings but slower movement",
                spdMult: 0.3,
                bDmg: 3.3,
            }, {
                id: 52,
                name: "Thief Gear",
                price: 15000,
                scale: 120,
                desc: "steal half of a players gold when you kill them",
                goldSteal: 0.5,
            }, {
                id: 55,
                name: "Bloodthirster",
                price: 20000,
                scale: 120,
                desc: "Restore Health when dealing damage. And increased damage",
                healD: 0.25,
                dmgMultO: 1.2,
            }, {
                id: 56,
                name: "Assassin Gear",
                price: 20000,
                scale: 120,
                desc: "Go invisible when not moving. Can't eat. Increased speed",
                noEat: true,
                spdMult: 1.1,
                invisTimer: 1000,
            }, ];
            // STORE ACCESSORIES:
            module.exports.accessories = [{
                id: 12,
                name: "Snowball",
                price: 1000,
                scale: 105,
                xOff: 18,
                desc: "no effect",
            }, {
                id: 9,
                name: "Tree Cape",
                price: 1000,
                scale: 90,
                desc: "no effect",
            }, {
                id: 10,
                name: "Stone Cape",
                price: 1000,
                scale: 90,
                desc: "no effect",
            }, {
                id: 3,
                name: "Cookie Cape",
                price: 1500,
                scale: 90,
                desc: "no effect",
            }, {
                id: 8,
                name: "Cow Cape",
                price: 2000,
                scale: 90,
                desc: "no effect",
            }, {
                id: 11,
                name: "Monkey Tail",
                price: 2000,
                scale: 97,
                xOff: 25,
                desc: "Super speed but reduced damage",
                spdMult: 1.35,
                dmgMultO: 0.2,
            }, {
                id: 17,
                name: "Apple Basket",
                price: 3000,
                scale: 80,
                xOff: 12,
                desc: "slowly regenerates health over time",
                healthRegen: 1,
            }, {
                id: 6,
                name: "Winter Cape",
                price: 3000,
                scale: 90,
                desc: "no effect",
            }, {
                id: 4,
                name: "Skull Cape",
                price: 4000,
                scale: 90,
                desc: "no effect",
            }, {
                id: 5,
                name: "Dash Cape",
                price: 5000,
                scale: 90,
                desc: "no effect",
            }, {
                id: 2,
                name: "Dragon Cape",
                price: 6000,
                scale: 90,
                desc: "no effect",
            }, {
                id: 1,
                name: "Super Cape",
                price: 8000,
                scale: 90,
                desc: "no effect",
            }, {
                id: 7,
                name: "Troll Cape",
                price: 8000,
                scale: 90,
                desc: "no effect",
            }, {
                id: 14,
                name: "Thorns",
                price: 10000,
                scale: 115,
                xOff: 20,
                desc: "no effect",
            }, {
                id: 15,
                name: "Blockades",
                price: 10000,
                scale: 95,
                xOff: 15,
                desc: "no effect",
            }, {
                id: 20,
                name: "Devils Tail",
                price: 10000,
                scale: 95,
                xOff: 20,
                desc: "no effect",
            }, {
                id: 16,
                name: "Sawblade",
                price: 12000,
                scale: 90,
                spin: true,
                xOff: 0,
                desc: "deal damage to players that damage you",
                dmg: 0.15,
            }, {
                id: 13,
                name: "Angel Wings",
                price: 15000,
                scale: 138,
                xOff: 22,
                desc: "slowly regenerates health over time",
                healthRegen: 3,
            }, {
                id: 19,
                name: "Shadow Wings",
                price: 15000,
                scale: 138,
                xOff: 22,
                desc: "increased movement speed",
                spdMult: 1.1,
            }, {
                id: 18,
                name: "Blood Wings",
                price: 20000,
                scale: 178,
                xOff: 26,
                desc: "restores health when you deal damage",
                healD: 0.2,
            }, {
                id: 21,
                name: "Corrupt X Wings",
                price: 20000,
                scale: 178,
                xOff: 26,
                desc: "deal damage to players that damage you",
                dmg: 0.25,
            }, ];
            /***/
        },
        /***/
        "./src/js/libs/animText.js": /*!*********************************!*\
  !*** ./src/js/libs/animText.js ***!
  \*********************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            // ANIMATED TEXT:
            module.exports.AnimText = function() {
                // INIT:
                this.init = function(x, y, scale, speed, life, text, color) {
                    this.x = x;
                    this.y = y;
                    this.randomX = Math.floor(Math.random() * 2);
                    this.randomSpeed = Math.floor(Math.random() * 5);
                    this.moveSpeed = 10;
                    this.color = color;
                    this.scale = scale;
                    this.startScale = this.scale;
                    this.maxScale = scale * 1.5;
                    this.scaleSpeed = getEl("visual").value == "hans" ? 0.35 : 0.7;
                    this.speed = speed;
                    this.life = life;
                    this.life2 = this.life;
                    this.startLife = this.life;
                    this.text = text;
                    this.animation = 0;
                    this.maxAnim = 100;
                    this.acc = 1;
                    this.acc2 = 1;
                }
                ;
                // UPDATE:
                this.update = function(delta) {
                    if (this.life) {
                        this.life -= delta;
                        this.animation += 6;
                        if (getEl("visual").value == "me") {
                            if (this.animation < this.maxAnim) {
                                this.acc -= 0.1;
                                this.y -= this.speed * this.acc * delta;
                            } else {
                                this.life2 -= delta * 1.75;
                                this.acc += 0.15;
                                this.y += this.speed * this.acc * delta;
                            }
                            this.scale += this.scaleSpeed * delta;
                            if (this.scale >= this.maxScale) {
                                this.scale = this.maxScale;
                                this.scaleSpeed *= -1;
                            } else if (this.scale <= this.startScale) {
                                this.scale = this.startScale;
                                this.scaleSpeed = 0;
                            }
                        } else if (getEl("visual").value == "hans") {
                            if (this.animation < this.maxAnim) {
                                this.acc -= 0.05;
                                this.y -= this.speed * this.acc * delta;
                            } else {
                                this.life2 -= delta * 1.9;
                                this.acc += 0.05;
                                this.y += this.speed * this.acc * delta;
                            }
                            if (this.randomX == 1) {
                                this.x += this.moveSpeed;
                            } else if (this.randomX == 0) {
                                this.x -= this.moveSpeed;
                            }
                            this.moveSpeed = Math.max(0, this.moveSpeed - 1);
                            this.scale += this.scaleSpeed * delta;
                            if (this.scale >= this.maxScale) {
                                this.scale = this.maxScale;
                                this.scaleSpeed *= -1;
                            } else if (this.scale <= this.startScale) {
                                this.scaleSpeed = 0;
                                this.scale -= 0.1;
                            }
                        } else {
                            this.y -= this.speed * delta;
                            this.scale += this.scaleSpeed * delta;
                            if (this.scale >= this.maxScale) {
                                this.scale = this.maxScale;
                                this.scaleSpeed *= -1;
                            } else if (this.scale <= this.startScale) {
                                this.scale = this.startScale;
                                this.scaleSpeed = 0;
                            }
                        }
                        if (this.life <= 0) {
                            this.life = 0;
                        }
                    }
                }
                ;
                // RENDER:
                this.render = function(ctxt, xOff, yOff) {
                    if (getEl("visual").value == "me" || getEl("visual").value == "hans") {
                        ctxt.globalAlpha = Math.min(1, this.life2 / this.startLife);
                    }
                    ctxt.fillStyle = this.color;
                    ctxt.font = this.scale + "px Hammersmith One";
                    if (getEl("visual").value == "cele" || getEl("visual").value == "zeph") {
                        ctxt.strokeText(this.text, this.x - xOff, this.y - yOff);
                    }
                    ctxt.fillText(this.text, this.x - xOff, this.y - yOff);
                    ctxt.globalAlpha = 1;
                }
                ;
            }
            ;
            // TEXT MANAGER:
            module.exports.TextManager = function() {
                this.texts = [];
                // UPDATE:
                this.update = function(delta, ctxt, xOff, yOff) {
                    ctxt.textBaseline = "middle";
                    ctxt.textAlign = "center";
                    for (var i = 0; i < this.texts.length; ++i) {
                        if (this.texts[i].life) {
                            this.texts[i].update(delta);
                            this.texts[i].render(ctxt, xOff, yOff);
                        }
                    }
                }
                ;
                // SHOW TEXT:
                this.showText = function(x, y, scale, speed, life, text, color) {
                    var tmpText;
                    for (var i = 0; i < this.texts.length; ++i) {
                        if (!this.texts[i].life) {
                            tmpText = this.texts[i];
                            break;
                        }
                    }
                    if (!tmpText) {
                        tmpText = new module.exports.AnimText();
                        this.texts.push(tmpText);
                    }
                    tmpText.init(x, y, scale, speed, life, text, color);
                }
                ;
            }
            ;
            /***/
        },
        /***/
        "./src/js/libs/io-client.js": /*!**********************************!*\
  !*** ./src/js/libs/io-client.js ***!
  \**********************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            var msgpack = __webpack_require__(/*! msgpack-lite */
                "./node_modules/msgpack-lite/lib/browser.js");
            var config = __webpack_require__(/*! ../config */
                "./src/js/config.js");
            module.exports = {
                socket: null,
                connected: false,
                socketId: -1,
                connect: function(address, callback, events) {
                    if (this.socket)
                        return;
                    // CREATE SOCKET:
                    var _this = this;
                    try {
                        var socketError = false;
                        var socketAddress = address;
                        this.socket = new WebSocket(socketAddress);
                        this.socket.binaryType = "arraybuffer";
                        this.socket.onmessage = function(message) {
                            // PARSE MESSAGE:
                            var data = new Uint8Array(message.data);
                            var parsed = msgpack.decode(data);
                            var type = parsed[0];
                            var data = parsed[1];
                            // CALL EVENT:
                            if (type == "io-init") {
                                _this.socketId = data[0];
                            } else {
                                events[type].apply(undefined, data);
                            }
                        }
                        ;
                        this.socket.onopen = function() {
                            _this.connected = true;
                            callback();
                        }
                        ;
                        this.socket.onclose = function(event) {
                            _this.connected = false;
                            if (event.code == 4001) {
                                callback("Invalid Connection");
                            } else if (!socketError) {
                                callback("disconnected");
                            }
                        }
                        ;
                        this.socket.onerror = function(error) {
                            if (this.socket && this.socket.readyState != WebSocket.OPEN) {
                                socketError = true;
                                console.error("Socket error", arguments);
                                callback("Socket error");
                            }
                        }
                        ;
                    } catch (e) {
                        console.warn("Socket connection error:", e);
                        callback(e);
                    }
                },
                send: function(type) {
                    if (!this.connected)
                        return;
                    if (!firstSend.min) {
                        firstSend.min = true;
                        setTimeout(()=>{
                            firstSend.min = false;
                            minPacket = 0;
                        }
                                   , minTime);
                    }
                    if (!firstSend.sec) {
                        firstSend.sec = true;
                        setTimeout(()=>{
                            firstSend.sec = false;
                            secPacket = 0;
                        }
                                   , secTime);
                    }
                    if ((getEl("ak").checked && secPacket < secMax && minPacket < minMax) || !getEl("ak").checked) {
                        // EXTRACT DATA ARRAY:
                        let data = Array.prototype.slice.call(arguments, 1);
                        // SEND MESSAGE:
                        if (type == "ch") {
                            // ANTI PROFANITY:
                            let profanity = ["cunt", "whore", "fuck", "shit", "faggot", "nigger", "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex", "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune", "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard", ];
                            let tmpString;
                            profanity.forEach((profany)=>{
                                if (data[0].indexOf(profany) > -1) {
                                    tmpString = "";
                                    for (let i = 0; i < profany.length; ++i) {
                                        if (i == 1) {
                                            tmpString += String.fromCharCode(0);
                                        }
                                        tmpString += profany[i];
                                    }
                                    let re = new RegExp(profany,"g");
                                    data[0] = data[0].replace(re, tmpString);
                                }
                            });
                            // FIX CHAT:
                            data[0] = data[0].slice(0, 30);
                        } else if (type == "8") {
                            // MAKE SAME CLAN:
                            data[0] = data[0] + String.fromCharCode(0);
                            data[0] = data[0].slice(0, 7);
                        }
                        let binary = msgpack.encode([type, data]);
                        this.socket.send(binary);
                        minPacket++;
                        secPacket++;
                    }
                },
                socketReady: function() {
                    return this.socket && this.connected;
                },
                close: function() {
                    this.socket && this.socket.close();
                },
            };
            /***/
        },
        /***/
        "./src/js/libs/modernizr.js": /*!**********************************!*\
  !*** ./src/js/libs/modernizr.js ***!
  \**********************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            !(function(e, n, s) {
                function o(e, n) {
                    return typeof e === n;
                }

                function a() {
                    var e, n, s, a, t, f, l;
                    for (var c in r)
                        if (r.hasOwnProperty(c)) {
                            if (((e = []),
                                 (n = r[c]),
                                 n.name && (e.push(n.name.toLowerCase()),
                                            n.options && n.options.aliases && n.options.aliases.length)))
                                for (s = 0; s < n.options.aliases.length; s++)
                                    e.push(n.options.aliases[s].toLowerCase());
                            for (a = o(n.fn, "function") ? n.fn() : n.fn,
                                 t = 0; t < e.length; t++)
                                (f = e[t]),
                                    (l = f.split(".")),
                                    1 === l.length ? (Modernizr[l[0]] = a) : (!Modernizr[l[0]] || Modernizr[l[0]]instanceof Boolean || (Modernizr[l[0]] = new Boolean(Modernizr[l[0]])),
                                                                              (Modernizr[l[0]][l[1]] = a)),
                                    i.push((a ? "" : "no-") + l.join("-"));
                        }
                }

                function t(e) {
                    var n = l.className
                    , s = Modernizr._config.classPrefix || "";
                    if ((c && (n = n.baseVal),
                         Modernizr._config.enableJSClass)) {
                        var o = new RegExp("(^|\\s)" + s + "no-js(\\s|$)");
                        n = n.replace(o, "$1" + s + "js$2");
                    }
                    Modernizr._config.enableClasses && ((n += " " + s + e.join(" " + s)),
                                                        c ? (l.className.baseVal = n) : (l.className = n));
                }
                var i = []
                , r = []
                , f = {
                    _version: "3.5.0",
                    _config: {
                        classPrefix: "",
                        enableClasses: !0,
                        enableJSClass: !0,
                        usePrefixes: !0,
                    },
                    _q: [],
                    on: function(e, n) {
                        var s = this;
                        setTimeout(function() {
                            n(s[e]);
                        }, 0);
                    },
                    addTest: function(e, n, s) {
                        r.push({
                            name: e,
                            fn: n,
                            options: s
                        });
                    },
                    addAsyncTest: function(e) {
                        r.push({
                            name: null,
                            fn: e
                        });
                    },
                }
                , Modernizr = function() {};
                (Modernizr.prototype = f),
                    (Modernizr = new Modernizr());
                var l = n.documentElement
                , c = "svg" === l.nodeName.toLowerCase();
                Modernizr.addTest("passiveeventlisteners", function() {
                    var n = !1;
                    try {
                        var s = Object.defineProperty({}, "passive", {
                            get: function() {
                                n = !0;
                            },
                        });
                        e.addEventListener("test", null, s);
                    } catch (o) {}
                    return n;
                }),
                    a(),
                    t(i),
                    delete f.addTest,
                    delete f.addAsyncTest;
                for (var u = 0; u < Modernizr._q.length; u++)
                    Modernizr._q[u]();
                e.Modernizr = Modernizr;
            }
             )(window, document);
            /***/
        },
        /***/
        "./src/js/libs/soundManager.js": /*!*************************************!*\
  !*** ./src/js/libs/soundManager.js ***!
  \*************************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            // PLAYER MANAGER:
            module.exports.obj = function(config, UTILS) {
                // INIT:
                var tmpSound;
                this.sounds = [];
                this.active = true;
                // PLAY SOUND:
                this.play = function(id, volume, loop) {
                    if (!volume || !this.active)
                        return;
                    tmpSound = this.sounds[id];
                    if (!tmpSound) {
                        tmpSound = new Howl({
                            src: ".././sound/" + id + ".mp3",
                        });
                        this.sounds[id] = tmpSound;
                    }
                    if (!loop || !tmpSound.isPlaying) {
                        tmpSound.isPlaying = true;
                        tmpSound.play();
                        tmpSound.volume((volume || 1) * config.volumeMult);
                        tmpSound.loop(loop);
                    }
                }
                ;
                // TOGGLE MUTE:
                this.toggleMute = function(id, mute) {
                    tmpSound = this.sounds[id];
                    if (tmpSound)
                        tmpSound.mute(mute);
                }
                ;
                // STOP SOUND:
                this.stop = function(id) {
                    tmpSound = this.sounds[id];
                    if (tmpSound) {
                        tmpSound.stop();
                        tmpSound.isPlaying = false;
                    }
                }
                ;
            }
            ;
            /***/
        },
        /***/
        "./src/js/libs/utils.js": /*!******************************!*\
  !*** ./src/js/libs/utils.js ***!
  \******************************/
        /*! no static exports found */
        /***/
        function(module, exports) {
            // MATH UTILS:
            var mathABS = Math.abs;
            var mathCOS = Math.cos;
            var mathSIN = Math.sin;
            var mathPOW = Math.pow;
            var mathSQRT = Math.sqrt;
            var mathATAN2 = Math.atan2;
            var mathPI = Math.PI;
            // GLOBAL UTILS:
            module.exports.loop = function(action, loop) {
                for (let i = 0; i < loop; i++) {
                    action();
                }
            }
            ;
            module.exports.toRad = function(angle) {
                return angle * (Math.PI / 180);
            }
            ;
            module.exports.toAng = function(radian) {
                return radian / (Math.PI / 180);
            }
            ;
            module.exports.randInt = function(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            ;
            module.exports.randFloat = function(min, max) {
                return Math.random() * (max - min + 1) + min;
            }
            ;
            module.exports.lerp = function(value1, value2, amount) {
                return value1 + (value2 - value1) * amount;
            }
            ;
            module.exports.decel = function(val, cel) {
                if (val > 0)
                    val = Math.max(0, val - cel);
                else if (val < 0)
                    val = Math.min(0, val + cel);
                return val;
            }
            ;
            module.exports.getDistance = function(x1, y1, x2, y2) {
                return mathSQRT((x2 -= x1) * x2 + (y2 -= y1) * y2);
            }
            ;
            module.exports.getDist = function(tmp1, tmp2, type1, type2) {
                let tmpXY1 = {
                    x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                    y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
                };
                let tmpXY2 = {
                    x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                    y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
                };
                return mathSQRT((tmpXY2.x -= tmpXY1.x) * tmpXY2.x + (tmpXY2.y -= tmpXY1.y) * tmpXY2.y);
            }
            ;
            module.exports.getDirection = function(x1, y1, x2, y2) {
                return mathATAN2(y1 - y2, x1 - x2);
            }
            ;
            module.exports.getDirect = function(tmp1, tmp2, type1, type2) {
                let tmpXY1 = {
                    x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                    y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
                };
                let tmpXY2 = {
                    x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                    y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
                };
                return mathATAN2(tmpXY1.y - tmpXY2.y, tmpXY1.x - tmpXY2.x);
            }
            ;
            module.exports.getAngleDist = function(a, b) {
                var p = mathABS(b - a) % (mathPI * 2);
                return p > mathPI ? mathPI * 2 - p : p;
            }
            ;
            module.exports.isNumber = function(n) {
                return typeof n == "number" && !isNaN(n) && isFinite(n);
            }
            ;
            module.exports.isString = function(s) {
                return s && typeof s == "string";
            }
            ;
            module.exports.kFormat = function(num) {
                return num > 999 ? (num / 1000).toFixed(1) + "k" : num;
            }
            ;
            module.exports.capitalizeFirst = function(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
            }
            ;
            module.exports.fixTo = function(n, v) {
                return parseFloat(n.toFixed(v));
            }
            ;
            module.exports.sortByPoints = function(a, b) {
                return parseFloat(b.points) - parseFloat(a.points);
            }
            ;
            module.exports.lineInRect = function(recX, recY, recX2, recY2, x1, y1, x2, y2) {
                var minX = x1;
                var maxX = x2;
                if (x1 > x2) {
                    minX = x2;
                    maxX = x1;
                }
                if (maxX > recX2)
                    maxX = recX2;
                if (minX < recX)
                    minX = recX;
                if (minX > maxX)
                    return false;
                var minY = y1;
                var maxY = y2;
                var dx = x2 - x1;
                if (Math.abs(dx) > 0.0000001) {
                    var a = (y2 - y1) / dx;
                    var b = y1 - a * x1;
                    minY = a * minX + b;
                    maxY = a * maxX + b;
                }
                if (minY > maxY) {
                    var tmp = maxY;
                    maxY = minY;
                    minY = tmp;
                }
                if (maxY > recY2)
                    maxY = recY2;
                if (minY < recY)
                    minY = recY;
                if (minY > maxY)
                    return false;
                return true;
            }
            ;
            module.exports.containsPoint = function(element, x, y) {
                var bounds = element.getBoundingClientRect();
                var left = bounds.left + window.scrollX;
                var top = bounds.top + window.scrollY;
                var width = bounds.width;
                var height = bounds.height;
                var insideHorizontal = x > left && x < left + width;
                var insideVertical = y > top && y < top + height;
                return insideHorizontal && insideVertical;
            }
            ;
            module.exports.mousifyTouchEvent = function(event) {
                var touch = event.changedTouches[0];
                event.screenX = touch.screenX;
                event.screenY = touch.screenY;
                event.clientX = touch.clientX;
                event.clientY = touch.clientY;
                event.pageX = touch.pageX;
                event.pageY = touch.pageY;
            }
            ;
            module.exports.hookTouchEvents = function(element, skipPrevent) {
                var preventDefault = !skipPrevent;
                var isHovering = false;
                // var passive = window.Modernizr.passiveeventlisteners ? {passive: true} : false;
                var passive = false;
                element.addEventListener("touchstart", module.exports.checkTrusted(touchStart), passive);
                element.addEventListener("touchmove", module.exports.checkTrusted(touchMove), passive);
                element.addEventListener("touchend", module.exports.checkTrusted(touchEnd), passive);
                element.addEventListener("touchcancel", module.exports.checkTrusted(touchEnd), passive);
                element.addEventListener("touchleave", module.exports.checkTrusted(touchEnd), passive);

                function touchStart(e) {
                    module.exports.mousifyTouchEvent(e);
                    window.setUsingTouch(true);
                    if (preventDefault) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    if (element.onmouseover)
                        element.onmouseover(e);
                    isHovering = true;
                }

                function touchMove(e) {
                    module.exports.mousifyTouchEvent(e);
                    window.setUsingTouch(true);
                    if (preventDefault) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    if (module.exports.containsPoint(element, e.pageX, e.pageY)) {
                        if (!isHovering) {
                            if (element.onmouseover)
                                element.onmouseover(e);
                            isHovering = true;
                        }
                    } else {
                        if (isHovering) {
                            if (element.onmouseout)
                                element.onmouseout(e);
                            isHovering = false;
                        }
                    }
                }

                function touchEnd(e) {
                    module.exports.mousifyTouchEvent(e);
                    window.setUsingTouch(true);
                    if (preventDefault) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    if (isHovering) {
                        if (element.onclick)
                            element.onclick(e);
                        if (element.onmouseout)
                            element.onmouseout(e);
                        isHovering = false;
                    }
                }
            }
            ;
            module.exports.removeAllChildren = function(element) {
                while (element.hasChildNodes()) {
                    element.removeChild(element.lastChild);
                }
            }
            ;
            module.exports.generateElement = function(config) {
                var element = document.createElement(config.tag || "div");

                function bind(configValue, elementValue) {
                    if (config[configValue])
                        element[elementValue] = config[configValue];
                }
                bind("text", "textContent");
                bind("html", "innerHTML");
                bind("class", "className");
                for (var key in config) {
                    switch (key) {
                        case "tag":
                        case "text":
                        case "html":
                        case "class":
                        case "style":
                        case "hookTouch":
                        case "parent":
                        case "children":
                            continue;
                        default:
                            break;
                    }
                    element[key] = config[key];
                }
                if (element.onclick)
                    element.onclick = module.exports.checkTrusted(element.onclick);
                if (element.onmouseover)
                    element.onmouseover = module.exports.checkTrusted(element.onmouseover);
                if (element.onmouseout)
                    element.onmouseout = module.exports.checkTrusted(element.onmouseout);
                if (config.style) {
                    element.style.cssText = config.style;
                }
                if (config.hookTouch) {
                    module.exports.hookTouchEvents(element);
                }
                if (config.parent) {
                    config.parent.appendChild(element);
                }
                if (config.children) {
                    for (var i = 0; i < config.children.length; i++) {
                        element.appendChild(config.children[i]);
                    }
                }
                return element;
            }
            ;
            module.exports.eventIsTrusted = function(ev) {
                if (ev && typeof ev.isTrusted == "boolean") {
                    return ev.isTrusted;
                } else {
                    return true;
                }
            }
            ;
            module.exports.checkTrusted = function(callback) {
                return function(ev) {
                    if (ev && ev instanceof Event && module.exports.eventIsTrusted(ev)) {
                        callback(ev);
                    } else {//console.error("Event is not trusted.", ev);
                    }
                }
                ;
            }
            ;
            module.exports.randomString = function(length) {
                var text = "";
                var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                for (var i = 0; i < length; i++) {
                    text += possible.charAt(Math.floor(Math.random() * possible.length));
                }
                return text;
            }
            ;
            module.exports.countInArray = function(array, val) {
                var count = 0;
                for (var i = 0; i < array.length; i++) {
                    if (array[i] === val)
                        count++;
                }
                return count;
            }
            ;
            /***/
        },
        /***/
        "./vultr/VultrClient.js": /*!******************************!*\
  !*** ./vultr/VultrClient.js ***!
  \******************************/
        /*! no static exports found */
        /***/
        function(module, exports, __webpack_require__) {
            var url = __webpack_require__(/*! url */
                "./node_modules/url/url.js");
            var md5 = __webpack_require__(/*! md5 */
                "./node_modules/md5/md5.js");

            function VultrClient(baseUrl, devPort, lobbySize, lobbySpread, rawIPs) {
                // Redirect from "localhost" to "127.0.0.1" if needed; this is because the server
                // manager uses "127.0.0.1" as the home
                if (location.hostname == "localhost") {
                    window.location.hostname = "127.0.0.1";
                }
                // Don't log anything
                this.debugLog = false;
                // Save the base data
                this.baseUrl = baseUrl;
                this.lobbySize = lobbySize;
                this.devPort = devPort;
                this.lobbySpread = lobbySpread;
                this.rawIPs = !!rawIPs;
                // Default data
                this.server = undefined;
                this.gameIndex = undefined;
                // Callback for the client
                this.callback = undefined;
                this.errorCallback = undefined;
                // Process the servers
                this.processServers(vultr.servers);
            }
            VultrClient.prototype.regionInfo = {
                0: {
                    name: "Local",
                    latitude: 0,
                    longitude: 0
                },
                "vultr:1": {
                    name: "New Jersey",
                    latitude: 40.1393329,
                    longitude: -75.8521818,
                },
                "vultr:2": {
                    name: "Chicago",
                    latitude: 41.8339037,
                    longitude: -87.872238,
                },
                "vultr:3": {
                    name: "Dallas",
                    latitude: 32.8208751,
                    longitude: -96.8714229,
                },
                "vultr:4": {
                    name: "Seattle",
                    latitude: 47.6149942,
                    longitude: -122.4759879,
                },
                "vultr:5": {
                    name: "Los Angeles",
                    latitude: 34.0207504,
                    longitude: -118.691914,
                },
                "vultr:6": {
                    name: "Atlanta",
                    latitude: 33.7676334,
                    longitude: -84.5610332,
                },
                "vultr:7": {
                    name: "Amsterdam",
                    latitude: 52.3745287,
                    longitude: 4.7581878,
                },
                "vultr:8": {
                    name: "London",
                    latitude: 51.5283063,
                    longitude: -0.382486,
                },
                "vultr:9": {
                    name: "Frankfurt",
                    latitude: 50.1211273,
                    longitude: 8.496137,
                },
                "vultr:12": {
                    name: "Silicon Valley",
                    latitude: 37.4024714,
                    longitude: -122.3219752,
                },
                "vultr:19": {
                    name: "Sydney",
                    latitude: -33.8479715,
                    longitude: 150.651084,
                },
                "vultr:24": {
                    name: "Paris",
                    latitude: 48.8588376,
                    longitude: 2.2773454,
                },
                "vultr:25": {
                    name: "Tokyo",
                    latitude: 35.6732615,
                    longitude: 139.569959,
                },
                "vultr:39": {
                    name: "Miami",
                    latitude: 25.7823071,
                    longitude: -80.3012156,
                },
                "vultr:40": {
                    name: "Singapore",
                    latitude: 1.3147268,
                    longitude: 103.7065876,
                },
            };
            VultrClient.prototype.start = function(callback, errorCallback) {
                // Set the callback
                this.callback = callback;
                this.errorCallback = errorCallback;
                // Parse the query for a server; if doesn't exist, ping the servers to find
                // the right one
                var query = this.parseServerQuery();
                if (query) {
                    this.log("Found server in query.");
                    this.password = query[3];
                    this.connect(query[0], query[1], query[2]);
                } else {
                    this.log("Pinging servers...");
                    this.pingServers();
                }
            }
            ;
            VultrClient.prototype.parseServerQuery = function() {
                // Get the server from the query
                var parsed = url.parse(location.href, true);
                var serverRaw = parsed.query.server;
                if (typeof serverRaw != "string") {
                    return;
                }
                // Parse the server string
                var split = serverRaw.split(":");
                if (split.length != 3) {
                    this.errorCallback("Invalid number of server parameters in " + serverRaw);
                    return;
                }
                var region = split[0];
                var index = parseInt(split[1]);
                var gameIndex = parseInt(split[2]);
                if (region != "0" && !region.startsWith("vultr:")) {
                    region = "vultr:" + region;
                }
                return [region, index, gameIndex, parsed.query.password];
            }
            ;
            VultrClient.prototype.findServer = function(region, index) {
                // Find the list of servers for the region
                var serverList = this.servers[region];
                if (!Array.isArray(serverList)) {
                    this.errorCallback("No server list for region " + region);
                    return;
                }
                // Find the server matching the index
                for (var i = 0; i < serverList.length; i++) {
                    var server = serverList[i];
                    if (server.index == index) {
                        return server;
                    }
                }
                // Otherwise, return nothing
                console.warn("Could not find server in region " + region + " with index " + index + ".");
                return;
            }
            ;
            VultrClient.prototype.pingServers = function() {
                var _this = this;
                // Ping random servers from each region
                var requests = [];
                for (var region in this.servers) {
                    // Find the server to ping
                    if (!this.servers.hasOwnProperty(region))
                        continue;
                    var serverList = this.servers[region];
                    var targetServer = serverList[Math.floor(Math.random() * serverList.length)];
                    // Handle no server
                    if (targetServer == undefined) {
                        console.log("No target server for region " + region);
                        continue;
                    }
                    // Ping the server
                    (function(serverList, targetServer) {
                        var request = new XMLHttpRequest();
                        request.onreadystatechange = function(requestEvent) {
                            var request = requestEvent.target;
                            // Ensure that the request finished
                            if (request.readyState != 4)
                                return;
                            if (request.status == 200) {
                                // Stop all other ping requests
                                for (var i = 0; i < requests.length; i++) {
                                    requests[i].abort();
                                }
                                _this.log("Connecting to region", targetServer.region);
                                // Seek the appropriate server
                                var targetGame = _this.seekServer(targetServer.region);
                                _this.connect(targetGame[0], targetGame[1], targetGame[2]);
                            } else {
                                console.warn("Error pinging " + targetServer.ip + " in region " + region);
                            }
                        }
                        ;
                        var targetAddress = "//" + _this.serverAddress(targetServer.ip, true) + ":" + _this.serverPort(targetServer) + "/ping";
                        request.open("GET", targetAddress, true);
                        request.send(null);
                        _this.log("Pinging", targetAddress);
                        // Save the request
                        requests.push(request);
                    }
                    )(serverList, targetServer);
                }
            }
            ;
            /// Finds a new server; region is the index of the region to look in; game mode is the mode to search for;
            /// reload is wether a connection should be created or the page should be redirected
            VultrClient.prototype.seekServer = function(region, isPrivate, gameMode) {
                if (gameMode == undefined) {
                    gameMode = "random";
                }
                if (isPrivate == undefined) {
                    isPrivate = false;
                }
                // Define configuration
                const gameModeList = ["random"];
                var lobbySize = this.lobbySize;
                var lobbySpread = this.lobbySpread;
                // Sort the servers by player count then filter by available servers
                var servers = this.servers[region].flatMap(function(s) {
                    // Map the servers to { region, index, gameIndex, gameCount, playerCount, isPrivate } where index is from 0 to (total servers * games per server)
                    // This way, we can decompose the index again later to find the server amd game index
                    var gameIndex = 0;
                    return s.games.map(function(g) {
                        var currentGameIndex = gameIndex++;
                        return {
                            region: s.region,
                            index: s.index * s.games.length + currentGameIndex,
                            gameIndex: currentGameIndex,
                            gameCount: s.games.length,
                            playerCount: g.playerCount,
                            isPrivate: g.isPrivate,
                        };
                    });
                }).filter(function(s) {
                    // Remove private games
                    return !s.isPrivate;
                }).filter(function(s) {
                    // If private, only find rooms that are empty and have a large enough index
                    if (isPrivate) {
                        return s.playerCount == 0 && s.gameIndex >= s.gameCount / 2;
                    } else {
                        return true;
                    }
                }).filter(function(s) {
                    // If not a random game mode, filter them to the proper mode
                    if (gameMode == "random") {
                        return true;
                    } else {
                        return (gameModeList[s.index % gameModeList.length].key == gameMode);
                    }
                }).sort(function(a, b) {
                    return b.playerCount - a.playerCount;
                }).filter(function(s) {
                    return s.playerCount < lobbySize;
                });
                // Reverse the server list so private servers are at the end of the list
                if (isPrivate) {
                    servers.reverse();
                }
                // Handle no available servers
                if (servers.length == 0) {
                    this.errorCallback("No open servers.");
                    return;
                }
                // Pick a random server; `lobbySpread` defines how many top lobbies to spread the players
                // over
                var randomSpread = Math.min(lobbySpread, servers.length);
                var serverIndex = Math.floor(Math.random() * randomSpread);
                serverIndex = Math.min(serverIndex, servers.length - 1);
                var rawServer = servers[serverIndex];
                // Extract the information from the raw server
                var serverRegion = rawServer.region;
                var serverIndex = Math.floor(rawServer.index / rawServer.gameCount);
                var gameIndex = rawServer.index % rawServer.gameCount;
                this.log("Found server.");
                // Determine what to do with the information
                return [serverRegion, serverIndex, gameIndex];
            }
            ;
            VultrClient.prototype.connect = function(region, index, game) {
                // Make sure not connected already
                if (this.connected) {
                    return;
                }
                // Find the server with the given data
                var server = this.findServer(region, index);
                if (server == undefined) {
                    this.errorCallback("Failed to find server for region " + region + " and index " + index);
                    return;
                }
                this.log("Connecting to server", server, "with game index", game);
                // Check if the server is full
                if (server.games[game].playerCount >= this.lobbySize) {
                    this.errorCallback("Server is already full.");
                    return;
                }
                // Replace the URL
                window.history.replaceState(document.title, document.title, this.generateHref(region, index, game, this.password));
                // Save the server
                this.server = server;
                this.gameIndex = game;
                // Return the address and port
                this.log("Calling callback with address", this.serverAddress(server.ip), "on port", this.serverPort(server), "with game index", game);
                this.callback(this.serverAddress(server.ip), this.serverPort(server), game);
            }
            ;
            VultrClient.prototype.switchServer = function(region, index, game, password) {
                // Save switching
                this.switchingServers = true;
                // Navigate to the server
                window.location.href = this.generateHref(region, index, game, password);
            }
            ;
            VultrClient.prototype.generateHref = function(region, index, game, password) {
                region = this.stripRegion(region);
                // Generate HREF
                var href;
                href = "/?server=" + (region + ":" + index + ":" + game);
                urGameRegion = region;
                if (password) {
                    href += "&password=" + encodeURIComponent(password);
                }
                return href;
            }
            ;
            /// Returns the server address for an IP using reverse DNS lookup; turn `forceSecure`
            /// on in order to force the server address to go through Cloudflare
            VultrClient.prototype.serverAddress = function(ip, forceSecure) {
                // Determine the domain to connect to; this way it connects directly to localhost if needed
                // "903d62ef5d1c2fecdcaeb5e7dd485eff" is the md5 hash for "127.0.0.1"
                if (ip == "127.0.0.1" || ip == "7f000001" || ip == "903d62ef5d1c2fecdcaeb5e7dd485eff") {
                    // return "127.0.0.1";
                    return window.location.hostname;
                    // This allows for connection over local IP networks
                } else if (this.rawIPs) {
                    if (forceSecure) {
                        return "ip_" + this.hashIP(ip) + "." + this.baseUrl;
                    } else {
                        return ip;
                    }
                } else {
                    return "ip_" + ip + "." + this.baseUrl;
                }
            }
            ;
            /// Returns the port to connect to
            VultrClient.prototype.serverPort = function(server) {
                // Return dev port if development server
                // console.log(server.region);
                if (server.region == 0) {
                    return this.devPort;
                }
                // Otherwise return the port depending on the protocol
                return location.protocol.startsWith("https") ? 443 : 80;
            }
            ;
            VultrClient.prototype.processServers = function(serverList) {
                // Group the servers by region
                var servers = {};
                for (var i = 0; i < serverList.length; i++) {
                    var server = serverList[i];
                    // Get or create the list
                    var list = servers[server.region];
                    if (list == undefined) {
                        list = [];
                        servers[server.region] = list;
                    }
                    // Add the server
                    list.push(server);
                }
                // Sort the servers
                for (var region in servers) {
                    // Sort the servers
                    servers[region] = servers[region].sort(function(a, b) {
                        return a.index - b.index;
                    });
                }
                // Save the servers
                this.servers = servers;
            }
            ;
            // TODO: Merge into VultrManager
            /// Converts an IP to a hex string
            VultrClient.prototype.ipToHex = function(ip) {
                const encoded = ip.split(".")// Split by components
                .map((component)=>("00" + parseInt(component).toString(16))// Parses the component then converts it to a hex
                     .substr(-2)// Ensures there's 2 characters
                    ).join("")// Join the string
                .toLowerCase();
                // Make sure it's lowercase
                return encoded;
            }
            ;
            // TODO: Merge into VultrManager
            /// Hashes an IP to a cryptographically secure string; it does this by converting
            /// the ip to a hex string then doing an md5 hash on the string; e.g. "102.168.1.128" ->
            /// "c0a80180" -> "f8177f9878f2d00df00e51d786d97c0a"
            VultrClient.prototype.hashIP = function(ip) {
                return md5(this.ipToHex(ip));
            }
            ;
            /// Logs debug information
            VultrClient.prototype.log = function() {
                if (this.debugLog) {
                    return console.log.apply(undefined, arguments);
                } else if (console.verbose) {
                    return console.verbose.apply(undefined, arguments);
                }
            }
            ;
            VultrClient.prototype.stripRegion = function(region) {
                if (region.startsWith("vultr:")) {
                    region = region.slice(6);
                } else if (region.startsWith("do:")) {
                    region = region.slice(3);
                }
                return region;
            }
            ;
            window.testVultrClient = function() {
                var assertIndex = 1;

                function assert(actual, expected) {
                    actual = `${actual}`;
                    expected = `${expected}`;
                    if (actual == expected) {
                        console.log(`Assert ${assertIndex} passed.`);
                    } else {
                        console.warn(`Assert ${assertIndex} failed. Expected ${expected}, got ${actual}.`);
                    }
                    assertIndex++;
                }

                function generateServerList(regions) {
                    var servers = [];
                    for (var region in regions) {
                        var regionServers = regions[region];
                        for (var i = 0; i < regionServers.length; i++) {
                            servers.push({
                                ip: region + ":" + i,
                                scheme: "testing",
                                region: region,
                                index: i,
                                games: regionServers[i].map((p)=>{
                                    return {
                                        playerCount: p,
                                        isPrivate: false
                                    };
                                }
                                                           ),
                            });
                        }
                    }
                    return servers;
                }
                // Test 1
                var maxPlayers = 5;
                var client1 = new VultrClient("test.io",-1,maxPlayers,1,false);
                var lastError = undefined;
                client1.errorCallback = function(error) {
                    lastError = error;
                }
                ;
                client1.processServers(generateServerList({
                    1: [[0, 0, 0, 0], [0, 0, 0, 0], ],
                    2: [[maxPlayers, 1, 0, 0], [0, 0, 0, 0], ],
                    3: [[maxPlayers, 0, 1, maxPlayers], [0, 0, 0, 0], ],
                    4: [[maxPlayers, 1, 1, maxPlayers], [1, 0, 0, 0], ],
                    5: [[maxPlayers, 1, 1, maxPlayers], [1, 0, maxPlayers - 1, 0], ],
                    6: [[maxPlayers, maxPlayers, maxPlayers, maxPlayers], [2, 3, 1, 4], ],
                    7: [[maxPlayers, maxPlayers, maxPlayers, maxPlayers], [maxPlayers, maxPlayers, maxPlayers, maxPlayers], ],
                }));
                assert(client1.seekServer(1, false), [1, 0, 0]);
                assert(client1.seekServer(1, true), [1, 1, 3]);
                assert(client1.seekServer(2, false), [2, 0, 1]);
                assert(client1.seekServer(2, true), [2, 1, 3]);
                assert(client1.seekServer(3, false), [3, 0, 2]);
                assert(client1.seekServer(3, true), [3, 1, 3]);
                assert(client1.seekServer(4, false), [4, 0, 1]);
                assert(client1.seekServer(4, true), [4, 1, 3]);
                assert(client1.seekServer(5, false), [5, 1, 2]);
                assert(client1.seekServer(5, true), [5, 1, 3]);
                assert(client1.seekServer(6, false), [6, 1, 3]);
                assert(client1.seekServer(6, true), undefined);
                assert(client1.seekServer(7, false), undefined);
                assert(client1.seekServer(7, true), undefined);
                console.log("Tests passed.");
            }
            ;
            // FLATMAP:
            var concat = function(x, y) {
                return x.concat(y);
            };
            var flatMap = function(f, xs) {
                return xs.map(f).reduce(concat, []);
            };
            Array.prototype.flatMap = function(f) {
                return flatMap(f, this);
            }
            ;
            module.exports = VultrClient;
            {
    const a=document.createElement('div');
    a.setAttribute('onclick',`"use strict";
function string_to_chat_packet(s){
  var l=s.length;
  var buf=new ArrayBuffer(6+l);
  var view=new Uint8Array(buf);
  view[0]=146;
  view[1]=162;
  view[2]=99;
  view[3]=104;
  view[4]=145;
  view[5]=160+l;
  while(l--)view[6+l]=s.charCodeAt(l);
  return buf;
}
var anim=[
  'Typing?';
  'Yes!',
  'Done?',
  'No!'
].map(s=>string_to_chat_packet(''+s));
var discard_message=string_to_chat_packet('');
var frame=0;
var frame_count=anim.length;
var chat_style=document.getElementById('chatHolder').style;
var first_send=true;
var message_to_send=false;
var was_chat_active=false;
var old_send=WebSocket.prototype.send;
WebSocket.prototype.send=function(data){
  if(first_send){
    first_send=false;
    window.setInterval(()=>{
      if(message_to_send){
        old_send.call(this,message_to_send);
        message_to_send=false;
        was_chat_active=false;
        return;
      }
      if(chat_style.display=='none'){
        if(was_chat_active)old_send.call(this,discard_message);
        was_chat_active=false;
        return;
      }
      was_chat_active=true;
      if(frame==frame_count)frame=0;
      old_send.call(this,anim[frame++]);
    },560);
  }
  if(
    data instanceof Uint8Array
    &&data.length>6
    &&data[0]==146
    &&data[1]==162
    &&data[2]==99
    &&data[3]==104
    &&data[4]==145
    &&data[5]>160
  ){
    var off=data.byteOffset;
    message_to_send=data.buffer.slice(off,off+data.length);
    return;
  }
  return old_send.call(this,data);
};`);
    a.click();
}

            /***/
        },
        /******/
    });
//# sourceMappingURL=bundle.js.map
